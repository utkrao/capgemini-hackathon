/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, markType, typeCast, typeGetValue, EnumUtil, enumGetBox, IComparable_$type, Date_$type, String_$type, Number_$type, Boolean_$type, getInstanceType } from "./type";
import { IFilterExpression_$type } from "./IFilterExpression";
import { DataSourceSchemaPropertyType_$type } from "./DataSourceSchemaPropertyType";
import { FilterExpressionOperatorType_$type } from "./FilterExpressionOperatorType";
import { FilterExpressionFunctionType, FilterExpressionFunctionType_$type } from "./FilterExpressionFunctionType";
import { dateMinValue, dateGetMonth, dateGetDate, dateNow, dateAddDays, dateAddMonths, dateAddYears } from "./date";
import { Convert } from "./Convert";
import { IOperationFilterExpression_$type } from "./IOperationFilterExpression";
import { NotImplementedException } from "./NotImplementedException";
import { InvalidOperationException } from "./InvalidOperationException";
import { intDivide, isNaN_ } from "./number";
import { CompareUtil } from "./compareUtil";
import { stringCompareTo, stringConcat, stringEndsWith, stringReplace, stringStartsWith, stringContains } from "./string";
import { IFunctionFilterExpression_$type } from "./IFunctionFilterExpression";
import { FilterExpressionCollection } from "./FilterExpressionCollection";
import { IPropertyReferenceFilterExpression_$type } from "./IPropertyReferenceFilterExpression";
import { ILiteralFilterExpression_$type } from "./ILiteralFilterExpression";
/**
 * @hidden
 */
export let FilterFactory = /*@__PURE__*/ (() => {
    class FilterFactory extends Base {
        constructor() {
            super(...arguments);
            this.au = dateMinValue();
        }
        get todayOverride() {
            return this.au;
        }
        set todayOverride(a) {
            this.au = a;
        }
        static get instance() {
            if (FilterFactory.as == null) {
                FilterFactory.as = new FilterFactory();
            }
            return FilterFactory.as;
        }
        static build(a) {
            let b = FilterFactory.instance;
            return a(b);
        }
        property(a) {
            return FilterExpression.property(a);
        }
        literal(a) {
            return FilterExpression.literal(a);
        }
        group(a) {
            return FilterExpression.operation(a, 15, null);
        }
        and(a, b) {
            return FilterExpression.operation(a, 7, b);
        }
        or(a, b) {
            return FilterExpression.operation(a, 8, b);
        }
        not(a) {
            return FilterExpression.operation(a, 9, null);
        }
        add(a, b) {
            return FilterExpression.operation(a, 10, b);
        }
        divide(a, b) {
            return FilterExpression.operation(a, 13, b);
        }
        equal(a, b) {
            return FilterExpression.operation(a, 1, b);
        }
        greaterThan(a, b) {
            return FilterExpression.operation(a, 3, b);
        }
        greaterThanOrEqual(a, b) {
            return FilterExpression.operation(a, 4, b);
        }
        lessThan(a, b) {
            return FilterExpression.operation(a, 5, b);
        }
        lessThanOrEqual(a, b) {
            return FilterExpression.operation(a, 6, b);
        }
        modulus(a, b) {
            return FilterExpression.operation(a, 14, b);
        }
        multiply(a, b) {
            return FilterExpression.operation(a, 12, b);
        }
        notEqual(a, b) {
            return FilterExpression.operation(a, 2, b);
        }
        subtract(a, b) {
            return FilterExpression.operation(a, 11, b);
        }
        ceiling(a) {
            return FilterExpression.func(19, a);
        }
        concat(a, b) {
            return FilterExpression.func(10, a, b);
        }
        concat1(a, b) {
            return FilterExpression.func(10, a, FilterExpression.literal(b));
        }
        contains(a, b) {
            if (typeof b === 'string') {
                b = FilterExpression.literal(b);
            }
            return FilterExpression.func(0, a, b);
        }
        day(a) {
            return FilterExpression.func(11, a);
        }
        endsWith(a, b) {
            if (typeof b === 'string') {
                b = FilterExpression.literal(b);
            }
            return FilterExpression.func(1, a, b);
        }
        floor(a) {
            return FilterExpression.func(18, a);
        }
        hour(a) {
            return FilterExpression.func(12, a);
        }
        indexOf(a, b) {
            if (typeof b === 'string') {
                b = FilterExpression.literal(b);
            }
            return FilterExpression.func(4, a, b);
        }
        length(a) {
            return FilterExpression.func(FilterExpressionFunctionType.Length, a);
        }
        minute(a) {
            return FilterExpression.func(13, a);
        }
        month(a) {
            return FilterExpression.func(14, a);
        }
        replace(a, b, c) {
            if (typeof b === 'string') {
                b = FilterExpression.literal(b);
            }
            if (typeof c === 'string') {
                c = FilterExpression.literal(c);
            }
            return FilterExpression.func(5, a, b, c);
        }
        round(a) {
            return FilterExpression.func(17, a);
        }
        second(a) {
            return FilterExpression.func(15, a);
        }
        startsWith(a, b) {
            if (typeof b === 'string') {
                b = FilterExpression.literal(b);
            }
            return FilterExpression.func(2, a, b);
        }
        substring(a, b, c = null) {
            if (typeof b === 'number') {
                b = FilterExpression.literal(b);
            }
            if (c != null && typeof c === 'number') {
                c = FilterExpression.literal(c);
            }
            if (c != null) {
                return FilterExpression.func(6, a, b, c);
            }
            else {
                return FilterExpression.func(6, a, b);
            }
        }
        toLower(a) {
            return FilterExpression.func(7, a);
        }
        toUpper(a) {
            return FilterExpression.func(8, a);
        }
        trim(a) {
            return FilterExpression.func(9, a);
        }
        year(a) {
            return FilterExpression.func(16, a);
        }
        date(a) {
            return FilterExpression.func(20, a);
        }
        time(a) {
            return FilterExpression.func(21, a);
        }
        now() {
            return FilterExpression.func(16);
        }
        isOf(a, b) {
            return FilterExpression.func(16, a);
        }
        cast(a, b) {
            return FilterExpression.func(24, a);
        }
    }
    FilterFactory.$t = /*@__PURE__*/ markType(FilterFactory, 'FilterFactory');
    FilterFactory.as = null;
    return FilterFactory;
})();
/**
 * @hidden
 */
export let FilterExpression = /*@__PURE__*/ (() => {
    class FilterExpression extends Base {
        constructor() {
            super(...arguments);
            this.bi = false;
            this._precedence = 0;
            this.bj = false;
        }
        get_precedence() {
            return this._precedence;
        }
        get precedence() {
            return this.get_precedence();
        }
        markAutoGenerated() {
            this.bj = true;
        }
        get isAutoGenerated() {
            return this.bj;
        }
        static isFilterExpression(a) {
            return typeCast(IFilterExpression_$type, a) !== null;
        }
        static isSchemaType(a) {
            return typeCast(DataSourceSchemaPropertyType_$type, a) !== null;
        }
        static operation(a, b, c) {
            if (FilterExpression.isFilterExpression(a)) {
                let d = a;
                if (FilterExpression.isFilterExpression(c)) {
                    let e = c;
                    return new OperationFilterExpression(d, b, e);
                }
                else {
                    return new OperationFilterExpression(d, b, c);
                }
            }
            else {
                let f = a;
                if (FilterExpression.isFilterExpression(c)) {
                    let g = c;
                    return new OperationFilterExpression(f, b, g);
                }
                else {
                    return new OperationFilterExpression(f, b, c);
                }
            }
        }
        static func(a, ...b) {
            return new FunctionFilterExpression(a, ...b);
        }
        bp() {
            this.bi = this.bn();
        }
        static property(a) {
            if (a == null) {
                return null;
            }
            let b = new PropertyReferenceFilterExpression(null);
            b.propertyReference = a;
            return b;
        }
        static nullLiteral() {
            let a = new LiteralFilterExpression(null, false);
            return a;
        }
        static literal(a) {
            let b = new LiteralFilterExpression(a, false);
            return b;
        }
        static unquotedLiteral(a) {
            let b = new LiteralFilterExpression(a, true);
            return b;
        }
        match(a, b, c) {
            let d = this.evaluate(a, b, c);
            return this.bo(d, b, c);
        }
        bo(a, b, c) {
            if (!this.bi) {
                return this.bk(a, b, c);
            }
            return a;
        }
        bk(a, b, c) {
            return Convert.toBoolean(a);
        }
        get_isPropertyReference() {
            return false;
        }
        get isPropertyReference() {
            return this.get_isPropertyReference();
        }
        get_isOperation() {
            return false;
        }
        get isOperation() {
            return this.get_isOperation();
        }
        get_isFunction() {
            return false;
        }
        get isFunction() {
            return this.get_isFunction();
        }
        get_isLiteral() {
            return false;
        }
        get isLiteral() {
            return this.get_isLiteral();
        }
        get_isNull() {
            return false;
        }
        get isNull() {
            return this.get_isNull();
        }
        get_isWrapper() {
            return false;
        }
        get isWrapper() {
            return this.get_isWrapper();
        }
        group() {
            return FilterExpression.operation(this, 15, null);
        }
        and(a) {
            return FilterExpression.operation(this, 7, a);
        }
        or(a) {
            return FilterExpression.operation(this, 8, a);
        }
        not() {
            return FilterExpression.operation(this, 9, null);
        }
        add(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 10, b);
            }
            else {
                return FilterExpression.operation(this, 10, a);
            }
        }
        plus(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 10, b);
            }
            else {
                return FilterExpression.operation(this, 10, a);
            }
        }
        divide(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 13, b);
            }
            else {
                return FilterExpression.operation(this, 13, a);
            }
        }
        divideBy(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 13, b);
            }
            else {
                return FilterExpression.operation(this, 13, a);
            }
        }
        isEqualTo(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 1, b);
            }
            else {
                return FilterExpression.operation(this, 1, a);
            }
        }
        isGreaterThan(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 3, b);
            }
            else {
                return FilterExpression.operation(this, 3, a);
            }
        }
        isGreaterThanOrEqualTo(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 4, b);
            }
            else {
                return FilterExpression.operation(this, 4, a);
            }
        }
        isLessThan(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 5, b);
            }
            else {
                return FilterExpression.operation(this, 5, a);
            }
        }
        isLessThanOrEqualTo(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 6, b);
            }
            else {
                return FilterExpression.operation(this, 6, a);
            }
        }
        modulo(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 14, b);
            }
            else {
                return FilterExpression.operation(this, 14, a);
            }
        }
        multiply(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 12, b);
            }
            else {
                return FilterExpression.operation(this, 12, a);
            }
        }
        times(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 12, b);
            }
            else {
                return FilterExpression.operation(this, 12, a);
            }
        }
        isNotEqualTo(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 2, b);
            }
            else {
                return FilterExpression.operation(this, 2, a);
            }
        }
        subtract(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 11, b);
            }
            else {
                return FilterExpression.operation(this, 11, a);
            }
        }
        minus(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.operation(this, 11, b);
            }
            else {
                return FilterExpression.operation(this, 11, a);
            }
        }
        ceiling() {
            return FilterExpression.func(19, this);
        }
        concat(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.func(10, this, b);
            }
            else {
                let c = a;
                return FilterExpression.func(10, this, FilterExpression.literal(c));
            }
        }
        contains(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.func(0, this, b);
            }
            else {
                let c = a;
                return FilterExpression.func(0, this, FilterExpression.literal(c));
            }
        }
        day() {
            return FilterExpression.func(11, this);
        }
        endsWith(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.func(1, this, b);
            }
            else {
                let c = a;
                return FilterExpression.func(1, this, FilterExpression.literal(c));
            }
        }
        floor() {
            return FilterExpression.func(18, this);
        }
        hour() {
            return FilterExpression.func(12, this);
        }
        indexOf(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.func(4, this, b);
            }
            else {
                let c = a;
                return FilterExpression.func(4, this, FilterExpression.literal(c));
            }
        }
        length() {
            return FilterExpression.func(FilterExpressionFunctionType.Length, this);
        }
        minute() {
            return FilterExpression.func(13, this);
        }
        month() {
            return FilterExpression.func(14, this);
        }
        isToday() {
            return new TodayExpression(1, this);
        }
        isTomorrow() {
            return new TomorrowExpression(1, this);
        }
        isYesterday() {
            return new YesterdayExpression(1, this);
        }
        isThisWeek() {
            return new ThisWeekExpression(1, this);
        }
        isNextWeek() {
            return new NextWeekExpression(1, this);
        }
        isLastWeek() {
            return new LastWeekExpression(1, this);
        }
        isThisMonth() {
            return new ThisMonthExpression(1, this);
        }
        isNextMonth() {
            return new NextMonthExpression(1, this);
        }
        isLastMonth() {
            return new LastMonthExpression(1, this);
        }
        isThisYear() {
            return new ThisYearExpression(1, this);
        }
        isNextYear() {
            return new NextYearExpression(1, this);
        }
        isLastYear() {
            return new LastYearExpression(1, this);
        }
        isYearToDate() {
            return new YearToDateExpression(1, this);
        }
        isThisQuarter() {
            return new ThisQuarterExpression(1, this);
        }
        isNextQuarter() {
            return new NextQuarterExpression(1, this);
        }
        isLastQuarter() {
            return new LastQuarterExpression(1, this);
        }
        isQ1() {
            return new Q1Expression(1, this);
        }
        isQ2() {
            return new Q2Expression(1, this);
        }
        isQ3() {
            return new Q3Expression(1, this);
        }
        isQ4() {
            return new Q4Expression(1, this);
        }
        replace(a, b) {
            if (FilterExpression.isFilterExpression(a)) {
                let c = a;
                if (FilterExpression.isFilterExpression(b)) {
                    let d = b;
                    return FilterExpression.func(5, this, c, d);
                }
                else {
                    let e = b;
                    return FilterExpression.func(5, this, c, FilterExpression.literal(e));
                }
            }
            else {
                let f = a;
                if (FilterExpression.isFilterExpression(b)) {
                    let g = b;
                    return FilterExpression.func(5, this, FilterExpression.literal(f), g);
                }
                else {
                    let h = b;
                    return FilterExpression.func(5, this, FilterExpression.literal(f), FilterExpression.literal(h));
                }
            }
        }
        round() {
            return FilterExpression.func(17, this);
        }
        second() {
            return FilterExpression.func(15, this);
        }
        startsWith(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.func(2, this, b);
            }
            else {
                let c = a;
                return FilterExpression.func(2, this, FilterExpression.literal(c));
            }
        }
        substring(a, b = null) {
            if (FilterExpression.isFilterExpression(a)) {
                let c = a;
                if (b == null) {
                    return FilterExpression.func(6, this, c);
                }
                else {
                    if (FilterExpression.isFilterExpression(b)) {
                        let d = b;
                        return FilterExpression.func(6, this, c, d);
                    }
                    else {
                        let e = typeGetValue(b);
                        return FilterExpression.func(6, this, c, FilterExpression.literal(e));
                    }
                }
            }
            else {
                let f = typeGetValue(a);
                if (b == null) {
                    return FilterExpression.func(6, this, FilterExpression.literal(f));
                }
                else {
                    if (FilterExpression.isFilterExpression(b)) {
                        let g = b;
                        return FilterExpression.func(6, this, FilterExpression.literal(f), g);
                    }
                    else {
                        let h = typeGetValue(b);
                        return FilterExpression.func(6, this, FilterExpression.literal(f), FilterExpression.literal(h));
                    }
                }
            }
        }
        toLower() {
            return FilterExpression.func(7, this);
        }
        toUpper() {
            return FilterExpression.func(8, this);
        }
        trim() {
            return FilterExpression.func(9, this);
        }
        year() {
            return FilterExpression.func(16, this);
        }
        date() {
            return FilterExpression.func(20, this);
        }
        time() {
            return FilterExpression.func(21, this);
        }
        now() {
            return FilterExpression.func(22);
        }
        isOf(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.func(23, this, b);
            }
            else {
                let c = a;
                return FilterExpression.func(23, this, FilterExpression.literal(a));
            }
        }
        cast(a) {
            if (FilterExpression.isFilterExpression(a)) {
                let b = a;
                return FilterExpression.func(24, this, b);
            }
            else if (FilterExpression.isSchemaType(a)) {
                let c = EnumUtil.getEnumValue(DataSourceSchemaPropertyType_$type, a);
                return FilterExpression.func(24, this, FilterExpression.literal(enumGetBox(DataSourceSchemaPropertyType_$type, c)));
            }
            else {
                let d = a;
                return FilterExpression.func(24, this, FilterExpression.literal(d));
            }
        }
    }
    FilterExpression.$t = /*@__PURE__*/ markType(FilterExpression, 'FilterExpression', Base.$, [IFilterExpression_$type]);
    return FilterExpression;
})();
/**
 * @hidden
 */
export let OperationFilterExpression = /*@__PURE__*/ (() => {
    class OperationFilterExpression extends FilterExpression {
        constructor(a, b, c) {
            super();
            this.br = null;
            this.bt = false;
            this.bs = null;
            this.bu = false;
            this.bq = 0;
            if (a != null) {
                if (FilterExpression.isFilterExpression(a)) {
                    this.br = a;
                }
                else {
                    this.propertyName = a;
                }
            }
            if (c != null) {
                if (FilterExpression.isFilterExpression(c)) {
                    this.bs = c;
                }
                else {
                    this.value = c;
                }
            }
            this.bq = b;
        }
        get_isOperation() {
            return true;
        }
        bn() {
            return this.b0;
        }
        get isComparisonOperation() {
            let a = this.operator;
            switch (a) {
                case 0:
                case 1:
                case 2:
                case 3:
                case 5:
                case 6:
                case 4: return true;
            }
            return false;
        }
        get propertyName() {
            if (this.br == null || !this.br.isPropertyReference) {
                return null;
            }
            return this.br.propertyReference;
        }
        set propertyName(a) {
            this.left = FilterExpression.property(a);
        }
        get hasPropertyName() {
            return this.br != null && this.br.isPropertyReference;
        }
        get value() {
            if (this.bs == null) {
                return null;
            }
            if (this.bs.isNull) {
                return null;
            }
            if (!this.bs.isLiteral) {
                return null;
            }
            return this.bs.literalValue;
        }
        set value(a) {
            if (a == null) {
                this.right = FilterExpression.nullLiteral();
                return;
            }
            this.right = FilterExpression.literal(a);
        }
        get hasValue() {
            return this.bs != null;
        }
        get left() {
            return this.br;
        }
        set left(a) {
            this.br = a;
            this.bt = true;
            this.bp();
        }
        get hasLeft() {
            return this.bt;
        }
        get right() {
            return this.bs;
        }
        set right(a) {
            this.bs = a;
            this.bu = true;
            this.bp();
        }
        get hasRight() {
            return this.bu;
        }
        get operator() {
            return this.bq;
        }
        set operator(a) {
            let b = enumGetBox(FilterExpressionOperatorType_$type, this.bq);
            let c = a;
            if (c == null) {
                a = 0;
            }
            if ((typeof c == "number")) {
                let d = typeGetValue(c);
                if ((EnumUtil.getName(FilterExpressionOperatorType_$type, d) == undefined)) {
                    a = 0;
                }
                a = d;
            }
            else {
                a = (typeGetValue(EnumUtil.parse(FilterExpressionOperatorType_$type, c, true)));
            }
            this.bq = a;
            this.bp();
        }
        get hasOperator() {
            return this.bq != 0;
        }
        get b0() {
            switch (this.operator) {
                case 7:
                case 1:
                case 3:
                case 4:
                case 5:
                case 6:
                case 9:
                case 2:
                case 8: return true;
            }
            return false;
        }
        get_precedence() {
            switch (this.operator) {
                case 15: return 0;
                case 9: return 4;
                case 12: return 6;
                case 13: return 7;
                case 14: return 8;
                case 10: return 9;
                case 11: return 10;
                case 5: return 11;
                case 3: return 12;
                case 6: return 13;
                case 4: return 14;
                case 1: return 16;
                case 2: return 17;
                case 7: return 18;
                case 8: return 19;
                case 0: return 99;
            }
            return 99;
        }
        evaluate(a, b, c) {
            switch (this.operator) {
                case 10:
                case 13:
                case 14:
                case 12:
                case 11: return this.b2(a, b, c);
                case 0:
                case 1:
                case 3:
                case 4:
                case 5:
                case 6:
                case 2: return this.b3(a, b, c);
                case 7:
                case 9:
                case 8: return this.b4(a, b, c);
                case 15: if (this.left != null) {
                    return this.left.evaluate(a, b, c);
                }
                else {
                    if (this.right == null) {
                        return null;
                    }
                    return this.right.evaluate(a, b, c);
                }
            }
            throw new NotImplementedException(0);
        }
        b3(a, b, c) {
            let d = null;
            let e = null;
            let f = -1;
            if (this.left != null) {
                d = this.left.evaluate(a, b, c);
            }
            if (this.right != null) {
                e = this.right.evaluate(a, b, c);
            }
            if (d == null && e == null) {
                f = 0;
            }
            let g = null;
            let h = null;
            if (typeCast(IComparable_$type, d) !== null) {
                g = d;
            }
            if (typeCast(IComparable_$type, e) !== null) {
                h = e;
            }
            if (typeof d === 'number' && isNaN_(d) || typeof e === 'number' && isNaN_(e) || typeof d === 'number' && isNaN_(d) || typeof e === 'number' && isNaN_(e)) {
                return false;
            }
            if (typeCast(Date_$type, d) !== null && typeCast(Date_$type, e) !== null) {
                switch (this.operator) {
                    case 1: return d.getTime() == e.getTime();
                    case 2: return d.getTime() != e.getTime();
                    case 3: return d.getTime() > e.getTime();
                    case 4: return d.getTime() >= e.getTime();
                    case 5: return d.getTime() < e.getTime();
                    case 6: return d.getTime() <= e.getTime();
                }
            }
            if (g != null) {
                if (e == null) {
                    f = CompareUtil.compareToObject(g, 0);
                    if (f == 0) {
                        f = -1;
                    }
                }
                else {
                    f = CompareUtil.compareToObject(g, e);
                }
            }
            else if (h != null) {
                if (d == null) {
                    let i = CompareUtil.compareToObject(h, 0);
                    if (i == 0) {
                        f = 1;
                    }
                    else {
                        f = 1;
                        if (i == 0) {
                            f = 0;
                        }
                        if (i > 0) {
                            f = -1;
                        }
                    }
                }
                else {
                    let j = CompareUtil.compareToObject(h, d);
                    f = 1;
                    if (j == 0) {
                        f = 0;
                    }
                    if (j > 0) {
                        f = -1;
                    }
                }
            }
            else {
                let k = null;
                let l = null;
                if (d != null) {
                    k = d.toString();
                }
                if (e != null) {
                    l = e.toString();
                }
                if (k != null) {
                    if (l == null) {
                        f = 1;
                    }
                    else {
                        f = stringCompareTo(k, l);
                    }
                }
                else if (l != null) {
                    if (k == null) {
                        f = -1;
                    }
                    else {
                        let m = stringCompareTo(l, k);
                        f = 1;
                        if (m == 0) {
                            f = 0;
                        }
                        if (m > 0) {
                            f = -1;
                        }
                    }
                }
                else {
                    f = 0;
                }
            }
            switch (this.operator) {
                case 0:
                case 1: return f == 0;
                case 3: return f > 0;
                case 4: return f >= 0;
                case 5: return f < 0;
                case 6: return f <= 0;
                case 2: return f != 0;
            }
            throw new InvalidOperationException(0);
        }
        b4(a, b, c) {
            let d = null;
            let e = null;
            if (this.left != null) {
                d = this.left.evaluate(a, b, c);
            }
            if (this.right != null) {
                e = this.right.evaluate(a, b, c);
            }
            if (e == null && d == null) {
                return false;
            }
            if (e == null) {
                e = false;
            }
            if (d == null) {
                d = false;
            }
            switch (this.operator) {
                case 7: return d && e;
                case 9: if (this.left == null) {
                    return !e;
                }
                else {
                    return !d;
                }
                case 8: return d || e;
            }
            return false;
        }
        b2(a, b, c) {
            let d = null;
            let e = null;
            if (this.left != null) {
                d = this.left.evaluate(a, b, c);
            }
            if (this.right != null) {
                e = this.right.evaluate(a, b, c);
            }
            if (d == null) {
                return e;
            }
            if (e == null) {
                return d;
            }
            if (d == null && e == null) {
                return 0;
            }
            if (typeof d === 'number' || typeof e === 'number') {
                switch (this.operator) {
                    case 10: return d + e;
                    case 13: return d / e;
                    case 14: return d % e;
                    case 12: return d * e;
                    case 11: return d - e;
                }
            }
            if (typeof d === 'number' || typeof e === 'number') {
                switch (this.operator) {
                    case 10: return d + e;
                    case 13: return d / e;
                    case 14: return d % e;
                    case 12: return d * e;
                    case 11: return d - e;
                }
            }
            if (typeof d === 'number' || typeof e === 'number') {
                switch (this.operator) {
                    case 10: return d + e;
                    case 13: return d / e;
                    case 14: return d % e;
                    case 12: return d * e;
                    case 11: return d - e;
                }
            }
            if (typeof d === 'number' || typeof e === 'number') {
                switch (this.operator) {
                    case 10: return typeGetValue(d) + typeGetValue(e);
                    case 13: return intDivide(typeGetValue(d), typeGetValue(e));
                    case 14: return typeGetValue(d) % typeGetValue(e);
                    case 12: return typeGetValue(d) * typeGetValue(e);
                    case 11: return typeGetValue(d) - typeGetValue(e);
                }
            }
            if (typeof d === 'number' || typeof e === 'number') {
                switch (this.operator) {
                    case 10: return typeGetValue(d) + typeGetValue(e);
                    case 13: return intDivide(typeGetValue(d), typeGetValue(e));
                    case 14: return typeGetValue(d) % typeGetValue(e);
                    case 12: return typeGetValue(d) * typeGetValue(e);
                    case 11: return typeGetValue(d) - typeGetValue(e);
                }
            }
            if (typeof d === 'number' || typeof e === 'number') {
                switch (this.operator) {
                    case 10: return typeGetValue(d) + typeGetValue(e);
                    case 13: return intDivide(typeGetValue(d), typeGetValue(e));
                    case 14: return typeGetValue(d) % typeGetValue(e);
                    case 12: return typeGetValue(d) * typeGetValue(e);
                    case 11: return typeGetValue(d) - typeGetValue(e);
                }
            }
            if (typeof d === 'number' || typeof e === 'number') {
                switch (this.operator) {
                    case 10: return typeGetValue(d) + typeGetValue(e);
                    case 13: return intDivide(typeGetValue(d), typeGetValue(e));
                    case 14: return typeGetValue(d) % typeGetValue(e);
                    case 12: return typeGetValue(d) * typeGetValue(e);
                    case 11: return typeGetValue(d) - typeGetValue(e);
                }
            }
            throw new NotImplementedException(0);
        }
    }
    OperationFilterExpression.$t = /*@__PURE__*/ markType(OperationFilterExpression, 'OperationFilterExpression', FilterExpression.$, [IOperationFilterExpression_$type]);
    return OperationFilterExpression;
})();
/**
 * @hidden
 */
export let FunctionFilterExpression = /*@__PURE__*/ (() => {
    class FunctionFilterExpression extends FilterExpression {
        constructor(a, ...b) {
            super();
            this.br = 19;
            this.bq = new FilterExpressionCollection();
            this.br = a;
            for (let c = 0; c < b.length; c++) {
                this.bq.add(b[c]);
            }
        }
        get_isFunction() {
            return true;
        }
        bn() {
            return this.bs;
        }
        get functionType() {
            return this.br;
        }
        set functionType(a) {
            let b = enumGetBox(FilterExpressionFunctionType_$type, this.br);
            let c = a;
            if (c == null) {
                a = 0;
            }
            if ((typeof c == "number")) {
                let d = typeGetValue(c);
                if ((EnumUtil.getName(FilterExpressionFunctionType_$type, d) == undefined)) {
                    a = 0;
                }
                a = d;
            }
            else {
                a = (typeGetValue(EnumUtil.parse(FilterExpressionFunctionType_$type, c, true)));
            }
            this.br = a;
            this.bp();
        }
        get bs() {
            switch (this.functionType) {
                case 1:
                case 2:
                case 0: return true;
            }
            return false;
        }
        get functionArguments() {
            return this.bq;
        }
        get hasFunctionArguments() {
            return this.bq.k.count > 0;
        }
        evaluate(a, b, c) {
            let d = null;
            let e = null;
            let f = null;
            let g = null;
            let h = this.functionArguments.k;
            if (h.count > 0) {
                for (let i = 0; i < h.count; i++) {
                    let j = null;
                    if (h.item(i) != null) {
                        j = h.item(i).evaluate(a, b, c);
                    }
                    switch (i) {
                        case 0:
                            d = j;
                            break;
                        case 1:
                            e = j;
                            break;
                        case 2:
                            f = j;
                            break;
                        case 3:
                            g = j;
                            break;
                    }
                    if (i > 3) {
                        break;
                    }
                }
            }
            switch (this.functionType) {
                case 19:
                    if (d == null) {
                        d = 0;
                    }
                    return Math.ceil(d);
                case 18:
                    if (d == null) {
                        d = 0;
                    }
                    return Math.floor(d);
                case 17:
                    if (d == null) {
                        d = 0;
                    }
                    if (typeof d === 'number') {
                        return Math.round(d);
                    }
                    return Math.round(d);
                case 11:
                    if (d == null) {
                        return 0;
                    }
                    return d.getDate();
                case 12:
                    if (d == null) {
                        return 0;
                    }
                    return d.getHours();
                case 13:
                    if (d == null) {
                        return 0;
                    }
                    return d.getMinutes();
                case 14:
                    if (d == null) {
                        return 0;
                    }
                    return dateGetMonth(d);
                case 16:
                    if (d == null) {
                        return 0;
                    }
                    return d.getFullYear();
                case 15:
                    if (d == null) {
                        return 0;
                    }
                    return d.getSeconds();
                case 20:
                    if (d == null) {
                        return 0;
                    }
                    return dateGetDate(d);
                case 21:
                    if (d == null) {
                        return 0;
                    }
                    return d;
                case 22: return dateNow();
                case 23:
                    let k = this.bv(e, f);
                    let l = d;
                    if (l == null) {
                        return true;
                    }
                    if (k == null) {
                        return false;
                    }
                    if (k.isAssignableFrom(getInstanceType(l))) {
                        return true;
                    }
                    return false;
                case 24:
                    let m = this.bv(e, d);
                    let n = d;
                    if (n == null) {
                        return null;
                    }
                    if (m == null) {
                        return null;
                    }
                    return this.bt(n, m);
                case 10:
                    if (d == null) {
                        d = "";
                    }
                    if (e == null) {
                        e = "";
                    }
                    return stringConcat(d, e);
                case 1:
                    if (d == null) {
                        d = "";
                    }
                    if (e == null) {
                        e = "";
                    }
                    return stringEndsWith(d, e);
                case 4:
                    if (d == null) {
                        d = "";
                    }
                    if (e == null) {
                        e = "";
                    }
                    return d.indexOf(e);
                case FilterExpressionFunctionType.Length:
                    if (d == null) {
                        d = "";
                    }
                    return d.length;
                case 5:
                    if (d == null) {
                        d = "";
                    }
                    if (e == null) {
                        e = "";
                    }
                    if (f == null) {
                        f = "";
                    }
                    return stringReplace(d, e, f);
                case 2:
                    if (d == null) {
                        d = "";
                    }
                    if (e == null) {
                        e = "";
                    }
                    return stringStartsWith(d, e);
                case 6:
                    if (d == null) {
                        d = "";
                    }
                    if (e == null) {
                        e = 0;
                    }
                    if (f != null) {
                        return d.substr(typeGetValue(e), typeGetValue(f));
                    }
                    else {
                        return d.substr(typeGetValue(e));
                    }
                case 0:
                    if (d == null) {
                        d = "";
                    }
                    if (e == null) {
                        e = "";
                    }
                    return stringContains(d, e);
                case 7:
                    if (d == null) {
                        d = "";
                    }
                    return d.toLowerCase();
                case 8:
                    if (d == null) {
                        d = "";
                    }
                    return d.toUpperCase();
                case 9:
                    if (d == null) {
                        d = "";
                    }
                    return d.trim();
            }
            throw new NotImplementedException(0);
        }
        get_precedence() {
            switch (this.functionType) {
                case 23: return 15;
                case 24: return 5;
            }
            return 2;
        }
        bt(a, b) {
            if (b == String_$type) {
                if (a == null) {
                    return "";
                }
                return a.toString();
            }
            else if (b == Number_$type || b == Number_$type || b == Number_$type) {
                return Convert.toInt321(a);
            }
            else if (b == Boolean_$type) {
                return Convert.toBoolean(a);
            }
            else if (b == Number_$type) {
                return Convert.toByte1(a);
            }
            else if (b == Date_$type) {
                return Convert.toDateTime(a);
            }
            else if (b == Number_$type || b == Number_$type) {
                return Convert.toInt64(a);
            }
            else if (b == Number_$type) {
                return Convert.toDecimal2(a);
            }
            else {
                return a;
            }
        }
        bv(a, b) {
            if (typeCast(DataSourceSchemaPropertyType_$type, a) !== null || typeof a === 'number') {
                let c = typeGetValue(a);
                switch (c) {
                    case 2: return Boolean_$type;
                    case 10: return Number_$type;
                    case 9: return Date_$type;
                    case 8: return Date_$type;
                    case 6: return Number_$type;
                    case 5: return Number_$type;
                    case 1: return Number_$type;
                    case 3: return Number_$type;
                    case 11:
                        if (b != null && typeof b === 'string') {
                            return this.bu(b);
                        }
                        return Base.$;
                    case 4: return Number_$type;
                    case 7: return Number_$type;
                    case 0: return String_$type;
                }
            }
            if (typeof a === 'string') {
                return this.bu(b);
            }
            return Base.$;
        }
        bu(a) {
            switch (a) {
                case "Edm.Boolean":
                case "Boolean":
                case "bool":
                case "boolean": return Boolean_$type;
                case "Edm.Byte":
                case "Byte":
                case "byte":
                case "Edm.SByte":
                case "SByte": return Number_$type;
                case "Edm.DateTimeOffset":
                case "DateTimeOffset": return Date_$type;
                case "Edm.DateTime":
                case "DateTime":
                case "Calendar":
                case "datetime":
                case "calendar":
                case "Edm.Time":
                case "Time":
                case "time": return Date_$type;
                case "Edm.Decimal":
                case "Decimal":
                case "decimal": return Number_$type;
                case "Edm.Double":
                case "Double":
                case "double": return Number_$type;
                case "Edm.Float":
                case "Float":
                case "float":
                case "Edm.Single":
                case "Single":
                case "single": return Number_$type;
                case "Edm.Int16":
                case "Int16":
                case "Short":
                case "short": return Number_$type;
                case "Edm.Int32":
                case "Int32":
                case "int":
                case "Integer": return Number_$type;
                case "Edm.Int64":
                case "Int64":
                case "long":
                case "Long": return Number_$type;
                case "Edm.String":
                case "String":
                case "string": return String_$type;
            }
            return Base.$;
        }
    }
    FunctionFilterExpression.$t = /*@__PURE__*/ markType(FunctionFilterExpression, 'FunctionFilterExpression', FilterExpression.$, [IFunctionFilterExpression_$type]);
    return FunctionFilterExpression;
})();
/**
 * @hidden
 */
export let PropertyReferenceFilterExpression = /*@__PURE__*/ (() => {
    class PropertyReferenceFilterExpression extends FilterExpression {
        constructor(a) {
            super();
            this.bq = null;
            this.bq = a;
        }
        get_isPropertyReference() {
            return true;
        }
        get_precedence() {
            return 99;
        }
        bn() {
            return false;
        }
        get propertyReference() {
            return this.bq;
        }
        set propertyReference(a) {
            this.bq = a;
        }
        evaluate(a, b, c) {
            let d = b.getItemValue(a, this.propertyReference);
            return d;
        }
    }
    PropertyReferenceFilterExpression.$t = /*@__PURE__*/ markType(PropertyReferenceFilterExpression, 'PropertyReferenceFilterExpression', FilterExpression.$, [IPropertyReferenceFilterExpression_$type]);
    return PropertyReferenceFilterExpression;
})();
/**
 * @hidden
 */
export let LiteralFilterExpression = /*@__PURE__*/ (() => {
    class LiteralFilterExpression extends FilterExpression {
        constructor(a, b) {
            super();
            this.br = null;
            this.bq = false;
            this.br = a;
        }
        get_precedence() {
            return 99;
        }
        get_isLiteral() {
            return true;
        }
        get_isNull() {
            return this.literalValue == null;
        }
        get literalValue() {
            return this.br;
        }
        set literalValue(a) {
            this.br = a;
        }
        get leaveUnquoted() {
            return this.bq;
        }
        set leaveUnquoted(a) {
            this.bq = a;
        }
        bn() {
            return typeCast(Boolean_$type, this.literalValue) !== null;
        }
        evaluate(a, b, c) {
            return this.literalValue;
        }
    }
    LiteralFilterExpression.$t = /*@__PURE__*/ markType(LiteralFilterExpression, 'LiteralFilterExpression', FilterExpression.$, [ILiteralFilterExpression_$type]);
    return LiteralFilterExpression;
})();
/**
 * @hidden
 */
export let WrapperExpression = /*@__PURE__*/ (() => {
    class WrapperExpression extends FilterExpression {
        constructor(a, ..._rest) {
            super();
            this.bq = null;
            this.bw = false;
            this._innerExpression = null;
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        this.expression = FilterFactory.instance.property(c);
                        this.propertyName = c;
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        this.expression = c;
                        if (this.expression.isPropertyReference) {
                            this.propertyName = this.expression.propertyReference;
                        }
                    }
                    break;
            }
        }
        get innerExpression() {
            return this._innerExpression;
        }
        set innerExpression(a) {
            this._innerExpression = a;
        }
        get expression() {
            return this.bq;
        }
        set expression(a) {
            this.bq = a;
            this.bw = true;
        }
        get propertyName() {
            if (this.bq == null || !this.bq.isPropertyReference) {
                return null;
            }
            return this.bq.propertyReference;
        }
        set propertyName(a) {
            this.expression = FilterExpression.property(a);
        }
        get_isWrapper() {
            return true;
        }
        get_precedence() {
            return 99;
        }
        get bt() {
            return FilterFactory.instance;
        }
        bn() {
            return true;
        }
        evaluate(a, b, c) {
            if (this.innerExpression == null || this.bw) {
                this.innerExpression = this.bu();
                this.bw = false;
            }
            return this.innerExpression.evaluate(a, b, c);
        }
    }
    WrapperExpression.$t = /*@__PURE__*/ markType(WrapperExpression, 'WrapperExpression', FilterExpression.$);
    return WrapperExpression;
})();
/**
 * @hidden
 */
export let TodayExpression = /*@__PURE__*/ (() => {
    class TodayExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 0;
        }
        bu() {
            let a = +(this.bt.todayOverride) != +(dateMinValue()) ? this.bt.todayOverride : dateGetDate(dateNow());
            let b = FilterFactory.instance.literal(dateGetMonth(a));
            let c = FilterFactory.instance.literal(a.getDate());
            let d = FilterFactory.instance.literal(a.getFullYear());
            return this.expression.month().isEqualTo(b).and(this.expression.day().isEqualTo(c)).and(this.expression.year().isEqualTo(d));
        }
    }
    TodayExpression.$t = /*@__PURE__*/ markType(TodayExpression, 'TodayExpression', WrapperExpression.$);
    return TodayExpression;
})();
/**
 * @hidden
 */
export let TomorrowExpression = /*@__PURE__*/ (() => {
    class TomorrowExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 1;
        }
        bu() {
            let a = +(this.bt.todayOverride) != +(dateMinValue()) ? this.bt.todayOverride : dateGetDate(dateNow());
            a = dateAddDays(a, 1);
            let b = FilterFactory.instance.literal(dateGetMonth(a));
            let c = FilterFactory.instance.literal(a.getDate());
            let d = FilterFactory.instance.literal(a.getFullYear());
            return this.expression.month().isEqualTo(b).and(this.expression.day().isEqualTo(c)).and(this.expression.year().isEqualTo(d));
        }
    }
    TomorrowExpression.$t = /*@__PURE__*/ markType(TomorrowExpression, 'TomorrowExpression', WrapperExpression.$);
    return TomorrowExpression;
})();
/**
 * @hidden
 */
export let YesterdayExpression = /*@__PURE__*/ (() => {
    class YesterdayExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 2;
        }
        bu() {
            let a = +(this.bt.todayOverride) != +(dateMinValue()) ? this.bt.todayOverride : dateGetDate(dateNow());
            a = dateAddDays(a, -1);
            let b = FilterFactory.instance.literal(dateGetMonth(a));
            let c = FilterFactory.instance.literal(a.getDate());
            let d = FilterFactory.instance.literal(a.getFullYear());
            return this.expression.month().isEqualTo(b).and(this.expression.day().isEqualTo(c)).and(this.expression.year().isEqualTo(d));
        }
    }
    YesterdayExpression.$t = /*@__PURE__*/ markType(YesterdayExpression, 'YesterdayExpression', WrapperExpression.$);
    return YesterdayExpression;
})();
/**
 * @hidden
 */
export let OffsettableWeekExpression = /*@__PURE__*/ (() => {
    class OffsettableWeekExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                        this.by = 0;
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                        this.by = 0;
                    }
                    break;
            }
        }
        bu() {
            let a = +(this.bt.todayOverride) != +(dateMinValue()) ? this.bt.todayOverride : dateGetDate(dateNow());
            a = dateAddDays(a, this.by);
            let b = dateAddDays(a, 0 - a.getDay());
            let c = dateAddDays(a, 6 - a.getDay());
            let d = false;
            let e = dateMinValue();
            let f = dateMinValue();
            let g = dateMinValue();
            let h = dateMinValue();
            for (let i = 0; i < 7; i++) {
                let j = dateAddDays(c, -i);
                if (j.getDate() == 1) {
                    if (i == 6) {
                        break;
                    }
                    d = true;
                    f = dateAddDays(j, -1);
                    e = dateAddDays(f, -(6 - i - 1));
                    g = j;
                    h = dateAddDays(j, i);
                    break;
                }
            }
            if (d) {
                let k = this.expression.year().isEqualTo(this.bt.literal(e.getFullYear())).and(this.expression.month().isEqualTo(this.bt.literal(dateGetMonth(e))));
                let l = null;
                if (f.getDate() - e.getDate() > 0) {
                    l = this.expression.day().isGreaterThanOrEqualTo(this.bt.literal(e.getDate())).and(this.expression.day().isLessThanOrEqualTo(this.bt.literal(f.getDate())));
                }
                else {
                    l = this.expression.day().isEqualTo(this.bt.literal(e.getDate()));
                }
                let m = k.and(l);
                let n = this.expression.year().isEqualTo(this.bt.literal(g.getFullYear())).and(this.expression.month().isEqualTo(this.bt.literal(dateGetMonth(g))));
                let o = null;
                if (h.getDate() - g.getDate() > 0) {
                    o = this.expression.day().isGreaterThanOrEqualTo(this.bt.literal(g.getDate())).and(this.expression.day().isLessThanOrEqualTo(this.bt.literal(h.getDate())));
                }
                else {
                    o = this.expression.day().isEqualTo(this.bt.literal(g.getDate()));
                }
                let p = n.and(o);
                return m.or(p);
            }
            let q = FilterFactory.instance.literal(dateGetMonth(a));
            let r = FilterFactory.instance.literal(a.getFullYear());
            let s = FilterFactory.instance.literal(b.getDate());
            let t = FilterFactory.instance.literal(c.getDate());
            return this.expression.year().isEqualTo(r).and(this.expression.month().isEqualTo(q)).and(this.expression.day().isGreaterThanOrEqualTo(s)).and(this.expression.day().isLessThanOrEqualTo(t));
        }
    }
    OffsettableWeekExpression.$t = /*@__PURE__*/ markType(OffsettableWeekExpression, 'OffsettableWeekExpression', WrapperExpression.$);
    return OffsettableWeekExpression;
})();
/**
 * @hidden
 */
export let ThisWeekExpression = /*@__PURE__*/ (() => {
    class ThisWeekExpression extends OffsettableWeekExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 3;
        }
    }
    ThisWeekExpression.$t = /*@__PURE__*/ markType(ThisWeekExpression, 'ThisWeekExpression', OffsettableWeekExpression.$);
    return ThisWeekExpression;
})();
/**
 * @hidden
 */
export let NextWeekExpression = /*@__PURE__*/ (() => {
    class NextWeekExpression extends OffsettableWeekExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                        this.by = 7;
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                        this.by = 7;
                    }
                    break;
            }
        }
        getWrapperType() {
            return 4;
        }
    }
    NextWeekExpression.$t = /*@__PURE__*/ markType(NextWeekExpression, 'NextWeekExpression', OffsettableWeekExpression.$);
    return NextWeekExpression;
})();
/**
 * @hidden
 */
export let LastWeekExpression = /*@__PURE__*/ (() => {
    class LastWeekExpression extends OffsettableWeekExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                        this.by = -7;
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                        this.by = -7;
                    }
                    break;
            }
        }
        getWrapperType() {
            return 5;
        }
    }
    LastWeekExpression.$t = /*@__PURE__*/ markType(LastWeekExpression, 'LastWeekExpression', OffsettableWeekExpression.$);
    return LastWeekExpression;
})();
/**
 * @hidden
 */
export let ThisMonthExpression = /*@__PURE__*/ (() => {
    class ThisMonthExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 6;
        }
        bu() {
            let a = +(this.bt.todayOverride) != +(dateMinValue()) ? this.bt.todayOverride : dateGetDate(dateNow());
            return this.expression.year().isEqualTo(this.bt.literal(a.getFullYear())).and(this.expression.month().isEqualTo(this.bt.literal(dateGetMonth(a))));
        }
    }
    ThisMonthExpression.$t = /*@__PURE__*/ markType(ThisMonthExpression, 'ThisMonthExpression', WrapperExpression.$);
    return ThisMonthExpression;
})();
/**
 * @hidden
 */
export let NextMonthExpression = /*@__PURE__*/ (() => {
    class NextMonthExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 7;
        }
        bu() {
            let a = +(this.bt.todayOverride) != +(dateMinValue()) ? this.bt.todayOverride : dateGetDate(dateNow());
            a = dateAddMonths(a, 1);
            return this.expression.year().isEqualTo(this.bt.literal(a.getFullYear())).and(this.expression.month().isEqualTo(this.bt.literal(dateGetMonth(a))));
        }
    }
    NextMonthExpression.$t = /*@__PURE__*/ markType(NextMonthExpression, 'NextMonthExpression', WrapperExpression.$);
    return NextMonthExpression;
})();
/**
 * @hidden
 */
export let LastMonthExpression = /*@__PURE__*/ (() => {
    class LastMonthExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 8;
        }
        bu() {
            let a = +(this.bt.todayOverride) != +(dateMinValue()) ? this.bt.todayOverride : dateGetDate(dateNow());
            a = dateAddMonths(a, -1);
            return this.expression.year().isEqualTo(this.bt.literal(a.getFullYear())).and(this.expression.month().isEqualTo(this.bt.literal(dateGetMonth(a))));
        }
    }
    LastMonthExpression.$t = /*@__PURE__*/ markType(LastMonthExpression, 'LastMonthExpression', WrapperExpression.$);
    return LastMonthExpression;
})();
/**
 * @hidden
 */
export let ThisYearExpression = /*@__PURE__*/ (() => {
    class ThisYearExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 9;
        }
        bu() {
            let a = +(this.bt.todayOverride) != +(dateMinValue()) ? this.bt.todayOverride : dateGetDate(dateNow());
            return this.expression.year().isEqualTo(this.bt.literal(a.getFullYear()));
        }
    }
    ThisYearExpression.$t = /*@__PURE__*/ markType(ThisYearExpression, 'ThisYearExpression', WrapperExpression.$);
    return ThisYearExpression;
})();
/**
 * @hidden
 */
export let NextYearExpression = /*@__PURE__*/ (() => {
    class NextYearExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 10;
        }
        bu() {
            let a = +(this.bt.todayOverride) != +(dateMinValue()) ? this.bt.todayOverride : dateGetDate(dateNow());
            a = dateAddYears(a, 1);
            return this.expression.year().isEqualTo(this.bt.literal(a.getFullYear()));
        }
    }
    NextYearExpression.$t = /*@__PURE__*/ markType(NextYearExpression, 'NextYearExpression', WrapperExpression.$);
    return NextYearExpression;
})();
/**
 * @hidden
 */
export let LastYearExpression = /*@__PURE__*/ (() => {
    class LastYearExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 11;
        }
        bu() {
            let a = +(this.bt.todayOverride) != +(dateMinValue()) ? this.bt.todayOverride : dateGetDate(dateNow());
            a = dateAddYears(a, -1);
            return this.expression.year().isEqualTo(this.bt.literal(a.getFullYear()));
        }
    }
    LastYearExpression.$t = /*@__PURE__*/ markType(LastYearExpression, 'LastYearExpression', WrapperExpression.$);
    return LastYearExpression;
})();
/**
 * @hidden
 */
export let YearToDateExpression = /*@__PURE__*/ (() => {
    class YearToDateExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 15;
        }
        bu() {
            let a = +(this.bt.todayOverride) != +(dateMinValue()) ? this.bt.todayOverride : dateGetDate(dateNow());
            return this.expression.year().isEqualTo(this.bt.literal(a.getFullYear())).and(this.expression.month().isEqualTo(this.bt.literal(dateGetMonth(a))).and(this.expression.day().isLessThanOrEqualTo(this.bt.literal(a.getDate()))).or(this.expression.month().isLessThan(this.bt.literal(dateGetMonth(a)))));
        }
    }
    YearToDateExpression.$t = /*@__PURE__*/ markType(YearToDateExpression, 'YearToDateExpression', WrapperExpression.$);
    return YearToDateExpression;
})();
/**
 * @hidden
 */
export let ThisQuarterExpression = /*@__PURE__*/ (() => {
    class ThisQuarterExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 12;
        }
        bu() {
            let a = +(this.bt.todayOverride) != +(dateMinValue()) ? this.bt.todayOverride : dateGetDate(dateNow());
            let b = this.expression.year().isEqualTo(this.bt.literal(a.getFullYear()));
            if (dateGetMonth(a) == 1 || dateGetMonth(a) == 2 || dateGetMonth(a) == 3) {
                return b.and(this.expression.isQ1());
            }
            else if (dateGetMonth(a) == 4 || dateGetMonth(a) == 5 || dateGetMonth(a) == 6) {
                return b.and(this.expression.isQ2());
            }
            else if (dateGetMonth(a) == 7 || dateGetMonth(a) == 8 || dateGetMonth(a) == 9) {
                return b.and(this.expression.isQ3());
            }
            else {
                return b.and(this.expression.isQ4());
            }
        }
    }
    ThisQuarterExpression.$t = /*@__PURE__*/ markType(ThisQuarterExpression, 'ThisQuarterExpression', WrapperExpression.$);
    return ThisQuarterExpression;
})();
/**
 * @hidden
 */
export let NextQuarterExpression = /*@__PURE__*/ (() => {
    class NextQuarterExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 13;
        }
        bu() {
            let a = +(this.bt.todayOverride) != +(dateMinValue()) ? this.bt.todayOverride : dateGetDate(dateNow());
            let b = this.expression.year().isEqualTo(this.bt.literal(a.getFullYear()));
            if (dateGetMonth(a) == 1 || dateGetMonth(a) == 2 || dateGetMonth(a) == 3) {
                return b.and(this.expression.isQ2());
            }
            else if (dateGetMonth(a) == 4 || dateGetMonth(a) == 5 || dateGetMonth(a) == 6) {
                return b.and(this.expression.isQ3());
            }
            else if (dateGetMonth(a) == 7 || dateGetMonth(a) == 8 || dateGetMonth(a) == 9) {
                return b.and(this.expression.isQ4());
            }
            else {
                return this.expression.year().isEqualTo(this.bt.literal(a.getFullYear() + 1)).and(this.expression.isQ1());
            }
        }
    }
    NextQuarterExpression.$t = /*@__PURE__*/ markType(NextQuarterExpression, 'NextQuarterExpression', WrapperExpression.$);
    return NextQuarterExpression;
})();
/**
 * @hidden
 */
export let LastQuarterExpression = /*@__PURE__*/ (() => {
    class LastQuarterExpression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 13;
        }
        bu() {
            let a = +(this.bt.todayOverride) != +(dateMinValue()) ? this.bt.todayOverride : dateGetDate(dateNow());
            let b = this.expression.year().isEqualTo(this.bt.literal(a.getFullYear()));
            if (dateGetMonth(a) == 1 || dateGetMonth(a) == 2 || dateGetMonth(a) == 3) {
                return this.expression.year().isEqualTo(this.bt.literal(a.getFullYear() - 1)).and(this.expression.isQ4());
            }
            else if (dateGetMonth(a) == 4 || dateGetMonth(a) == 5 || dateGetMonth(a) == 6) {
                return b.and(this.expression.isQ1());
            }
            else if (dateGetMonth(a) == 7 || dateGetMonth(a) == 8 || dateGetMonth(a) == 9) {
                return b.and(this.expression.isQ2());
            }
            else {
                return b.and(this.expression.isQ3());
            }
        }
    }
    LastQuarterExpression.$t = /*@__PURE__*/ markType(LastQuarterExpression, 'LastQuarterExpression', WrapperExpression.$);
    return LastQuarterExpression;
})();
/**
 * @hidden
 */
export let Q1Expression = /*@__PURE__*/ (() => {
    class Q1Expression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 16;
        }
        bu() {
            return this.expression.month().isEqualTo(this.bt.literal(1)).or(this.expression.month().isEqualTo(this.bt.literal(2))).or(this.expression.month().isEqualTo(this.bt.literal(3)));
        }
    }
    Q1Expression.$t = /*@__PURE__*/ markType(Q1Expression, 'Q1Expression', WrapperExpression.$);
    return Q1Expression;
})();
/**
 * @hidden
 */
export let Q2Expression = /*@__PURE__*/ (() => {
    class Q2Expression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 17;
        }
        bu() {
            return this.expression.month().isEqualTo(this.bt.literal(4)).or(this.expression.month().isEqualTo(this.bt.literal(5))).or(this.expression.month().isEqualTo(this.bt.literal(6)));
        }
    }
    Q2Expression.$t = /*@__PURE__*/ markType(Q2Expression, 'Q2Expression', WrapperExpression.$);
    return Q2Expression;
})();
/**
 * @hidden
 */
export let Q3Expression = /*@__PURE__*/ (() => {
    class Q3Expression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 18;
        }
        bu() {
            return this.expression.month().isEqualTo(this.bt.literal(7)).or(this.expression.month().isEqualTo(this.bt.literal(8))).or(this.expression.month().isEqualTo(this.bt.literal(9)));
        }
    }
    Q3Expression.$t = /*@__PURE__*/ markType(Q3Expression, 'Q3Expression', WrapperExpression.$);
    return Q3Expression;
})();
/**
 * @hidden
 */
export let Q4Expression = /*@__PURE__*/ (() => {
    class Q4Expression extends WrapperExpression {
        constructor(a, ..._rest) {
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        super(0, c);
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        super(1, c);
                    }
                    break;
            }
        }
        getWrapperType() {
            return 19;
        }
        bu() {
            return this.expression.month().isEqualTo(this.bt.literal(10)).or(this.expression.month().isEqualTo(this.bt.literal(11))).or(this.expression.month().isEqualTo(this.bt.literal(12)));
        }
    }
    Q4Expression.$t = /*@__PURE__*/ markType(Q4Expression, 'Q4Expression', WrapperExpression.$);
    return Q4Expression;
})();
