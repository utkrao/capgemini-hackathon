import { Base, FormatException, Type, Nullable$1, IEnumerable$1, Stream, IFormatProvider } from "igniteui-react-core";
import { Encoding } from "igniteui-react-core";
import { Color } from "igniteui-react-core";
import { EscherSysIndex } from "./EscherSysIndex";
import { CultureInfo } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { IComparer$1 } from "igniteui-react-core";
import { BinaryReader } from "igniteui-react-core";
import { BinaryWriter } from "igniteui-react-core";
/**
 * @hidden
 */
export declare class DocCoreUtils extends Base {
    static $t: Type;
    static staticInit(): void;
    static a(a: number[]): number[];
    static n<T>($t: Type, a: string): FormatException;
    static am(a: Nullable$1<number>, b: Nullable$1<number>, c: Nullable$1<Color>, d: Nullable$1<number>, e: Nullable$1<EscherSysIndex>, f: Nullable$1<number>): {
        p2: Nullable$1<Color>;
        p3: Nullable$1<number>;
        p4: Nullable$1<EscherSysIndex>;
        p5: Nullable$1<number>;
    };
    static w(a: number): number;
    static an(a: Nullable$1<Color>, b: Nullable$1<number>, c: Nullable$1<EscherSysIndex>, d: Nullable$1<number>, e: Nullable$1<number>, f: Nullable$1<number>): {
        p4: Nullable$1<number>;
        p5: Nullable$1<number>;
    };
    static ai(a: number): number;
    static ak(a: boolean, b?: string): void;
    static al(a: string): void;
    static ao<T>($t: Type, a: IEnumerable$1<T>, b: (arg1: T) => void): void;
    static i(a: number): number;
    static af(a: number): Encoding;
    static r(a: Encoding): number;
    static y(a: Encoding): string;
    static o(a: number): CultureInfo;
    static s(a: string): number;
    static aa(a: string): string;
    static ab(a: string, ...b: any[]): string;
    static d(a: string): boolean;
    static e(a: any): boolean;
    static ap(a: string, b?: number, c?: string): void;
    static x(a: number): number;
    static j(a: number): number;
    private static b;
    static k(a: number, b: number): number;
    static aj(a: number, b: number): number;
    static t(a: number, b: number): number;
    static as<T>($t: Type, a: List$1<T>, b: IComparer$1<T>): void;
    static aq<T>($t: Type, a: T[], b: T[], c: IComparer$1<T>): void;
    static ar<T>($t: Type, a: T[], b: T[], c: IComparer$1<T>, d: number, e: number): void;
    private static at;
    static c(a: Stream): number[];
    static au<T>($t: Type, a: T, b: T): {
        p0?: T;
        p1?: T;
    };
    static p(a: number): number;
    static l(a: number): number;
    static v(a: string, b: string, c: string): {
        ret: Stream;
        p2: string;
    };
    static g(a: string, b: string, c: IFormatProvider, d: Date): {
        ret: boolean;
        p3: Date;
    };
    static u(a: number): number;
    static av(a: any, b: string): void;
    static aw<T>($t: Type, a: number, b: string, c: number, d: number): void;
    static get q(): number;
    static get ae(): Encoding;
    static f: boolean;
    static z(a: Stream): string;
    static ac(a: Encoding, b: number[]): string;
    static ag(a: Encoding, b: number): Encoding;
    static ad(a: BinaryReader): string;
    static ax(a: BinaryWriter, b: string): void;
}
