import { Base, Nullable$1, Type, Stream, IConvertible, Point, IList$1, ICollection$1, IEnumerable$1, IEnumerator$1, IEnumerator, IDisposable, BaseError, IEnumerable, ValueType, IFormatProvider, IComparable$1, EnumeratorWrapper, IEquatable$1, IComparable } from "igniteui-react-core";
import { WorkItem } from "./WorkItem";
import { List$1 } from "igniteui-react-core";
import { WorkbookThemeColorType } from "./WorkbookThemeColorType";
import { WorksheetCellFormatOptions } from "./WorksheetCellFormatOptions";
import { WorksheetTableStyleArea } from "./WorksheetTableStyleArea";
import { FontSuperscriptSubscriptStyle } from "./FontSuperscriptSubscriptStyle";
import { FontUnderlineStyle } from "./FontUnderlineStyle";
import { DiagonalBorders } from "./DiagonalBorders";
import { Color } from "igniteui-react-core";
import { CellBorderLineStyle } from "./CellBorderLineStyle";
import { FillPatternStyle } from "./FillPatternStyle";
import { WorksheetCellFormatType } from "./WorksheetCellFormatType";
import { WorkbookFormat } from "./WorkbookFormat";
import { BuiltInStyleType } from "./BuiltInStyleType";
import { CultureInfo, Calendar, DateTimeFormat } from "igniteui-react-core";
import { Encoding } from "igniteui-react-core";
import { Rect } from "igniteui-react-core";
import { WBitmap } from "./WBitmap";
import { ImageHolder } from "./ImageHolder";
import { ExcelImage } from "./ExcelImage";
import { ImageFormat } from "./ImageFormat";
import { CalendarType } from "./CalendarType";
import { StringComparer } from "igniteui-react-core";
import { Dictionary$2 } from "igniteui-react-core";
import { FontFamilyInternal } from "./FontFamilyInternal";
import { HashSet$1 } from "igniteui-react-core";
import { IComparer$1 } from "igniteui-react-core";
import { WeakReference } from "igniteui-react-core";
import { Uri } from "igniteui-react-core";
import { ST_IconSetType } from "./ST_IconSetType";
import { CellIconInfo } from "./CellIconInfo";
import { Guid } from "igniteui-react-core";
import { CellFormatValue } from "./CellFormatValue";
import { CellFormatValueChangedOptions } from "./CellFormatValueChangedOptions";
import { ArgumentExceptionExtension } from "./ArgumentExceptionExtension";
import { ArgumentOutOfRangeExceptionExtension } from "./ArgumentOutOfRangeExceptionExtension";
import { Regex } from "igniteui-react-core";
import { StringBuilder } from "igniteui-react-core";
import { PropertyTableBase_PropertyValue } from "./PropertyTableBase_PropertyValue";
import { PropertyType } from "./PropertyType";
import { XColorType } from "./XColorType";
import { FormatConditionIconSet } from "./FormatConditionIconSet";
import { Size } from "igniteui-react-core";
import { WorkItem$1 } from "./WorkItem$1";
import { WorkbookOptionsBase } from "./WorkbookOptionsBase";
import { IPackageFactory } from "./IPackageFactory";
import { StructuredStorageManager } from "./StructuredStorageManager";
import { IPackage } from "./IPackage";
import { CellReferenceMode } from "./CellReferenceMode";
import { HorizontalCellAlignment } from "./HorizontalCellAlignment";
import { TextFormatMode } from "./TextFormatMode";
import { VerticalCellAlignment } from "./VerticalCellAlignment";
import { WorksheetColumnWidthUnit } from "./WorksheetColumnWidthUnit";
import { ImageData } from "./ImageData";
import { BorderThickness } from "./BorderThickness";
import { Tuple$3 } from "igniteui-react-core";
import { FormulaType } from "./FormulaType";
import { FullColorExtInfo } from "./FullColorExtInfo";
import { GradStopInfo } from "./GradStopInfo";
import { XFExtGradientInfo } from "./XFExtGradientInfo";
import { XFPropColorInfo } from "./XFPropColorInfo";
import { ChartType } from "./ChartType";
import { PreventTextFormattingTypes } from "./PreventTextFormattingTypes";
import { SeriesType } from "./SeriesType";
import { SortMethod } from "./SortMethod";
import { FormatConditionIcon } from "./FormatConditionIcon";
import { FileMode } from "./FileMode";
import { SheetType } from "./SheetType";
import { IRegionAddress } from "./IRegionAddress";
import { ExcelChangeAction } from "./ExcelChangeAction";
import { DateInterval } from "./DateInterval";
import { FirstDayOfWeek } from "./FirstDayOfWeek";
import { FirstWeekOfYear } from "./FirstWeekOfYear";
import { WorksheetPermissions } from "./WorksheetPermissions";
import { CalculationMode } from "./CalculationMode";
import { DateSystem } from "./DateSystem";
import { WorkbookPasswordInfo } from "./WorkbookPasswordInfo";
import { Precision } from "./Precision";
import { ChartDeserializationCache } from "./ChartDeserializationCache";
import { BinaryData } from "./BinaryData";
import { KeyValuePair$2 } from "igniteui-react-core";
import { PivotCacheInfo } from "./PivotCacheInfo";
import { OleDataSpacesEncryptionMode } from "./OleDataSpacesEncryptionMode";
import { SortedList$2 } from "./SortedList$2";
import { RoundTripControlData } from "./RoundTripControlData";
import { ST_TotalsRowFunction } from "./ST_TotalsRowFunction";
import { ValueTuple$2 } from "./ValueTuple$2";
import { IDictionary$2 } from "igniteui-react-core";
import { Stack$1 } from "igniteui-react-core";
import { Directory } from "./Directory";
import { ReferenceActionCode } from "./ReferenceActionCode";
import { WorksheetVisibility } from "./WorksheetVisibility";
import { IgSize } from "igniteui-react-core";
import { FontScheme } from "./FontScheme";
import { ExtPropType } from "./ExtPropType";
import { ColorableItem } from "./ColorableItem";
import { XFPropType } from "./XFPropType";
import { ReadOnlyCollection$1 } from "igniteui-react-core";
import { WorkbookColorTransform } from "./WorkbookColorTransform";
import { CellShiftType } from "./CellShiftType";
import { WorksheetCellBlock_DataType } from "./WorksheetCellBlock_DataType";
import { ShiftAddressResult } from "./ShiftAddressResult";
import { WorkbookFontProxy_PropertyIds } from "./WorkbookFontProxy_PropertyIds";
import { AxisGroup } from "./AxisGroup";
import { SeriesChartTypeGroup } from "./SeriesChartTypeGroup";
import { StackedType } from "./StackedType";
import { AxisGroupValidationResult } from "./AxisGroupValidationResult";
import { ShapePositioningMode } from "./ShapePositioningMode";
import { ICalloutRule } from "./ICalloutRule";
import { ShapeType } from "./ShapeType";
import { ST_ShapeType } from "./ST_ShapeType";
import { PredefinedShapeType } from "./PredefinedShapeType";
import { PositioningOptions } from "./PositioningOptions";
import { IgRect } from "igniteui-react-core";
import { IgPoint } from "igniteui-react-core";
import { IEscherRecord } from "./IEscherRecord";
import { LineStyle } from "./LineStyle";
import { BorderLineStyle } from "./BorderLineStyle";
import { ApplyFormulaFlags } from "./ApplyFormulaFlags";
import { ReferenceShiftType } from "./ReferenceShiftType";
import { EvaluationResult$1 } from "./EvaluationResult$1";
import { IExcelCalcReferenceCollection } from "./IExcelCalcReferenceCollection";
import { ExcelCalcErrorCode } from "./ExcelCalcErrorCode";
import { HorizontalTitleAlignment } from "./HorizontalTitleAlignment";
import { TextHorizontalOverflow } from "./TextHorizontalOverflow";
import { ElementPosition } from "./ElementPosition";
import { ReadingOrder } from "./ReadingOrder";
import { TextDirection } from "./TextDirection";
import { VerticalTitleAlignment } from "./VerticalTitleAlignment";
import { TextVerticalOverflow } from "./TextVerticalOverflow";
import { UpDownBarType } from "./UpDownBarType";
import { BarShape } from "./BarShape";
import { DisplayBlanksAs } from "./DisplayBlanksAs";
import { Excel2007ChartData } from "./Excel2007ChartData";
import { Tuple$2 } from "igniteui-react-core";
import { ChartTypeContext } from "./ChartTypeContext";
import { MarkerStyle } from "./MarkerStyle";
import { AxisPosition } from "./AxisPosition";
import { XValuesDataType } from "./XValuesDataType";
import { SeriesValuesType } from "./SeriesValuesType";
import { AxisType } from "./AxisType";
import { WallType } from "./WallType";
import { AxisCrosses } from "./AxisCrosses";
import { TickMark } from "./TickMark";
import { DisplayUnit } from "./DisplayUnit";
import { DataLabelPosition } from "./DataLabelPosition";
import { TickLabelPosition } from "./TickLabelPosition";
import { WorksheetView } from "./WorksheetView";
import { PaneLocation } from "./PaneLocation";
import { ObjectDisplayStyle } from "./ObjectDisplayStyle";
import { ScrollBars } from "./ScrollBars";
import { DataValidationOperatorType } from "./DataValidationOperatorType";
import { DataValidationType } from "./DataValidationType";
import { DataValidationErrorStyle } from "./DataValidationErrorStyle";
import { DataValidationImeMode } from "./DataValidationImeMode";
import { Token } from "./Token";
import { TokenClass } from "./TokenClass";
import { NameType } from "./NameType";
import { GetCellTextResult } from "./GetCellTextResult";
import { WorksheetTableColumnArea } from "./WorksheetTableColumnArea";
import { MutableItemRange } from "./MutableItemRange";
import { FormatConditionType } from "./FormatConditionType";
import { FormatConditionNotificationType } from "./FormatConditionNotificationType";
import { IWorksheetElementResizeContext } from "./IWorksheetElementResizeContext";
import { IndexRange } from "./IndexRange";
import { WorksheetElementResizeState } from "./WorksheetElementResizeState";
import { BiffSheetType } from "./BiffSheetType";
import { CellShiftResult } from "./CellShiftResult";
import { PivotTableInfo } from "./PivotTableInfo";
import { WorksheetItemPosition } from "./WorksheetItemPosition";
import { CellShiftInitializeFormatType } from "./CellShiftInitializeFormatType";
import { ValueFormatter_SectionType } from "./ValueFormatter_SectionType";
import { DataValidationCriteria } from "./DataValidationCriteria";
import { OneConstraintDataValidationOperator } from "./OneConstraintDataValidationOperator";
import { TwoConstraintDataValidationOperator } from "./TwoConstraintDataValidationOperator";
import { SummaryInformation } from "./SummaryInformation";
import { DocumentSummaryInformation } from "./DocumentSummaryInformation";
import { VerticalTextAlignment } from "./VerticalTextAlignment";
import { HorizontalTextAlignment } from "./HorizontalTextAlignment";
import { CT_TextBodyPropertiesBase } from "./CT_TextBodyPropertiesBase";
import { IShallowCloneable } from "./IShallowCloneable";
import { ValueFormatterOptions } from "./ValueFormatterOptions";
import { BuiltInName } from "./BuiltInName";
import { Orientation } from "./Orientation";
import { PageNumbering } from "./PageNumbering";
import { PaperSize } from "./PaperSize";
import { PrintErrors } from "./PrintErrors";
import { PrintNotes } from "./PrintNotes";
import { PageOrder } from "./PageOrder";
import { ScalingType } from "./ScalingType";
import { WorksheetProtectedSelectionMode } from "./WorksheetProtectedSelectionMode";
import { WorksheetProtectionType } from "./WorksheetProtectionType";
import { ObjectPool$1 } from "./ObjectPool$1";
import { LoadOnDemandTree_BinaryTreeNode$1 } from "./LoadOnDemandTree_BinaryTreeNode$1";
import { IBinaryTreeNodeOwner$1 } from "./IBinaryTreeNodeOwner$1";
import { LoadOnDemandTree$1 } from "./LoadOnDemandTree$1";
import { ILoadOnDemandTreeOwner$1 } from "./ILoadOnDemandTreeOwner$1";
import { ISortable } from "./ISortable";
import { WorksheetSortType } from "./WorksheetSortType";
import { WorksheetTableArea } from "./WorksheetTableArea";
import { StructuredTableReferenceKeywordType } from "./StructuredTableReferenceKeywordType";
import { AverageFilterType } from "./AverageFilterType";
import { ConditionalOperator } from "./ConditionalOperator";
import { DatePeriodFilterType } from "./DatePeriodFilterType";
import { RelativeDateRangeOffset } from "./RelativeDateRangeOffset";
import { RelativeDateRangeDuration } from "./RelativeDateRangeDuration";
import { TopOrBottomFilterType } from "./TopOrBottomFilterType";
import { IWorksheetImage } from "./IWorksheetImage";
import { StyleCategory } from "./StyleCategory";
import { NodeState } from "./NodeState";
import { UltraCalcOperatorFunction } from "./UltraCalcOperatorFunction";
import { UltraCalcException } from "./UltraCalcException";
import { ValueFormatterFlags } from "./ValueFormatterFlags";
import { ValueFormatter_WellKnownPartType } from "./ValueFormatter_WellKnownPartType";
import { IValueFormatterSectionInfo } from "./IValueFormatterSectionInfo";
import { ValueFormatter_CompareOperator } from "./ValueFormatter_CompareOperator";
import { ValueFormatter_LiteralType } from "./ValueFormatter_LiteralType";
import { ValueFormatter_NumberSection } from "./ValueFormatter_NumberSection";
import { WorksheetCellBlock_DataTypeEncoded } from "./WorksheetCellBlock_DataTypeEncoded";
import { WorksheetRowSerializationCache } from "./WorksheetRowSerializationCache";
import { SheetSerializationCache } from "./SheetSerializationCache";
import { FtCmo } from "./FtCmo";
import { ISelectorFunctionOptimizationToken } from "./ISelectorFunctionOptimizationToken";
import { FormatConditionOperator } from "./FormatConditionOperator";
import { FormatConditionTopBottom } from "./FormatConditionTopBottom";
import { FormatConditionAboveBelow } from "./FormatConditionAboveBelow";
import { FormatConditionTimePeriod } from "./FormatConditionTimePeriod";
import { FormatConditionTextOperator } from "./FormatConditionTextOperator";
import { ColorScaleType } from "./ColorScaleType";
import { WhitespaceType } from "./WhitespaceType";
import { AttrTokenBase_AttrType } from "./AttrTokenBase_AttrType";
import { FormulaParser_TextSpan } from "./FormulaParser_TextSpan";
import { FormulaParser_PositionInfo } from "./FormulaParser_PositionInfo";
import { DataBarFillType } from "./DataBarFillType";
import { DataBarDirection } from "./DataBarDirection";
import { LoadOnDemandTree_ChangeAdjustmentPoint$1 } from "./LoadOnDemandTree_ChangeAdjustmentPoint$1";
import { LoadOnDemandTree_ChangeHistoryItem$1 } from "./LoadOnDemandTree_ChangeHistoryItem$1";
import { LoadOnDemandTree_ChangeHistoryItemAdd$1 } from "./LoadOnDemandTree_ChangeHistoryItemAdd$1";
import { BuiltInStyleInfo } from "./BuiltInStyleInfo";
import { LoadOnDemandTree_ChangeHistoryItemRemove$1 } from "./LoadOnDemandTree_ChangeHistoryItemRemove$1";
import { SparklineDisplayBlanksAs } from "./SparklineDisplayBlanksAs";
import { SparklineType } from "./SparklineType";
import { SparklineAxisMinMax } from "./SparklineAxisMinMax";
import { SortDirection } from "./SortDirection";
import { ST_SortBy } from "./ST_SortBy";
import { LengthType } from "./LengthType";
import { ST_DynamicFilterType } from "./ST_DynamicFilterType";
import { ExcelComparisonOperator } from "./ExcelComparisonOperator";
import { ST_FilterOperator } from "./ST_FilterOperator";
import { FixedDateGroup_DateRange } from "./FixedDateGroup_DateRange";
import { FixedDateGroupType } from "./FixedDateGroupType";
import { ST_DateTimeGrouping } from "./ST_DateTimeGrouping";
import { DateRange } from "./DateRange";
import { FormatConditionValueType } from "./FormatConditionValueType";
import { ColorScaleCriterionThreshold } from "./ColorScaleCriterionThreshold";
import { ConditionValueInfo } from "./ConditionValueInfo";
import { DataBarAxisPosition } from "./DataBarAxisPosition";
import { ThresholdComparison } from "./ThresholdComparison";
import { IconCriterionInfo } from "./IconCriterionInfo";
import { DataBarNegativeBarColorType } from "./DataBarNegativeBarColorType";
import { GridLineType } from "./GridLineType";
import { TimeUnit } from "./TimeUnit";
import { CategoryType } from "./CategoryType";
import { ScaleType } from "./ScaleType";
import { ChartsheetProtectionType } from "./ChartsheetProtectionType";
import { ParentLabelLayout } from "./ParentLabelLayout";
import { GetXValuesResult } from "./GetXValuesResult";
import { GeographicMapProjection } from "./GeographicMapProjection";
import { GeographicMappingArea } from "./GeographicMappingArea";
import { GeographicMapLabels } from "./GeographicMapLabels";
import { GeographicMapSeriesColor } from "./GeographicMapSeriesColor";
import { TrendlinePolynomialOrder } from "./TrendlinePolynomialOrder";
import { TrendlineType } from "./TrendlineType";
import { ErrorBarDirection } from "./ErrorBarDirection";
import { EndStyleCap } from "./EndStyleCap";
import { ErrorValueType } from "./ErrorValueType";
import { LegendPosition } from "./LegendPosition";
import { IntervalClosedSide } from "./IntervalClosedSide";
import { SeriesValuesColorBy } from "./SeriesValuesColorBy";
import { BoxAndWhiskerSettings } from "./BoxAndWhiskerSettings";
import { PictureType } from "./PictureType";
import { TickLabelAlignment } from "./TickLabelAlignment";
import { DdeItem } from "./DdeItem";
import { OleItem } from "./OleItem";
import { CT_Transform2D } from "./CT_Transform2D";
import { CT_GroupTransform2D } from "./CT_GroupTransform2D";
import { LbsDropData } from "./LbsDropData";
import { FtPioGrbit } from "./FtPioGrbit";
import { FtNts } from "./FtNts";
import { FtCf } from "./FtCf";
import { FtGmo } from "./FtGmo";
import { FtCbls } from "./FtCbls";
import { FtRbo } from "./FtRbo";
import { FtSbs } from "./FtSbs";
import { FtCblsData } from "./FtCblsData";
import { FtEdoData } from "./FtEdoData";
import { FtGboData } from "./FtGboData";
import { PictFmlaEmbedInfo } from "./PictFmlaEmbedInfo";
import { CalcArgumentSource } from "./CalcArgumentSource";
import { CalcArgumentFlags } from "./CalcArgumentFlags";
/**
 * @hidden
 */
export declare class DefaultStyleHelper extends Base {
    static $t: Type;
    static a(a: List$1<WorksheetTableStyle>): WorkItem;
    static c(a: List$1<WorksheetTableStyle>): void;
    static b(a: List$1<WorkbookBuiltInStyle>): void;
}
/**
 * @hidden
 */
export declare class ExcelUtils extends Base {
    static $t: Type;
    static hb(a: number, b: number, c: number, d: number): Rect;
    static fm(a: () => void): void;
    static fn(a: (arg1: any) => void, b?: any): void;
    static ee(a: Stream): string;
    static g5(a: number[], b: number, c: number): WBitmap;
    static b(a: WBitmap, b: number, c: number): {
        ret: number[];
        p1: number;
        p2: number;
    };
    static g6(a: ImageHolder): WBitmap;
    static x(a: WBitmap, b: ImageFormat): ExcelImage;
    static readonly b0: string;
    static readonly b1: string;
    static readonly b2: string;
    static d3(a: any, b: CultureInfo): string;
    static cp(a: CalendarType): Calendar;
    static get cq(): CultureInfo;
    static ce(a: number): Date;
    static ay(a: FillPatternStyle): boolean;
    static a2(a: Type): boolean;
    static bb(a: Type): boolean;
    static bf(a: Type): boolean;
    static em(a: CultureInfo, b: boolean): StringComparer;
    static staticInit(): void;
    static readonly g9: Point;
    static readonly ha: Point;
    private static readonly d;
    static bq: boolean;
    static readonly dq: Nullable$1<boolean>;
    static readonly ds: Nullable$1<number>;
    static readonly dt: Nullable$1<WorkbookThemeColorType>;
    static e0(a: number, b: number, c: number, d: number): {
        p0?: number;
    };
    static e1(a: number, b: number, c: number, d: number): {
        p0?: number;
    };
    static e2(a: number, b: number, c: number, d: number): {
        p0?: number;
    };
    static e3(a: number, b: number, c: number, d: number): {
        p0?: number;
    };
    static e5(a: HashSet$1<number>, b: number[]): void;
    static e4(a: HashSet$1<number>, b: number[]): void;
    static gu(a: number, b: number, c: number, d: number, e: number): Color;
    static gv(a: Color, b: number): Color;
    private static cn;
    private static ck;
    static gw(a: Color, b: number): Color;
    static cv<T>($t: Type, a: IList$1<T>, b: T, c: IComparer$1<T>): number;
    static cw<T>($t: Type, a: List$1<WeakReference>, b: T, c: IComparer$1<T>, d: boolean, e: T): {
        ret: number;
        p4: T;
    };
    static cf(a: Workbook, b: IEnumerable$1<WorksheetRegion>): number;
    static cg(a: Workbook, b: number, c: IEnumerable$1<WorksheetRegion>): number;
    static ch(a: Workbook, b: IEnumerable$1<WorksheetRegion>): number;
    private static fp;
    static e6(a: number, b: number, c: number): {
        p0?: number;
    };
    static e7(a: number, b: number, c: number): {
        p0?: number;
    };
    static e8(a: number, b: number, c: number): {
        p0?: number;
    };
    static e9(a: number, b: number, c: number): {
        p0?: number;
    };
    static ez(a: Uri): Uri;
    static gz(a: number): Color;
    static gy(a: number, b: number, c: number): Color;
    static readonly gx: Color;
    static ak(a: Color): boolean;
    static al(a: Color): boolean;
    static cx(a: Color): number;
    static d2(a: Color): string;
    static g3(a: Color): Color;
    static g4(a: Color): Color;
    static am(a: Workbook, b: WorksheetCellFormatData, c: CellConditionalFormat, d: CellFill): boolean;
    static an(a: Workbook, b: WorksheetCellFormatData, c: CellConditionalFormat, d: WorkbookColorInfo): boolean;
    static ao(a: CellConditionalFormat, b: ST_IconSetType, c: Nullable$1<number>): boolean;
    static cr(a: number[]): Guid;
    private static fr;
    private static fs;
    private static ft;
    static eu(a: number, b: number[]): number;
    private static c;
    private static fq;
    static cs(a: number): number;
    static et(a: number): number;
    static g0(a: number, b: number, c: number): Color;
    static fa(a: Color, b: number, c: number, d: number): {
        p1: number;
        p2: number;
        p3: number;
    };
    static fd(a: WorksheetCellFormatProxy, b: WorksheetCellFormatProxy, c: CellFormatValue, d?: boolean, e?: CellFormatValueChangedOptions): void;
    static fb(a: WorksheetCellFormatData, b: WorksheetCellFormatData, c: CellFormatValue): void;
    static fc(a: WorksheetCellFormatData, b: WorksheetCellFormatProxy, c: CellFormatValue): void;
    static fe(a: WorksheetCellFormatProxy, b: WorksheetCellFormatProxy, c: CellFormatValue, d?: boolean, e?: boolean, f?: CellFormatValueChangedOptions, g?: boolean): void;
    static v(a: string, b: string, c: BaseError): ArgumentExceptionExtension;
    static w(a: string, b: any, c: string): ArgumentOutOfRangeExceptionExtension;
    static g7(a: number, b: number): Point;
    static g8(a: number, b: number): Point;
    static b8(): HashSet$1<Rect>;
    static d5(a: string, b: string): string;
    static d6(a: string, b: string, c: string): string;
    static d4(a: string, b: boolean, c: string, d: string): string;
    static ep(a: string, b: boolean): {
        ret: Regex;
        p1: boolean;
    };
    static ff(a: boolean, b?: string): void;
    static fg(a: string): void;
    static fh(): void;
    static fi(): void;
    static fj(a: boolean, b: string): void;
    static g1(a: number): Color;
    static ci(a: number): number;
    static d7(a: string, b: string): string;
    static ap(a: ICellShiftOperationOverride, b: WorksheetRegionAddress): boolean;
    static aq(a: ICellShiftOperationOverride, b: number, c: number, d: number, e: number): boolean;
    static ar(a: ICellShiftOperationOverride, b: WorksheetRegionAddress): boolean;
    static as(a: ICellShiftOperationOverride, b: number, c: number, d: number, e: number): boolean;
    static c1(a: number): number;
    static hc(a: Rect): Rect;
    static cj(a: number): number;
    static dh(a: number): number;
    static fk(a: List$1<PropertyTableBase_PropertyValue>, b: Color, c: PropertyType, d: PropertyType): void;
    static ev(a: Color): number;
    static d8(a: string): string;
    static get en(): Encoding;
    static c2(a: Encoding): number;
    static eo(a: number): Encoding;
    static d9(a: string): string;
    static ea(a: string): string;
    static fl(a: number): {
        p0?: number;
    };
    static eb(a: string): string;
    static y(a: any): SingleTargetFormula;
    static d1(a: number): number;
    private static c3;
    static l(a: CellFormatValue): CellFormatValue;
    static c4(a: number, b: number, c: number): number;
    static c6(a: number, b: number, c: number): number;
    static c7(a: number, b: number, c: number): number;
    static c5(a: number, b: number, c: number): number;
    static c8(a: number, b: number, c: number): number;
    static b9(a: WorksheetRegion): IEnumerable$1<any>;
    private static _ca;
    static ca(a: IEnumerable$1<WorksheetRegion>, b?: boolean): IEnumerable$1<any>;
    static dr(a: ReferenceToken): Nullable$1<CellAddressRange>;
    static m(a: WorksheetCellFormatOptions): CellFormatValue;
    static ab(a: Workbook, b: XColorType, c: number, d: Nullable$1<number>): WorkbookColorInfo;
    private static c9;
    static o(a: IChartObject, b: number): ChartSolidFill;
    static ec(a: DateTimeFormat): string;
    static ed(a: Type, b: any): string;
    static da(a: number): number;
    static ac(a: IWorkbookFont, b?: WorkbookThemeColorType): WorkbookColorInfo;
    static r(a: string): FontFamilyInternal;
    private static b3;
    private static b7;
    private static fz;
    static z(a: any): StringElement;
    static db(a: number): number;
    static dc(a: CellConditionalFormat, b: WorksheetCellFormatData, c?: boolean): number;
    static aj(a: FormatConditionIconSet): ST_IconSetType;
    static cc(a: string, b: List$1<number>, c: List$1<string>): {
        ret: List$1<string>;
        p1: List$1<number>;
        p2: List$1<string>;
    };
    static n(a: CellFormatValue): CellFormatValue;
    static he(): Size;
    static dd(a: Date): number;
    static cd(a: Formula): List$1<CellAddressRange>;
    static hf(): Size;
    private static de;
    static ef(a: string): string;
    static eg(a: string, ...b: any[]): string;
    private static b6;
    private static b4;
    private static cb;
    static a(a: CellFormatValue, b: boolean): CellFormatValue[];
    static dy(a: WeakReference): any;
    static f(a: Stream, b: string, c: boolean, d: WorkbookOptionsBase, e?: IPackageFactory): WorkItem$1<WorkbookFormat>;
    static co: (arg1: IPackage) => Nullable$1<WorkbookFormat>;
    private static dg;
    static at(a: WorkbookFormat): boolean;
    static au(a: WorkbookFormat): boolean;
    static a3(a: any): boolean;
    static av(a: CellBorderLineStyle): boolean;
    static aw(a: CellReferenceMode): boolean;
    static get ax(): boolean;
    static az(a: DiagonalBorders): boolean;
    static a0(a: DiagonalBorders): boolean;
    static a1(a: CellFormatValue): boolean;
    static a4(a: Nullable$1<boolean>): boolean;
    static a5(a: CellFormatValue): boolean;
    static a6(a: HorizontalCellAlignment): boolean;
    static a7(a: WorkbookFormat): boolean;
    static a8(a: any): boolean;
    static a9(a: any): boolean;
    static ba(a: any): boolean;
    static bc(a: number): boolean;
    static bd(a: TextFormatMode): boolean;
    static be(a: string): boolean;
    static bg(a: CellFormatValue): boolean;
    static bh(a: VerticalCellAlignment): boolean;
    static bi(a: Stream): boolean;
    static bk(a: WorksheetColumnWidthUnit): boolean;
    static bj(a: WorkbookFormat): boolean;
    static e(a: Workbook, b: Uri): ImageData;
    static cl(a: number): number;
    static h(a: BorderThickness, b: BorderThickness): BorderThickness;
    private static b5;
    static aa<T>($t: Type, a: T, b: T): T;
    static u(a: IWorkbookFont[], b: Workbook): IWorkbookFont;
    static fu(a: Rect, b: number, c: number): {
        p0?: Rect;
    };
    static bl(a: string, b: WorkbookFormat, c: CultureInfo, d: number, e: number): {
        ret: boolean;
        p3: number;
        p4: number;
    };
    static bm(a: string, b: number, c: number, d: WorkbookFormat, e: CultureInfo, f: number, g: number): {
        ret: boolean;
        p5: number;
        p6: number;
    };
    static ah(a: string, b: Worksheet, c: CultureInfo): WorksheetRegion;
    static fv(a: string, b: WorkbookFormat, c: CultureInfo, d: number, e: number, f: number, g: number): {
        p3: number;
        p4: number;
        p5: number;
        p6: number;
    };
    static bn(a: string, b: WorkbookFormat, c: number, d: boolean, e: number, f: boolean): {
        ret: boolean;
        p2: number;
        p3: boolean;
        p4: number;
        p5: boolean;
    };
    static bo(a: string, b: number, c: number, d: WorkbookFormat, e: number, f: boolean, g: number, h: boolean): {
        ret: boolean;
        p4: number;
        p5: boolean;
        p6: number;
        p7: boolean;
    };
    static fw(a: string, b: WorkbookFormat, c: WorksheetRow, d: number, e: number, f: number, g: number, h: number): {
        p4: number;
        p5: number;
        p6: number;
        p7: number;
    };
    static fx(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo, e: WorksheetRow, f: number, g: number, h: number, i: number, j: number): {
        p6: number;
        p7: number;
        p8: number;
        p9: number;
    };
    static t(a: string, b: Sheet, c: number, d: number, e: CellReferenceMode, f: string, g: string, h: List$1<Tuple$3<Worksheet, WorksheetRegionAddress, string>>, i?: List$1<WorkbookReferenceBase>, j?: FormulaType): Formula;
    private static f0;
    static fy(a: any[], b: any): void;
    static f1(a: number, b: number): {
        p0?: number;
        p1?: number;
    };
    static g2(a: Color): Color;
    static eh(a: string): string;
    static bp(a: List$1<WorksheetCell>, b: WorksheetRow, c: number): boolean;
    static f2(a: DiagonalBorders): {
        p0?: DiagonalBorders;
    };
    static f3(a: DiagonalBorders): {
        p0?: DiagonalBorders;
    };
    static f4(a: List$1<WorksheetCell>): void;
    static dz(a: Worksheet, b: WorksheetRow, c: number, d: WorksheetRow, e: number, f: CellFormatValue): any;
    static d0(a: RowColumnBase, b: RowColumnBase, c: CellFormatValue): any;
    static ad(a: Workbook, b: FullColorExtInfo): WorkbookColorInfo;
    static k(a: Workbook, b: GradStopInfo): CellFillGradientStop;
    static j(a: Workbook, b: XFExtGradientInfo): CellFillGradient;
    static ae(a: Workbook, b: XFPropColorInfo): WorkbookColorInfo;
    static f5(a: Color, b: number, c: number, d: number): {
        p1: number;
        p2: number;
        p3: number;
    };
    private static cm;
    static dj(a: number, b: number): number;
    static f6(a: ExcelImage, b: ImageFormat, c: Stream): void;
    static f8(a: number, b: Nullable$1<boolean>, c: number): {
        p0?: number;
    };
    static f7(a: number, b: boolean, c: number): {
        p0?: number;
    };
    static ga(a: number, b: Nullable$1<boolean>, c: number): {
        p0?: number;
    };
    static f9(a: number, b: boolean, c: number): {
        p0?: number;
    };
    static gb(a: number, b: boolean, c: number): {
        p0?: number;
    };
    static br(a: Size): boolean;
    static gc(a: Sheet, b: string, c: boolean, d: boolean, e: WorksheetRegion, f: CellReferenceMode, g: (arg1: number) => void, h: () => void, i: (arg1: Worksheet, arg2: WorksheetRegionAddress, arg3: WorksheetRegionAddress, arg4: string) => void): void;
    static ei(a: ChartType[], b?: string): string;
    static ge(a: WorksheetCellFormatProxy, b: WorksheetCellFormatProxy, c: CellFormatValue, d: any, e: CellFormatValueChangedOptions): void;
    static gd<T>($t: Type, a: T, b: T): {
        p0?: T;
        p1?: T;
    };
    static bs(a: number, b: number): boolean;
    static bt(a: number, b: number): boolean;
    static bu(a: DiagonalBorders, b: DiagonalBorders): boolean;
    static bv(a: PreventTextFormattingTypes, b: PreventTextFormattingTypes): boolean;
    static bw(a: WorksheetCellFormatOptions, b: WorksheetCellFormatOptions): boolean;
    static af(a: Color): WorkbookColorInfo;
    static dv(a: boolean): Nullable$1<boolean>;
    static dw(a: Nullable$1<boolean>): Nullable$1<boolean>;
    static ey(a: number): number;
    static s(a: ST_IconSetType): FormatConditionIconSet;
    static ai(a: FormatConditionIconSet): ST_IconSetType;
    static ag(a: WorkbookColorInfo, b: Workbook): WorkbookColorInfo;
    static i(a: CellFill, b: Workbook): CellFill;
    static p(a: ChartType): SeriesType;
    static ej(a: number, b: IFormatProvider): string;
    static gf(a: IFormattedRunOwner): void;
    static bx(a: any, b: Workbook, c: IFormatProvider, d: boolean, e: number): {
        ret: boolean;
        p4: number;
    };
    static by(a: number, b: number): {
        ret: boolean;
        p1: number;
    };
    static bz(a: Workbook, b: any, c: number): {
        ret: boolean;
        p2: number;
    };
    static dm(a: number): number;
    static dn(a: number): number;
    static hd(a: Rect): Rect;
    static ek(a: string): string;
    static el(a: string): string;
    static gg(a: CultureInfo, b: SortMethod): {
        p0?: CultureInfo;
    };
    static gh(a: WorksheetRegion[], b?: HashSet$1<IRegionBlockingValue>): void;
    static gi(a: number, b: number): void;
    static gj(a: Worksheet, b: number, c: string): void;
    static gk(a: Worksheet, b: number, c: string): void;
    static gl(a: Nullable$1<boolean>): void;
    static gm(a: Nullable$1<boolean>, b: string): void;
    static gn<T>($t: Type, a: T): void;
    static go<T>($t: Type, a: T, b: string): void;
    static gp(a: Nullable$1<boolean>, b: string): void;
    static gq(a: Worksheet, b: number, c: string): void;
    static gr(a: Worksheet, b: number, c: string): void;
    static gs(a: TextFormatMode): void;
    static gt(a: WorksheetColumnWidthUnit): void;
    static fo<T>($t: Type, a: IEnumerable$1<T>, b: (arg1: T) => void): void;
    static g(a: CellBorderLineStyle): BorderThickness;
    static du(a: Nullable$1<boolean>): Nullable$1<boolean>;
    static dk(a: Nullable$1<boolean>): number;
    static dx<T>($t: Type, a: T): Nullable$1<T>;
}
/**
 * @hidden
 */
export declare class WorksheetRegionAddress extends ValueType implements IComparable$1<WorksheetRegionAddress>, IRegionAddress {
    static $t: Type;
    constructor(a: number, b: number, c: number, d: number, e: number);
    constructor(a: number, b: WorksheetCellAddress, c: WorksheetCellAddress);
    constructor();
    constructor(a: number, ..._rest: any[]);
    static readonly _b: WorksheetRegionAddress;
    private readonly _u;
    private readonly _y;
    private readonly _v;
    private readonly _aa;
    private readonly _z;
    compareTo(a: WorksheetRegionAddress): number;
    equals(a: any): boolean;
    getHashCode(): number;
    toString(): string;
    private static _ab;
    _a(): WorksheetRegionAddress;
    _g(a: WorksheetCellAddress): boolean;
    _i(a: number, b: number): boolean;
    _h(a: WorksheetRegionAddress): boolean;
    static _ag(a: WorksheetRegionAddress, b: WorksheetRegionAddress): Nullable$1<WorksheetRegionAddress>;
    _j(a: WorksheetRegionAddress): boolean;
    _k(a: Workbook): boolean;
    _l(a: Workbook): boolean;
    _ah(a: boolean, b: boolean, c: WorkbookFormat, d: CellReferenceMode, e?: string): string;
    _c(a: number): WorksheetRegionAddress;
    _d(a: number): WorksheetRegionAddress;
    _e(a: number): WorksheetRegionAddress;
    _f(a: number): WorksheetRegionAddress;
    get _w(): number;
    get _ac(): number;
    get _ad(): number;
    get _m(): boolean;
    get _n(): boolean;
    get _x(): number;
    get _ae(): number;
    get _af(): number;
    containsColumns(a: number, b: number): boolean;
    containsRows(a: number, b: number): boolean;
    intersectsWithRows(a: number, b: number): boolean;
    intersectsWithColumns(a: number, b: number): boolean;
    static _o(a: WorksheetRegionAddress, b: WorksheetRegionAddress): boolean;
    static _p(a: Nullable$1<WorksheetRegionAddress>, b: Nullable$1<WorksheetRegionAddress>): boolean;
    static _q(a: WorksheetRegionAddress, b: WorksheetRegionAddress): boolean;
    static _r(a: Nullable$1<WorksheetRegionAddress>, b: Nullable$1<WorksheetRegionAddress>): boolean;
}
/**
 * @hidden
 */
export declare abstract class ChangeInfo extends Base {
    static $t: Type;
    readonly c: string;
    readonly a: ExcelChangeAction;
    constructor(a: string, b: ExcelChangeAction);
    d(a: Workbook, b: any): void;
    b(a: Workbook, b: Sheet, c: string): any;
    e<TContext extends IChangeInfoContext, TValue>($tContext: Type, $tValue: Type, a: TContext, b: TValue, c: TValue): void;
    static f(a: ChangeInfo[], b: number, c: ChangeInfo): void;
    g<TContext extends IChangeInfoContext, TValue>($tContext: Type, $tValue: Type, a: TContext, b: TValue, c: TValue, d?: boolean): {
        p1?: TValue;
    };
    h<TContext extends IChangeInfoContext, TValue>($tContext: Type, $tValue: Type, a: TContext, b: TValue): void;
    static i(a: ChangeInfo[]): void;
}
/**
 * @hidden
 */
export declare class SilverlightFixes extends Base {
    static $t: Type;
    static staticInit(): void;
    static readonly v: Color;
    static get t(): Encoding;
    static l(a: Encoding): number;
    static u(a: number): Encoding;
    static j(a: number): CultureInfo;
    static p(a: number): number;
    static o(a: number): number;
    static h(a: number, b: number): number;
    static g(a: number): number;
    static m(a: CultureInfo): number;
    static s(a: string): string;
    static d<T>($t: Type, a: ICollection$1<T>): boolean;
    static c(a: any): boolean;
    static r<T>($t: Type, a: ICollection$1<T>): any;
    static b(a: Color): boolean;
    static w(a: number): Color;
    static k(a: Color): number;
    static e(a: DateInterval, b: number, c: Date): Date;
    static a(a: string): DateInterval;
    static q(a: DateInterval, b: Date, c: Date, d: FirstDayOfWeek, e: FirstWeekOfYear): number;
    private static f;
    private static n;
    private static get i();
}
/**
 * @hidden
 */
export interface IWorkbookProvider {
    readonly workbook: Workbook;
}
/**
 * @hidden
 */
export declare let IWorkbookProvider_$type: Type;
/**
 * @hidden
 */
export interface ISheetProvider {
    readonly sheet: Sheet;
}
/**
 * @hidden
 */
export declare let ISheetProvider_$type: Type;
/**
 * @hidden
 */
export interface IChangeInfoContext extends IWorkbookProvider, ISheetProvider {
    readonly source: any;
}
/**
 * @hidden
 */
export declare let IChangeInfoContext_$type: Type;
/**
 * @hidden
 */
export declare class Workbook_ChangeInfoContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: Workbook);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly a;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class ChangeInfo$2<TContext extends IChangeInfoContext, TValue> extends ChangeInfo {
    static $t: Type;
    protected $tContext: Type;
    protected $tValue: Type;
    readonly u: (arg1: TContext) => TValue;
    readonly r: boolean;
    readonly s: boolean;
    readonly m: WorksheetPermissions;
    readonly o: (arg1: TContext, arg2: TValue) => void;
    readonly p: (arg1: TContext, arg2: TValue) => void;
    private t;
    private n;
    private readonly q;
    constructor($tContext: Type, $tValue: Type, a: string, b: ExcelChangeAction, c: (arg1: TContext) => TValue, d: (arg1: TContext, arg2: TValue) => void, e: (arg1: TContext, arg2: TValue) => void, f: boolean, g: WorksheetPermissions, h: boolean, i: (arg1: TContext) => number, j: (arg1: TContext) => void);
    v(a: TContext): number;
    w(a: TContext): any;
    j(a: TContext): TValue;
    l(a: TContext): Workbook;
    k(a: TContext): Sheet;
    x(a: TContext, b: TValue, c: TValue): void;
    y(a: TContext, b: TValue): void;
    z(a: TContext): void;
}
export declare class Workbook extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static _br(a: Workbook): TextMetricsProviderBase;
    /**
     * @hidden
     */
    _f(): number[];
    /**
     * @hidden
     */
    get _cs(): boolean;
    /**
     * @hidden
     */
    get _cw(): boolean;
    static readonly maxExcel2007RowCount: number;
    static readonly maxExcel2007ColumnCount: number;
    static readonly maxExcelRowCount: number;
    static readonly maxExcelColumnCount: number;
    static readonly maxExcelCellFormatCount: number;
    static readonly maxExcel2007CellFormatCount: number;
    static readonly maxExcelWorkbookFonts: number;
    /**
     * @hidden
     */
    static readonly _gq: string;
    /**
     * @hidden
     */
    static readonly _gr: string;
    /**
     * @hidden
     */
    static readonly _gt: string;
    /**
     * @hidden
     */
    static readonly _gu: string;
    /**
     * @hidden
     */
    static readonly _gs: string;
    /**
     * @hidden
     */
    static readonly _b0: WorkbookFormat;
    /**
     * @hidden
     */
    private static readonly _fg;
    /**
     * @hidden
     */
    private static readonly _fj;
    /**
     * @hidden
     */
    private static readonly _fk;
    /**
     * @hidden
     */
    private static readonly _f7;
    /**
     * @hidden
     */
    private static readonly _f8;
    /**
     * @hidden
     */
    private static readonly _gd;
    /**
     * @hidden
     */
    private static readonly _ge;
    /**
     * @hidden
     */
    private static readonly _gf;
    /**
     * @hidden
     */
    static readonly _gp: string;
    /**
     * @hidden
     */
    private static readonly _fi;
    /**
     * @hidden
     */
    private static readonly _fl;
    /**
     * @hidden
     */
    private static readonly _fm;
    /**
     * @hidden
     */
    private static readonly _fn;
    /**
     * @hidden
     */
    private static readonly _ga;
    /**
     * @hidden
     */
    private static readonly _gb;
    /**
     * @hidden
     */
    private static readonly _gc;
    /**
     * @hidden
     */
    private static readonly _gh;
    /**
     * @hidden
     */
    private static readonly _fu;
    /**
     * @hidden
     */
    private static readonly _fq;
    /**
     * @hidden
     */
    private static readonly _gg;
    /**
     * @hidden
     */
    private static readonly _f9;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    static readonly _g1: Encoding;
    /**
     * @hidden
     */
    static readonly _fd: IFormatProvider;
    /**
     * @hidden
     */
    private static _jj;
    /**
     * @hidden
     */
    private static _jk;
    /**
     * @hidden
     */
    private static _jm;
    /**
     * @hidden
     */
    static _fa: CultureInfo;
    /**
     * @hidden
     */
    private static _e9;
    /**
     * @hidden
     */
    static _ez: (arg1: Workbook, arg2: Stream, arg3: string, arg4: WorkbookLoadOptions) => WorkItem;
    /**
     * @hidden
     */
    static _e2: (arg1: Workbook, arg2: Stream, arg3: WorkbookSaveOptions) => WorkItem;
    /**
     * @hidden
     */
    static _e1: (arg1: Workbook, arg2: Stream, arg3: WorkbookLoadOptions, arg4: IPackageFactory) => WorkItem;
    /**
     * @hidden
     */
    static _e3: (arg1: Workbook, arg2: Stream, arg3: WorkbookSaveOptions) => WorkItem;
    /**
     * @hidden
     */
    static _e0: (arg1: Workbook, arg2: Stream, arg3: IPackageFactory) => WorkItem;
    private _dx;
    private _v;
    private _x;
    private _fh;
    private _b9;
    private _cb;
    private _z;
    private _bx;
    private _ag;
    private _ai;
    private _fo;
    private _ak;
    private _au;
    private _as;
    private _aw;
    private _b1;
    private _em;
    private _c3;
    private _dc;
    private _ev;
    private _f4;
    private _a4;
    private _bv;
    private _d0;
    private _a6;
    private _dg;
    private _di;
    private _dm;
    private _dp;
    private _b5;
    private _j;
    private _gz;
    private _b7;
    private _ce;
    private _bn;
    private _gi;
    private _ei;
    private _ek;
    private _ee;
    private _eg;
    private _bi;
    private _bg;
    private _dy;
    private _d;
    private _ae;
    private _ch;
    private _g;
    private _dr;
    private _d2;
    private _g5;
    private _e4;
    private _e7;
    private _a8;
    private _ba;
    private _de;
    private _jl;
    private readonly _dw;
    private _cl;
    private _d5;
    private _eb;
    private _ed;
    private _ec;
    private readonly _am;
    private _az;
    private readonly _bt;
    private _bk;
    private _dv;
    private readonly _b3;
    /**
     * @hidden
     */
    _bu: Workbook_MetricsProviderCache;
    /**
     * @hidden
     */
    _m: RoundTripControlData;
    /**
     * @hidden
     */
    _n: RoundTripControlData;
    /**
     * @hidden
     */
    _o: RoundTripControlData;
    /**
     * @hidden
     */
    _gx: string;
    /**
     * @hidden
     */
    _gy: string;
    /**
     * @hidden
     */
    _i: number[];
    /**
     * @hidden
     */
    _du: number;
    /**
     * @hidden
     */
    _fb: Guid;
    private _t;
    static staticInit(): void;
    constructor();
    constructor(format: WorkbookFormat);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    private static _bz;
    /**
     * Converts units of 1/256s of the average character width to pixels.
     * <p class="body">
     * The units of 1/256s of the average character width are based on the font height of the normal style.
     * </p>
     * @param characterWidth256ths The number of units of 1/256s of the average character width.
     * @return The number of pixels equivalent to the 'characterWidth256ths' value.
     * @see [[pixelsToCharacterWidth256ths]]
     * @see [[WorksheetColumn.width]]
     * @see [[Worksheet.defaultColumnWidth]]
     */
    characterWidth256thsToPixels(characterWidth256ths: number): number;
    /**
     * Clears all external data connections from the [[Workbook]].
     */
    clearConnectionData(): void;
    /**
     * Clears all pivot tables and associated slicers from the [[Workbook]].
     */
    clearPivotTableData(): void;
    /**
     * Clears all vba information from the [[Workbook]].
     */
    clearVbaData(): void;
    /**
     * Factory method which creates new workbook font.
     * <p class="body">[[IWorkbookFont]] describes font used in excel workbook.
     * If many parts of excel workbook have same and complex (more than one property in common) font formatting, use this method in following manner:
     * <ol>
     * <li class="taskitem"><span class="taskitemtext">Create new font format with [[createNewWorkbookFont]],</span></li>
     * <li class="taskitem"><span class="taskitemtext">Set all necessary properties on given font format,</span></li>
     * <li class="taskitem"><span class="taskitemtext">Apply font format to all excel objects which use it with [[IWorkbookFont.setFontFormatting]] method.</span></li>
     * </ol></p>
     * <p class="body">Use of this procedure will simplify you code for complex font formats and increase speed of resulting program. It will not reduce total number of font formats in a workbook as font formats are internally cached no matter which method is used.</p>
     * @return The created excel font object.
     */
    createNewWorkbookFont(): IWorkbookFont;
    /**
     * Creates new worksheet cell format.
     * <p class="body">[[IWorksheetCellFormat]] describes cell specific formatting (font, number format, appearance etc.). Total number of different cell formats in excel workbook is limited to [[Workbook.maxExcelCellFormatCount]].
     * If many parts of excel workbook have same and complex (more than one property in common) cell formatting, use this method in following manner:
     * <ol>
     * <li class="taskitem"><span class="taskitemtext">Create new cell format with [[createNewWorksheetCellFormat]],</span></li>
     * <li class="taskitem"><span class="taskitemtext">Set all necessary properties on given cell format,</span></li>
     * <li class="taskitem"><span class="taskitemtext">Apply cell format to all excel objects which use it with [[IWorksheetCellFormat.setFormatting]] method.</span></li>
     * </ol></p>
     * <p class="body">Use of this procedure will simplify you code for complex cell formats and increase speed of resulting program. It will not reduce total number of cell formats in a workbook as cell formats are internally cached no matter which method is used.</p>
     * @return The cell format which was created.
     */
    createNewWorksheetCellFormat(): IWorksheetCellFormat;
    /**
     * @hidden
     */
    _cd(a: WorksheetCellFormatType): WorksheetCellFormatData;
    /**
     * Gets the table with the specified name.
     * <p class="body">
     * Table names are compared case-insensitively.
     * </p>
     * @param name The name of the table to get.
     * @return A [[WorksheetTable]] instance if a table exists with the specified name; Otherwise null.
     */
    getTable(name: string): WorksheetTable;
    /**
     * Converts pixels to units of 1/256s of the average character width.
     * <p class="body">
     * The units of 1/256s of the average character width are based on the font height of the normal style.
     * </p>
     * @param pixels The number of pixels.
     * @return The number of units of 1/256s of the average character width equivalent to the 'pixels' value.
     * @see [[characterWidth256thsToPixels]]
     * @see [[WorksheetColumn.width]]
     * @see [[Worksheet.defaultColumnWidth]]
     */
    pixelsToCharacterWidth256ths(pixels: number): number;
    /**
     * Protects the Workbook without a password.
     * <p class="body">When a Workbook is protected without a password, the end user may unprotect the Workbook in Excel without
     * having to supply a password. To programatically unprotect a Workbook, one may use the [[unprotect]] method.</p>
     * <p class="body">When a Workbook is protected, the values of the properties of the [[WorkbookProtection]] instance from
     * this Workbook's [[protection]] property indicate the disabled operations.</p>
     * <p class="note"><b>Note:</b> If [[isProtected]] is already true, the method will be ignored.</p>
     * @param allowEditStructure Optional boolean indicating the new value for the [[WorkbookProtection.allowEditStructure]].
     * @param allowEditWindows Optional boolean indicating the new value for the [[WorkbookProtection.allowEditWindows]].
     * @see [[hasProtectionPassword]]
     * @see [[isProtected]]
     * @see [[protection]]
     * @see [[WorkbookProtection]]
     * @see [[unprotect]]
     */
    protect(allowEditStructure?: boolean, allowEditWindows?: boolean): void;
    /**
     * Recalculates all dirty formulas pending a calculation on the workbook.
     * <p class="body">
     * This can be used when the [[calculationMode]] is Manual. In Manual mode, when cells are dirtied, formulas referencing
     * those cells will not be recalculated until Recalculate is called or [[recalculateBeforeSave]] is True and the workbook is saved.
     * </p>
     * <p class="body">
     * To force a recalculation of non-dirty formulas, use the [[recalculate]] overload and specify True for the includeNonDirtyFormulas
     * parameter.
     * </p>
     * @see [[calculationMode]]
     * @see [[recalculateBeforeSave]]
     */
    recalculate(): void;
    /**
     * Recalculates all formulas on the workbook.
     * <p class="body">
     * This can be used when the [[calculationMode]] is Manual. In Manual mode, when cells are dirtied, formulas referencing
     * those cells will not be recalculated until Recalculate is called or [[recalculateBeforeSave]] is True and the workbook is saved.
     * </p>
     * @param includeNonDirtyFormulas True to recalculate all formulas on the workbook regardless of whether they had a pending evaluation. False to only calculate dirty formulas.
     * @see [[calculationMode]]
     * @see [[recalculateBeforeSave]]
     */
    recalculate(includeNonDirtyFormulas: boolean): void;
    /**
     * @hidden
     */
    _recalculate(): void;
    /**
     * @hidden
     */
    _recalculate1(a: boolean): void;
    /**
     * @hidden
     */
    _it(a: boolean, b: boolean): void;
    /**
     * Registers a single [[ExcelCalcFunction]] instance.
     * <p class="body">
     * Users can build custom functions used in formulas by sub-classing the [[ExcelCalcFunction]] class.
     * Once the derived class is instantiated it must be registered by using the RegisterUserDefinedFunction method before being available and referenced by a formulas.
     * </p>
     * @param userDefinedFunction User defined function instance to register
     * @return Returns true if the type was registered successfully, else false if the registration failed
     */
    registerUserDefinedFunction(userDefinedFunction: ExcelCalcFunction): boolean;
    /**
     * Registers a custom function.
     * @param name The name of the function
     * @param minArgs The minimum number of arguments
     * @param maxArgs The maximum number of arguments
     * @param evaluate The function used to perform the calculation that gets an [[ExcelCalcNumberStack]] and the number of arguments on the stack for the function and returns an [[ExcelCalcValue]] that represents the result of the formula
     * @return Returns true if the type was registered successfully, else false if the registration failed
     */
    registerUserDefinedFunction(name: string, minArgs: number, maxArgs: number, evaluate: (arg1: ExcelCalcNumberStack, arg2: number) => ExcelCalcValue): boolean;
    /**
     * @hidden
     */
    _registerUserDefinedFunction(a: ExcelCalcFunction): boolean;
    /**
     * @hidden
     */
    _registerUserDefinedFunction1(a: string, b: number, c: number, d: (arg1: ExcelCalcNumberStack, arg2: number) => ExcelCalcValue): boolean;
    /**
     * Resumes the calculation of formulas.
     * <p class="body">
     * If calculations were not suspended when this is called, it will have no effect.
     * </p>
     * <p class="body">
     * For each call to [[suspendCalculations]], a call to ResumeCalculations must be made. As soon as the number of calls to
     * ResumeCalculations equals the number of calls to SuspendCalculations, calculations will be resumed.
     * </p>
     * @see [[suspendCalculations]]
     */
    resumeCalculations(): void;
    /**
     * Writes the workbook to a Uint8Array.
     * <p class="body">
     * The workbook will be written in the format specified by the [[currentFormat]].
     * </p>
     * @param saveOptions The options to use to save the stream or null to use the default options.
     * @param successCallback The function to call when the Workbook has been successfully saved into a Uint8Array or base-64 encoded string.
     * @param failCallback The function to call when saving the Workbook has caused an error.
     * @throws [[InvalidOperationException]] The workbook has no worksheets in its [[worksheets]] collection.
     * @throws [[InvalidOperationException]] No worksheet in this workbook's Worksheets collection has its DisplayOptions.Visibility
     * set to Visible.
     * @throws [[InvalidOperationException]] A [[CustomView]] in the workbook's [[customViews]] collection has all worksheets hidden.
     * At least one worksheet must be visible in all custom views.
     * @see [[isSaving]]
     */
    save(saveOptions: WorkbookSaveOptions, successCallback: (arg1: any) => void, failCallback: (arg1: BaseError) => void): void;
    /**
     * Writes the workbook to a Uint8Array.
     * <p class="body">
     * The workbook will be written in the format specified by the [[currentFormat]].
     * </p>
     * @param successCallback The function to call when the Workbook has been successfully saved into a Uint8Array or base-64 encoded string.
     * @param failCallback The function to call when saving the Workbook has caused an error.
     * @throws [[InvalidOperationException]] The workbook has no worksheets in its [[worksheets]] collection.
     * @throws [[InvalidOperationException]] No worksheet in this workbook's Worksheets collection has its DisplayOptions.Visibility
     * set to Visible.
     * @throws [[InvalidOperationException]] A [[CustomView]] in the workbook's [[customViews]] collection has all worksheets hidden.
     * At least one worksheet must be visible in all custom views.
     * @see [[isSaving]]
     */
    save(successCallback: (arg1: any) => void, failCallback: (arg1: BaseError) => void): void;
    /**
     * @hidden
     */
    _save1(a: (arg1: any) => void, b: (arg1: BaseError) => void): void;
    /**
     * @hidden
     */
    _save(a: WorkbookSaveOptions, b: (arg1: any) => void, c: (arg1: BaseError) => void): void;
    private _isSaving;
    /**
     * Gets the value indicating whether the [[Workbook]] is currently being saved.
     */
    get isSaving(): boolean;
    set isSaving(a: boolean);
    /**
     * @hidden
     */
    _i1(a: Stream, b?: WorkbookSaveOptions): void;
    /**
     * Sets the current format of the workbook.
     * @param format The file format to use when imposing format restrictions and saving.
     * @throws [[InvalidEnumArgumentException]] 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidOperationException]] The workbook already contains data which exceeds the limits imposed by 'format'.
     * @see [[currentFormat]]
     */
    setCurrentFormat(format: WorkbookFormat): void;
    /**
     * Temporarily suspends the calculation of formulas.
     * <p class="body">
     * This should be used when adding many formulas or modifying large amounts of data on a workbook at once so formulas are not calculated
     * each time cells are dirtied.
     * </p>
     * <p class="body">
     * For each call to SuspendCalculations, a call to [[resumeCalculations]] must be made. As soon as the number of calls to
     * ResumeCalculations equals the number of calls to SuspendCalculations, calculations will be resumed.
     * </p>
     * @see [[resumeCalculations]]
     */
    suspendCalculations(): void;
    /**
     * Removes the Workbook protection.
     * @see [[isProtected]]
     * @see [[hasProtectionPassword]]
     * @see [[protect]]
     */
    unprotect(): void;
    /**
     * Loads a workbook from a File.
     * <p class="body">
     * When loading the workbook, the contents of the file will be examined to try to determine the format.
     * The [[currentFormat]] of the resulting workbook will indicate the format the workbook was loaded from.
     * </p>
     * @param file The file from which to load the workbook.
     * @param loadOptions The options to use to load the stream or null to use the default options.
     * @param successCallback The function to call when the Workbook has been successfully loaded.
     * @param failCallback The function to call when loading the Workbook has resulted in an error.
     * @throws [[ArgumentException]] 'file' does not contain valid Microsoft Excel file contents.
     * @throws [[ArgumentException]] The file format cannot be determined from the specified stream.
     * @throws [[InvalidOperationException]] The format of the workbook data is in an unsupported format.
     * @throws [[NotSupportedException]] The workbook being loaded is in an Excel 2007 format and the CLR 2.0 Excel assembly is being used. The overload taking an
     * [[IPackageFactory]] must be used in this case so the Excel 2007 file package can be accessed.
     * @throws [[DocumentEncryptedException]] Occurs when the workbook is encrypted.
     * @return The workbook loaded from the stream.
     */
    static load(file: File, loadOptions: WorkbookLoadOptions, successCallback: (arg1: Workbook) => void, failCallback: (arg1: any) => void): void;
    /**
     * Loads a workbook from a File.
     * <p class="body">
     * When loading the workbook, the contents of the file will be examined to try to determine the format.
     * The [[currentFormat]] of the resulting workbook will indicate the format the workbook was loaded from.
     * </p>
     * @param file The file from which to load the workbook.
     * @param successCallback The function to call when the Workbook has been successfully loaded.
     * @param failCallback The function to call when loading the Workbook has resulted in an error.
     * @throws [[ArgumentException]] 'file' does not contain valid Microsoft Excel file contents.
     * @throws [[ArgumentException]] The file format cannot be determined from the specified stream.
     * @throws [[InvalidOperationException]] The format of the workbook data is in an unsupported format.
     * @throws [[NotSupportedException]] The workbook being loaded is in an Excel 2007 format and the CLR 2.0 Excel assembly is being used. The overload taking an
     * [[IPackageFactory]] must be used in this case so the Excel 2007 file package can be accessed.
     * @throws [[DocumentEncryptedException]] Occurs when the workbook is encrypted.
     * @return The workbook loaded from the stream.
     */
    static load(file: File, successCallback: (arg1: Workbook) => void, failCallback: (arg1: any) => void): void;
    /**
     * Loads a workbook from a Uint8Array or base64 encoded string.
     * <p class="body">
     * When loading the workbook, the contents of the file will be examined to try to determine the format.
     * The [[currentFormat]] of the resulting workbook will indicate the format the workbook was loaded from.
     * </p>
     * @param data The data from which to load the workbook.
     * @param loadOptions The options to use to load the stream or null to use the default options.
     * @param successCallback The function to call when the Workbook has been successfully loaded.
     * @param failCallback The function to call when loading the Workbook has resulted in an error.
     * @throws [[ArgumentException]] 'data' does not contain valid Microsoft Excel file contents.
     * @throws [[ArgumentException]] The file format cannot be determined from the specified stream.
     * @throws [[InvalidOperationException]] The format of the workbook data is in an unsupported format.
     * @throws [[NotSupportedException]] The workbook being loaded is in an Excel 2007 format and the CLR 2.0 Excel assembly is being used. The overload taking an
     * [[IPackageFactory]] must be used in this case so the Excel 2007 file package can be accessed.
     * @throws [[DocumentEncryptedException]] Occurs when the workbook is encrypted.
     * @return The workbook loaded from the stream.
     */
    static load(data: string | Uint8Array, loadOptions: WorkbookLoadOptions, successCallback: (arg1: Workbook) => void, failCallback: (arg1: BaseError) => void): void;
    /**
     * Loads a workbook from a Uint8Array or base64 encoded string.
     * <p class="body">
     * When loading the workbook, the contents of the file will be examined to try to determine the format.
     * The [[currentFormat]] of the resulting workbook will indicate the format the workbook was loaded from.
     * </p>
     * @param data The data from which to load the workbook.
     * @param successCallback The function to call when the Workbook has been successfully loaded.
     * @param failCallback The function to call when loading the Workbook has resulted in an error.
     * @throws [[ArgumentException]] 'data' does not contain valid Microsoft Excel file contents.
     * @throws [[ArgumentException]] The file format cannot be determined from the specified stream.
     * @throws [[InvalidOperationException]] The format of the workbook data is in an unsupported format.
     * @throws [[NotSupportedException]] The workbook being loaded is in an Excel 2007 format and the CLR 2.0 Excel assembly is being used. The overload taking an
     * [[IPackageFactory]] must be used in this case so the Excel 2007 file package can be accessed.
     * @throws [[DocumentEncryptedException]] Occurs when the workbook is encrypted.
     * @return The workbook loaded from the stream.
     */
    static load(data: string | Uint8Array, successCallback: (arg1: Workbook) => void, failCallback: (arg1: BaseError) => void): void;
    /**
     * @hidden
     */
    static _load2(a: File, b: (arg1: Workbook) => void, c: (arg1: any) => void): void;
    /**
     * @hidden
     */
    static _load1(a: File, b: WorkbookLoadOptions, c: (arg1: Workbook) => void, d: (arg1: any) => void): void;
    /**
     * @hidden
     */
    static _load4(a: Stream, b: (arg1: Workbook) => void, c: (arg1: BaseError) => void): void;
    /**
     * @hidden
     */
    static _load3(a: Stream, b: WorkbookLoadOptions, c: (arg1: Workbook) => void, d: (arg1: BaseError) => void): void;
    /**
     * @hidden
     */
    static _bs(a: Stream, b?: WorkbookLoadOptions): Workbook;
    /**
     * @hidden
     */
    private static _p;
    /**
     * Returns the WorkbookFormat based on the file extension of the specified file.
     * @param fileName The filename of an excel file.
     * @return The workbook format based on the file extension of the file, or null if the correct format cannot be determined.
     */
    static getWorkbookFormat(fileName: string): WorkbookFormat | null;
    /**
     * @hidden
     */
    static _getWorkbookFormat$i(a: string): Nullable$1<WorkbookFormat>;
    /**
     * Determines whether the workbook in the specified stream is encrypted with an open password.
     * @param stream The stream to check for encryption.
     * @throws [[ArgumentNullException]] Occurs when 'stream' is null.
     * @return True if the stream contains a workbook which is encrypted; False otherwise
     */
    static isWorkbookEncrypted(stream: string | Uint8Array): boolean;
    /**
     * @hidden
     */
    static _isWorkbookEncrypted$i(a: Stream): boolean;
    /**
     * @hidden
     */
    _g7(a: BinaryData): void;
    /**
     * @hidden
     */
    _g8(a: BinaryData): void;
    /**
     * @hidden
     */
    _g9(a: SingleTargetFormula): void;
    /**
     * @hidden
     */
    _ha(a: NamedCalcReferenceBase): void;
    /**
     * @hidden
     */
    _hb(a: PivotCacheInfo): void;
    /**
     * @hidden
     */
    _hc(a: PivotCacheInfo): void;
    /**
     * @hidden
     */
    _hd(a: BinaryData): void;
    /**
     * @hidden
     */
    get _cn(): boolean;
    /**
     * @hidden
     */
    _he(a: string, b: Stream): void;
    /**
     * @hidden
     */
    private __d7;
    _d7(): IEnumerable$1<KeyValuePair$2<string, number[]>>;
    /**
     * @hidden
     */
    static _fc(a: Workbook): IDisposable;
    /**
     * @hidden
     */
    static _ep(a: Workbook, b: number, c: boolean): number;
    /**
     * @hidden
     */
    static _eq(a: number): number;
    /**
     * @hidden
     */
    static _er(a: Workbook, b: number, c: boolean, d?: boolean): number;
    /**
     * @hidden
     */
    static _es(a: number): number;
    /**
     * @hidden
     */
    _hj(): void;
    /**
     * @hidden
     */
    _hk(a: RefBase): void;
    /**
     * @hidden
     */
    _gv(a: string): string;
    /**
     * @hidden
     */
    _bh(a: boolean): SharedStringTable;
    /**
     * @hidden
     */
    static _fr(a: WorkbookFormat): number;
    /**
     * Returns the number of columns that are supported by the specified format.
     * @param format The format used by the workbook.
     * @return The maximum number of columns supported by the format.
     */
    static getMaxColumnCount(format: WorkbookFormat): number;
    /**
     * @hidden
     */
    static _fe(a: WorkbookFormat): number;
    /**
     * Returns the number of rows that are supported by the specified format.
     * @param format The format used by the workbook.
     * @return The maximum number of rows supported by the format.
     */
    static getMaxRowCount(format: WorkbookFormat): number;
    /**
     * @hidden
     */
    _a2(a: string, b: Worksheet): NamedReferenceBase;
    /**
     * @hidden
     */
    _g2(): number;
    /**
     * @hidden
     */
    _g4(): number;
    /**
     * @hidden
     */
    _hl(a: number): {
        p0?: number;
    };
    /**
     * @hidden
     */
    _d8(): IEnumerable$1<PivotCacheInfo>;
    /**
     * @hidden
     */
    _d9(): IEnumerable$1<PivotCacheInfo>;
    /**
     * @hidden
     */
    static _et(a: Workbook, b: boolean): number;
    /**
     * @hidden
     */
    _ea(): IEnumerable$1<BinaryData>;
    /**
     * @hidden
     */
    _cj(a: string): WorksheetTableStyle;
    /**
     * @hidden
     */
    _ao(a: WorksheetTableColumn, b: ST_TotalsRowFunction): Formula;
    /**
     * @hidden
     */
    _ck(a: WorksheetTableColumn): ST_TotalsRowFunction;
    /**
     * @hidden
     */
    private _gl;
    /**
     * @hidden
     */
    static _eu(a: Workbook, b: boolean): number;
    /**
     * @hidden
     */
    static _hm(a: Workbook, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo): {
        p1: CellReferenceMode;
        p2: WorkbookFormat;
        p3: CultureInfo;
    };
    /**
     * @hidden
     */
    _bf(a: string): WorkbookReferenceBase;
    /**
     * @hidden
     */
    _be(a: string, b?: string): WorkbookReferenceBase;
    /**
     * @hidden
     */
    static _c5(a: string, b?: string): boolean;
    /**
     * @hidden
     */
    static _c6(a: string, b: string): boolean;
    /**
     * @hidden
     */
    _bc(a: string, b: string): DdeLinkWorkbookReference;
    /**
     * @hidden
     */
    _bd(a: string, b: Uri): OleLinkWorkbookReference;
    /**
     * @hidden
     */
    _a3(a: string): NamedReferenceBase;
    /**
     * @hidden
     */
    _bl(a: number): Sheet;
    /**
     * @hidden
     */
    _an(): FormatLimitErrors;
    /**
     * @hidden
     */
    _hn(a: (arg1: Sheet, arg2: Formula) => void, b: boolean): void;
    /**
     * @hidden
     */
    _ho(a: (arg1: Sheet, arg2: Formula) => void, b: IEnumerable$1<NamedReferenceBase>, c: IList$1<Sheet>, d: boolean): void;
    /**
     * @hidden
     */
    private _hq;
    /**
     * @hidden
     */
    private _hp;
    /**
     * @hidden
     */
    _hv(a: WorksheetTable): void;
    /**
     * @hidden
     */
    _hw(a: CellCalcReference): void;
    /**
     * @hidden
     */
    _hx<TContext extends IChangeInfoContext, TValue>($tContext: Type, $tValue: Type, a: TContext, b: TValue, c: TValue, d: ChangeInfo$2<TContext, TValue>): void;
    /**
     * @hidden
     */
    _hy(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    _hz(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    _h0(a: WorksheetDataTable): void;
    /**
     * @hidden
     */
    _h1(): void;
    /**
     * @hidden
     */
    _h2(): void;
    /**
     * @hidden
     */
    _h3(a: NamedReferenceBase): void;
    /**
     * @hidden
     */
    _h4(a: NamedReferenceBase): void;
    /**
     * @hidden
     */
    _h5(a: NamedReferenceBase, b: string): void;
    /**
     * @hidden
     */
    _ic(a: WorkbookStyle): void;
    /**
     * @hidden
     */
    _ig(a: WorksheetTable, b: List$1<WorksheetTableColumn>, c: List$1<Formula>): void;
    /**
     * @hidden
     */
    _id(a: WorksheetTable, b: List$1<KeyValuePair$2<WorksheetTableColumn, string>>): void;
    /**
     * @hidden
     */
    _ie(a: WorksheetTable): void;
    /**
     * @hidden
     */
    _go(a: Sheet, b: ExcelChangeAction, c: string): any;
    /**
     * @hidden
     */
    _ih(a: any): void;
    /**
     * @hidden
     */
    _ii(a: any): void;
    /**
     * @hidden
     */
    _ik(): void;
    /**
     * @hidden
     */
    _h7(a: Sheet): void;
    /**
     * @hidden
     */
    _h8(a: Sheet, b: number): void;
    /**
     * @hidden
     */
    _ib(a: Sheet, b: string): void;
    /**
     * @hidden
     */
    _h6(): void;
    /**
     * @hidden
     */
    _h9(a: Sheet, b: number): void;
    /**
     * @hidden
     */
    _ia(a: Sheet): void;
    /**
     * @hidden
     */
    _ar(a: string, b: CellReferenceMode, c: Worksheet, d: WorksheetRow, e: number, f: boolean, g?: boolean, h?: boolean): {
        ret: RefBase;
        p5: boolean;
    };
    /**
     * @hidden
     */
    _ap(a: FormulaContext, b: boolean, c?: boolean, d?: boolean): {
        ret: RefBase;
        p1: boolean;
    };
    /**
     * @hidden
     */
    private _aq;
    /**
     * @hidden
     */
    _io(a: () => void): void;
    /**
     * @hidden
     */
    _iq(a: WorksheetRow, b: number): void;
    /**
     * @hidden
     */
    _iu(a: IWorkbookOwner): void;
    /**
     * @hidden
     */
    _iv(a: SingleTargetFormula): void;
    /**
     * @hidden
     */
    _iw(a: NamedCalcReferenceBase): void;
    /**
     * @hidden
     */
    static _ey(a: Workbook, b: number, c: boolean, d: boolean): number;
    /**
     * @hidden
     */
    _i3(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    _ja(a: IWorkbookOwner): void;
    /**
     * @hidden
     */
    _je(): void;
    /**
     * @hidden
     */
    _jh(a: string, b: NamedReferenceBase): void;
    /**
     * @hidden
     */
    _jg(a: Formula, b: WorksheetRow, c: number): void;
    /**
     * @hidden
     */
    static _i6(): void;
    /**
     * @hidden
     */
    _i7(): void;
    /**
     * @hidden
     */
    static _i8(a: boolean): void;
    /**
     * @hidden
     */
    _ji(a: Sheet, b: string, c: string): void;
    /**
     * @hidden
     */
    _hf(a: StructuredStorageManager, b: Directory, c: string): void;
    /**
     * @hidden
     */
    private static _ac;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private static _q;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private _il;
    /**
     * @hidden
     */
    private _im;
    /**
     * @hidden
     */
    private _ij;
    /**
     * @hidden
     */
    private _s;
    /**
     * @hidden
     */
    private _jb;
    /**
     * @hidden
     */
    private _jd;
    /**
     * @hidden
     */
    _jf(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * Gets or sets the value which indicates how a formula will be recalculated when a referenced value changes.
     * <p class="body">
     * If this is set to a value of Manual, the [[recalculateBeforeSave]] property will determine
     * if formulas are recalculated just before saving the file.  Otherwise, that property is ignored.
     * </p>
     * The value which indicates how a formula will be recalculated when a referenced value changes.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[calculationMode]] enumeration.
     * @see [[recalculateBeforeSave]]
     */
    get calculationMode(): CalculationMode;
    set calculationMode(a: CalculationMode);
    /**
     * Gets or sets the value which indicates the way cells in the workbook are referenced.
     * <p class="body">
     * The value of this property will affect the row and columns labels of the workbook when opened in Microsoft Excel.
     * In addition, it will affect the display of formulas referencing different cells.
     * </p>
     * The value which indicates the way cells in the workbook are referenced.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[cellReferenceMode]] enumeration.
     */
    get cellReferenceMode(): CellReferenceMode;
    set cellReferenceMode(a: CellReferenceMode);
    /**
     * Gets or sets the culture to use as the current culture for the workbook when doing any culture-aware conversions
     * or comparisons.
     * <p class="note">
     * <b>Note:</b> The culture is not saved or loaded in workbook files, so this is only used at when accessing and
     * manipulating objects owned or associated with the Workbook.
     * </p>
     * The current culture for the workbook or Null to use the thread's current culture.
     */
    get culture(): string | CultureInfo;
    set culture(a: string | CultureInfo);
    /**
     * @hidden
     */
    get _culture$i(): CultureInfo;
    /**
     * @hidden
     */
    set _culture$i(a: CultureInfo);
    /**
     * Gets the current format of the workbook. This is the format which will be used when saving and imposing format restrictions.
     * @see [[setCurrentFormat]]
     */
    get currentFormat(): WorkbookFormat;
    /**
     * Gets the [[WorksheetTableStyle]] at the specified index.
     * @param index The index at which to get the WorksheetTableStyle.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @return The WorksheetTableStyle instance at the specified index.
     */
    customTableStyles(index: number): WorksheetTableStyle;
    /**
     * Gets the [[WorksheetTableStyle]] with the specified name.
     * <p class="body">
     * Table style names are compared case-insensitively.
     * </p>
     * @param name The name of the WorksheetTableStyle to find.
     * @return The WorksheetTableStyle instance with the specified name or null if a table style with that name does not exist.
     */
    customTableStyles(name: string): WorksheetTableStyle;
    /**
     * Gets the collection of custom table styles in the workbook.
     * @see [[defaultTableStyle]]
     * @see [[standardTableStyles]]
     */
    customTableStyles(): CustomTableStyleCollection;
    /**
     * @hidden
     */
    get _customTableStyles$i(): CustomTableStyleCollection;
    /**
     * Gets the custom view at the specified index.
     * The custom view at the specified index.
     * @param index The zero-based index of the custom view to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    customViews(index: number): CustomView;
    /**
     * Gets the collection of custom views for the workbook.
     * <p class="body">
     * Each custom view stores display settings and optionally print settings, which can later be applied to the workbook
     * and its worksheets as one operation, through both the Microsoft Excel UI and the Excel assembly by calling the
     * [[CustomView.apply]] method.
     * </p>
     * The collection of custom views for the workbook.
     * @see [[CustomView]]
     */
    customViews(): CustomViewCollection;
    /**
     * @hidden
     */
    get _customViews$i(): CustomViewCollection;
    /**
     * @hidden
     */
    get _cq(): boolean;
    /**
     * Gets or sets the date system used internally by Microsoft Excel.
     * The date system used internally by Microsoft Excel.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[dateSystem]] enumeration.
     */
    get dateSystem(): DateSystem;
    set dateSystem(a: DateSystem);
    /**
     * Gets or sets the default style for tables in the workbook.
     * <p class="body">
     * This can be set to any [[WorksheetTableStyle]] in the [[customTableStyles]] or [[standardTableStyles]] collection.
     * </p>
     * <p class="body">
     * This will never return a null value. If it is set to null, it will be reset to the TableStyleMedium2 table style.
     * </p>
     * <p class="body">
     * If this value is changed, it will not be applied to existing tables in the workbook. Only newly created tables will use
     * default table style on the workbook.
     * </p>
     * @throws [[ArgumentException]] The specified value is not in the [[customTableStyles]] or [[standardTableStyles]] collections.
     * @see [[customTableStyles]]
     * @see [[standardTableStyles]]
     * @see [[WorksheetTable.style]]
     */
    get defaultTableStyle(): WorksheetTableStyle;
    set defaultTableStyle(a: WorksheetTableStyle);
    /**
     * Gets the properties associated with the workbook document.
     * <p class="body">
     * The document properties are pieces of information which provide details on the content of the workbook,
     * such as the author, title, and subject of the workbook.
     * </p>
     * The properties associated with the workbook document.
     */
    get documentProperties(): DocumentProperties;
    /**
     * @hidden
     */
    get _cr(): boolean;
    /**
     * The editing culture affects certain language specific features such as formatting of dates.
     * or comparisons.
     * <p class="note">
     * <b>Note:</b> The EditingCulture is not saved or loaded in workbook files, so this is only used at when accessing and
     * manipulating objects owned or associated with the Workbook.
     * </p>
     * @see [[culture]]
     */
    get editingCulture(): string | CultureInfo;
    set editingCulture(a: string | CultureInfo);
    /**
     * @hidden
     */
    get _editingCulture$i(): CultureInfo;
    /**
     * @hidden
     */
    set _editingCulture$i(a: CultureInfo);
    /**
     * Returns a boolean indicating if the Workbook has been protected with a password.
     * <p class="body">When protecting a Workbook, a password is optional. The HasProtectionPassword will return true if the
     * Workbook is currently protected (see [[isProtected]]) and a password was specified when it was protected. To protect
     * a Workbook without a password, one may use the [[protect]]
     * method that doesn't take a password.</p>
     * @see [[isProtected]]
     * @see [[protection]]
     * @see [[WorkbookProtection]]
     * @see [[protect]]
     * @see [[unprotect]]
     */
    get hasProtectionPassword(): boolean;
    /**
     * Returns a boolean indicating if the Workbook has been protected.
     * <p class="body">The IsProtected property will return true if the Workbook is currently protected. When a Workbook is protected
     * certain operations related to the Worksheets displayed or their order or the properties of the windows for the Workbook may be
     * restricted based on the values of the [[protection]].</p>
     * @see [[hasProtectionPassword]]
     * @see [[protection]]
     * @see [[WorkbookProtection]]
     * @see [[protect]]
     * @see [[unprotect]]
     */
    get isProtected(): boolean;
    /**
     * Gets a value indicating whether the specified function will be recognized and solved by Microsoft Excel when the workbook is saved out.
     * @param functionName The case-insensitive name of the function.
     * @return True if the function will be recognized in Microsoft Excel; False otherwise.
     */
    isValidFunctionName(functionName: string): boolean;
    /**
     * Gets or sets the value which indicates whether iterations are allowed while calculating formulas containing
     * circular references.
     * <p class="body">
     * When iterative calculations are enabled, a formula is allowed to use circular references,
     * or directly or indirectly reference the cell to which it belongs. Microsoft Excel stops iteratively
     * calculating formulas after iterating [[maxRecursionIterations]] times or when all formula
     * values change by less than [[maxChangeInIteration]] between two iterations.
     * </p>
     * <p class="body">
     * When iterative calculations are disabled, circular references are not allowed, and a formula which
     * references the cell to which it belongs, directly or indirectly, will cause Microsoft Excel to show an
     * error message and the cell will contain a <see cref="ErrorValue.Circularity">Circularity</see> error.
     * </p>
     * The value which indicates whether iterations are allowed while calculating recursive formulas.
     * @see [[ErrorValue.circularity]]
     * @see [[maxChangeInIteration]]
     * @see [[maxRecursionIterations]]
     */
    get iterativeCalculationsEnabled(): boolean;
    set iterativeCalculationsEnabled(a: boolean);
    /**
     * Gets or sets the maximum change of the values in a formula between iterations which will exit from iteration.
     * <p class="body">
     * This property is only valid when [[iterativeCalculationsEnabled]] is True. Otherwise it is ignored.
     * </p>
     * <p class="body">
     * When iterative calculations, or circular references, are enabled, this property determines the maximum change in
     * all values of a formula between two iterations that will cause the formula to exit iterative calculations. Iterative
     * calculations will also be stopped if the formula iterates [[maxRecursionIterations]] times.
     * </p>
     * The maximum change of the values in a formula between iterations which will exit from iteration.
     * @see [[iterativeCalculationsEnabled]]
     * @see [[maxRecursionIterations]]
     */
    get maxChangeInIteration(): number;
    set maxChangeInIteration(a: number);
    /**
     * Gets the maximum number of columns allowed in each worksheet based on the [[currentFormat]].
     */
    get maxColumnCount(): number;
    /**
     * Gets or sets the maximum number of times formulas should be iteratively calculated.
     * <p class="body">
     * This property is only valid when [[iterativeCalculationsEnabled]] is True. Otherwise it is ignored.
     * </p>
     * <p class="body">
     * When iterative calculations, or circular references, are enabled, this property determines the number of iterations
     * allowed when calculating iteratively.
     * </p>
     * The maximum number of times formulas should be iteratively calculated.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 1 and 32767.
     * @see [[iterativeCalculationsEnabled]]
     * @see [[maxChangeInIteration]]
     */
    get maxRecursionIterations(): number;
    set maxRecursionIterations(a: number);
    /**
     * Gets the maximum number of rows allowed in each worksheet based on the [[currentFormat]].
     */
    get maxRowCount(): number;
    /**
     * Gets the named reference at the specified index.
     * The named reference at the specified index.
     * @param index The zero-based index of the named reference to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    namedReferences(index: number): NamedReference;
    /**
     * Gets the collection of named references in the workbook.
     * <p class="body">
     * Named references are typically used to refer to cells or ranges of cells by name.
     * The named reference names are used by formulas instead of explicitly naming the
     * cells or cell ranges.
     * </p>
     * The collection of named references in the workbook.
     * @see [[NamedReference]]
     */
    namedReferences(): NamedReferenceCollection;
    /**
     * @hidden
     */
    get _namedReferences$i(): NamedReferenceCollection;
    /**
     * @hidden
     */
    get _cv(): boolean;
    /**
     * Gets or sets a color in the palette.
     * <p class="body">
     * When a color is set in the palette, [[isCustom]] will return True. The palette can than be reset with the
     * [[reset]] method.
     * </p>
     * <p class="body">
     * Colors added to the palette must be opaque.
     * </p>
     * @param index The index of the color to get or set in the palette.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than 55.
     * @throws [[ArgumentException]] The value assigned is an empty color, a system color, or is not opaque.
     * @see [[isCustom]]
     * @see [[reset]]
     */
    palette(index: number, value?: string | Color): string;
    /**
     * Gets the color palette used when the saved file is opened in Microsoft Excel 2003 and earlier versions.
     * <p class="body">
     * When the file is opened in Microsoft Excel 2003 and earlier versions, the actual colors used in cells and shapes may not be displayed.
     * Instead, the closest color in the palette will be displayed instead. Therefore, the palette can be customized if necessary to keep the
     * colors as accurate as possible in older versions of Excel.
     * </p>
     */
    palette(): WorkbookColorPalette;
    /**
     * @hidden
     */
    get _palette$i(): WorkbookColorPalette;
    /**
     * Gets or sets the precision to use when obtaining a cell's value.
     * <p class="body">
     * The precision determines whether to use the actual value of the cell or the display value of the cell.
     * These are typically the same, but the format of a cell could cause a loss of precision in the displayed
     * value.  For example, if a cell's value is 18.975, and a currency format is used for the cell, the display
     * value will be 18.98.
     * </p>
     * The precision to use when obtaining a cell's value.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the  enumeration.
     */
    get precision(): Precision;
    set precision(a: Precision);
    /**
     * @hidden
     */
    _df: boolean;
    /**
     * Returns an object that provides information used when the Workbook has been protected.
     * @see [[hasProtectionPassword]]
     * @see [[isProtected]]
     * @see [[WorkbookProtection]]
     * @see [[protect]]
     * @see [[unprotect]]
     */
    get protection(): WorkbookProtection;
    /**
     * Gets or sets the value which indicates whether the workbook should recalculate all formulas before saving.
     * <p class="body">
     * This property only applies if the [[calculationMode]] is set to Manual.  Otherwise, it is ignored.
     * </p>
     * The value which indicates whether the workbook should recalculate all formulas before saving.
     * @see [[recalculate]]
     * @see [[calculationMode]]
     */
    get recalculateBeforeSave(): boolean;
    set recalculateBeforeSave(a: boolean);
    /**
     * Gets or sets the value which indicates whether to save values linked from external workbooks.
     * <p class="body">
     * This value will only be used when the workbook is opened in Microsoft Excel. When referencing external values
     * and saving a workbook through the Excel assembly, external linked values will never be saved.
     * </p>
     * The value which indicates whether to save values linked from external workbooks.
     */
    get saveExternalLinkedValues(): boolean;
    set saveExternalLinkedValues(a: boolean);
    /**
     * Gets or sets the Dpi to use when calculating row and column sizes for the workbook. If empty, the system Dpi will be used.
     * @throws [[ArgumentException]] Occurs when the specified value is not empty and does not have two positive values.
     */
    get screenDpi(): IgSize;
    set screenDpi(a: IgSize);
    /**
     * @hidden
     */
    get _screenDpi$i(): Size;
    /**
     * @hidden
     */
    set _screenDpi$i(a: Size);
    /**
     * @hidden
     */
    private _i4;
    /**
     * @hidden
     */
    static _jc(a: Size): void;
    /**
     * @hidden
     */
    private static _c2;
    /**
     * Gets the sheet at the specified index.
     * The sheet at the specified index.
     * @param index The zero-based index of the sheet to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    sheets(index: number): Sheet;
    /**
     * Gets the sheet with the specified name.
     * <p class="body">
     * Sheet names are compared case-insensitively.
     * </p>
     * The sheet with the specified name.
     * @param name The name of the sheet to get.
     * @throws [[InvalidOperationException]] A sheet with the specified name does not exist in the collection.
     * @see [[Sheet.name]]
     */
    sheets(name: string): Sheet;
    /**
     * Gets the collection of sheets in the workbook.
     * <p class="body">
     * Use <see cref="Excel.WindowOptions.SelectedSheet">WindowOptions.SelectedSheet</see> to set the
     * selected sheet. The selected sheet is the sheet seen when the workbook is opened in Microsoft Excel.
     * </p>
     * The collection of worksheets in the workbook.
     */
    sheets(): SheetCollection;
    /**
     * @hidden
     */
    get _sheets$i(): SheetCollection;
    /**
     * Gets or sets the value which indicates whether carriage return characters should be removed from string values in cells
     * when the workbook is saved to an Excel file.
     * <p class="body">
     * In Microsoft Excel 2003, carriage return characters are displayed as boxes. Most of the time, this should not be seen
     * and removing the carriage return characters has no adverse effect on the layout of the text within a cell. Therefore,
     * this property is True by default.
     * </p>
     * True if the saved workbook file should not contain the carriage return characters from cell values; False to export the
     * string values as they have been set on the cells.
     */
    get shouldRemoveCarriageReturnsOnSave(): boolean;
    set shouldRemoveCarriageReturnsOnSave(a: boolean);
    /**
     * Gets the [[WorksheetTableStyle]] at the specified index.
     * @param index The index at which to get the WorksheetTableStyle.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @return The WorksheetTableStyle instance at the specified index.
     */
    standardTableStyles(index: number): WorksheetTableStyle;
    /**
     * Gets the [[WorksheetTableStyle]] with the specified name.
     * <p class="body">
     * Table style names are compared case-insensitively.
     * </p>
     * @param name The name of the WorksheetTableStyle to find.
     * @return The WorksheetTableStyle instance with the specified name or null if a table style with that name does not exist.
     */
    standardTableStyles(name: string): WorksheetTableStyle;
    /**
     * Gets the read-only collection of preset table styles in the workbook.
     * @see [[defaultTableStyle]]
     * @see [[customTableStyles]]
     */
    standardTableStyles(): StandardTableStyleCollection;
    /**
     * @hidden
     */
    get _standardTableStyles$i(): StandardTableStyleCollection;
    /**
     * Gets the style at the specified index.
     * The style at the specified index.
     * @param index The zero-based index of the style to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    styles(index: number): WorkbookStyle;
    /**
     * Gets the style with the specified name.
     * <p class="body">
     * Style names are compared case-insensitively.
     * </p>
     * The style with the specified name or null if no style with that name exists.
     * @param name The name of the style to get.
     * @throws [[ArgumentNullException]] 'name' is null.
     */
    styles(name: string): WorkbookStyle;
    /**
     * Gets the collection of custom styles in the workbook.
     * <p class="body">
     * Use this collection to add custom styles to Excel workbook. The user can apply those styles to different
     * parts of excel workbook and thereby set complex formatting with ease.
     * </p>
     * The collection of custom styles in the workbook.
     * @see [[WorkbookStyle]]
     */
    styles(): WorkbookStyleCollection;
    /**
     * @hidden
     */
    get _styles$i(): WorkbookStyleCollection;
    /**
     * Gets or sets the default Dpi to use when calculating row and column sizes for the workbook. If empty, the resolved system Dpi will be used.
     */
    static get systemDpi(): IgSize;
    static set systemDpi(a: IgSize);
    /**
     * @hidden
     */
    static get _systemDpi$i(): Size;
    /**
     * @hidden
     */
    static set _systemDpi$i(a: Size);
    /**
     * Gets or sets the value indicating whether the format strings should be validated when they are set.
     * <p class="body">
     * This value is False by default to maintain backward compatibility.
     * </p>
     * <p class="body">
     * When True, format strings will be validated when a [[IWorksheetCellFormat.formatString]] property is set. An invalid
     * format string will cause an exception. When False, invalid format strings will be allowed, but if the display text of a cell is
     * requested, an exception will be thrown at that time. If invalid format strings are allowed and the workbook is saved and opened
     * in Microsoft Excel, it will show an error.
     * </p>
     * @see [[IWorksheetCellFormat.formatString]]
     * @see [[WorksheetCell.getText]]
     * @see [[WorksheetCell.getText]]
     * @see [[WorksheetRow.getCellText]]
     * @see [[WorksheetRow.getCellText]]
     */
    get validateFormatStrings(): boolean;
    set validateFormatStrings(a: boolean);
    /**
     * Gets the options which control various workbook level display properties.
     * <p class="body">
     * The window options control properties of the child MDI window showing the workbook in Microsoft Excel.
     * They also control display options of the workbook which do not change based on the selected worksheet.
     * </p>
     * The options which control various workbook level display properties.
     * @see [[CustomView.windowOptions]]
     */
    get windowOptions(): WorkbookWindowOptions;
    /**
     * Gets the worksheet at the specified index.
     * The worksheet at the specified index.
     * @param index The zero-based index of the worksheet to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    worksheets(index: number): Worksheet;
    /**
     * Gets the worksheet with the specified name.
     * <p class="body">
     * Worksheet names are compared case-insensitively.
     * </p>
     * The worksheet with the specified name.
     * @param name The name of the worksheet to get.
     * @throws [[InvalidOperationException]] A worksheet with the specified name does not exist in the collection.
     * @see [[Sheet.name]]
     */
    worksheets(name: string): Worksheet;
    /**
     * Gets the collection of worksheets in the workbook.
     * <p class="body">
     * Use <see cref="Excel.WindowOptions.SelectedWorksheet">WindowOptions.SelectedWorksheet</see> to set the
     * selected worksheet. The selected worksheet is the worksheet seen when the workbook is opened in Microsoft Excel.
     * </p>
     * The collection of worksheets in the workbook.
     */
    worksheets(): WorksheetCollection;
    /**
     * @hidden
     */
    get _worksheets$i(): WorksheetCollection;
    /**
     * @hidden
     */
    get _u(): ActiveCellChangedInfo;
    /**
     * @hidden
     */
    get _a9(): AddInFunctionsWorkbookReference;
    /**
     * @hidden
     */
    get _cm(): boolean;
    /**
     * @hidden
     */
    get _ab(): CellSizeMeasurementContext;
    /**
     * @hidden
     */
    get _bq(): TextMetricsProviderBase;
    /**
     * @hidden
     */
    get _ca(): WorksheetCellFormatCollection;
    /**
     * @hidden
     */
    _ad: ChartDeserializationCache;
    /**
     * @hidden
     */
    get _e6(): CultureInfo;
    /**
     * @hidden
     */
    get _bb(): CurrentWorkbookReference;
    /**
     * @hidden
     */
    _g3: number;
    /**
     * @hidden
     */
    get _e(): number[];
    /**
     * @hidden
     */
    set _e(a: number[]);
    /**
     * @hidden
     */
    get _ef(): List$1<BinaryData>;
    /**
     * @hidden
     */
    get _eh(): List$1<BinaryData>;
    /**
     * @hidden
     */
    get _fp(): number;
    /**
     * @hidden
     */
    _gk: Nullable$1<number>;
    /**
     * @hidden
     */
    get _cc(): WorksheetCellFormatCollection;
    /**
     * @hidden
     */
    get _ej(): List$1<PropertyTableBase_PropertyValue>;
    /**
     * @hidden
     */
    set _ej(a: List$1<PropertyTableBase_PropertyValue>);
    /**
     * @hidden
     */
    get _el(): List$1<PropertyTableBase_PropertyValue>;
    /**
     * @hidden
     */
    set _el(a: List$1<PropertyTableBase_PropertyValue>);
    /**
     * @hidden
     */
    get _dz(): Dictionary$2<string, WorkbookReferenceBase>;
    /**
     * @hidden
     */
    get _av(): GenericCachedCollectionEx$1<WorkbookFontData>;
    /**
     * @hidden
     */
    get _at(): GenericCachedCollectionEx$1<WorkbookFontData>;
    /**
     * @hidden
     */
    get _ax(): GenericCachedCollectionEx$1<WorkbookFontData>;
    /**
     * @hidden
     */
    get _b2(): WorkbookFormatCollection;
    /**
     * @hidden
     */
    get _ct(): boolean;
    /**
     * @hidden
     */
    get _co(): boolean;
    /**
     * @hidden
     */
    set _co(a: boolean);
    /**
     * @hidden
     */
    get _cp(): boolean;
    /**
     * @hidden
     */
    get _cx(): boolean;
    /**
     * @hidden
     */
    get _cy(): boolean;
    /**
     * @hidden
     */
    get _cz(): boolean;
    /**
     * @hidden
     */
    get _c1(): boolean;
    /**
     * @hidden
     */
    get _en(): List$1<NamedReference>;
    /**
     * @hidden
     */
    get _cu(): boolean;
    /**
     * @hidden
     */
    get _c4(): boolean;
    /**
     * @hidden
     */
    get _c9(): boolean;
    /**
     * @hidden
     */
    _gw: string;
    /**
     * @hidden
     */
    get _fv(): number;
    /**
     * @hidden
     */
    get _ff(): number;
    /**
     * @hidden
     */
    get _g6(): number;
    /**
     * @hidden
     */
    set _g6(a: number);
    /**
     * @hidden
     */
    _gn: Nullable$1<WorksheetRegionAddress>;
    /**
     * @hidden
     */
    get _d1(): Dictionary$2<string, Formula>;
    /**
     * @hidden
     */
    _l: OleDataSpacesEncryptionMode;
    /**
     * @hidden
     */
    get _a0(): IWorkbookOwner;
    /**
     * @hidden
     */
    static get _jn(): Size;
    /**
     * @hidden
     */
    get _dj(): boolean;
    /**
     * @hidden
     */
    set _dj(a: boolean);
    /**
     * @hidden
     */
    get _d6(): HashSet$1<number>;
    /**
     * @hidden
     */
    get _bj(): SharedStringTable;
    /**
     * @hidden
     */
    get _h(): Color[];
    /**
     * @hidden
     */
    static _c(): Color[];
    /**
     * @hidden
     */
    get _k(): BinaryData;
    /**
     * @hidden
     */
    set _k(a: BinaryData);
    /**
     * @hidden
     */
    get _g0(): string;
    /**
     * @hidden
     */
    set _g0(a: string);
    /**
     * @hidden
     */
    _dt: boolean;
    /**
     * @hidden
     */
    get _bm(): Sheet;
    /**
     * @hidden
     */
    get _gj(): number;
    /**
     * @hidden
     */
    _ix(): void;
    /**
     * @hidden
     */
    private static _d3;
    /**
     * @hidden
     */
    private static get _d4();
    /**
     * @hidden
     */
    get _w(): ExcelCalcEngine;
    /**
     * @hidden
     */
    private static get _jo();
    /**
     * @hidden
     */
    get _jq(): Size;
}
/**
 * @hidden
 */
export declare class Workbook_MetricsProviderCache extends Base implements IDisposable {
    static $t: Type;
    private _f;
    private readonly _e;
    private _c;
    private _a;
    constructor(a: Workbook);
    get _b(): CellSizeMeasurementContext;
    get _d(): TextMetricsProviderBase;
    _g(): void;
    dispose(): void;
}
/**
 * @hidden
 */
export declare abstract class GenericCacheElement extends Base {
    static $t: Type;
    private e;
    constructor();
    equals(a: any): boolean;
    getHashCode(): number;
    abstract g(a: Workbook): any;
    abstract c(a: GenericCacheElement): boolean;
    j(): void;
    k(): void;
    protected l(a: boolean): void;
    static h<T extends GenericCacheElement>($t: Type, a: GenericCachedCollection$1<T>, b: T): {
        p1?: T;
    };
    static i<T extends GenericCacheElement>($t: Type, a: GenericCachedCollection$1<T>, b: T, c: boolean): {
        p1?: T;
    };
    static a<T extends GenericCacheElement>($t: Type, a: T, b: GenericCachedCollection$1<T>): T;
    static m<T extends GenericCacheElement>($t: Type, a: T, b: GenericCachedCollection$1<T>): void;
    static o<T extends GenericCacheElement>($t: Type, a: GenericCachedCollection$1<T>, b: GenericCachedCollection$1<T>, c: T): {
        p1?: GenericCachedCollection$1<T>;
        p2?: T;
    };
    protected n(): void;
    get f(): number;
}
/**
 * @hidden
 */
export declare abstract class GenericCacheElementEx extends GenericCacheElement {
    static $t: Type;
    private s;
    private u;
    private w;
    constructor(a: Workbook);
    ab(a: IGenericCachedCollectionEx): void;
    ac(): void;
    abstract aa(a: GenericCacheElement): void;
    protected abstract af(): void;
    static z<T extends GenericCacheElementEx>($t: Type, a: GenericCachedCollection$1<T>, b: T): {
        p1?: T;
    };
    static p<T extends GenericCacheElementEx>($t: Type, a: T, b: boolean): {
        ret: GenericCachedCollection$1<T>;
        p0?: T;
    };
    y(): any;
    static r<T extends GenericCacheElementEx>($t: Type, a: T, b: GenericCachedCollection$1<T>): T;
    static q<T extends GenericCacheElementEx>($t: Type, a: T): GenericCachedCollection$1<T>;
    static ad<T extends GenericCacheElementEx>($t: Type, a: GenericCachedCollection$1<T>, b: T): {
        p1?: T;
    };
    ae(a: Workbook, b: boolean): void;
    get t(): IGenericCachedCollectionEx;
    set t(a: IGenericCachedCollectionEx);
    get x(): boolean;
    set x(a: boolean);
    get v(): Workbook;
    set v(a: Workbook);
}
/**
 * @hidden
 */
export interface IWorkbookFontDefaultsResolver {
    resolveDefaults(a: WorkbookFontData): void;
}
/**
 * @hidden
 */
export declare let IWorkbookFontDefaultsResolver_$type: Type;
/**
 * Represents the format for the cell.
 * <p class="body">
 * Depending on where the format is exposed, it will have a different meaning. For example, a cell's format just applies to itself,
 * but a row or column's format applies to all cells in that row or column. There are also style formats, which can be the parent of
 * other formats, meaning they provide defaults for values not set on the format. And finally, there are differential formats, such
 * as the format for areas in a table, which provide default values for cells which exist in the associated area.
 * </p>
 * @see [[WorksheetCell.cellFormat]]
 * @see [[RowColumnBase.cellFormat]]
 * @see [[WorksheetMergedCellsRegion.cellFormat]]
 * @see [[WorkbookStyle.styleFormat]]
 * @see [[WorksheetTable.areaFormats]]
 * @see [[WorksheetTableColumn.areaFormats]]
 * @see [[WorksheetTableStyle.areaFormats]]
 * @see [[WorksheetCell.getResolvedCellFormat]]
 * @see [[RowColumnBase.getResolvedCellFormat]]
 * @see [[WorksheetMergedCellsRegion.getResolvedCellFormat]]
 */
export interface IWorksheetCellFormat {
    setFormatting(source: IWorksheetCellFormat): void;
    alignment: HorizontalCellAlignment;
    bottomBorderColorInfo: WorkbookColorInfo;
    bottomBorderStyle: CellBorderLineStyle;
    diagonalBorderColorInfo: WorkbookColorInfo;
    diagonalBorders: DiagonalBorders;
    diagonalBorderStyle: CellBorderLineStyle;
    fill: CellFill;
    readonly font: IWorkbookFont;
    formatOptions: WorksheetCellFormatOptions;
    formatString: string;
    indent: number;
    leftBorderColorInfo: WorkbookColorInfo;
    leftBorderStyle: CellBorderLineStyle;
    locked: boolean | null;
    _locked$i: Nullable$1<boolean>;
    rightBorderColorInfo: WorkbookColorInfo;
    rightBorderStyle: CellBorderLineStyle;
    rotation: number;
    shrinkToFit: boolean | null;
    _shrinkToFit$i: Nullable$1<boolean>;
    style: WorkbookStyle;
    topBorderColorInfo: WorkbookColorInfo;
    topBorderStyle: CellBorderLineStyle;
    verticalAlignment: VerticalCellAlignment;
    wrapText: boolean | null;
    _wrapText$i: Nullable$1<boolean>;
}
/**
 * @hidden
 */
export declare let IWorksheetCellFormat_$type: Type;
/**
 * @hidden
 */
export declare class WorksheetCellFormatData extends GenericCacheElementEx implements IWorkbookFontDefaultsResolver, IWorksheetCellFormat {
    static $t: Type;
    _as: CellFormatCache;
    private _b4;
    private _a3;
    private _ba;
    private _ag;
    private _cx;
    private _bt;
    private _bb;
    private _au;
    private _ah;
    private _aq;
    private _bo;
    private _bw;
    private _a5;
    private _ci;
    private _cj;
    private _b5;
    private _bc;
    private _ai;
    private _cz;
    private _av;
    private _bd;
    private _aj;
    private _ck;
    private _c0;
    private _bq;
    private _be;
    private _ak;
    private _b0;
    private _b2;
    private _a7;
    private _c1;
    private _cy;
    constructor(a: Workbook, b: WorksheetCellFormatType);
    resolveDefaults(a: WorkbookFontData): void;
    g(a: Workbook): any;
    _bu(): WorksheetCellFormatData;
    _bv(a: Workbook, b?: boolean): WorksheetCellFormatData;
    aa(a: GenericCacheElement): void;
    equals(a: any): boolean;
    _ca(a: WorksheetCellFormatData): boolean;
    getHashCode(): number;
    c(a: GenericCacheElement): boolean;
    ab(a: IGenericCachedCollectionEx): void;
    ac(): void;
    protected l(a: boolean): void;
    protected af(): void;
    setFormatting(a: IWorksheetCellFormat): void;
    _dh(a: WorksheetCellFormatOptions, b: WorksheetCellFormatData): void;
    _dk(): void;
    static _c8(a: CellFormatValue): any;
    _ay(a: CellFill): FillPatternStyle;
    static _az(a: CellFill, b: IWorksheetCellFormat): FillPatternStyle;
    _bi(a: CellFill, b: boolean, c: boolean): WorkbookColorInfo;
    static _bj(a: CellFill, b: boolean, c: boolean, d: IWorksheetCellFormat, e: boolean): WorkbookColorInfo;
    static _a2(a: Workbook, b: WorksheetCellFormatData): GenericCachedCollectionEx$1<WorkbookFontData>;
    _da(a: CellFormatValue, b?: (borderProperty: CellFormatValue, value: any) => {
        ret: boolean;
        p1: any;
    }): any;
    private _db;
    _dd(a: CellFormatValue): any;
    _cg(): List$1<ExtProp>;
    _ch(): List$1<XFProp>;
    _cc(): boolean;
    static _cf(a: CellFormatValue, b: any): boolean;
    _dm(): void;
    _ds(a: CellFormatValue): void;
    _dv(a: CellFormatValue, b: any): void;
    _dw(a: WorkbookColorInfo, b: ExtPropType, c: List$1<ExtProp>): void;
    _dx(a: WorkbookColorInfo, b: XFPropType, c: List$1<XFProp>): void;
    private static _di;
    _br(a: WorkbookStyle): WorkbookStyle;
    private _bx;
    private _dj;
    static _by(a: CellFormatValue): WorksheetCellFormatOptions;
    private static _at;
    private _dl;
    private _c9;
    private static _dc;
    _cb(a: WorksheetCellFormatOptions): boolean;
    private _dp;
    private _dq;
    _dr(a: WorksheetCellFormatOptions): void;
    private _dy;
    private _dz;
    private _d0;
    private _d1;
    private _d2;
    private _d3;
    private _bn;
    get alignment(): HorizontalCellAlignment;
    set alignment(a: HorizontalCellAlignment);
    get bottomBorderColorInfo(): WorkbookColorInfo;
    set bottomBorderColorInfo(a: WorkbookColorInfo);
    get bottomBorderStyle(): CellBorderLineStyle;
    set bottomBorderStyle(a: CellBorderLineStyle);
    get diagonalBorderColorInfo(): WorkbookColorInfo;
    set diagonalBorderColorInfo(a: WorkbookColorInfo);
    get diagonalBorders(): DiagonalBorders;
    set diagonalBorders(a: DiagonalBorders);
    get diagonalBorderStyle(): CellBorderLineStyle;
    set diagonalBorderStyle(a: CellBorderLineStyle);
    get fill(): CellFill;
    set fill(a: CellFill);
    get font(): IWorkbookFont;
    get formatOptions(): WorksheetCellFormatOptions;
    set formatOptions(a: WorksheetCellFormatOptions);
    _dt(a: WorksheetCellFormatOptions): void;
    private _dn;
    get formatString(): string;
    set formatString(a: string);
    get indent(): number;
    set indent(a: number);
    get leftBorderColorInfo(): WorkbookColorInfo;
    set leftBorderColorInfo(a: WorkbookColorInfo);
    get leftBorderStyle(): CellBorderLineStyle;
    set leftBorderStyle(a: CellBorderLineStyle);
    get locked(): boolean | null;
    set locked(a: boolean | null);
    get _locked$i(): Nullable$1<boolean>;
    set _locked$i(a: Nullable$1<boolean>);
    get rightBorderColorInfo(): WorkbookColorInfo;
    set rightBorderColorInfo(a: WorkbookColorInfo);
    get rightBorderStyle(): CellBorderLineStyle;
    set rightBorderStyle(a: CellBorderLineStyle);
    get rotation(): number;
    set rotation(a: number);
    get shrinkToFit(): boolean | null;
    set shrinkToFit(a: boolean | null);
    get _shrinkToFit$i(): Nullable$1<boolean>;
    set _shrinkToFit$i(a: Nullable$1<boolean>);
    get style(): WorkbookStyle;
    set style(a: WorkbookStyle);
    _du(a: WorkbookStyle): void;
    get topBorderColorInfo(): WorkbookColorInfo;
    set topBorderColorInfo(a: WorkbookColorInfo);
    get topBorderStyle(): CellBorderLineStyle;
    set topBorderStyle(a: CellBorderLineStyle);
    get verticalAlignment(): VerticalCellAlignment;
    set verticalAlignment(a: VerticalCellAlignment);
    get wrapText(): boolean | null;
    set wrapText(a: boolean | null);
    get _wrapText$i(): Nullable$1<boolean>;
    set _wrapText$i(a: Nullable$1<boolean>);
    get _a4(): HorizontalCellAlignment;
    get _bf(): WorkbookColorInfo;
    get _al(): CellBorderLineStyle;
    get _bg(): WorkbookColorInfo;
    get _aw(): DiagonalBorders;
    get _am(): CellBorderLineStyle;
    get _ar(): CellFill;
    get _c2(): Nullable$1<boolean>;
    get _bh(): WorkbookColorInfo;
    get _cq(): number;
    get _c3(): Nullable$1<boolean>;
    get _df(): string;
    get _c4(): Nullable$1<boolean>;
    get _a0(): FontSuperscriptSubscriptStyle;
    get _a1(): FontUnderlineStyle;
    get _bz(): WorksheetCellFormatOptions;
    get _cs(): number;
    get _dg(): string;
    get _ct(): number;
    get _bk(): WorkbookColorInfo;
    get _an(): CellBorderLineStyle;
    get _c5(): Nullable$1<boolean>;
    get _bl(): WorkbookColorInfo;
    get _ao(): CellBorderLineStyle;
    get _cw(): number;
    get _c6(): Nullable$1<boolean>;
    get _bs(): WorkbookStyle;
    get _bm(): WorkbookColorInfo;
    get _ap(): CellBorderLineStyle;
    get _a9(): VerticalCellAlignment;
    get _c7(): Nullable$1<boolean>;
    get _b6(): boolean;
    set _b6(a: boolean);
    get _cl(): number;
    get _cm(): number;
    get _cn(): number;
    get _cp(): number;
    get _co(): number;
    get _b7(): boolean;
    get _a8(): VerticalCellAlignment;
    get _b8(): boolean;
    get _b9(): boolean;
    get _bp(): WorkbookFontProxy;
    get _a6(): FontScheme;
    set _a6(a: FontScheme);
    get _cr(): number;
    set _cr(a: number);
    get _cd(): boolean;
    get _ce(): boolean;
    set _ce(a: boolean);
    get _b1(): WorksheetCellFormatType;
    set _b1(a: WorksheetCellFormatType);
    get _ax(): DiagonalBorders;
    get _b3(): (arg1: WorksheetCellFormatOptions) => void;
    set _b3(a: (arg1: WorksheetCellFormatOptions) => void);
}
/**
 * @hidden
 */
export declare class CellFormatCache extends Base {
    static $t: Type;
    c: number;
    a: WorksheetCellFormatData;
    f: any;
    d: HTMLCanvasElement;
    e: CanvasRenderingContext2D;
    b: boolean;
    constructor(a: WorksheetCellFormatData);
    g(): void;
    static h(a: any): void;
}
/**
 * @hidden
 */
export declare abstract class TextMetricsProviderBase extends Base implements IDisposable {
    static $t: Type;
    protected readonly _a: Workbook;
    constructor(a: Workbook);
    dispose(): void;
    protected get__b(): boolean;
    get _b(): boolean;
    abstract _d(a: WorksheetCellFormatData): number;
    abstract _g(a: WorksheetCellFormatData, b: string, c: Nullable$1<Size>, d: boolean, e: boolean): Size;
    _e(a: WorksheetCellFormatData): number;
    static _c(a: FontUnderlineStyle): boolean;
    _f(a: Size): {
        p0?: Size;
    };
}
/**
 * @hidden
 */
export declare class HtmlTextMetricsProvider extends TextMetricsProviderBase {
    static $t: Type;
    private _o;
    constructor(a: Workbook, b: number);
    dispose(): void;
    private readonly _h;
    private _j;
    private _l;
    private _k;
    _d(a: WorksheetCellFormatData): number;
    _e(a: WorksheetCellFormatData): number;
    _g(a: WorksheetCellFormatData, b: string, c?: Nullable$1<Size>, d?: boolean, e?: boolean): Size;
    private static _i;
    private _n;
    private _m;
}
/**
 * Contains the options related to loading a workbook from a file or stream.
 * @see [[Workbook.load]]
 */
export declare class WorkbookLoadOptions extends WorkbookOptionsBase {
    static $t: Type;
    /**
     * @hidden
     */
    _f(): number[];
    /**
     * @hidden
     */
    get _j(): boolean;
    private _g;
    private _h;
    private _n;
    private _p;
    constructor();
    /**
     * Returns or sets a boolean indicating whether the Workbook will automatically call its [[Workbook.resumeCalculations]] methods before the Load method returns.
     * When the Load method starts the [[Workbook.suspendCalculations]] is invoked so that no
     * calculations occurs as the load is in progress. When the Load operation is complete and the Workbook
     * is about to be returned from the Load method, it will call the [[Workbook.resumeCalculations]]
     * method to ensure that the loaded formulas have been added to the calculation network and the formulas
     * can be calculated. However if one wanted to delay calling that method, perhaps to add additional formulas
     * to the workbook being loaded, one can set this property to false and then the Workbook will not call
     * ResumeCalculations. Instead it will be the responsibility of the caller to invoke this method.
     * @see [[Workbook.suspendCalculations]]
     * @see [[Workbook.resumeCalculations]]
     */
    get autoResumeCalculations(): boolean;
    set autoResumeCalculations(a: boolean);
    /**
     * Returns or sets the value for the [[Workbook.culture]] property.
     * @see [[Workbook.culture]]
     */
    get culture(): string | CultureInfo;
    set culture(a: string | CultureInfo);
    private _culture$i_1;
    /**
     * @hidden
     */
    get _culture$i(): CultureInfo;
    /**
     * @hidden
     */
    set _culture$i(a: CultureInfo);
    /**
     * @hidden
     */
    get _k(): boolean;
    /**
     * Returns or sets a boolean indicating whether duplicate formulas parsed during the load will be optimized for faster loading of the workbook.
     * <p class="body">
     * By default when an exact duplicate of a formula string is encountered during the load, the previously parsed formula
     * will be cloned rather than reparsing the string to create an entirely new formula.
     * </p>
     * <p class="note"><b>Note:</b> This property does not apply to the loading of the xls formats.</p>
     */
    get isDuplicateFormulaParsingOptimized(): boolean;
    set isDuplicateFormulaParsingOptimized(a: boolean);
    /**
     * Gets or sets the Dpi to use when calculating row and column sizes for the workbook. If empty, the system Dpi will be used.
     * @throws [[ArgumentException]] Occurs when the specified value is not empty and does not have two positive values.
     */
    get screenDpi(): IgSize;
    set screenDpi(a: IgSize);
    /**
     * @hidden
     */
    get _screenDpi$i(): Size;
    /**
     * @hidden
     */
    set _screenDpi$i(a: Size);
    /**
     * Returns a list of user defined functions that should be registered before the workbook is loaded.
     */
    get userDefinedFunctions(): IList$1<ExcelCalcFunction>;
}
/**
 * Represents a range of cells in a worksheet that may be edited by the end user.
 */
export declare class WorksheetProtectedRange extends Base {
    static $t: Type;
    private _a;
    private _k;
    /**
     * @hidden
     */
    _b(): number[];
    /**
     * @hidden
     */
    _m(): string;
    /**
     * @hidden
     */
    _o(a: number[]): void;
    /**
     * @hidden
     */
    _p(a: string): void;
    private _d;
    private _g;
    private _l;
    private _f;
    /**
     * @hidden
     */
    readonly _c: WorkbookPasswordInfo;
    constructor(title: string);
    /**
     * Returns true if the range has a password associated with it.
     */
    get hasPassword(): boolean;
    /**
     * Returns a boolean indicating if the range is currently locked.
     * <p class="body">When the associated Worksheet is protected, the ranges with a password
     * will be marked as protected until they are unprotected.</p>
     */
    get isProtected(): boolean;
    set isProtected(a: boolean);
    /**
     * Returns a collection of ranges that may be edited when the worksheet is protected.
     */
    get ranges(): ICollection$1<WorksheetRegion>;
    /**
     * Returns or sets the name of the range.
     */
    get title(): string;
    set title(a: string);
    /**
     * Returns the worksheet with which the edit range is associated.
     */
    get worksheet(): Worksheet;
    set worksheet(a: Worksheet);
    /**
     * Removes the password from the range.
     * <p class="note"><b>Note:</b> If the range is not currently protected (i.e. [[isProtected]] returns
     * false) the method will not do anything.</p>
     * @see [[isProtected]]
     * @see [[hasPassword]]
     */
    unprotect(): void;
}
/**
 * @hidden
 */
export declare class MathUtilities extends Base {
    static $t: Type;
    static get l(): CultureInfo;
    static q(a: number, b: CultureInfo): string;
    private static p;
    private static n;
    static r(a: number, b: CultureInfo): string;
    static b(a: string, b: IFormatProvider, c: number): {
        ret: boolean;
        p2: number;
    };
    static c(a: string, b: IFormatProvider, c: number): {
        ret: boolean;
        p2: number;
    };
    private static d;
    private static e;
    static m(a: number): number;
    static o(a: number): number;
    static f(a: number): number;
    private static a;
    static g(a: number, b: number): number;
    private static h;
    static i(a: number): number;
    static j(a: number): number;
    static k(a: number, b: number): number;
}
/**
 * Abstract base class for the fill of a cell.
 * @see [[IWorksheetCellFormat.fill]]
 * @see [[CellFillPattern]]
 * @see [[CellFillGradient]]
 * @see [[CellFillLinearGradient]]
 * @see [[CellFillRectangularGradient]]
 */
export declare abstract class CellFill extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    abstract _r(a: WorksheetCellFormatData, b: List$1<ExtProp>): void;
    /**
     * @hidden
     */
    abstract _s(a: WorksheetCellFormatData, b: List$1<XFProp>): void;
    /**
     * @hidden
     */
    abstract _c(a: Workbook): CellFill;
    /**
     * Creates a linear gradient that can be applied to a cell's fill.
     * @param angle The angle, in degrees, of the direction of the linear gradient, going clockwise from the left-to-right direction.
     * @param stops Two or more gradient stops which describe the color transitions and their positions within the gradient.
     * @throws [[ArgumentException]] 'stops' contains less than two gradient stops. There must be at least two stops to define the gradient.
     * @see [[CellFillLinearGradient]]
     */
    static createLinearGradientFill(angle: number, ...stops: CellFillGradientStop[]): CellFillLinearGradient;
    /**
     * Creates a linear gradient that can be applied to a cell's fill.
     * @param angle The angle, in degrees, of the direction of the linear gradient, going clockwise from the left-to-right direction.
     * @param colorInfo1 A [[WorkbookColorInfo]] which describes the color at the start of the gradient.
     * @param colorInfo2 A [[WorkbookColorInfo]] which describes the color at the end of the gradient.
     * @throws [[ArgumentException]] 'colorInfo1' or 'colorInfo2' is an automatic or a system color.
     * @see [[CellFillLinearGradient]]
     */
    static createLinearGradientFill(angle: number, colorInfo1: WorkbookColorInfo, colorInfo2: WorkbookColorInfo): CellFillLinearGradient;
    /**
     * Creates a linear gradient that can be applied to a cell's fill.
     * @param angle The angle, in degrees, of the direction of the linear gradient, going clockwise from the left-to-right direction.
     * @param color1 The color at the start of the gradient.
     * @param color2 The color at the end of the gradient.
     * @throws [[ArgumentException]] 'color1' or 'color2' are the empty or system colors or have a non-opaque alpha channel.
     * @see [[CellFillLinearGradient]]
     */
    static createLinearGradientFill(angle: number, color1: string | Color, color2: string | Color): CellFillLinearGradient;
    /**
     * @hidden
     */
    static _createLinearGradientFill2(a: number, b: Color, c: Color): CellFillLinearGradient;
    /**
     * @hidden
     */
    static _createLinearGradientFill1(a: number, b: WorkbookColorInfo, c: WorkbookColorInfo): CellFillLinearGradient;
    /**
     * @hidden
     */
    static _createLinearGradientFill(a: number, ...b: CellFillGradientStop[]): CellFillLinearGradient;
    /**
     * Creates a solid color or pattern fill that can be applied to a cell.
     * <p class="body">
     * 'backgroundColorInfo' and 'patternColorInfo' can be specified as null to use the default colors.
     * </p>
     * @param backgroundColorInfo A [[WorkbookColorInfo]] which describes the background color of the cell, which will only be seen if the
     * 'patternStyle' is not None.
     * @param patternColorInfo A [[WorkbookColorInfo]] which describes the pattern color of the cell, which will only be seen if the
     * 'patternStyle' is not None or Solid.
     * @param patternStyle The fill pattern for the cell.
     * @throws [[InvalidEnumArgumentException]] 'patternStyle' is Default or not defined in the [[FillPatternStyle]] enumeration.
     * @see [[CellFillPattern]]
     */
    static createPatternFill(backgroundColorInfo: WorkbookColorInfo, patternColorInfo: WorkbookColorInfo, patternStyle: FillPatternStyle): CellFillPattern;
    /**
     * Creates a solid color or pattern fill that can be applied to a cell.
     * @param backgroundColor The background color of the cell, which will only be seen if the 'patternStyle' is not None.
     * @param patternColor The pattern color of the cell, which will only be seen if the 'patternStyle' is not None or Solid.
     * @param patternStyle The fill pattern for the cell.
     * @throws [[ArgumentException]] 'backgroundColor' or 'patternColor' are the empty color or have a non-opaque alpha channel.
     * @throws [[InvalidEnumArgumentException]] 'patternStyle' is Default or not defined in the [[FillPatternStyle]] enumeration.
     * @see [[CellFillPattern]]
     */
    static createPatternFill(backgroundColor: string | Color, patternColor: string | Color, patternStyle: FillPatternStyle): CellFillPattern;
    /**
     * @hidden
     */
    static _createPatternFill1(a: Color, b: Color, c: FillPatternStyle): CellFillPattern;
    /**
     * @hidden
     */
    static _createPatternFill(a: WorkbookColorInfo, b: WorkbookColorInfo, c: FillPatternStyle): CellFillPattern;
    /**
     * Creates a rectangular gradient that can be applied to a cell's fill.
     * @param colorInfo1 A [[WorkbookColorInfo]] which describes the color at the inner rectangle (cell center) of the gradient.
     * @param colorInfo2 A [[WorkbookColorInfo]] which describes the color at the outer rectangle (cell edges) of the gradient.
     * @throws [[ArgumentException]] 'colorInfo1' or 'colorInfo2' is an automatic or a system color.
     * @see [[CellFillRectangularGradient]]
     */
    static createRectangularGradientFill(colorInfo1: WorkbookColorInfo, colorInfo2: WorkbookColorInfo): CellFillRectangularGradient;
    /**
     * Creates a rectangular gradient that can be applied to a cell's fill.
     * <p class="body">
     * The rectangular gradient is defined by specifying an inner rectangle and a set of gradient stops. The gradient goes from the
     * edges of the inner rectangle to the edges of the cell. If the inner rectangle does not have a height or width of 0, the color
     * of the first gradient stop will be filled in the center of the inner rectangle.
     * </p>
     * <p class="body">
     * The inner rectangle is defined by the 'left', 'top', 'right', and
     * 'bottom' parameters. They are relative values ranging from 0.0 to 1.0 and they go from the top/left to the
     * bottom/right. So, for example, to specify a gradient that goes out from the center, all values would be 0.5. Or to specify a
     * gradient which goes out from the bottom-left corner of the cell, the following values would be used: left = 0.0, top = 1.0,
     * right = 0.0, bottom = 1.0.
     * </p>
     * @param left The left edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     * @param top The top edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     * @param right The right edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     * @param bottom The bottom edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     * @param stops Two or more gradient stops which describe the color transitions and their positions within the gradient.
     * @throws [[ArgumentOutOfRangeException]] 'left', 'top', 'right', or 'bottom' are less than 0.0 or
     * greater than 1.0.
     * @throws [[ArgumentException]] 'stops' contains less than two gradient stops. There must be at least two stops to define the gradient.
     * @see [[CellFillRectangularGradient]]
     */
    static createRectangularGradientFill(left: number, top: number, right: number, bottom: number, ...stops: CellFillGradientStop[]): CellFillRectangularGradient;
    /**
     * Creates a rectangular gradient that can be applied to a cell's fill.
     * <p class="body">
     * The rectangular gradient is defined by specifying an inner rectangle and a set of gradient stops. The gradient goes from the
     * edges of the inner rectangle to the edges of the cell. If the inner rectangle does not have a height or width of 0, the color
     * of the first gradient stop will be filled in the center of the inner rectangle.
     * </p>
     * <p class="body">
     * The inner rectangle is defined by the 'left', 'top', 'right', and
     * 'bottom' parameters. They are relative values ranging from 0.0 to 1.0 and they go from the top/left to the
     * bottom/right. So, for example, to specify a gradient that goes out from the center, all values would be 0.5. Or to specify a
     * gradient which goes out from the bottom-left corner of the cell, the following values would be used: left = 0.0, top = 1.0,
     * right = 0.0, bottom = 1.0.
     * </p>
     * @param left The left edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     * @param top The top edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     * @param right The right edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     * @param bottom The bottom edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     * @param colorInfo1 A [[WorkbookColorInfo]] which describes the color at the inner rectangle of the gradient.
     * @param colorInfo2 A [[WorkbookColorInfo]] which describes the color at the outer rectangle (cell edges) of the gradient.
     * @throws [[ArgumentException]] 'colorInfo1' or 'colorInfo2' is an automatic or a system color.
     * @throws [[ArgumentOutOfRangeException]] 'left', 'top', 'right', or 'bottom' are less than 0.0 or
     * greater than 1.0.
     * @see [[CellFillRectangularGradient]]
     */
    static createRectangularGradientFill(left: number, top: number, right: number, bottom: number, colorInfo1: WorkbookColorInfo, colorInfo2: WorkbookColorInfo): CellFillRectangularGradient;
    /**
     * Creates a rectangular gradient that can be applied to a cell's fill.
     * <p class="body">
     * The rectangular gradient is defined by specifying an inner rectangle and a set of gradient stops. The gradient goes from the
     * edges of the inner rectangle to the edges of the cell. If the inner rectangle does not have a height or width of 0, the color
     * of the first gradient stop will be filled in the center of the inner rectangle.
     * </p>
     * <p class="body">
     * The inner rectangle is defined by the 'left', 'top', 'right', and
     * 'bottom' parameters. They are relative values ranging from 0.0 to 1.0 and they go from the top/left to the
     * bottom/right. So, for example, to specify a gradient that goes out from the center, all values would be 0.5. Or to specify a
     * gradient which goes out from the bottom-left corner of the cell, the following values would be used: left = 0.0, top = 1.0,
     * right = 0.0, bottom = 1.0.
     * </p>
     * @param left The left edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     * @param top The top edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     * @param right The right edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     * @param bottom The bottom edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     * @param color1 The color at the inner rectangle of the gradient.
     * @param color2 The color at the outer rectangle (cell edges) of the gradient.
     * @throws [[ArgumentOutOfRangeException]] 'left', 'top', 'right', or 'bottom' are less than 0.0 or
     * greater than 1.0.
     * @throws [[ArgumentException]] 'color1' or 'color2' are empty or system colors or have a non-opaque alpha channel.
     * @see [[CellFillRectangularGradient]]
     */
    static createRectangularGradientFill(left: number, top: number, right: number, bottom: number, color1: string | Color, color2: string | Color): CellFillRectangularGradient;
    /**
     * Creates a rectangular gradient that can be applied to a cell's fill.
     * @param color1 The color at the inner rectangle (cell center) of the gradient.
     * @param color2 The color at the outer rectangle (cell edges) of the gradient.
     * @throws [[ArgumentException]] 'color1' or 'color2' are empty or system colors or have a non-opaque alpha channel.
     * @see [[CellFillRectangularGradient]]
     */
    static createRectangularGradientFill(color1: string | Color, color2: string | Color): CellFillRectangularGradient;
    /**
     * @hidden
     */
    static _createRectangularGradientFill4(a: Color, b: Color): CellFillRectangularGradient;
    /**
     * @hidden
     */
    static _createRectangularGradientFill3(a: number, b: number, c: number, d: number, e: Color, f: Color): CellFillRectangularGradient;
    /**
     * @hidden
     */
    static _createRectangularGradientFill(a: WorkbookColorInfo, b: WorkbookColorInfo): CellFillRectangularGradient;
    /**
     * @hidden
     */
    static _createRectangularGradientFill2(a: number, b: number, c: number, d: number, e: WorkbookColorInfo, f: WorkbookColorInfo): CellFillRectangularGradient;
    /**
     * @hidden
     */
    static _createRectangularGradientFill1(a: number, b: number, c: number, d: number, ...e: CellFillGradientStop[]): CellFillRectangularGradient;
    /**
     * Creates a solid color fill that can be applied to a cell.
     * @param solidColorInfo A [[WorkbookColorInfo]] which describes the solid color of the fill.
     * @see [[CellFillPattern]]
     */
    static createSolidFill(solidColorInfo: WorkbookColorInfo): CellFillPattern;
    /**
     * Creates a solid color fill that can be applied to a cell.
     * @param solidColor The solid color of the fill.
     * @throws [[ArgumentException]] 'solidColor' is the empty color or has a non-opaque alpha channel.
     * @see [[CellFillPattern]]
     */
    static createSolidFill(solidColor: string | Color): CellFillPattern;
    /**
     * @hidden
     */
    static _createSolidFill1(a: Color): CellFillPattern;
    /**
     * @hidden
     */
    static _createSolidFill(a: WorkbookColorInfo): CellFillPattern;
    /**
     * @hidden
     */
    static _q(a: WorkbookColorInfo): {
        p0?: WorkbookColorInfo;
    };
    /**
     * @hidden
     */
    static _p(a: Color): WorkbookColorInfo;
    /**
     * Gets the default cell fill, which is no background color.
     */
    static get noColor(): CellFill;
}
/**
 * An immutable object which represents a solid or pattern fill for a cell.
 * @see [[IWorksheetCellFormat.fill]]
 */
export declare class CellFillPattern extends CellFill {
    static $t: Type;
    private readonly _v;
    private readonly _w;
    private readonly _t;
    constructor(backgroundColorInfo: WorkbookColorInfo, patternColorInfo: WorkbookColorInfo, patternStyle: FillPatternStyle);
    constructor(backgroundColorInfo: WorkbookColorInfo, patternColorInfo: WorkbookColorInfo, patternStyle: FillPatternStyle, owningFormat: WorksheetCellFormatData);
    constructor(backgroundColorInfo: WorkbookColorInfo, patternColorInfo: WorkbookColorInfo, patternStyle: FillPatternStyle, owningFormat: WorksheetCellFormatData, isCreatedInternally: boolean);
    constructor(backgroundColorInfo: WorkbookColorInfo, patternColorInfo: WorkbookColorInfo, patternStyle: FillPatternStyle, doesReverseColorsForSolidFill: boolean, isCreatedInternally: boolean);
    constructor(backgroundColorIndex: number, foregroundColorIndex: number, patternStyle: FillPatternStyle, owningFormat: WorksheetCellFormatData);
    constructor(..._rest: any[]);
    /**
     * Determines whether the [[CellFillPattern]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[CellFillPattern]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _r(a: WorksheetCellFormatData, b: List$1<ExtProp>): void;
    /**
     * @hidden
     */
    _s(a: WorksheetCellFormatData, b: List$1<XFProp>): void;
    /**
     * @hidden
     */
    _c(a: Workbook): CellFill;
    /**
     * @hidden
     */
    _y(a: WorksheetCellFormatData): WorkbookColorInfo;
    /**
     * @hidden
     */
    _z(a: boolean): WorkbookColorInfo;
    /**
     * @hidden
     */
    _aa(a: WorksheetCellFormatData): WorkbookColorInfo;
    /**
     * @hidden
     */
    _ab(a: boolean): WorkbookColorInfo;
    /**
     * Gets the [[WorkbookColorInfo]] which describes the background color of the cell, which will only be seen if the
     * [[patternStyle]] is not None.
     */
    get backgroundColorInfo(): WorkbookColorInfo;
    /**
     * Gets the fill pattern for the cell.
     */
    get patternStyle(): FillPatternStyle;
    /**
     * Gets the [[WorkbookColorInfo]] which describes the pattern color of the cell, which will only be seen if the
     * [[patternStyle]] is not None or Solid.
     */
    get patternColorInfo(): WorkbookColorInfo;
}
/**
 * Abstract base class for a gradient fill of a cell.
 * @see [[IWorksheetCellFormat.fill]]
 * @see [[CellFillLinearGradient]]
 * @see [[CellFillRectangularGradient]]
 */
export declare abstract class CellFillGradient extends CellFill {
    static $t: Type;
    private readonly _v;
    constructor(a: CellFillGradientStop[]);
    /**
     * Determines whether the [[CellFillGradient]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[CellFillGradient]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _r(a: WorksheetCellFormatData, b: List$1<ExtProp>): void;
    /**
     * @hidden
     */
    _t(a: Workbook, b: boolean): {
        ret: CellFillGradientStop[];
        p1: boolean;
    };
    /**
     * @hidden
     */
    _w(a: List$1<XFProp>): void;
    /**
     * Gets the read-only collection of gradient stops which describe the color transitions and their positions within the gradient.
     */
    get stops(): IList$1<CellFillGradientStop>;
}
/**
 * An immutable object which represents a linear gradient fill for a cell.
 * @see [[IWorksheetCellFormat.fill]]
 */
export declare class CellFillLinearGradient extends CellFillGradient {
    static $t: Type;
    private readonly _x;
    constructor(angle: number, ...stops: CellFillGradientStop[]);
    /**
     * Determines whether the [[CellFillLinearGradient]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[CellFillLinearGradient]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _s(a: WorksheetCellFormatData, b: List$1<XFProp>): void;
    /**
     * @hidden
     */
    _c(a: Workbook): CellFill;
    /**
     * Gets the angle, in degrees, of the direction of the linear gradient, going clockwise from the left-to-right direction.
     */
    get angle(): number;
}
/**
 * An immutable object which represents a rectangular gradient fill for a cell.
 * @see [[IWorksheetCellFormat.fill]]
 */
export declare class CellFillRectangularGradient extends CellFillGradient {
    static $t: Type;
    private readonly _x;
    private readonly _y;
    private readonly _z;
    private readonly _aa;
    constructor(left: number, top: number, right: number, bottom: number, ...stops: CellFillGradientStop[]);
    /**
     * Determines whether the [[CellFillRectangularGradient]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[CellFillRectangularGradient]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _s(a: WorksheetCellFormatData, b: List$1<XFProp>): void;
    /**
     * @hidden
     */
    _c(a: Workbook): CellFill;
    /**
     * @hidden
     */
    private static _af;
    /**
     * Gets the bottom edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     */
    get bottom(): number;
    /**
     * Gets the left edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     */
    get left(): number;
    /**
     * Gets the right edge of the inner rectangle of the gradient, ranging from 0.0 (the left of the cell) to 1.0 (the right of the cell).
     */
    get right(): number;
    /**
     * Gets the top edge of the inner rectangle of the gradient, ranging from 0.0 (the top of the cell) to 1.0 (the bottom of the cell).
     */
    get top(): number;
}
/**
 * Immutable class which describes a color transition in a cell fill gradient.
 * @see [[CellFillLinearGradient]]
 * @see [[CellFillRectangularGradient]]
 */
export declare class CellFillGradientStop extends Base {
    static $t: Type;
    private readonly _b;
    private readonly _e;
    constructor(color: string | Color, offset: number);
    constructor(colorInfo: WorkbookColorInfo, offset: number);
    constructor(..._rest: any[]);
    /**
     * Determines whether the [[CellFillGradientStop]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[CellFillGradientStop]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _a(a: Workbook): CellFillGradientStop;
    /**
     * Gets the [[WorkbookColorInfo]] describing the color transition for the gradient stop.
     * @see [[offset]]
     */
    get colorInfo(): WorkbookColorInfo;
    /**
     * Gets the position in the gradient of the color transition for the gradient stop, ranging from 0.0 to 1.0.
     * <p class="body">
     * When used in a [[CellFillLinearGradient]], a value of 0.0 is at the beginning of the gradient and 1.0 is at the end of the
     * gradient. When used in a [[CellFillRectangularGradient]], a value of 0.0 is at the inner rectangle and 1.0 is at the outer
     * edges of the cell.
     * </p>
     * @see [[colorInfo]]
     */
    get offset(): number;
}
/**
 * An immutable object which represents a color in a Microsoft Excel workbook.
 * @see [[IWorksheetCellFormat.bottomBorderColorInfo]]
 * @see [[IWorksheetCellFormat.diagonalBorderColorInfo]]
 * @see [[IWorksheetCellFormat.leftBorderColorInfo]]
 * @see [[IWorksheetCellFormat.rightBorderColorInfo]]
 * @see [[IWorksheetCellFormat.topBorderColorInfo]]
 * @see [[IWorkbookFont.colorInfo]]
 * @see [[CellFillPattern.backgroundColorInfo]]
 * @see [[CellFillPattern.patternColorInfo]]
 * @see [[CellFillGradientStop.colorInfo]]
 */
export declare class WorkbookColorInfo extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _a;
    private readonly _ag;
    private readonly _i;
    private readonly _v;
    private readonly _w;
    private _j;
    constructor();
    constructor(color: string | Color);
    constructor(color: string | Color, tint: number);
    constructor(color: string | Color, transform: WorkbookColorTransform);
    constructor(themeColorType: WorkbookThemeColorType);
    constructor(themeColorType: WorkbookThemeColorType, tint: number);
    constructor(themeColorType: WorkbookThemeColorType, transform: WorkbookColorTransform);
    constructor(color: string | Color, themeColorType: WorkbookThemeColorType | null, tint: number | null, isLoading: boolean, preventUsingAutomaticColor?: boolean);
    constructor(color: string | Color, themeColorType: WorkbookThemeColorType | null, tint: number | null, transform: WorkbookColorTransform, isLoading: boolean, preventUsingAutomaticColor?: boolean);
    constructor(workbook: Workbook, index: number);
    constructor(..._rest: any[]);
    /**
     * Determines whether the [[WorkbookColorInfo]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[WorkbookColorInfo]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * Gets the string representation of the [[WorkbookColorInfo]].
     * @return
     */
    toString(): string;
    /**
     * Gets the actual color which will be seen in Microsoft Excel if the [[WorkbookColorInfo]] is used.
     * @throws [[ArgumentNullException]] The [[themeColorType]] is not null. When the ThemeColorType is set, the [[getResolvedColor]] method must be called with
     * a non-null [[Workbook]].
     * @return A Color which combines the [[color]] and [[tint]] if it is set.
     */
    getResolvedColor(): string;
    /**
     * Gets the actual color which will be seen in Microsoft Excel if the [[WorkbookColorInfo]] is used.
     * @param workbook The workbook in which the WorkbookColorInfo is used.
     * @throws [[ArgumentNullException]] 'workbook' is null and [[themeColorType]] is not null. When the ThemeColorType is set, the method must be called with a
     * non-null [[Workbook]].
     * @return A Color which combines the [[color]], [[themeColorType]], and/or [[tint]], depending on what is set.
     */
    getResolvedColor(workbook: Workbook): string;
    /**
     * @hidden
     */
    _getResolvedColor(): Color;
    /**
     * @hidden
     */
    _getResolvedColor1(a: Workbook): Color;
    /**
     * @hidden
     */
    _aj(a: Workbook, b?: boolean, c?: boolean): Color;
    /**
     * @hidden
     */
    _y(a: Workbook, b: ColorableItem): number;
    /**
     * @hidden
     */
    _o(a: Workbook, b: ColorableItem): boolean;
    /**
     * @hidden
     */
    _g(a: Workbook, b?: boolean): WorkbookColorInfo;
    /**
     * @hidden
     */
    _h(a: WorkbookColorTransform): WorkbookColorInfo;
    /**
     * @hidden
     */
    private static _u;
    /**
     * @hidden
     */
    private static _ad;
    /**
     * @hidden
     */
    private static _ae;
    /**
     * @hidden
     */
    private static _af;
    /**
     * Gets the automatic color, which is the window text system color.
     * @see [[isAutomatic]]
     */
    static get automatic(): WorkbookColorInfo;
    /**
     * Gets the base color associated of the [[WorkbookColorInfo]].
     * @see [[tint]]
     */
    get color(): string | Color;
    /**
     * @hidden
     */
    get _color$i(): Nullable$1<Color>;
    /**
     * Gets the value which indicates whether the [[WorkbookColorInfo]] is automatic, or the window text system color.
     */
    get isAutomatic(): boolean;
    /**
     * Gets the base theme color associated of the [[WorkbookColorInfo]].
     * @see [[tint]]
     */
    get themeColorType(): WorkbookThemeColorType | null;
    /**
     * @hidden
     */
    get _themeColorType$i(): Nullable$1<WorkbookThemeColorType>;
    /**
     * Gets the to apply to the base color, from -1.0 (100% darken) to 1.0 (100% lighten).
     * @see [[color]]
     * @see [[themeColorType]]
     */
    get tint(): number | null;
    /**
     * @hidden
     */
    get _tint$i(): Nullable$1<number>;
    /**
     * Returns the associated [[WorkbookColorTransform]], or null
     * if this instance is not associated with a transform.
     */
    get transform(): WorkbookColorTransform;
    /**
     * @hidden
     */
    get _n(): boolean;
    /**
     * @hidden
     */
    get _p(): boolean;
    /**
     * @hidden
     */
    static l_op_Equality(a: WorkbookColorInfo, b: WorkbookColorInfo): boolean;
    /**
     * @hidden
     */
    static l_op_Inequality(a: WorkbookColorInfo, b: WorkbookColorInfo): boolean;
    /**
     * @hidden
     */
    static l_op_Implicit_WorkbookColorInfo_Color(color: string | Color): WorkbookColorInfo;
    /**
     * @hidden
     */
    static _l_op_Implicit_WorkbookColorInfo_Color$i(a: Color): WorkbookColorInfo;
    /**
     * @hidden
     */
    static l_op_Implicit_WorkbookColorInfo_WorkbookThemeColorType(themeColorType: WorkbookThemeColorType): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare abstract class FormattingRunBase extends Base {
    static $t: Type;
    private b;
    private j;
    constructor(a: IFormattedRunOwner, b: number);
    abstract get i(): number;
    abstract set i(a: number);
    abstract d(a: Workbook): IWorkbookFont;
    abstract f(a: Workbook): WorkbookFontProxy;
    a(a: Workbook, b: IFormattedRunOwner): FormattingRunBase;
    e(): WorkbookFontProxy;
    g(a: Workbook, b: WorkbookFontProxy): {
        ret: WorkbookFontProxy;
        p1?: WorkbookFontProxy;
    };
    m(a: FormattingRunBase, b: Workbook): void;
    abstract get h(): boolean;
    get k(): number;
    set k(a: number);
    get c(): IFormattedRunOwner;
    protected get_l(): string;
    get l(): string;
}
/**
 * @hidden
 */
export declare class CellFormattingRunPlaceholder extends FormattingRunBase {
    static $t: Type;
    private n;
    constructor(a: StringElement, b: IWorkbookFont);
    protected get_i(): number;
    protected set_i(a: number): void;
    get i(): number;
    set i(a: number);
    d(a: Workbook): IWorkbookFont;
    f(a: Workbook): WorkbookFontProxy;
    protected get_h(): boolean;
    get h(): boolean;
    m(a: FormattingRunBase, b: Workbook): void;
    protected get_l(): string;
}
/**
 * @hidden
 */
export interface IFormattedRunOwner {
    addRun(a: FormattingRunBase): void;
    createRun(a: number): FormattingRunBase;
    getFormattingRuns(a: Workbook): List$1<FormattingRunBase>;
    insertRun(a: number, b: FormattingRunBase): void;
    readonly startIndex: number;
    readonly unformattedString: string;
}
/**
 * @hidden
 */
export declare let IFormattedRunOwner_$type: Type;
/**
 * @hidden
 */
export declare class CellFormattingRunPlaceholder_RunOwner extends Base implements IFormattedRunOwner {
    static $t: Type;
    private a;
    constructor(a: StringElement);
    addRun(a: FormattingRunBase): void;
    createRun(a: number): FormattingRunBase;
    getFormattingRuns(a: Workbook): List$1<FormattingRunBase>;
    insertRun(a: number, b: FormattingRunBase): void;
    get startIndex(): number;
    get unformattedString(): string;
}
/**
 * @hidden
 */
export interface ICellShiftOperationOverride {
    readonly count: number;
    readonly index: number;
    readonly isRemoveOperation: boolean;
    readonly isUndoOperation: boolean;
    readonly performsShift: boolean;
    readonly shiftsColumns: boolean;
    readonly shiftsRows: boolean;
    readonly worksheet: Worksheet;
    onBeforeShift(a: CellShiftOperation): void;
    performShift(a: CellShiftOperation): boolean;
}
/**
 * @hidden
 */
export declare let ICellShiftOperationOverride_$type: Type;
/**
 * @hidden
 */
export declare class CellShiftOperation extends ValueType {
    static $t: Type;
    constructor(a: number, b: Worksheet, c: CellShiftType, d: number, e: number, f: number, g: number, h: number);
    constructor(a: number, b: Worksheet, c: CellShiftType, d: WorksheetTableResizeOperation, e: number, f: number, g: number, h: number, i: number, j: boolean);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly j;
    private readonly n;
    private readonly v;
    private readonly a;
    private readonly m;
    private readonly g;
    readonly u: List$1<WorksheetRegion>;
    i(a: WorksheetCellAddress): WorksheetCellAddress;
    private z;
    private ab;
    private aa;
    private ac;
    private ad;
    private ae;
    c(a: WorksheetCellAddress): {
        ret: ShiftAddressResult;
        p0?: WorksheetCellAddress;
    };
    d(a: number, b: number): {
        ret: ShiftAddressResult;
        p0?: number;
        p1?: number;
    };
    e(a: WorksheetRegionAddress, b: boolean): {
        ret: ShiftAddressResult;
        p0?: WorksheetRegionAddress;
    };
    f(a: WorksheetRegionAddress, b: boolean, c: boolean, d: List$1<WorksheetRegionAddress>): {
        ret: ShiftAddressResult;
        p0?: WorksheetRegionAddress;
        p3: List$1<WorksheetRegionAddress>;
    };
    private r;
    af(a: ICellShiftOperationOverride): void;
    s<T>($t: Type, a: ICellShiftOperationOverride, b: List$1<T>, c: T, d: WorksheetRegionAddress): boolean;
    private t;
    get x(): Nullable$1<WorksheetRegionAddress>;
    get y(): Nullable$1<WorksheetRegionAddress>;
    get o(): boolean;
    get k(): WorksheetRegionAddress;
    get l(): WorksheetRegionAddress;
    get p(): boolean;
    get q(): boolean;
    get w(): number;
    get b(): CellShiftType;
    get h(): Worksheet;
}
/**
 * @hidden
 */
export declare class SheetChangeInfoContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: Sheet);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly b;
    get sheet(): Sheet;
    get workbook(): Workbook;
    get c(): Worksheet;
    get source(): any;
    static a<TSheet extends Sheet, TValue>($tSheet: Type, $tValue: Type, a: string, b: ExcelChangeAction, c: (arg1: TSheet) => TValue, d: (arg1: TSheet, arg2: TValue) => void, e?: (arg1: TSheet, arg2: TValue) => void, f?: boolean, g?: boolean, h?: WorksheetPermissions): ChangeInfo;
}
/**
 * Base class for a sheet in a Microsoft Excel workbook.
 */
export declare abstract class Sheet extends Base implements IWorkbookProvider {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    private static readonly _aa;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static _a;
    private _k;
    private _ah;
    private _v;
    private _q;
    private _m;
    private readonly _al;
    private _aj;
    /**
     * @hidden
     */
    readonly _h: SheetChangeInfoContext;
    static staticInit(): void;
    constructor(a: string, b: Workbook, c: number);
    /**
     * @hidden
     */
    get _c(): CellReferenceMode;
    /**
     * @hidden
     */
    get _y(): CultureInfo;
    /**
     * @hidden
     */
    get _o(): WorkbookFormat;
    /**
     * @hidden
     */
    abstract get _e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    get _r(): boolean;
    /**
     * @hidden
     */
    set _r(a: boolean);
    /**
     * Returns a boolean indicating if the Sheet has been protected with a password.
     * <p class="body">When protecting a Sheet, a password is optional. The HasProtectionPassword will return true if the
     * Sheet is currently protected (see [[isProtected]]) and a password was specified when it was protected.</p>
     * @see [[isProtected]]
     * @see@see [[sheetProtection]]
     * @see [[Worksheet.protect]]
     * @see [[unprotect]]
     */
    get hasProtectionPassword(): boolean;
    /**
     * @hidden
     */
    get _t(): boolean;
    /**
     * Returns a boolean indicating if the Worksheet has been protected.
     * <p class="body">The IsProtected property will return true if the Worksheet is currently protected. When a Worksheet is protected
     * only unprotected cells may be edited. In addition, other operations may be limited based on the properties of the
     * [[WorksheetProtection]] which may be accessed using the Protection property.</p>
     * @see [[hasProtectionPassword]]
     * @see [[sheetProtection]]
     * @see [[WorksheetProtection]]
     * @see@see [[Worksheet.protection]]
     * @see [[Chartsheet.protection]]
     * @see [[unprotect]]
     */
    get isProtected(): boolean;
    /**
     * @hidden
     */
    get _w(): boolean;
    /**
     * @hidden
     */
    set _w(a: boolean);
    /**
     * Gets or sets the sheet name.
     * <p class="body">The sheet name is case-insensitively unique in the workbook.</p>
     * <p class="body">
     * The sheet name is shown in the tab for the worksheet. In addition, the worksheet name can be used by formulas
     * from other worksheets to refer to cells in this worksheet.
     * </p>
     * The sheet name.
     * @throws [[ArgumentNullException]] The value assigned is null or empty.
     * @throws [[ArgumentException]] The value assigned contains the invalid characters: ':', '\', '/', '?', '*', '[', or ']'.
     * @throws [[ArgumentException]] The value assigned exceeds 31 characters in length.
     * @throws [[ArgumentException]] The value assigned is being used as the name of another sheet (sheet names are case-insensitively compared).
     */
    get name(): string;
    set name(a: string);
    /**
     * @hidden
     */
    private _at;
    /**
     * @hidden
     */
    abstract get _g(): PrintOptionsBase;
    /**
     * Gets the value which indicates whether this worksheet is selected.
     * <p class="body">
     * If the worksheet has been removed from its parent [[Workbook.worksheets]] collection, this will always return False.
     * </p>
     * The value which indicates whether this worksheet is selected.
     * @see [[WindowOptions]]
     * @see */
    get selected(): boolean;
    /**
     * @hidden
     */
    abstract get _p(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    get _am(): number;
    /**
     * Gets the zero-based index of this sheet in its parent [[Workbook.sheets]] collection.
     * <p class="body">
     * Negative one indicates the sheet has been removed from its parent collection.
     * </p>
     * The zero-based index of this sheet in its parent Sheets collection.
     * @see [[SheetCollection.indexOf]]
     * @see [[moveToSheetIndex]]
     */
    get sheetIndex(): number;
    /**
     * @hidden
     */
    abstract get _i(): SheetProtection;
    /**
     * Gets or sets the [[WorkbookColorInfo]] to use for the associated sheet's tab in the tab bar of Microsoft Excel.
     * <p class="body">
     * If the tab bar is not visible, this color will not be seen.
     * </p>
     * The WorkbookColorInfo to use for the associated sheet's tab in the tab bar of Microsoft Excel.
     * @see [[WindowOptions.tabBarVisible]]
     */
    get tabColorInfo(): WorkbookColorInfo;
    set tabColorInfo(a: WorkbookColorInfo);
    /**
     * Returns a value indicating the type of sheet
     */
    abstract get type(): SheetType;
    /**
     * @hidden
     */
    get _ak(): string;
    /**
     * @hidden
     */
    set _ak(a: string);
    /**
     * Gets the [[workbook]] that owns the worksheet.
     * The Workbook that owns the worksheet.
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    protected get__ag(): number;
    /**
     * @hidden
     */
    get _ag(): number;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    abstract _d(a: CustomView): DisplayOptionsBase;
    /**
     * @hidden
     */
    abstract _f(): PrintOptionsBase;
    /**
     * Moves the sheet to a new position in the owning workbook's collections of sheets.
     * @param index The new 0-based index to where the sheet should be moved.
     * @throws [[InvalidOperationException]] The sheet has previously been removed from its workbook.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to the number of sheets in the owning workbook.
     * @see [[Workbook.sheets]]
     * @see [[SheetCollection.indexOf]]
     * @see [[sheetIndex]]
     */
    moveToSheetIndex(index: number): void;
    /**
     * @hidden
     */
    _ao(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    _ap(): void;
    /**
     * @hidden
     */
    _aq(): void;
    /**
     * @hidden
     */
    _ar(): void;
    /**
     * @hidden
     */
    _as(a: WorksheetVisibility, b: WorksheetVisibility): void;
    /**
     * Removes the Sheet protection.
     * @see [[isProtected]]
     * @see [[hasProtectionPassword]]
     * @see [[Worksheet.protect]]
     */
    unprotect(): void;
    /**
     * @hidden
     */
    static readonly _ab: number;
    /**
     * @hidden
     */
    static _aw(a: string, b: string): void;
    /**
     * @hidden
     */
    _av(a: FormatLimitErrors, b: WorkbookFormat): void;
}
/**
 * @hidden
 */
export interface IWorksheetShapeOwner extends ISheetProvider {
    onChildShapeBoundsChanged(a: WorksheetShape, b: WorksheetCellAddress, c: WorksheetCellAddress, d: boolean): void;
    onShapeAdded(a: WorksheetShape): void;
    onShapeRemoved(a: WorksheetShape): void;
    readonly areChildrenTopMost: boolean;
    readonly ChildShapes: WorksheetShapeCollection;
}
/**
 * @hidden
 */
export declare let IWorksheetShapeOwner_$type: Type;
/**
 * A sheet in a Mirosoft Excel workbook that displays a single chart.
 */
export declare class Chartsheet extends Sheet implements IWorksheetShapeOwner {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _a8;
    /**
     * @hidden
     */
    private static readonly _a9;
    /**
     * @hidden
     */
    private static _ax;
    private readonly _a6;
    private _be;
    private _az;
    private _a1;
    private readonly _a3;
    private _ba;
    static staticInit(): void;
    constructor(a: string, b: Workbook, c: number);
    /**
     * @hidden
     */
    _d(a: CustomView): DisplayOptionsBase;
    /**
     * @hidden
     */
    _f(): PrintOptionsBase;
    /**
     * @hidden
     */
    protected get__e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    get _e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    _ao(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    protected get__g(): PrintOptionsBase;
    /**
     * @hidden
     */
    get _g(): PrintOptionsBase;
    /**
     * @hidden
     */
    protected get__p(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    get _p(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    protected get__i(): SheetProtection;
    /**
     * @hidden
     */
    get _i(): SheetProtection;
    /**
     * Returns Chartsheet
     */
    protected get_type(): SheetType;
    /**
     * Returns Chartsheet
     */
    get type(): SheetType;
    /**
     * Returns the [[WorksheetChart]] displayed in this chartsheet.
     */
    get chart(): WorksheetChart;
    /**
     * Gets the object which controls the display of the chartsheet.
     * <p class="body">
     * The display options include any settings which affect the display of the chartsheet when viewed in Microsoft Excel.
     * These settings will not affect the printed chartsheet or the data stored in the chartsheet.
     * </p>
     * The object which controls the display of the chartsheet.
     * @see [[CustomView.getSheetDisplayOptions]]
     */
    get displayOptions(): ChartsheetDisplayOptions;
    /**
     * @hidden
     */
    get _bf(): WBitmap;
    /**
     * @hidden
     */
    set _bf(a: WBitmap);
    /**
     * @hidden
     */
    private _bd;
    /**
     * @hidden
     */
    get _bb(): any;
    /**
     * @hidden
     */
    set _bb(a: any);
    /**
     * @hidden
     */
    _a7: ImageFormat;
    /**
     * Gets the object which controls how the chartsheet prints.
     * The object which controls how the chartsheet prints.
     * @see [[CustomView.getSheetPrintOptions]]
     */
    get printOptions(): ChartsheetPrintOptions;
    /**
     * Returns an object that provides information used when the Chartsheet has been protected.
     * @see@see@see [[ChartsheetProtection]]
     * @see [[protect]]
     * @see */
    get protection(): ChartsheetProtection;
    /**
     * @hidden
     */
    private static _ay;
    /**
     * Protects the chartsheet without a password.
     * <p class="body">When a Chartsheet is protected without a password, the end user may unprotect the Chartsheet in Excel without
     * having to supply a password. To programatically unprotect a Chartsheet, one may use the Unprotect() method.</p>
     * <p class="body">The optional parameters are used to update the property values of the [[ChartsheetProtection]] instance from
     * this Worksheet's [[protection]] property. If the parameter is null, the current value of the associated property will
     * be retained; otherwise the property will be updated with the specified value. For example, if the [[ChartsheetProtection.allowEditObjects]]
     * is currently true and the 'allowEditObjects' is null, then the property will continue to be true but if the
     * 'allowEditObjects' is false the [[ChartsheetProtection.allowEditObjects]] will be changed to false.</p>
     * <p class="note"><b>Note:</b> If IsProtected is already true, the method will be ignored.</p>
     * @param allowEditObjects Optional boolean indicating the new value for the [[ChartsheetProtection.allowEditObjects]].
     * @param allowEditContents Optional boolean indicating the new value for the ChartsheetProtection.AllowEditScenarios.
     * @see@see@see [[protection]]
     * @see [[ChartsheetProtection]]
     * @see */
    protect(allowEditObjects?: boolean, allowEditContents?: boolean): void;
    /**
     * @hidden
     */
    _protect$i(a?: Nullable$1<boolean>, b?: Nullable$1<boolean>): void;
    /**
     * @hidden
     */
    onChildShapeBoundsChanged(childShape: WorksheetShape, oldTopLeftCell: WorksheetCellAddress, oldBottomRightCell: WorksheetCellAddress, isNotifyOnly: boolean): void;
    /**
     * @hidden
     */
    onShapeAdded(shape: WorksheetShape): void;
    /**
     * @hidden
     */
    onShapeRemoved(shape: WorksheetShape): void;
    /**
     * @hidden
     */
    get areChildrenTopMost(): boolean;
    /**
     * @hidden
     */
    get ChildShapes(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    get sheet(): Sheet;
}
/**
 * @hidden
 */
export interface IChartObject extends ISheetProvider, IWorkbookProvider {
    readonly chart: WorksheetChart;
    onPropertyChanged(): void;
    isReferencingAnythingInRegion(a: Worksheet, b: WorksheetRegionAddress): boolean;
    iterateFormulas(a: (arg1: Sheet, arg2: Formula) => void): void;
    onShiftRegion(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    undoChartShift(a: any): any;
    verifyFormulas(a: Worksheet): void;
}
/**
 * @hidden
 */
export declare let IChartObject_$type: Type;
/**
 * Abstract base class for objects that are exposed off a
 * @see [[WorksheetChart]]
 */
export declare abstract class ChartObject extends Base implements IChartObject, IChangeInfoContext {
    static $t: Type;
    private _c;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _e(a: Workbook): WorkbookFontProxy;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    _f(a: Workbook, b?: boolean): WorkbookFontProxy;
    /**
     * @hidden
     */
    _l(a: IChartObject): void;
    /**
     * @hidden
     */
    private _n;
    /**
     * @hidden
     */
    _j(a: ExcelChangeAction): any;
    /**
     * @hidden
     */
    _p(a: any): void;
    /**
     * @hidden
     */
    _q<TContext extends IChangeInfoContext, T>($tContext: Type, $t: Type, a: TContext, b: number, c: T, d: T): {
        p2?: T;
    };
    /**
     * @hidden
     */
    _r<TContext extends IChangeInfoContext, T>($tContext: Type, $t: Type, a: TContext, b: number, c: T, d: T, e?: (arg1: T) => void): {
        p2?: T;
    };
    /**
     * @hidden
     */
    _s(): void;
    /**
     * @hidden
     */
    _u(): void;
    /**
     * @hidden
     */
    static _v(a: IChartObject, b: IChartObject): void;
    /**
     * Returns the owning chart (read-only)
     * @see [[owner]]
     */
    get chart(): WorksheetChart;
    /**
     * returns this object's owner. (read-only)
     * The owner or null if this object is owned directly by the Chart
     * @see [[chart]]
     */
    get owner(): ChartObject;
    /**
     * The owning sheet (read-only)
     */
    get sheet(): Sheet;
    /**
     * The owning workbook (read-only)
     */
    get workbook(): Workbook;
    /**
     * The owning worksheet (read-only)
     */
    get worksheet(): Worksheet;
    /**
     * @hidden
     */
    get _h(): boolean;
    /**
     * @hidden
     */
    get _d(): IChartObject;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    onPropertyChanged(): void;
    /**
     * @hidden
     */
    isReferencingAnythingInRegion(ws: Worksheet, region: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    iterateFormulas(callback: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    onShiftRegion(callback: (arg1: IChartObject, arg2: any) => void, shiftOperation: CellShiftOperation, operationOverride: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    undoChartShift(context: any): any;
    /**
     * @hidden
     */
    _k(a: any): any;
    /**
     * @hidden
     */
    verifyFormulas(removedWorksheet: Worksheet): void;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
}
/**
 * Exposes chart-level properties for [[Series]] which appear within a combo chart.
 * @see [[WorksheetChart.comboChartGroups]]
 */
export declare class ComboChartGroup extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static readonly _ah;
    private _aj;
    private _ak;
    private _al;
    private _am;
    static staticInit(): void;
    constructor(a: ComboChartGroupCollection, b: ChartType, c: AxisGroup, d: boolean);
    /**
     * @hidden
     */
    _ac(a: ComboChartGroupCollection, b: ChartType, c: AxisGroup): ComboChartGroup;
    private _axisGroup;
    /**
     * Returns the [[axisGroup]] value with which this instance was created.
     */
    get axisGroup(): AxisGroup;
    set axisGroup(a: AxisGroup);
    private _chartType;
    /**
     * Returns the [[chartType]] value with which this instance was created.
     */
    get chartType(): ChartType;
    set chartType(a: ChartType);
    /**
     * Returns or sets the size of the hole in a doughnut chart,
     * expressed as a percentage of the size of the encompassing circle.
     * <p class="body">
     * This property is only applicable to doughnut charts.
     * </p>
     * <p class="body">
     * The valid range for this property is 0 through 90, inclusive.
     * </p>
     * @see [[WorksheetChart.doughnutHoleSize]]
     */
    get doughnutHoleSize(): number | null;
    set doughnutHoleSize(a: number | null);
    /**
     * @hidden
     */
    get _doughnutHoleSize$i(): Nullable$1<number>;
    /**
     * @hidden
     */
    set _doughnutHoleSize$i(a: Nullable$1<number>);
    /**
     * Returns or sets the angle, expressed in degrees which determines the origin
     * of the first slice, as relative to the 12 o'clock position of the emcompassing
     * circle.
     * <p class="body">
     * This property is only applicable to pie and doughnut charts.
     * </p>
     * <p class="body">
     * The valid range for this property is between 0 and 360, inclusive.
     * </p>
     * @see [[WorksheetChart.firstSliceAngle]]
     */
    get firstSliceAngle(): number | null;
    set firstSliceAngle(a: number | null);
    /**
     * @hidden
     */
    get _firstSliceAngle$i(): Nullable$1<number>;
    /**
     * @hidden
     */
    set _firstSliceAngle$i(a: Nullable$1<number>);
    /**
     * Specifies the width of the gap between bars.
     * Applicable only for bar/column charts.
     * <p class="body">
     * This property is only applicable for bar charts.
     * </p>
     * <p class="body">
     * The valid range for this property is between 0 and 500, inclusive.
     * </p>
     * @see [[WorksheetChart.gapWidth]]
     */
    get gapWidth(): number | null;
    set gapWidth(a: number | null);
    /**
     * @hidden
     */
    get _gapWidth$i(): Nullable$1<number>;
    /**
     * @hidden
     */
    set _gapWidth$i(a: Nullable$1<number>);
    /**
     * Determines the amount by which intersecting [[Series]] overlap,
     * expressed as a percentage of the bar size.
     * <p class="body">
     * This property is only applicable for bar charts.
     * </p>
     * <p class="body">
     * The valid range for this property is between -100 and 100, inclusive.
     * </p>
     * @see [[WorksheetChart.seriesOverlap]]
     */
    get seriesOverlap(): number | null;
    set seriesOverlap(a: number | null);
    /**
     * @hidden
     */
    get _seriesOverlap$i(): Nullable$1<number>;
    /**
     * @hidden
     */
    set _seriesOverlap$i(a: Nullable$1<number>);
    /**
     * @hidden
     */
    static _ar(a: ChartType, b: AxisGroup): string;
    /**
     * @hidden
     */
    static _as(a: ChartType, b: AxisGroup, c: SeriesChartTypeGroup): {
        ret: string;
        p2: SeriesChartTypeGroup;
    };
    /**
     * @hidden
     */
    static _at(a: SeriesChartTypeGroup, b: AxisGroup): string;
    /**
     * @hidden
     */
    static _ad(a: ChartType): SeriesChartTypeGroup;
    /**
     * @hidden
     */
    static _y(a: SeriesChartTypeGroup): ChartType[];
    /**
     * @hidden
     */
    static _au(a: ChartType): void;
    /**
     * @hidden
     */
    private static _w;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * @hidden
 */
export declare class ComboChartGroupValidator extends Base {
    static $t: Type;
    static r(a: ChartType): boolean;
    static s(a: SeriesChartTypeGroup): boolean;
    static p(a: ChartType): boolean;
    static q(a: SeriesChartTypeGroup): boolean;
    static n(a: ChartType): boolean;
    static o(a: SeriesChartTypeGroup): boolean;
    static l(a: ChartType): boolean;
    static m(a: SeriesChartTypeGroup): boolean;
    static x(a: ChartType): boolean;
    static y(a: SeriesChartTypeGroup): boolean;
    static v(a: ChartType): boolean;
    static w(a: SeriesChartTypeGroup): boolean;
    static t(a: ChartType): boolean;
    static u(a: SeriesChartTypeGroup): boolean;
    static h(a: ChartType): StackedType;
    static i(a: SeriesChartTypeGroup): StackedType;
    static b(a: ChartType, b: StackedType): ChartType;
    private static g;
    private static f;
    static j(a: ChartType, b: ChartType, c?: boolean): boolean;
    static k(a: SeriesChartTypeGroup, b: SeriesChartTypeGroup): boolean;
    static aa(a: Series, b: ChartType, c: AxisGroup, d: SeriesCollection): List$1<Series>;
    static d(a: ChartType[], b?: boolean): ComboChartGroupValidationResult;
    private static e;
    static z(a: ChartType[], b: ChartType[]): {
        ret: boolean;
        p1: ChartType[];
    };
    static ac(a: SeriesCollection, b: ChartType[], c: AxisGroup[]): {
        p1?: ChartType[];
        p2?: AxisGroup[];
    };
    static c(a: Series, b: SeriesCollection, c: ChartType, d: AxisGroup): ChartTypeValidationResult;
    static a(a: Series, b: SeriesCollection, c: AxisGroup): AxisGroupValidationResult;
}
/**
 * @hidden
 */
export declare class ChartTypeValidationResult extends Base {
    static $t: Type;
    d: Nullable$1<AxisGroup>;
    c: BaseError;
    get a(): boolean;
    b: List$1<Series>;
}
/**
 * @hidden
 */
export declare class ComboChartGroupValidationResult extends Base {
    static $t: Type;
    constructor();
    e: List$1<SeriesAxisGroup>;
    get d(): boolean;
    c: ChartType[];
    private a;
    b(a: ChartType[]): AxisGroup[];
}
/**
 * @hidden
 */
export declare class SeriesAxisGroup extends Base implements IEnumerable$1<ChartType> {
    static $t: Type;
    constructor();
    _a(a: ChartType): boolean;
    private _b;
    toString(): string;
    getEnumerator(): IEnumerator$1<ChartType>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare class ComboChartGroupCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: ComboChartGroupCollection, c: ComboChartGroup);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: ComboChartGroupCollection;
    readonly a: ComboChartGroup;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of [[ComboChartGroup]] objects for a [[WorksheetChart]]
 * <p class="body">
 * This collection is used to apply chart-specific properties to [[Series]] which
 * appear within a combo chart.
 * </p>
 * @see [[ComboChartGroup]]
 * @see [[WorksheetChart.comboChartGroups]]
 */
export declare class ComboChartGroupCollection extends ChartObject implements IEnumerable$1<ComboChartGroup> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static _w;
    private _af;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * Returns the number of items in the collection (read-only)
     */
    get count(): number;
    /**
     * Returns the [[ComboChartGroup]] instance associated with the specified
     * 'chartType' and 'axisGroup', or null if no such
     * instance exists.
     * @param chartType A [[ChartType]] constant which identifies the combo chart group.
     * @param axisGroup An [[AxisGroup]] constant which identifies the combo chart group.
     * @return A new or existing [[ComboChartGroup]] instance.
     */
    item(a: ChartType, b: AxisGroup): ComboChartGroup;
    /**
     * @hidden
     */
    _item1(a: string): ComboChartGroup;
    /**
     * Determines if the collecion can be modified (read-only)
     */
    get isReadOnly(): boolean;
    /**
     * Creates a new [[ComboChartGroup]], or returns an existing one,
     * which matches the specified 'chartType' and 'axisGroup'.
     * <p class="body">
     * This method returns an object which provides a way to set chart-specific
     * properties for a [[Series]] that is displayed within a combo chart.
     * </p>
     * <p class="body">
     * For example, to change the [[WorksheetChart.gapWidth]] property for
     * each series associated with a bar chart contained within a combo chart, set the
     * [[ComboChartGroup.gapWidth]] property of the instance returned from
     * this method.
     * </p>
     * <p class="body">
     * If a [[ComboChartGroup]] instance corresponding to the specified
     * 'chartType' and 'axisGroup' already exists,
     * that instance is returned; otherwise a new instance is created and that instance
     * is returned.
     * </p>
     * @param chartType A [[ChartType]] constant which identifies the combo chart group.
     * @param axisGroup An [[AxisGroup]] constant which identifies the combo chart group.
     * @return A new or existing [[ComboChartGroup]] instance.
     * @see [[ComboChartGroup]]
     * @see [[remove]]
     * @throws [[NotSupportedException]] The specified 'chartType' is not supported within a combo chart.
     * See documentation for the WorksheetChart.<see cref="WorksheetChart.SetComboChartSourceData(string, ChartType[], bool, CellReferenceMode?)">SetComboChartSourceData</see>
     * method for a list of supported chart types.
     */
    add(chartType: ChartType, axisGroup: AxisGroup): ComboChartGroup;
    /**
     * @hidden
     */
    private _al;
    /**
     * Clears the collection.
     */
    clear(): void;
    [Symbol.iterator](): EnumeratorWrapper<ComboChartGroup>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<ComboChartGroup>;
    /**
     * Removes the specified [[ComboChartGroup]] from this collection.
     * @param chartType A [[ChartType]] constant which identifies the combo chart group.
     * @param axisGroup An [[AxisGroup]] constant which identifies the combo chart group.
     * @return True if the item was removed, otherwise false.
     */
    remove(chartType: ChartType, axisGroup: AxisGroup): boolean;
    /**
     * Removes the specified [[ComboChartGroup]] from this collection.
     * @param comboChartGroup The [[ComboChartGroup]] instance to be removed.
     * @return True if the item was removed, otherwise false.
     */
    remove(comboChartGroup: ComboChartGroup): boolean;
    /**
     * @hidden
     */
    _remove1(a: ComboChartGroup): boolean;
    /**
     * @hidden
     */
    _remove(a: ChartType, b: AxisGroup): boolean;
    /**
     * @hidden
     */
    _am(a: ComboChartGroup): void;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    private static _an;
    /**
     * @hidden
     */
    private static _ao;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
}
/**
 * Abstract base class for the fill of a shape.
 * @see [[WorksheetShape.fill]]
 * @see [[ShapeFillSolid]]
 */
export declare abstract class ShapeFill extends Base {
    static $t: Type;
    /**
     * Creates an instance to describe a solid fill outline.
     * @param solidColor The color of the fill to create.
     * @return A [[ShapeFillSolid]] instance with the specified color.
     */
    static fromColor(solidColor: string | Color): ShapeFill;
    /**
     * @hidden
     */
    static _fromColor$i(a: Color): ShapeFill;
    /**
     * Creates an instance to describe a solid fill outline.
     * @param solidColorInfo The [[WorkbookColorInfo]] describing the color of the fill to create.
     * @return A [[ShapeFillSolid]] instance with the specified color.
     */
    static fromColorInfo(solidColorInfo: WorkbookColorInfo): ShapeFill;
    /**
     * @hidden
     */
    abstract _d(a: WorksheetShape): void;
    /**
     * @hidden
     */
    abstract _c<TArg, TResult>($tArg: Type, $tResult: Type, a: IShapeFillVisitor$2<TArg, TResult>, b: TArg): TResult;
}
/**
 * Abstract base class for the outline of a shape.
 * @see [[WorksheetShape.outline]]
 * @see [[ShapeOutlineSolid]]
 */
export declare abstract class ShapeOutline extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    abstract _c<TArg, TResult>($tArg: Type, $tResult: Type, a: IShapeOutlineVisitor$2<TArg, TResult>, b: TArg): TResult;
    /**
     * Creates an instance to describe a solid color outline.
     * @param solidColor The color of the outline to create.
     * @return A [[ShapeOutlineSolid]] instance with the specified color.
     */
    static fromColor(solidColor: string | Color): ShapeOutline;
    /**
     * @hidden
     */
    static _fromColor$i(a: Color): ShapeOutline;
    /**
     * Creates an instance to describe a solid color outline.
     * @param solidColorInfo The [[WorkbookColorInfo]] describing the color of the outline to create.
     * @return A [[ShapeOutlineSolid]] instance with the specified color.
     */
    static fromColorInfo(solidColorInfo: WorkbookColorInfo): ShapeOutline;
    /**
     * @hidden
     */
    static _g(a: WorksheetShape): number;
    /**
     * @hidden
     */
    abstract _h(a: WorksheetShape): void;
    /**
     * @hidden
     */
    _e: any;
    /**
     * @hidden
     */
    _f: any;
    /**
     * @hidden
     */
    _d: number;
}
/**
 * Abstract base class for all shapes (atomic or compound) in a worksheet.
 * <p class="body">
 * Atomic shapes are singular shape entities, such as an image, a polygon, or text.
 * Compound shapes are groupings of shapes, and are represented by [[WorksheetShapeGroup]]
 * instances.
 * </p>
 * <p class="body">
 * Currently, not all shape information is customizable (such as shape rotation).  However,
 * for round-tripping purposes, when a shape is loaded from an Excel file, this
 * information in maintained with the shape.  See [[clearUnknownData]] for more
 * information about unsupported data.
 * </p>
 */
export declare abstract class WorksheetShape extends Base implements IRegionAddress, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _bo;
    /**
     * @hidden
     */
    private static readonly _bq;
    /**
     * @hidden
     */
    private static readonly _br;
    /**
     * @hidden
     */
    private static readonly _bs;
    /**
     * @hidden
     */
    private static readonly _bu;
    /**
     * @hidden
     */
    private static readonly _bv;
    /**
     * @hidden
     */
    private static readonly _bw;
    /**
     * @hidden
     */
    private static readonly _bx;
    /**
     * @hidden
     */
    private static readonly _bp;
    /**
     * @hidden
     */
    private static readonly _bt;
    /**
     * @hidden
     */
    static readonly _cf: number;
    /**
     * @hidden
     */
    static readonly _cg: number;
    /**
     * @hidden
     */
    static readonly _ch: number;
    /**
     * @hidden
     */
    static readonly _ci: number;
    /**
     * @hidden
     */
    static readonly _ck: number;
    /**
     * @hidden
     */
    static readonly _cj: number;
    /**
     * @hidden
     */
    static readonly _cl: number;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    private static _bf;
    /**
     * @hidden
     */
    private static _bg;
    private _an;
    private _u;
    private _ac;
    private _di;
    private _dp;
    private _o;
    private _w;
    private _ag;
    private _ai;
    private _ae;
    private _dk;
    private _b2;
    private _bd;
    private _bh;
    private _bj;
    private _bl;
    private _g;
    private _b5;
    private _cb;
    private _cd;
    private _e;
    private _cm;
    private _at;
    private _av;
    private _i;
    private _l;
    private _ba;
    static staticInit(): void;
    constructor(a: number);
    constructor(a: number, b: boolean);
    constructor(a: number, b: WorksheetShape);
    constructor(a: number, ..._rest: any[]);
    /**
     * Clears the cached unknown shape data which was read in from a parsed excel file.
     * <p class="body">
     * This method will only be needed until all shape information is supported and customizable.
     * After all shape data can be controlled, this method will become obsolete. Currently, all
     * unsupported data will be stored with the shape for round-tripping purposes.  For example,
     * if an Excel file with complex and unsupported shapes is loaded into a
     * [[Workbook]] instance, some cell values are changed, and it is saved to
     * the same file, the complex shapes will still exist in the workbook.  However, if a
     * loaded shape needs to be modified before it is saved back, this method
     * allows for that unsupported data to be removed while all supported data is maintained.
     * </p>
     * <p class="note">
     * <B>Note:</B> This method only clears unsupported data.  In future versions of the product,
     * as more shape data is supported, this method will have different effects on the shape,
     * until eventually all data is supported and this method will have no effect on the shape.
     * </p>
     * @throws [[InvalidOperationException]] This method is called on an [[UnknownShape]] instance.
     */
    clearUnknownData(): void;
    /**
     * Creates a shape which is predefined in Microsoft Excel.
     * @param shapeType The type of shape to create.
     * @throws [[InvalidEnumArgumentException]] 'shapeType' is not defined in the [[PredefinedShapeType]] enumeration.
     * @return A [[WorksheetShape]]-derived instance representing the predefined shape.
     */
    static createPredefinedShape(shapeType: PredefinedShapeType): WorksheetShape;
    /**
     * @hidden
     */
    static _al(a: PredefinedShapeType, b: boolean): WorksheetShape;
    /**
     * Gets the bounds of the shape in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before or within the shape are resized, these bounds will no longer reflect the
     * position of the shape.
     * </p>
     * @throws [[InvalidOperationException]] The [[topLeftCornerCell]] or [[bottomRightCornerCell]] are null, in which case the shape has no bounds.
     * @return The bounds of the shape on its worksheet.
     * @see [[setBoundsInTwips]]
     */
    getBoundsInTwips(): IgRect;
    /**
     * Gets the bounds of the shape in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before or within the shape are resized, these bounds will no longer reflect the
     * position of the shape.
     * </p>
     * @param options The options to use when getting the bounds of the shape.
     * @throws [[InvalidOperationException]] The [[topLeftCornerCell]] or [[bottomRightCornerCell]] are null, in which case the shape has no bounds.
     * @return The bounds of the shape on its worksheet.
     * @see [[setBoundsInTwips]]
     */
    getBoundsInTwips(options: PositioningOptions): IgRect;
    /**
     * @hidden
     */
    _getBoundsInTwips(): Rect;
    /**
     * @hidden
     */
    _getBoundsInTwips1(a: PositioningOptions): Rect;
    /**
     * Sets the bounds of the shape in twips (1/20th of a point).
     * <p class="body">
     * The shape will only be positioned at the specified bounds while the worksheet remains in the current configuration.
     * Depending on the [[positioningMode]] of the shape, it may change bounds if any rows or columns before or within the shape are resized.
     * </p>
     * @throws [[ArgumentNullException]] 'sheet' is null.
     * @param sheet The worksheet on which the shape should be placed.
     * @param bounds The new bounds where the shape should be placed.
     */
    setBoundsInTwips(sheet: Sheet, bounds: IgRect): void;
    /**
     * Sets the bounds of the shape in twips (1/20th of a point).
     * <p class="body">
     * The shape will only be positioned at the specified bounds while the worksheet remains in the current configuration.
     * Depending on the [[positioningMode]] of the shape, it may change bounds if any rows or columns before or within the shape are resized.
     * </p>
     * @throws [[ArgumentNullException]] s
     *
     * 'sheet' is null.
     * @param sheet The sheet on which the shape should be placed.
     * @param bounds The new bounds where the shape should be placed.
     * @param options The options to use when setting the bounds of the shape.
     */
    setBoundsInTwips(sheet: Sheet, bounds: IgRect, options: PositioningOptions): void;
    /**
     * @hidden
     */
    _setBoundsInTwips(a: Sheet, b: Rect): void;
    /**
     * @hidden
     */
    _setBoundsInTwips1(a: Sheet, b: Rect, c: PositioningOptions): void;
    /**
     * @hidden
     */
    private static _c9;
    /**
     * @hidden
     */
    private _c8;
    /**
     * @hidden
     */
    _dd(a: WorksheetShapePosition): void;
    /**
     * @hidden
     */
    abstract _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b: TArg): TResult;
    /**
     * @hidden
     */
    static _by(a: ShapeType): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    static _bz(a: ST_ShapeType): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    static _ds(a: Sheet, b: WorksheetCellAddress, c: Point, d: WorksheetCellAddress, e: Point): Rect;
    /**
     * @hidden
     */
    static _dt(a: Sheet, b: WorksheetCellAddress, c: Point, d: WorksheetCellAddress, e: Point, f: PositioningOptions): Rect;
    /**
     * @hidden
     */
    static _du(a: Sheet, b: number, c: number, d: Point, e: number, f: number, g: Point, h: PositioningOptions): Rect;
    /**
     * @hidden
     */
    _cr(): void;
    /**
     * @hidden
     */
    _cs(a: WorksheetShape): void;
    /**
     * @hidden
     */
    _ct(a: WorksheetShapeCollection): void;
    /**
     * @hidden
     */
    _cu(a: WorksheetElementResizeContext): void;
    /**
     * @hidden
     */
    _a9(a: CellShiftOperation, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _cv(): void;
    /**
     * @hidden
     */
    _cw(a: Sheet, b: WorksheetCellAddress, c: Point, d: WorksheetCellAddress, e: Point, f: boolean): void;
    /**
     * @hidden
     */
    _cy(): void;
    /**
     * @hidden
     */
    _cz(): void;
    /**
     * @hidden
     */
    _c0(a: Sheet): void;
    /**
     * @hidden
     */
    _c2(a: WorkbookColorInfo, b: PropertyType, c: PropertyType): void;
    /**
     * @hidden
     */
    _c3(): void;
    /**
     * @hidden
     */
    _c4(a: WorksheetCell, b: WorksheetCellAddress, c: WorksheetCellAddress): void;
    /**
     * @hidden
     */
    _c5(a: Worksheet, b: WorksheetCellAddress, c: Point, d: WorksheetCellAddress, e: Point, f?: boolean): void;
    /**
     * @hidden
     */
    _da(a: ShapePositioningMode, b: boolean): void;
    /**
     * @hidden
     */
    _r(a: CellShiftOperation, b: boolean, c: WorksheetRegionAddress): {
        ret: ShiftAddressResult;
        p2?: WorksheetRegionAddress;
    };
    /**
     * @hidden
     */
    _s(a: CellShiftOperation, b: ICellShiftOperationOverride, c: Dictionary$2<WorksheetShape, Rect>): ShiftAddressResult;
    /**
     * @hidden
     */
    _t(a: CellShiftOperation, b: Rect, c: boolean, d: WorksheetCellAddress, e: Point, f: WorksheetCellAddress, g: Point): {
        ret: ShiftAddressResult;
        p3: WorksheetCellAddress;
        p4: Point;
        p5: WorksheetCellAddress;
        p6: Point;
    };
    /**
     * @hidden
     */
    private static _db;
    /**
     * @hidden
     */
    _dc(): void;
    /**
     * @hidden
     */
    _dg(): void;
    /**
     * @hidden
     */
    _dh(a: ShapePositioningMode): void;
    /**
     * @hidden
     */
    private static _co;
    /**
     * @hidden
     */
    private _dm;
    /**
     * @hidden
     */
    private _bn;
    /**
     * @hidden
     */
    private _dn;
    /**
     * @hidden
     */
    private _cp;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _cx;
    /**
     * @hidden
     */
    static _c1(a: ChangeInfo[], b: ExcelChangeAction): void;
    /**
     * @hidden
     */
    _de(a: (arg1: WorksheetShape) => Rect): void;
    /**
     * @hidden
     */
    private _df;
    /**
     * @hidden
     */
    private _a6;
    /**
     * Gets or sets the fill to use in the background of the shape.
     * <p class="note">
     * <b>Note:</b> some shapes, such as connectors or groups, cannot have a fill set. For these shapes, the value on this property
     * will be ignored and lost when the workbook is saved.
     * </p>
     * A [[ShapeFill]]-derived instance describing the fill of the shape, or null for no fill.
     * @see [[ShapeFill.fromColor]]
     * @see [[ShapeFillSolid]]
     * @see [[outline]]
     */
    get fill(): ShapeFill;
    set fill(a: ShapeFill);
    /**
     * @hidden
     */
    get _k(): ShapeFill;
    /**
     * Gets or sets the cell where the bottom-right corner of the shape resides.
     * <p class="body">
     * This anchor cell, along with the [[topLeftCornerCell]], determines where the shape will be
     * positioned on the worksheet.  In addition, the [[bottomRightCornerPosition]] and
     * [[topLeftCornerPosition]] properties allow for finer control of the shape's position.
     * </p>
     * The cell where the bottom-right corner of the shape resides.
     * @throws [[ArgumentException]] The value assigned is a cell whose worksheet is not the same as this shape's worksheet.
     * @throws [[ArgumentNullException]] The value assigned is null and this shape already exists on a worksheet or group.
     * @see [[bottomRightCornerPosition]]
     * @see [[topLeftCornerCell]]
     * @see [[topLeftCornerPosition]]
     */
    get bottomRightCornerCell(): WorksheetCell;
    set bottomRightCornerCell(a: WorksheetCell);
    /**
     * Gets or sets the position in the [[bottomRightCornerCell]] of the shape's bottom-right corner,
     * expressed in percentages.
     * <p class="body">
     * These percentages are expressed as distance across the associated dimension of the cell, starting at the
     * top-left corner of the cell.  For example, (0.0, 0.0) represents the top-left corner of the cell, whereas
     * (100.0, 100.0) represents the bottom-right corner of the cell.  (50.0, 10.0) would represent the location
     * in the cell which is centered horizontally, and a tenth of the way down from the top.
     * </p>
     * The position in the bottom-right corner cell of the shape's bottom-right corner.
     * @throws [[ArgumentOutOfRangeException]] Either coordinate of the value assigned is outside the range of 0.0 to 100.0.
     * @see [[bottomRightCornerCell]]
     * @see [[topLeftCornerCell]]
     * @see [[topLeftCornerPosition]]
     */
    get bottomRightCornerPosition(): IgPoint;
    set bottomRightCornerPosition(a: IgPoint);
    /**
     * @hidden
     */
    get _bottomRightCornerPosition$i(): Point;
    /**
     * @hidden
     */
    set _bottomRightCornerPosition$i(a: Point);
    /**
     * Gets or sets the value which indicates whether the shape is flipped horizontally along the vertical center line.
     * @throws [[InvalidOperationException]] The value is set to True and this shape doesn't allow flipping or rotating, such as a [[WorksheetChart]].
     */
    get flippedHorizontally(): boolean;
    set flippedHorizontally(a: boolean);
    /**
     * Gets or sets the value which indicates whether the shape is flipped vertically along the horizontal center line.
     * @throws [[InvalidOperationException]] The value is set to True and this shape doesn't allow flipping or rotating, such as a [[WorksheetChart]].
     */
    get flippedVertically(): boolean;
    set flippedVertically(a: boolean);
    /**
     * Gets or sets the outline to use for the shape.
     * <p class="note">
     * <b>Note:</b> some shapes, such as comments or groups, cannot have a outline set. For these shapes, the value on this property
     * will be ignored and lost when the workbook is saved.
     * </p>
     * A [[ShapeOutline]]-derived instance describing the outline of the shape, or null for no outline.
     * @see [[ShapeOutline.fromColorInfo]]
     * @see [[ShapeOutlineSolid]]
     * @see [[fill]]
     */
    get outline(): ShapeOutline;
    set outline(a: ShapeOutline);
    /**
     * @hidden
     */
    get _n(): ShapeOutline;
    /**
     * Gets or sets the way shapes will be repositioned in excel when cells before or within the shape are resized.
     * <p class="body">
     * This value will not be saved for shapes contained in a [[WorksheetShapeGroup]], which inherit their
     * positioning mode from their parent group.
     * </p>
     * The way shapes will be repositioned in excel when cells before or within the shape are resized.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[ShapePositioningMode]] enumeration.
     */
    get positioningMode(): ShapePositioningMode;
    set positioningMode(a: ShapePositioningMode);
    /**
     * @hidden
     */
    get _q(): ShapePositioningMode;
    /**
     * @hidden
     */
    get _b6(): number;
    /**
     * @hidden
     */
    set _b6(a: number);
    /**
     * Gets or sets the cell where the top-left corner of the shape resides.
     * <p class="body">
     * This anchor cell, along with the [[bottomRightCornerCell]], determines where the shape will be
     * positioned on the worksheet.  In addition, the [[bottomRightCornerPosition]] and
     * [[topLeftCornerPosition]] properties allow for finer control of the shape's position.
     * </p>
     * The cell where the top-left corner of the shape resides.
     * @throws [[ArgumentException]] The value assigned is a cell whose worksheet is not the same as this shape's worksheet.
     * @throws [[ArgumentNullException]] The value assigned is null and this shape already exists on a worksheet or group.
     * @see [[bottomRightCornerCell]]
     * @see [[bottomRightCornerPosition]]
     * @see [[topLeftCornerPosition]]
     */
    get topLeftCornerCell(): WorksheetCell;
    set topLeftCornerCell(a: WorksheetCell);
    /**
     * Gets or sets the position in the [[topLeftCornerCell]] of the shape's top-left corner,
     * expressed in percentages.
     * <p class="body">
     * These percentages are expressed as distance across the associated dimension of the cell, starting at the
     * top-left corner of the cell.  For example, (0.0, 0.0) represents the top-left corner of the cell, whereas
     * (100.0, 100.0) represents the bottom-right corner of the cell.  (50.0, 10.0) would represent the location
     * in the cell which is centered horizontally, and a tenth of the way down from the top.
     * </p>
     * The position in the top-left corner cell of the shape's top-left corner.
     * @throws [[ArgumentOutOfRangeException]] Either coordinate of the value assigned is outside the range of 0.0 to 100.0.
     * @see [[bottomRightCornerCell]]
     * @see [[bottomRightCornerPosition]]
     * @see [[topLeftCornerCell]]
     */
    get topLeftCornerPosition(): IgPoint;
    set topLeftCornerPosition(a: IgPoint);
    /**
     * @hidden
     */
    get _topLeftCornerPosition$i(): Point;
    /**
     * @hidden
     */
    set _topLeftCornerPosition$i(a: Point);
    /**
     * Gets or sets the value indicating whether the shape is visible on the worksheet.
     * The value indicating whether the shape is visible on the worksheet.
     */
    get visible(): boolean;
    set visible(a: boolean);
    /**
     * Gets the worksheet on which the shape resides.
     * The worksheet on which the shape resides.
     */
    protected get_sheet(): Sheet;
    /**
     * Gets the worksheet on which the shape resides.
     * The worksheet on which the shape resides.
     */
    get sheet(): Sheet;
    /**
     * Gets the worksheet on which the shape resides.
     * The worksheet on which the shape resides.
     */
    get worksheet(): Worksheet;
    /**
     * @hidden
     */
    get _ad(): WorksheetCellAddress;
    /**
     * @hidden
     */
    get _af(): WorksheetCellAddress;
    /**
     * @hidden
     */
    get _v(): Worksheet;
    /**
     * @hidden
     */
    get _f(): ICalloutRule;
    /**
     * @hidden
     */
    set _f(a: ICalloutRule);
    /**
     * @hidden
     */
    protected get__aq(): boolean;
    /**
     * @hidden
     */
    get _aq(): boolean;
    /**
     * @hidden
     */
    protected get__ar(): boolean;
    /**
     * @hidden
     */
    get _ar(): boolean;
    /**
     * @hidden
     */
    protected get__as(): boolean;
    /**
     * @hidden
     */
    get _as(): boolean;
    /**
     * @hidden
     */
    get _bi(): List$1<PropertyTableBase_PropertyValue>;
    /**
     * @hidden
     */
    set _bi(a: List$1<PropertyTableBase_PropertyValue>);
    /**
     * @hidden
     */
    get _a1(): boolean;
    /**
     * @hidden
     */
    get _bk(): List$1<PropertyTableBase_PropertyValue>;
    /**
     * @hidden
     */
    set _bk(a: List$1<PropertyTableBase_PropertyValue>);
    /**
     * @hidden
     */
    get _a2(): boolean;
    /**
     * @hidden
     */
    get _bm(): List$1<PropertyTableBase_PropertyValue>;
    /**
     * @hidden
     */
    set _bm(a: List$1<PropertyTableBase_PropertyValue>);
    /**
     * @hidden
     */
    get _a3(): boolean;
    /**
     * @hidden
     */
    get _ao(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    _b3: any;
    /**
     * @hidden
     */
    _ax: boolean;
    /**
     * @hidden
     */
    _ay: boolean;
    /**
     * @hidden
     */
    _aa: WorksheetCell;
    /**
     * @hidden
     */
    _az: boolean;
    /**
     * @hidden
     */
    _a0: boolean;
    /**
     * @hidden
     */
    protected get__a4(): boolean;
    /**
     * @hidden
     */
    get _a4(): boolean;
    /**
     * @hidden
     */
    protected get__a5(): boolean;
    /**
     * @hidden
     */
    get _a5(): boolean;
    /**
     * @hidden
     */
    get _a7(): boolean;
    /**
     * @hidden
     */
    protected get__a8(): boolean;
    /**
     * @hidden
     */
    get _a8(): boolean;
    /**
     * @hidden
     */
    _b7: string;
    /**
     * @hidden
     */
    _b8: string;
    /**
     * @hidden
     */
    get _h(): Obj;
    /**
     * @hidden
     */
    set _h(a: Obj);
    /**
     * @hidden
     */
    get _d(): IWorksheetShapeOwner;
    /**
     * @hidden
     */
    get _bb(): boolean;
    /**
     * @hidden
     */
    protected get__cn(): number;
    /**
     * @hidden
     */
    protected set__cn(a: number): void;
    /**
     * @hidden
     */
    get _cn(): number;
    /**
     * @hidden
     */
    set _cn(a: number);
    /**
     * @hidden
     */
    protected get__ap(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    get _ap(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    _b4: any;
    /**
     * @hidden
     */
    _b9: string;
    /**
     * @hidden
     */
    _ca: string;
    /**
     * @hidden
     */
    get _ah(): WorksheetCellAddress;
    /**
     * @hidden
     */
    get _aj(): WorksheetCellAddress;
    /**
     * @hidden
     */
    get _x(): Worksheet;
    /**
     * @hidden
     */
    get _cc(): number;
    /**
     * @hidden
     */
    set _cc(a: number);
    /**
     * @hidden
     */
    get _ce(): number;
    /**
     * @hidden
     */
    set _ce(a: number);
    /**
     * @hidden
     */
    abstract get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    abstract get _b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _bc(): boolean;
    /**
     * @hidden
     */
    set _bc(a: boolean);
    /**
     * @hidden
     */
    containsColumns(firstColumn: number, lastColumn: number): boolean;
    /**
     * @hidden
     */
    intersectsWithColumns(firstColumn: number, lastColumn: number): boolean;
    /**
     * @hidden
     */
    containsRows(firstRow: number, lastRow: number): boolean;
    /**
     * @hidden
     */
    intersectsWithRows(firstRow: number, lastRow: number): boolean;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get source(): any;
}
/**
 * Represents a group of shapes in a worksheet.  This group is also a shape which can be
 * positioned and contained within another group or on a worksheet.
 */
export declare abstract class WorksheetShapeGroupBase extends WorksheetShape implements IWorksheetShapeOwner {
    static $t: Type;
    private _dw;
    private _dy;
    private _d1;
    private _d0;
    constructor(a: number);
    constructor(a: number, b: boolean);
    constructor(a: number, b: WorksheetShape);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__ar(): boolean;
    /**
     * @hidden
     */
    protected get__as(): boolean;
    /**
     * @hidden
     */
    protected get__a4(): boolean;
    /**
     * @hidden
     */
    _ct(a: WorksheetShapeCollection): void;
    /**
     * @hidden
     */
    _cv(): void;
    /**
     * @hidden
     */
    _cw(a: Sheet, b: WorksheetCellAddress, c: Point, d: WorksheetCellAddress, e: Point, f: boolean): void;
    /**
     * @hidden
     */
    _cz(): void;
    /**
     * @hidden
     */
    _c0(a: Sheet): void;
    /**
     * @hidden
     */
    protected get__ap(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get areChildrenTopMost(): boolean;
    /**
     * @hidden
     */
    onChildShapeBoundsChanged(childShape: WorksheetShape, oldTopLeftCell: WorksheetCellAddress, oldBottomRightCell: WorksheetCellAddress, isNotifyOnly: boolean): void;
    /**
     * @hidden
     */
    onShapeAdded(shape: WorksheetShape): void;
    /**
     * @hidden
     */
    onShapeRemoved(shape: WorksheetShape): void;
    /**
     * @hidden
     */
    _dv(a: number, b: WorksheetShapeCollection): {
        ret: WorksheetShape;
        p1: WorksheetShapeCollection;
    };
    /**
     * @hidden
     */
    _d2(a: List$1<IEscherRecord>): void;
    /**
     * @hidden
     */
    _d3(): void;
    /**
     * @hidden
     */
    private _d4;
    /**
     * @hidden
     */
    private static _d5;
    /**
     * @hidden
     */
    private static _d6;
    /**
     * @hidden
     */
    private static _d7;
    /**
     * @hidden
     */
    private static _d8;
    /**
     * Gets the shape at the specified index in the collection.
     * The shape at the specified index.
     * @param index The zero-based index of the shape to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    shapes(index: number): WorksheetShape;
    /**
     * Gets the collection of shapes contained in the group.
     * The collection of shapes contained in the group.
     */
    shapes(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    get _shapes$i(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    get ChildShapes(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    get _dz(): boolean;
}
/**
 * @hidden
 */
export interface IFormattedStringOwner extends ISheetProvider {
    onUnformattedStringChanged(a: FormattedString): void;
    onFormattingChanged(): void;
    getFontDefaultsResolver(): IWorkbookFontDefaultsResolver;
    readonly allowDefaultValues: boolean;
    getDefaultFont(): IWorkbookFont;
}
/**
 * @hidden
 */
export declare let IFormattedStringOwner_$type: Type;
/**
 * Base class for objects which relate to the background fill of a chart element.
 */
export declare abstract class ChartFillBase extends ChartObject {
    static $t: Type;
    constructor(a: IChartObject);
}
/**
 * Represents a <see cref="ChartBorder">border</see> or
 * <see cref="ChartTickLines">tick line</see>.
 */
export declare class ChartLineBase extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    static readonly _ag: number;
    /**
     * @hidden
     */
    static readonly _ad: number;
    /**
     * @hidden
     */
    private static _w;
    private _aa;
    private _ac;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill color/gradient for the line.
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     */
    get fill(): ChartFillBase;
    set fill(a: ChartFillBase);
    /**
     * Determines the width of the line, expressed in points.
     * <p class="body">
     * A point is a graphical unit equal to 1/72", i.e., there are 72 points in one inch.
     * </p>
     */
    get widthInPoints(): number;
    set widthInPoints(a: number);
    /**
     * @hidden
     */
    protected get__ai(): Nullable$1<LineStyle>;
    /**
     * @hidden
     */
    get _ai(): Nullable$1<LineStyle>;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    _aj(a: number): void;
}
/**
 * Represents the border of a chart element.
 * <p class="body">
 * The color of the border is controlled by the [[ChartLineBase.fill]] property.
 * </p>
 * <p class="body">
 * The width of the border lines are controlled by the [[ChartLineBase.widthInPoints]] property.
 * </p>
 */
export declare class ChartBorder extends ChartLineBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _aq;
    /**
     * @hidden
     */
    private static readonly _ar;
    private _an;
    static staticInit(): void;
    constructor();
    constructor(owner: IChartObject);
    constructor(..._rest: any[]);
    /**
     * Returns or sets the line style for the border, i.e.,
     * solid, dashed, dotted, etc.
     */
    get lineStyle(): BorderLineStyle;
    set lineStyle(a: BorderLineStyle);
    /**
     * @hidden
     */
    protected get__ai(): Nullable$1<LineStyle>;
    /**
     * @hidden
     */
    get _ap(): ChartFillBase;
    /**
     * @hidden
     */
    private static _ak;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _am;
    /**
     * @hidden
     */
    private static _al;
}
/**
 * @hidden
 */
export declare class Formula_TokensReplacedChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: Formula, c: FormulaToken[], d: number[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly c;
    private readonly b;
    private readonly a;
    private readonly d;
    e(): void;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Represents a formula for a cell or group of cells.
 * <p class="body">
 * Formulas provide a way to show dynamic values in a cell. The value could be based any number of factors, such as
 * the values of other cells and the time of day.  Those alternate cells can even exist in different workbook files
 * on the user's machine or on the internet.
 * </p>
 * <p class="body">
 * See Microsoft Excel help for more information on formulas.
 * </p>
 * <p class="body">
 * Use one of the Parse or TryParse overloads to create a new formula.
 * </p>
 */
export declare abstract class Formula extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _be: number;
    /**
     * @hidden
     */
    static readonly _bd: number;
    /**
     * @hidden
     */
    private static readonly _bf;
    /**
     * @hidden
     */
    private static readonly _bc;
    /**
     * @hidden
     */
    private static _a;
    private _a8;
    private _q;
    private _a9;
    /**
     * @hidden
     */
    _d: FormulaToken[];
    private _r;
    static staticInit(): void;
    constructor(a: number, b: number, c: FormulaType);
    constructor(a: number, b: ArrayFormula);
    constructor(a: number, b: WorksheetDataTable);
    constructor(a: number, b: Formula, c?: boolean);
    constructor(a: number, ..._rest: any[]);
    /**
     * Converts the formula to a string representation, similar to the string with which it was created.
     * This uses the [[CellReferenceMode]] with which the formula was created to create cell
     * reference strings.
     * @return The string representing the formula.
     */
    toString(): string;
    /**
     * Converts the formula to a string representation, similar to the string with which it was created.
     * @param cellReferenceMode The cell reference mode used to create cell reference strings.
     * @return The string representing the formula.
     */
    toString(cellReferenceMode: CellReferenceMode): string;
    /**
     * Converts the formula to a string representation, similar to the string with which it was created.
     * @param cellReferenceMode The cell reference mode used to create cell reference strings.
     * @param culture The culture used to generate the formula string.
     * @return The string representing the formula.
     */
    toString(cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): string;
    /**
     * @hidden
     */
    _toString(): string;
    /**
     * Applies the formula to all specified regions of cells.
     * <p class="body">
     * This method, or one of the other ApplyTo overrides must be used to set the value of a cell to a formula.
     * </p>
     * <p class="body">
     * After this method returns, the [[WorksheetCell.formula]] of all cells in all specified regions will
     * return the formula.
     * </p>
     * @param regions The regions of cells to apply the formula to.
     * @throws [[ArgumentNullException]] 'regions' is null.
     * @throws [[ArgumentException]] 'regions' has a length of 0.
     * @throws [[ArgumentException]] Not all regions specified are from the same worksheet.
     * @throws [[InvalidOperationException]] One or more regions specified contain array formulas or data tables which extend outside the region.
     * @see [[applyTo]]
     * @see [[applyTo]]
     * @see [[WorksheetCell.applyFormula]]
     * @see [[WorksheetRegion.applyFormula]]
     */
    applyTo(regions: WorksheetRegion[]): void;
    /**
     * Applies the formula to the specified cell.
     * <p class="body">
     * This method, or one of the other ApplyTo overrides must be used to set the value of a cell to a formula.
     * </p>
     * <p class="body">
     * After this method returns, the [[WorksheetCell.formula]] of the specified cell will return the formula.
     * </p>
     * @param cell The cell to apply the formula to.
     * @throws [[ArgumentNullException]] 'cell' is null.
     * @throws [[InvalidOperationException]] 'cell' is part of an array formula or data table which is not confined to just the cell.
     * @see [[WorksheetCell.value]]
     * @see [[applyTo]]
     * @see [[applyTo]]
     * @see [[WorksheetCell.applyFormula]]
     * @see [[WorksheetRegion.applyFormula]]
     * @see [[WorksheetRegion.applyArrayFormula]]
     */
    applyTo(cell: WorksheetCell): void;
    /**
     * Applies the formula to the specified region of cells.
     * <p class="body">
     * This method, or one of the other ApplyTo overrides must be used to set the value of a cell to a formula.
     * </p>
     * <p class="body">
     * After this method returns, the [[WorksheetCell.formula]] of all cells in the specified region will
     * return the formula.
     * </p>
     * @param region The region of cells to apply the formula to.
     * @throws [[ArgumentNullException]] 'region' is null.
     * @throws [[InvalidOperationException]] 'region' contains an array formula or data table which extends outside the region.
     * @see [[applyTo]]
     * @see [[applyTo]]
     * @see [[WorksheetCell.applyFormula]]
     * @see [[WorksheetRegion.applyFormula]]
     * @see [[WorksheetRegion.applyArrayFormula]]
     */
    applyTo(region: WorksheetRegion): void;
    /**
     * @hidden
     */
    _applyTo2(a: WorksheetCell): void;
    /**
     * @hidden
     */
    _bp(a: WorksheetRow, b: number, c?: ApplyFormulaFlags): void;
    /**
     * @hidden
     */
    _applyTo3(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    _applyTo(a: WorksheetRegion[]): void;
    /**
     * @hidden
     */
    _toString1(a: CellReferenceMode): string;
    /**
     * @hidden
     */
    _toString2(a: CellReferenceMode, b: CultureInfo): string;
    /**
     * @hidden
     */
    _bq(a: WorksheetRow, b: number, c: WorksheetRow, d: number, e?: ApplyFormulaFlags): void;
    /**
     * @hidden
     */
    _bm(a: WorksheetRegion[], b: WorksheetRow, c: number, d?: ApplyFormulaFlags): void;
    /**
     * @hidden
     */
    _br(a: WorksheetRow, b: number, c: WorksheetCellBlock): void;
    /**
     * @hidden
     */
    _ad(a: Workbook, b: WorksheetRow, c: number, d: Point): boolean;
    /**
     * @hidden
     */
    abstract _g(): Formula;
    /**
     * @hidden
     */
    _b6(a: Workbook): void;
    /**
     * @hidden
     */
    _b5(a: FormulaContext): void;
    /**
     * @hidden
     */
    protected get__i(): Formula;
    /**
     * @hidden
     */
    get _i(): Formula;
    /**
     * @hidden
     */
    _bs(a: Workbook, b: WorksheetTable): void;
    /**
     * @hidden
     */
    _bt(a: Workbook): void;
    /**
     * @hidden
     */
    static _u(a: Formula, b: WorksheetCell): SingleTargetFormula;
    /**
     * @hidden
     */
    _bu(): void;
    /**
     * @hidden
     */
    _ae(): boolean;
    /**
     * @hidden
     */
    _af(): boolean;
    /**
     * @hidden
     */
    _c(a: Workbook, b: Worksheet): WorksheetRegionAddress[];
    /**
     * @hidden
     */
    _bv(a: Worksheet, b: WorkbookReferenceBase, c: Worksheet, d: Nullable$1<boolean>, e: (arg1: string) => string, f: (arg1: NamedReferenceBase, arg2: (arg1: Formula) => void) => NamedReferenceBase): void;
    /**
     * @hidden
     */
    _ao(a: Formula): boolean;
    /**
     * @hidden
     */
    _ar(a: Workbook, b: Worksheet, c: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _bw(a: Workbook, b: WorksheetRow, c: number, d: Point): void;
    /**
     * @hidden
     */
    _av(a: Sheet, b: CellShiftOperation, c: ReferenceShiftType): boolean;
    /**
     * @hidden
     */
    _bx(a: Workbook, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    _by(a: NamedReferenceBase): void;
    /**
     * @hidden
     */
    _b0(): void;
    /**
     * @hidden
     */
    _aw(a: WorksheetTable, b: List$1<WorksheetTableColumn>): boolean;
    /**
     * @hidden
     */
    _bz(a: WorksheetTable, b: List$1<KeyValuePair$2<WorksheetTableColumn, string>>): void;
    /**
     * @hidden
     */
    _b2(a: FormulaToken[], b: number[]): void;
    /**
     * @hidden
     */
    _b3(a: Worksheet, b: number): void;
    /**
     * @hidden
     */
    _b4(a: Worksheet, b: number): void;
    /**
     * @hidden
     */
    _b9(a: FormulaToken[]): void;
    /**
     * @hidden
     */
    _v(a: number, b: number, c: WorkbookFormat, d: boolean): SingleTargetFormula;
    /**
     * @hidden
     */
    _w(a: number, b: number, c: WorkbookFormat): SingleTargetFormula;
    /**
     * @hidden
     */
    _x(a: number, b: number, c: WorkbookFormat): SingleTargetFormula;
    /**
     * @hidden
     */
    _ca(a: Workbook, b: FormatLimitErrors, c: WorkbookFormat, d: CellReferenceMode, e: boolean, f?: WorksheetRow, g?: number): void;
    /**
     * @hidden
     */
    _cb(): void;
    /**
     * @hidden
     */
    static _h(a: CellReferenceMode, b: FormulaType): Formula;
    /**
     * Determines whether two [[Formula]] instances are equal using the specified cell reference mode.
     * This essentially performs a case-insensitive string comparison, ignoring the white space in the formula.
     * @param formulaA The first Formula to compare.
     * @param formulaB The second Formula to compare.
     * @param cellReferenceMode The cell reference mode to use when comparing the two formulas.
     * @return True if the formulas are both null or both equivalent; False otherwise.
     */
    static areEqual(formulaA: Formula, formulaB: Formula, cellReferenceMode: CellReferenceMode): boolean;
    /**
     * @hidden
     */
    static _p(a: string, b: Workbook, c?: Nullable$1<CellReferenceMode>): Formula;
    /**
     * Parses the specified formula value and returns the formula which was created from it.
     * @param value The string which defines the formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return A [[Formula]] instance which represents the formula specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode): Formula;
    /**
     * Parses the specified formula value and returns the formula which was created from it.
     * @param value The string which defines the formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @param fileFormat The file format to use when parsing the formula. This will be used to determine certain limits which are format dependant.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[InvalidEnumArgumentException]] 'fileFormat' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return A [[Formula]] instance which represents the formula specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode, fileFormat: WorkbookFormat): Formula;
    /**
     * Parses the specified formula value and returns the formula which was created from it.
     * @param value The string which defines the formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @param fileFormat The file format to use when parsing the formula. This will be used to determine certain limits which are format dependant.
     * @param culture The culture used to parse the formula.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[InvalidEnumArgumentException]] 'fileFormat' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return A [[Formula]] instance which represents the formula specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode, fileFormat: WorkbookFormat, culture: string | CultureInfo): Formula;
    /**
     * Parses the specified formula value and returns the formula which was created from it.
     * @param value The string which defines the formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @param culture The culture used to parse the formula.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return A [[Formula]] instance which represents the formula specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): Formula;
    /**
     * @hidden
     */
    static _parse(a: string, b: CellReferenceMode): Formula;
    /**
     * @hidden
     */
    static _parse4(a: string, b: CellReferenceMode, c: CultureInfo): Formula;
    /**
     * @hidden
     */
    static _parse2(a: string, b: CellReferenceMode, c: WorkbookFormat): Formula;
    /**
     * @hidden
     */
    static _parse3(a: string, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo): Formula;
    /**
     * @hidden
     */
    static _k(a: string, b: CellReferenceMode, c: FormulaType, d: WorkbookFormat, e: CultureInfo, f: List$1<WorkbookReferenceBase>): Formula;
    /**
     * @hidden
     */
    static _o(a: string, b: FormulaType, c: FormulaContext, d: List$1<WorkbookReferenceBase>): Formula;
    /**
     * @hidden
     */
    static _ay(a: string, b: CellReferenceMode, c: Formula): {
        ret: boolean;
        p2: Formula;
    };
    /**
     * @hidden
     */
    static _a5(a: string, b: CellReferenceMode, c: CultureInfo, d: Formula): {
        ret: boolean;
        p3: Formula;
    };
    /**
     * @hidden
     */
    static _az(a: string, b: CellReferenceMode, c: Formula, d: FormulaParseException): {
        ret: boolean;
        p2: Formula;
        p3: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _a6(a: string, b: CellReferenceMode, c: CultureInfo, d: Formula, e: FormulaParseException): {
        ret: boolean;
        p3: Formula;
        p4: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _a1(a: string, b: CellReferenceMode, c: WorkbookFormat, d: Formula): {
        ret: boolean;
        p3: Formula;
    };
    /**
     * @hidden
     */
    static _a3(a: string, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo, e: Formula): {
        ret: boolean;
        p4: Formula;
    };
    /**
     * @hidden
     */
    static _a2(a: string, b: CellReferenceMode, c: WorkbookFormat, d: Formula, e: FormulaParseException): {
        ret: boolean;
        p3: Formula;
        p4: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _a4(a: string, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo, e: Formula, f: FormulaParseException): {
        ret: boolean;
        p4: Formula;
        p5: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _a0(a: string, b: CellReferenceMode, c: FormulaType, d: WorkbookFormat, e: CultureInfo, f: List$1<WorkbookReferenceBase>, g: Formula, h: FormulaParseException): {
        ret: boolean;
        p6: Formula;
        p7: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _a7(a: string, b: FormulaType, c: FormulaContext, d: List$1<WorkbookReferenceBase>, e: Formula, f: FormulaParseException): {
        ret: boolean;
        p4: Formula;
        p5: FormulaParseException;
    };
    /**
     * @hidden
     */
    private static _f;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _ah;
    /**
     * @hidden
     */
    _au(a: FormulaTokenModifierVisitor): boolean;
    /**
     * @hidden
     */
    _b1(): void;
    /**
     * @hidden
     */
    abstract _b7(): void;
    /**
     * @hidden
     */
    private _b8;
    /**
     * @hidden
     */
    _bk(a: CellReferenceMode, b: CultureInfo): string;
    /**
     * @hidden
     */
    get _ac(): boolean;
    /**
     * @hidden
     */
    set _ac(a: boolean);
    /**
     * @hidden
     */
    get _ba(): CultureInfo;
    /**
     * @hidden
     */
    protected get__z(): WorkbookFormat;
    /**
     * @hidden
     */
    protected set__z(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    get _z(): WorkbookFormat;
    /**
     * @hidden
     */
    set _z(a: WorkbookFormat);
    /**
     * @hidden
     */
    get _ai(): boolean;
    /**
     * @hidden
     */
    set _ai(a: boolean);
    /**
     * @hidden
     */
    get _aj(): boolean;
    /**
     * @hidden
     */
    set _aj(a: boolean);
    /**
     * @hidden
     */
    get _al(): boolean;
    /**
     * @hidden
     */
    set _al(a: boolean);
    /**
     * @hidden
     */
    protected get__am(): boolean;
    /**
     * @hidden
     */
    get _am(): boolean;
    /**
     * @hidden
     */
    get _an(): boolean;
    /**
     * @hidden
     */
    set _an(a: boolean);
    /**
     * @hidden
     */
    protected get__ak(): boolean;
    /**
     * @hidden
     */
    get _ak(): boolean;
    /**
     * @hidden
     */
    protected get__ap(): boolean;
    /**
     * @hidden
     */
    get _ap(): boolean;
    /**
     * @hidden
     */
    get _aq(): boolean;
    /**
     * @hidden
     */
    get _as(): boolean;
    /**
     * @hidden
     */
    get _at(): boolean;
    /**
     * @hidden
     */
    set _at(a: boolean);
    /**
     * @hidden
     */
    abstract get _ab(): WorksheetRow;
    /**
     * @hidden
     */
    abstract get _aa(): WorksheetCellAddress;
    /**
     * @hidden
     */
    abstract get _bb(): number;
    /**
     * @hidden
     */
    get _e(): FormulaToken[];
    /**
     * @hidden
     */
    set _e(a: FormulaToken[]);
    /**
     * @hidden
     */
    get _ax(): boolean;
    /**
     * @hidden
     */
    set _ax(a: boolean);
    /**
     * @hidden
     */
    get _bg(): any;
    /**
     * @hidden
     */
    get _s(): FormulaType;
    /**
     * @hidden
     */
    protected get__y(): Workbook;
    /**
     * @hidden
     */
    get _y(): Workbook;
    /**
     * @hidden
     */
    abstract get _t(): Sheet;
}
/**
 * Interface implemented by the formula object.
 */
export interface IExcelCalcFormula {
    addDynamicReferenceI(reference: IExcelCalcReference): boolean;
    readonly dynamicReferences: IExcelCalcReferenceCollection;
    readonly formulaString: string;
    readonly hasAlwaysDirty: boolean;
    readonly baseReference: IExcelCalcReference;
    evaluate(reference: IExcelCalcReference): ExcelCalcValue;
    readonly staticReferences: IExcelCalcReferenceCollection;
}
/**
 * @hidden
 */
export declare let IExcelCalcFormula_$type: Type;
/**
 * The Primary Reference Inteface.
 */
export interface IExcelCalcReference {
    readonly absoluteName: string;
    readonly elementName: string;
    value: ExcelCalcValue;
    readonly formula: IExcelCalcFormula;
    readonly context: any;
    createReference(referenceString: string): IExcelCalcReference;
    readonly references: IExcelCalcReferenceCollection;
    containsReference(inReference: IExcelCalcReference): boolean;
    isSubsetReference(inReference: IExcelCalcReference): boolean;
    readonly isEnumerable: boolean;
    readonly normalizedAbsoluteName: string;
}
/**
 * @hidden
 */
export declare let IExcelCalcReference_$type: Type;
/**
 * @hidden
 */
export interface IExcelCalcReferenceCollectionEx extends IExcelCalcReferenceCollection, IEnumerable$1<IExcelCalcReference> {
}
/**
 * @hidden
 */
export declare let IExcelCalcReferenceCollectionEx_$type: Type;
/**
 * @hidden
 */
export declare class SingleTargetFormula extends Formula implements IExcelCalcFormula, IExcelCalcReferenceCollectionEx {
    static $t: Type;
    private _cc;
    private _ci;
    readonly _cl: List$1<IExcelCalcReference>;
    _cn: number;
    private _cm;
    private _cg;
    constructor(a: number, b: number, c: FormulaType);
    constructor(a: number, b: ArrayFormula);
    constructor(a: number, b: WorksheetDataTable);
    constructor(a: number, b: Formula, c?: boolean);
    constructor(a: number, ..._rest: any[]);
    addDynamicReferenceI(a: IExcelCalcReference): boolean;
    get baseReference(): IExcelCalcReference;
    get dynamicReferences(): IExcelCalcReferenceCollection;
    evaluate(a: IExcelCalcReference): ExcelCalcValue;
    get formulaString(): string;
    get staticReferences(): IExcelCalcReferenceCollection;
    getEnumerator(): IEnumerator$1<IExcelCalcReference>;
    getEnumeratorObject(): IEnumerator;
    _g(): Formula;
    protected get__z(): WorkbookFormat;
    protected set__z(a: WorkbookFormat): void;
    protected get__bb(): number;
    get _bb(): number;
    protected get__ab(): WorksheetRow;
    get _ab(): WorksheetRow;
    protected get__aa(): WorksheetCellAddress;
    get _aa(): WorksheetCellAddress;
    _b7(): void;
    protected get__y(): Workbook;
    protected get__t(): Sheet;
    get _t(): Sheet;
    _addDynamicReference1(a: IExcelCalcReference, b: ExcelCalcEngine, c?: boolean): boolean;
    private _co;
    _ct(a: ExcelCalcEngine): void;
    private static _cp;
    private _cu;
    evaluateCore(a: Workbook): ExcelCalcValue;
    _cf(a: Workbook, b: IExcelCalcReference, c: boolean): ExcelCalcValue;
    _cr(): number;
    private _cq;
    private _cs;
    _cv(a: Workbook): void;
    private _cw;
    private _cx;
    _cy(a: RefBase, b: Workbook, c?: boolean): void;
    get _cd(): ExcelCalcValue;
    set _cd(a: ExcelCalcValue);
    get hasAlwaysDirty(): boolean;
    protected get__ck(): boolean;
    get _ck(): boolean;
    get _ch(): RefBase;
}
/**
 * @hidden
 */
export interface IWorksheetCellOwnedValue {
    verifyNewOwner(a: WorksheetRow, b: number): void;
    readonly isOwnedByAllCellsAppliedTo: boolean;
    setOwningCell(a: WorksheetRow, b: number): void;
}
/**
 * @hidden
 */
export declare let IWorksheetCellOwnedValue_$type: Type;
/**
 * @hidden
 */
export interface IFormattedString {
    setWorkbook(a: Workbook): void;
}
/**
 * @hidden
 */
export declare let IFormattedString_$type: Type;
/**
 * @hidden
 */
export interface IFormattedItem extends IWorkbookProvider {
    readonly owner: any;
    getOwnerAt(a: number): IFormattedRunOwner;
    onFormattingChanged(): void;
}
/**
 * @hidden
 */
export declare let IFormattedItem_$type: Type;
/**
 * Represents a string with mixed formatting in a cell or cell comment.
 * <p class="body">
 * The formatting of the string is controlled in a similar fashion as it would be in Microsoft Excel. In Excel, the user
 * must select a portion of the text and set the various formatting properties of that selected text.
 * </p>
 * <p class="body">
 * With the FormattedString, a portion of the string is "selected" by calling either <see cref="GetFont(int)">GetFont(int)</see> or
 * <see cref="GetFont(int,int)">GetFont(int,int)</see>. Formatting properties are then set on the returned
 * [[FormattedStringFont]] and all characters in the font's selection range are given these properties.
 * </p>
 * <p class="body">
 * Getting the formatting properties of a [[FormattedStringFont]] will return the formatting of the first
 * character in font's selection range. This is similar to Excel, which will update the formatting interface to
 * reflect the formatting of the first character in a selection range when a cell's text is selected.
 * </p>
 */
export declare class FormattedString extends Base implements IWorksheetCellOwnedValue, IComparable$1<FormattedString>, IFormattedString, IFormattedItem, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _s;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    private static readonly _a;
    private _l;
    private _i;
    private _h;
    constructor(workbook: Workbook, element: StringElement);
    constructor(workbook: Workbook, element: StringElement, isElementInCache: boolean, addElementToCache: boolean);
    constructor(unformattedString: string);
    constructor(..._rest: any[]);
    /**
     * Determines whether the specified [[Object]] is equal to this [[FormattedString]].
     * @param obj The value to test for equality to this FormattedString.
     * @return True if the 'obj' is a FormattedString instance and it contains the same unformatted
     * string and formatting as this FormattedString; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Calculates the has code for this [[FormattedString]].
     * @return A number which can be used in hashing functions.
     */
    getHashCode(): number;
    /**
     * Returns the [[String]] that represents this [[FormattedString]].
     * This is just the unformatted string.
     * <p class="body">
     * This will return the same value as [[unformattedString]].
     * </p>
     * @return The String that represents this FormattedString.
     */
    toString(): string;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    compareTo(other: FormattedString): number;
    /**
     * @hidden
     */
    get owner(): any;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    getOwnerAt(startIndex: number): IFormattedRunOwner;
    /**
     * @hidden
     */
    onFormattingChanged(): void;
    /**
     * @hidden
     */
    setWorkbook(workbook: Workbook): void;
    /**
     * @hidden
     */
    get isOwnedByAllCellsAppliedTo(): boolean;
    /**
     * @hidden
     */
    setOwningCell(row: WorksheetRow, columnIndex: number): void;
    /**
     * @hidden
     */
    _setOwningCell(a: WorksheetRow, b: number): void;
    /**
     * @hidden
     */
    verifyNewOwner(ownerRow: WorksheetRow, ownerColumnIndex: number): void;
    /**
     * @hidden
     */
    _verifyNewOwner1(a: IFormattedStringOwner): void;
    /**
     * @hidden
     */
    _w(): void;
    /**
     * @hidden
     */
    _x(): void;
    /**
     * @hidden
     */
    private _y;
    /**
     * Creates a new [[FormattedString]] that is a copy of this one.
     * <p class="body">
     * This should be used if the same formatted string needs to be used in multiple cells.
     * The FormattedString class can only exist as the [[WorksheetCell.value]]
     * of one cell at a time. If the FormattedString is already the value of a cell, and needs
     * to be set as the value of another cell, clone the FormattedString and set the returned
     * clone as value of the cell.
     * </p>
     * <p class="body">
     * The cloned FormattedString only takes its original configuration for this instance.
     * If this instance is cloned and than changed, the clone will not be changed as well; it will
     * remain as it was when it was cloned.
     * </p>
     * @return A new FormattedString that is a copy of this one.
     */
    clone(): FormattedString;
    /**
     * @hidden
     */
    private static _aa;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    _e(): FormattedStringElement;
    /**
     * Gets the font which controls the formatting properties in the string from the specified start index to
     * the end of the string.
     * <p class="body">
     * If the start index is greater than or equal to the length of the unformatted string, no exception
     * will be thrown. It will be thrown later when one of the formatting properties of the returned
     * [[FormattedStringFont]] is set.
     * </p>
     * @param startIndex The index of the first character the returned font controls.
     * @throws [[ArgumentOutOfRangeException]] 'startIndex' is less than zero.
     * @return A FormattedStringFont instance which controls the formatting of the end portion of the string.
     */
    getFont(startIndex: number): FormattedStringFont;
    /**
     * Gets the font which controls the formatting properties in the string from the specified start index for
     * the specified number of characters.
     * <p class="body">
     * If the start index is greater than or equal to the length of the unformatted string, no exception
     * will be thrown. It will be thrown later when one of the formatting properties of the returned
     * [[FormattedStringFont]] is set.
     * </p>
     * @param startIndex The index of the first character the returned font controls.
     * @param length The number of characters after the start index controlled by the returned font.
     * @throws [[ArgumentOutOfRangeException]] 'startIndex' is less than zero.
     * @throws [[ArgumentOutOfRangeException]] 'length' is less than one. A zero length string cannot be controlled by a formatting font.
     * @return A FormattedStringFont instance which controls the formatting of a portion of the string.
     */
    getFont(startIndex: number, length: number): FormattedStringFont;
    /**
     * @hidden
     */
    _getFont(a: number): FormattedStringFont;
    /**
     * @hidden
     */
    _getFont1(a: number, b: number): FormattedStringFont;
    /**
     * Gets the collection of formatting runs representing contiguous blocks of similar formatting starting at the beginning of the string.
     */
    private _getFormattingRuns;
    getFormattingRuns(): IEnumerable$1<FormattedStringFont>;
    /**
     * @hidden
     */
    _c(): FormattingRunBase[];
    /**
     * @hidden
     */
    _z(a: GenericCachedCollection$1<StringElement>): void;
    /**
     * @hidden
     */
    _ac(a: Sheet): void;
    /**
     * @hidden
     */
    _af(): void;
    /**
     * Gets or sets the unformatted string.
     * <p class="body">
     * If the new unformatted string assigned is shorter than the old unformatted string, all formatting
     * outside the range of the new value will be lost.
     * </p>
     * The unformatted string.
     * @throws [[ArgumentNullException]] The value assigned is a null string.
     */
    get unformattedString(): string;
    set unformattedString(a: string);
    /**
     * @hidden
     */
    private _ad;
    /**
     * @hidden
     */
    get _m(): StringElement;
    /**
     * @hidden
     */
    get _owner(): IFormattedStringOwner;
    /**
     * @hidden
     */
    set _owner(a: IFormattedStringOwner);
    /**
     * @hidden
     */
    get _t(): number;
    /**
     * @hidden
     */
    get _sheet(): Sheet;
    /**
     * @hidden
     */
    get _workbook(): Workbook;
}
/**
 * Represents the text area of a chart element.
 * @see [[ChartTitle]]
 * @see [[DisplayUnitLabel]]
 */
export declare class ChartTextAreaBase extends ChartObject implements IFormattedStringOwner {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _bl;
    /**
     * @hidden
     */
    private static readonly _bm;
    /**
     * @hidden
     */
    private static readonly _bn;
    /**
     * @hidden
     */
    private static readonly _bo;
    /**
     * @hidden
     */
    private static readonly _bp;
    /**
     * @hidden
     */
    private static readonly _bq;
    /**
     * @hidden
     */
    private static readonly _bs;
    /**
     * @hidden
     */
    private static readonly _bt;
    /**
     * @hidden
     */
    private static readonly _bu;
    /**
     * @hidden
     */
    private static readonly _bw;
    /**
     * @hidden
     */
    private static readonly _bv;
    /**
     * @hidden
     */
    private static readonly _bx;
    /**
     * @hidden
     */
    private static readonly _by;
    /**
     * @hidden
     */
    private static readonly _bz;
    /**
     * @hidden
     */
    private static readonly _b0;
    /**
     * @hidden
     */
    static readonly _br: number;
    /**
     * @hidden
     */
    static readonly _ai: HorizontalTitleAlignment;
    /**
     * @hidden
     */
    static readonly _ar: TextHorizontalOverflow;
    /**
     * @hidden
     */
    static readonly _bg: number;
    /**
     * @hidden
     */
    static readonly _af: ElementPosition;
    /**
     * @hidden
     */
    static readonly _al: ReadingOrder;
    /**
     * @hidden
     */
    static readonly _bh: number;
    /**
     * @hidden
     */
    static readonly _ao: TextDirection;
    /**
     * @hidden
     */
    static readonly _ax: VerticalTitleAlignment;
    /**
     * @hidden
     */
    static readonly _au: TextVerticalOverflow;
    /**
     * @hidden
     */
    static readonly _ba: boolean;
    /**
     * @hidden
     */
    private static _w;
    private _z;
    private _a8;
    private _ab;
    private _a4;
    private _b1;
    private _ah;
    private _aq;
    private _bd;
    private _ae;
    private _ak;
    private _be;
    private _az;
    private _an;
    private _bf;
    private _aw;
    private _at;
    private _a9;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _k(a: any): any;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Determines the appearance of the border drawn around
     * the text area, as well as whether a border appears.
     */
    get border(): ChartBorder;
    set border(a: ChartBorder);
    /**
     * Defines the font properties for each formatted run in the
     * [[text]] that has no more specific setting. Read-only.
     * <p class="body">
     * Use this object to apply font formatting to the entire run of text
     * which comprises the chart or axis title.
     * </p>
     * <p class="body">
     * Font formatting can be applied to individual runs of text using the
     * [[FormattedString.getFont]] method of the object
     * returned from the [[text]] property. Any such formatting
     * overrides that which is defined by the DefaultFont settings.
     * </p>
     * <para class="note"><b>Note:</b> this property will return null until the [[ChartTitle]]
     * is set on the <see cref="WorksheetChart.ChartTitle">WorksheetChart.ChartTitle</see> property.</para>
     * @see [[text]]
     * @see [[FormattedString]]
     */
    get defaultFont(): IWorkbookFont;
    /**
     * @hidden
     */
    _e(a: Workbook): WorkbookFontProxy;
    /**
     * @hidden
     */
    get _a7(): WorkbookColorInfo;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill properties for the text area.
     * <p class="body">
     * This property returns null by default, indicating that no fill is applied.
     * </p>
     * <p class="body">
     * To apply a solid color fill, assign an instance of the
     * [[ChartSolidFill]] class to this property.
     * </p>
     * <p class="body">
     * To apply a gradient fill, assign an instance of the
     * [[ChartGradientFill]] class to this property.
     * </p>
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     */
    get fill(): ChartFillBase;
    set fill(a: ChartFillBase);
    /**
     * @hidden
     */
    protected get__ad(): ChartFillBase;
    /**
     * @hidden
     */
    get _ad(): ChartFillBase;
    /**
     * The formula used to get the text displayed within the text area. (read-only).
     * <para class="body">
     * To set this property call the <seealso cref="SetFormula(string, CellReferenceMode?)">SetFormula</seealso> method.
     * </para>
     * @see [[setFormula]]
     */
    protected get_formula(): Formula;
    /**
     * The formula used to get the text displayed within the text area. (read-only).
     * <para class="body">
     * To set this property call the <seealso cref="SetFormula(string, CellReferenceMode?)">SetFormula</seealso> method.
     * </para>
     * @see [[setFormula]]
     */
    get formula(): Formula;
    /**
     * @hidden
     */
    get _a5(): SingleTargetFormula;
    /**
     * @hidden
     */
    set _a5(a: SingleTargetFormula);
    /**
     * @hidden
     */
    get _aj(): HorizontalTitleAlignment;
    /**
     * @hidden
     */
    set _aj(a: HorizontalTitleAlignment);
    /**
     * Determines whether text is allowed to continue horizontally
     * outside the bounds of the containing element.
     */
    get horizontalOverflow(): TextHorizontalOverflow;
    set horizontalOverflow(a: TextHorizontalOverflow);
    /**
     * The left position of the text area (ignored unless [[position]] is set to 'Custom').
     * <p class="body">
     * The value of this property is expressed as a fractional value between 0 and 1
     * which represents the ratio of the offset to the width of the chart element.
     * </p>
     * <p class="body">
     * For example, a value of 0 positions the text area as close as possible to the
     * edge of the chart element; a value of 1 positions it as close as possible to the opposite
     * edge. All values in between 0 and 1 represent a scalar which, when applied to the width of
     * the entire chart element, yields the offset.
     * </p>
     * @see [[position]]
     */
    protected get_left(): number;
    protected set_left(a: number): void;
    /**
     * The left position of the text area (ignored unless [[position]] is set to 'Custom').
     * <p class="body">
     * The value of this property is expressed as a fractional value between 0 and 1
     * which represents the ratio of the offset to the width of the chart element.
     * </p>
     * <p class="body">
     * For example, a value of 0 positions the text area as close as possible to the
     * edge of the chart element; a value of 1 positions it as close as possible to the opposite
     * edge. All values in between 0 and 1 represent a scalar which, when applied to the width of
     * the entire chart element, yields the offset.
     * </p>
     * @see [[position]]
     */
    get left(): number;
    set left(a: number);
    /**
     * Determines whether the position of the text area is automatic or custom
     * as specified by the [[left]] and [[top]] properties.
     */
    protected get_position(): ElementPosition;
    protected set_position(a: ElementPosition): void;
    /**
     * Determines whether the position of the text area is automatic or custom
     * as specified by the [[left]] and [[top]] properties.
     */
    get position(): ElementPosition;
    set position(a: ElementPosition);
    /**
     * Determines the reading order
     */
    get readingOrder(): ReadingOrder;
    set readingOrder(a: ReadingOrder);
    /**
     * Determines the rotation of the text area, expressed in degrees.
     */
    get rotation(): number;
    set rotation(a: number);
    /**
     * Returns or sets a [[FormattedString]] object which defines
     * the text to be displayed by the associated chart element.
     * <p class="body">
     * Because mixed font settings are supported for chart element text,
     * a special object is required to customize the text.
     * </p>
     * <p class="body">
     * For the simple case where all the text has the same formatting,
     * create an instance of the [[FormattedString]] class,
     * specifiying the text as the value of the 'unformattedString'
     * parameter.
     * </p>
     * <p class="body">
     * To apply font attributes to a given run of text, i.e., a substring
     * within the text, use the [[FormattedString.getFont]]
     * method, and set the applicable properties of the [[FormattedStringFont]]
     * instance returned from the GetFont method.
     * </p>
     * @see [[FormattedString..ctor]]
     * @see [[FormattedString.getFont]]
     */
    protected get_text(): FormattedString;
    protected set_text(a: FormattedString): void;
    /**
     * Returns or sets a [[FormattedString]] object which defines
     * the text to be displayed by the associated chart element.
     * <p class="body">
     * Because mixed font settings are supported for chart element text,
     * a special object is required to customize the text.
     * </p>
     * <p class="body">
     * For the simple case where all the text has the same formatting,
     * create an instance of the [[FormattedString]] class,
     * specifiying the text as the value of the 'unformattedString'
     * parameter.
     * </p>
     * <p class="body">
     * To apply font attributes to a given run of text, i.e., a substring
     * within the text, use the [[FormattedString.getFont]]
     * method, and set the applicable properties of the [[FormattedStringFont]]
     * instance returned from the GetFont method.
     * </p>
     * @see [[FormattedString..ctor]]
     * @see [[FormattedString.getFont]]
     */
    get text(): FormattedString;
    set text(a: FormattedString);
    /**
     * Determines the orientation and direction in which text flows.
     * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
     * @see [[rotation]]
     */
    get textDirection(): TextDirection;
    set textDirection(a: TextDirection);
    /**
     * The top position of the text area (ignored unless [[position]] is set to 'Custom').
     * <p class="body">
     * The value of this property is expressed as a fractional value between 0 and 1
     * which represents the ratio of the offset to the height of the associated chart
     * element.
     * </p>
     * <p class="body">
     * For example, a value of 0 positions the title as close as possible to the
     * edge of the associated chart element; a value of 1 positions it as close as possible to the opposite
     * edge. All values in between 0 and 1 represent a scalar which, when applied to the height of
     * the entire chart element, yields the offset.
     * </p>
     * @see [[position]]
     */
    protected get_top(): number;
    protected set_top(a: number): void;
    /**
     * The top position of the text area (ignored unless [[position]] is set to 'Custom').
     * <p class="body">
     * The value of this property is expressed as a fractional value between 0 and 1
     * which represents the ratio of the offset to the height of the associated chart
     * element.
     * </p>
     * <p class="body">
     * For example, a value of 0 positions the title as close as possible to the
     * edge of the associated chart element; a value of 1 positions it as close as possible to the opposite
     * edge. All values in between 0 and 1 represent a scalar which, when applied to the height of
     * the entire chart element, yields the offset.
     * </p>
     * @see [[position]]
     */
    get top(): number;
    set top(a: number);
    /**
     * Determines the vertical alignment of the text area.
     */
    get verticalAlignment(): VerticalTitleAlignment;
    set verticalAlignment(a: VerticalTitleAlignment);
    /**
     * Determines whether text is allowed to continue vertically
     * outside the bounds of the containing element.
     */
    get verticalOverflow(): TextVerticalOverflow;
    set verticalOverflow(a: TextVerticalOverflow);
    /**
     * Determines whether text is wrapped when it would exceed
     * the bounds of the containing element.
     */
    get wrapText(): boolean;
    set wrapText(a: boolean);
    /**
     * Assigns a new [[Formula]] to this instance.
     * @param formula The string representation of the formula used to get the [[text]].
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     * @see [[text]]
     */
    setFormula(formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setFormula1(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    _b2(a: Sheet, b: SingleTargetFormula): void;
    /**
     * @hidden
     */
    _a3(a?: boolean): IWorkbookFont;
    /**
     * @hidden
     */
    _bb(a: boolean, b?: ElementPosition): boolean;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    private static _a6;
    /**
     * @hidden
     */
    get allowDefaultValues(): boolean;
    /**
     * @hidden
     */
    getDefaultFont(): IWorkbookFont;
    /**
     * @hidden
     */
    getFontDefaultsResolver(): IWorkbookFontDefaultsResolver;
    /**
     * @hidden
     */
    onUnformattedStringChanged(sender: FormattedString): void;
    /**
     * @hidden
     */
    onFormattingChanged(): void;
}
/**
 * Represents the title of a [[WorksheetChart]] or [[Axis]].
 */
export declare class ChartTitle extends ChartTextAreaBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ce;
    /**
     * @hidden
     */
    static readonly _cd: number;
    private _b9;
    private _b8;
    static staticInit(): void;
    constructor();
    /**
     * @hidden
     */
    get _b7(): IWorkbookFont;
    /**
     * @hidden
     */
    get _ca(): boolean;
    /**
     * Determines whether the chart title is laid over the plot area.
     */
    get overlay(): boolean;
    set overlay(a: boolean);
    /**
     * @hidden
     */
    _cf(a: IWorkbookFont): void;
    /**
     * @hidden
     */
    _cc(): boolean;
    /**
     * @hidden
     */
    private static _b4;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _b6;
    /**
     * @hidden
     */
    private static _b5;
}
/**
 * Exposes properties which control the fill and width
 * of the drop lines in a stock chart.
 * @see [[WorksheetChart.dropLines]]
 */
export declare class ChartDropLines extends ChartLineBase {
    static $t: Type;
    constructor();
}
/**
 * Exposes properties which control the fill and width of the lines
 * which depict the high and low values in a stock chart.
 * @see [[WorksheetChart.highLowLines]]
 */
export declare class ChartHighLowLines extends ChartLineBase {
    static $t: Type;
    constructor();
    /**
     * @hidden
     */
    get _ak(): ChartFillBase;
}
/**
 * @hidden
 */
export declare class WorksheetChart_LegendChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetChart, c: Legend, d: LegendEntry[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly c: WorksheetChart;
    readonly b: Legend;
    readonly a: LegendEntry[];
    d(): void;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Exposes properties which control the fill and width of the lines
 * which connect the first and second plot areas in a 'bar of pie'
 * or 'pie of pie' chart.
 * @see [[WorksheetChart.seriesLines]]
 */
export declare class ChartSeriesLines extends ChartLineBase {
    static $t: Type;
    private _al;
    constructor();
    /**
     * @hidden
     */
    get _ak(): ChartFillBase;
}
/**
 * Represents the bars which depict gain or loss on a stock chart.
 */
export declare class UpDownBars extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    static readonly _ae: number;
    private _ad;
    private _aa;
    private _z;
    constructor();
    /**
     * Returns an [[UpDownBar]] instance which controls the appearance
     * of the down bars for a stock chart.
     * @see [[downBar]]
     * @see [[WorksheetChart.upDownBars]]
     * @see [[WorksheetChart.highLowLines]]
     */
    get downBar(): UpDownBar;
    /**
     * Specifies the width of the gap between bars.
     */
    get gapWidth(): number;
    set gapWidth(a: number);
    /**
     * Returns an [[UpDownBar]] instance which controls the appearance
     * of the up bars for a stock chart.
     * @see [[upBar]]
     * @see [[WorksheetChart.upDownBars]]
     * @see [[WorksheetChart.highLowLines]]
     */
    get upBar(): UpDownBar;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
export declare class WorksheetChart extends WorksheetShapeGroupBase implements IChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ho: number;
    /**
     * @hidden
     */
    private static readonly _hh;
    /**
     * @hidden
     */
    private static readonly _hi;
    /**
     * @hidden
     */
    private static readonly _hj;
    /**
     * @hidden
     */
    private static readonly _hk;
    /**
     * @hidden
     */
    private static readonly _hx;
    /**
     * @hidden
     */
    private static readonly _hy;
    /**
     * @hidden
     */
    private static readonly _h0;
    /**
     * @hidden
     */
    private static readonly _h1;
    /**
     * @hidden
     */
    private static readonly _h3;
    /**
     * @hidden
     */
    private static readonly _h5;
    /**
     * @hidden
     */
    private static readonly _h7;
    /**
     * @hidden
     */
    private static readonly _h9;
    /**
     * @hidden
     */
    private static readonly _ia;
    /**
     * @hidden
     */
    static readonly _ib: number;
    /**
     * @hidden
     */
    private static readonly _ig;
    /**
     * @hidden
     */
    private static readonly _ih;
    /**
     * @hidden
     */
    private static readonly _ii;
    /**
     * @hidden
     */
    private static readonly _ik;
    /**
     * @hidden
     */
    private static readonly _im;
    /**
     * @hidden
     */
    private static readonly _ip;
    /**
     * @hidden
     */
    private static readonly _iq;
    /**
     * @hidden
     */
    private static readonly _is;
    /**
     * @hidden
     */
    private static readonly _it;
    /**
     * @hidden
     */
    private static readonly _iu;
    /**
     * @hidden
     */
    private static readonly _id;
    /**
     * @hidden
     */
    static readonly _hs: number;
    /**
     * @hidden
     */
    static readonly _ht: number;
    /**
     * @hidden
     */
    static readonly _hq: number;
    /**
     * @hidden
     */
    static readonly _hp: number;
    /**
     * @hidden
     */
    static readonly _hn: number;
    /**
     * @hidden
     */
    static readonly _hr: number;
    /**
     * @hidden
     */
    static readonly _hu: number;
    /**
     * @hidden
     */
    static readonly _hv: number;
    /**
     * @hidden
     */
    static readonly _ic: number;
    /**
     * @hidden
     */
    static _d9: ChangeInfo[];
    /**
     * @hidden
     */
    private static readonly _f0;
    private _fz;
    private _ef;
    private _fj;
    private _iv;
    private _el;
    private _e1;
    private _e3;
    private _g6;
    private _e6;
    private _g7;
    private _en;
    private _fk;
    private _g8;
    private _g9;
    private _ha;
    private _hb;
    private _er;
    /**
     * @hidden
     */
    _e8: Legend;
    private _hc;
    private _fa;
    private _hd;
    private _he;
    private _fc;
    private _hf;
    private _et;
    private _hg;
    private _fl;
    private _fh;
    private _fm;
    private _fy;
    private _fu;
    private _ew;
    private _ex;
    private _ev;
    private _ep;
    static staticInit(): void;
    /**
     * True if Microsoft Excel scales a 3-D chart so that it's closer in size to the equivalent 2-D chart. The [[rightAngleAxes]]  property must be True
     */
    get autoScaling(): boolean;
    set autoScaling(a: boolean);
    /**
     * Indexer
     * @param type The type of the axis.
     * @param group The axis group, defaults to primary.
     * @return The corresponding axis or null if not in the collection.
     */
    axisCollection(type: AxisType, group?: AxisGroup): Axis;
    /**
     * Returns the axis collection (read-only)
     */
    axisCollection(): AxisCollection;
    /**
     * @hidden
     */
    get _axisCollection$i(): AxisCollection;
    /**
     * Returns a [[Wall]] object that allows the user to
     * format the back wall of a 3-D chart. Read-only.
     * @see [[floor]]
     * @see [[sideWall]]
     * @see [[wallDefault]]
     */
    get backWall(): Wall;
    /**
     * Returns or sets the shape of [[Series]] bars.
     * Applicable only to 3D bar-type charts.
     * <p class="body">
     * This property is applicable only to the following chart types:
     * </p>
     * <p class="body">
     * <ul>
     * <li>Bar3DStacked</li>
     * <li>Column3DStacked</li>
     * <li>ConeBarStacked</li>
     * <li>ConeColStacked</li>
     * <li>PyramidBarStacked</li>
     * <li>PyramidColStacked</li>
     * <li>CylinderBarStacked</li>
     * <li>CylinderColStacked</li>
     * <li>Bar3DStacked100</li>
     * <li>Column3DStacked100</li>
     * <li>ConeBarStacked100</li>
     * <li>ConeColStacked100</li>
     * <li>PyramidBarStacked100</li>
     * <li>PyramidColStacked100</li>
     * <li>CylinderBarStacked100</li>
     * <li>CylinderColStacked100</li>
     * <li>Column3D</li>
     * <li>PyramidCol</li>
     * <li>ConeCol</li>
     * <li>CylinderCol</li>
     * </ul>
     * </p>
     * <p class="body">
     * Use this property to set the bar shape for all series bars.
     * </p>
     * <p class="body">
     * To set the shape for a particular series bar, use the [[Series.barShape]] property.
     * </p>
     * @see [[Series.barShape]]
     * @see [[chartType]]
     */
    get barShape(): BarShape | null;
    set barShape(a: BarShape | null);
    /**
     * @hidden
     */
    get _barShape$i(): Nullable$1<BarShape>;
    /**
     * @hidden
     */
    set _barShape$i(a: Nullable$1<BarShape>);
    /**
     * Returns the resolved value of the [[barShape]] property.
     * @see [[barShape]]
     * @see [[Series.barShape]]
     */
    get barShapeResolved(): BarShape;
    /**
     * @hidden
     */
    get _ej(): BarShape;
    /**
     * @hidden
     */
    _ek(a: ChartType): BarShape;
    /**
     * Returns a [[chartArea]] object that represents the complete chart area for the chart. Read-only.
     */
    get chartArea(): ChartArea;
    /**
     * Returns or sets an [[chartTitle]] object.
     */
    get chartTitle(): ChartTitle;
    set chartTitle(a: ChartTitle);
    /**
     * Specifies the chart type.
     * <p class="body">
     * All chart types are supported by the [[WorksheetChart]] type;
     * no derived classes exist or are necessary to support different chart types.
     * </p>
     * <p class="body">
     * Note that changing the chart type may cause related property values
     * to be changed.
     * </p>
     * <p class="body">
     * For example, when transitioning from a chart type which supports
     * line markers, The [[Series.markerStyle]] property is changed
     * to reflect the new chart style.
     * </p>
     * <p class="body">
     * Using another example, when transitioning from a chart type which does
     * not support <see cref="Axis">axes</see>, such as a pie or doughnut chart,
     * to a chart type that does support them, the [[axisCollection]]
     * is modified accordingly.
     * </p>
     * @see [[WorksheetShapeCollection.addChart]]
     */
    get chartType(): ChartType;
    set chartType(a: ChartType);
    /**
     * Returns the [[ComboChartGroup]] instance associated with the specified
     * 'chartType' and 'axisGroup', or null if no such
     * instance exists.
     * @param chartType A [[ChartType]] constant which identifies the combo chart group.
     * @param axisGroup An [[AxisGroup]] constant which identifies the combo chart group.
     * @return A new or existing [[ComboChartGroup]] instance.
     */
    comboChartGroups(chartType: ChartType, axisGroup: AxisGroup): ComboChartGroup;
    /**
     * Returns a collection of the [[ComboChartGroup]] instances associated with this chart.
     * <p class="body">
     * The properties of the [[WorksheetChart]] class which apply only to a specific chart type
     * are not applicable for combo charts. For example, the [[gapWidth]] property,
     * which applies to bar charts, is not used for bar charts which appear within a combo chart. The reason
     * for this is that combo charts support multiple occurrences of the same chart type,
     * making the WorksheetChart-level properties ambiguous in the context of a combo chart.
     * </p>
     * <p class="body">
     * This class makes it possible to set chart-specific properties for one or more occurrences of
     * a particular chart type, for a particular axis group.
     * </p>
     * <p class="body">
     * For example, consider a combo chart with two <i>ClusteredColumn</i> series, one on the primary
     * axis and another on the secondary.
     * To set the [[gapWidth]] property for the chart on the primary axis, add an item to
     * this collection with a [[chartType]] of <i>ClusteredColumn</i>, and an [[AxisGroup]]
     * of <i>Primary</i>. On the [[ComboChartGroup]] instance returned from the collection's Add method,
     * set the <i>GapWidth</i> property to the desired value.
     * </p>
     * <p class="body">
     * When the chart is serialized, this collection is checked against each series in the combo chart.
     * If the <see cref="Series.ChartType">ChartType</see> and the <see cref="Series.AxisGroup">AxisGroup</see>
     * match the respective properties on a ComboChartGroup instance, the value of that instance's <i>GapWidth</i>
     * property is applied to the chart element for that series. Because the other clustered column series exists
     * on the secondary axis, the property is not applied to that series, since while it has the same <i>ChartType</i>,
     * its <i>AxisGroup</i> is different.
     * </p>
     * @see [[ComboChartGroup]]
     * @see [[Series.chartType]]
     * @see [[Series.axisGroup]]
     */
    comboChartGroups(): ComboChartGroupCollection;
    /**
     * @hidden
     */
    get _comboChartGroups$i(): ComboChartGroupCollection;
    /**
     * Returns or sets the depth of a 3-D chart as a percentage of the chart width (between 20 and 2000 percent).
     */
    get depthPercent(): number;
    set depthPercent(a: number);
    /**
     * Returns or sets the way that blank cells are plotted on a chart.
     */
    get displayBlanksAs(): DisplayBlanksAs;
    set displayBlanksAs(a: DisplayBlanksAs);
    /**
     * Returns or sets the size of the hole in a doughnut chart,
     * expressed as a percentage of the size of the encompassing circle.
     * <p class="body">
     * This property is only applicable to doughnut charts.
     * </p>
     * <p class="body">
     * The valid range for this property is 0 through 90, inclusive.
     * </p>
     */
    get doughnutHoleSize(): number;
    set doughnutHoleSize(a: number);
    /**
     * Returns or sets a [[ChartDropLines]] instance which determines
     * the appearance for a stock chart's drop lines.
     * <p class="body">
     * This property is only applicable for stock charts.
     * </p>
     * <p class="body">
     * High/low lines are not displayed by default; to enable them,
     * assign a [[ChartDropLines]]to this property.
     * to null.
     * </p>
     */
    get dropLines(): ChartDropLines;
    set dropLines(a: ChartDropLines);
    /**
     * Returns a [[Wall]] object that allows the user to
     * format the bottom wall of a 3-D chart. Read-only.
     * @see [[backWall]]
     * @see [[sideWall]]
     * @see [[wallDefault]]
     */
    get floor(): Wall;
    /**
     * Returns or sets the gap depth in a 3-D chart, expressed
     * as a percentage of the marker width. The value of this property must
     * be between 0 and 500.
     * @see [[gapWidth]]
     */
    get gapDepth(): number;
    set gapDepth(a: number);
    /**
     * @hidden
     */
    get _ix(): Nullable$1<number>;
    /**
     * Returns or sets the distance between the data series in a bar chart,
     * as a percentage of the marker width. The value of this property must
     * be between 0 and 500.
     * @see [[gapDepth]]
     */
    get gapWidth(): number;
    set gapWidth(a: number);
    /**
     * @hidden
     */
    get _iy(): Nullable$1<number>;
    /**
     * Returns or sets the angle which determines the origin of the first
     * slice, as relative to the 12 o'clock position of the emcompassing circle.
     * <p class="body">
     * This property is only applicable to pie and doughnut charts.
     * </p>
     * <p class="body">
     * The valid range for this property is 0 through 360, inclusive. Fractional
     * angles are not supported; nor are negative angles.
     * </p>
     * <p class="body">
     * By default, the first slice begins at the "12 o'clock" position of the
     * pie chart, i.e., the top center point of the encompassing circle.
     * </p>
     * <p class="body">
     * Use this property to offset the origin of the first slice; for example, a
     * value of 30 positions the first slice at the 1 o'clock position, 60 at the
     * 2 o'clock position, 90 for 3 o'clock, etc.
     * </p>
     * <p class="body">
     * Larger values move along the circumference of the emcompassing circle
     * in a clockwise direction, with a value of 0 or 360 both coinciding with
     * the 12 o'clock position.
     * </p>
     */
    get firstSliceAngle(): number;
    set firstSliceAngle(a: number);
    /**
     * Returns or sets the height of a 3-D chart as a percentage of the chart width (between 5 and 500 percent).
     */
    get heightPercent(): number;
    set heightPercent(a: number);
    /**
     * Returns or sets a [[ChartHighLowLines]] instance which determines
     * the appearance for a stock chart's high/low lines.
     * <p class="body">
     * This property is only applicable for stock charts.
     * </p>
     * <p class="body">
     * High/low lines depict the high and low prices for a stock chart.
     * </p>
     * <p class="body">
     * High/low lines are displayed by default; to disable them, set this property
     * to null.
     * </p>
     */
    get highLowLines(): ChartHighLowLines;
    set highLowLines(a: ChartHighLowLines);
    /**
     * Returns or sets a [[legend]] object which represents
     * the legend for the chart.
     */
    get legend(): Legend;
    set legend(a: Legend);
    /**
     * Returns or sets a value that represents the perspective
     * for the 3-D chart view, expressed in degrees.
     * <p class="body">
     * This property supports values within the inclusive range of <b>0</b> and <b>120</b>.
     * </p>
     */
    get perspective(): number;
    set perspective(a: number);
    /**
     * Returns a PlotArea object that represents the plot area of a chart. Read-only.
     */
    get plotArea(): PlotArea;
    /**
     * True if only visible cells are plotted. False if both visible and hidden cells are plotted.
     */
    get plotVisibleOnly(): boolean;
    set plotVisibleOnly(a: boolean);
    /**
     * True if the chart axes are at right angles, independent of chart rotation or elevation. Applies only to 3-D line, column, and bar charts.
     */
    get rightAngleAxes(): boolean;
    set rightAngleAxes(a: boolean);
    /**
     * Returns or sets the rotation of a 3-D chart view around the X-axis, expressed in degrees.
     * <p class="body">
     * This property controls the viewing perspective by rotating the
     * chart around the horizontal axis, such that the top of the chart
     * appears to move closer or further away.
     * </p>
     * <p class="body">
     * This property is only applicable to 3D charts.
     * </p>
     * @see [[rotationY]]
     */
    get rotationX(): number;
    set rotationX(a: number);
    /**
     * Returns or sets the rotation of a 3-D chart view around the Y-axis, expressed in degrees.
     * <p class="body">
     * This property controls the viewing perspective by rotating the
     * chart around the vertical axis, such that the left edge of the chart
     * appears to move closer or further away.
     * </p>
     * <p class="body">
     * This property is only applicable to 3D charts.
     * </p>
     * @see [[rotationX]]
     */
    get rotationY(): number;
    set rotationY(a: number);
    /**
     * Returns or sets the size of the second plot area in a 'bar of pie'
     * or 'pie of pie' chart, expressed as a percentage of the first plot
     * area's size.
     * <p class="body">
     * This property is only applicable for the <i>BarOfPie</i> and <i>PieOfPie</i>
     * <see cref="WorksheetChart.ChartType">chart types</see>.
     * </p>
     * <p class="body">
     * This property supports values in the range of <b>5</b>  to <b>200</b>, inclusively.
     * </p>
     */
    get secondPlotSize(): number;
    set secondPlotSize(a: number);
    /**
     * Indexer
     * @param index A zero based index
     * @return
     */
    seriesCollection(index: number): Series;
    /**
     * Returns the series collection (read-only)
     */
    seriesCollection(): SeriesCollection;
    /**
     * @hidden
     */
    get _seriesCollection$i(): SeriesCollection;
    /**
     * Determines the <see cref="ChartLineBase.Fill">fill</see> and
     * <see cref="ChartLineBase.WidthInPoints">width</see> for the lines
     * which connect the first and second plot areas in a 'bar of pie'
     * or 'pie of pie' chart.
     * <p class="body">
     * This property is only applicable for the <i>BarOfPie</i> and <i>PieOfPie</i>
     * <see cref="WorksheetChart.ChartType">chart types</see>.
     * </p>
     * @see [[secondPlotSize]]
     */
    get seriesLines(): ChartSeriesLines;
    set seriesLines(a: ChartSeriesLines);
    /**
     * Determines the amount by which intersecting [[Series]] overlap,
     * expressed as a percentage of the bar size.
     * <p class="body">
     * This property is only applicable for 2D bar charts.
     * </p>
     * @see [[gapDepth]]
     * @see [[gapWidth]]
     */
    get seriesOverlap(): number;
    set seriesOverlap(a: number);
    /**
     * Returns a [[Wall]] object that allows the user to
     * format the side wall of a 3-D chart. Read-only.
     * @see [[floor]]
     * @see [[backWall]]
     * @see [[wallDefault]]
     */
    get sideWall(): Wall;
    /**
     * Returns or sets a [[UpDownBars]] instance which determines
     * the appearance for a stock chart's up/down bars.
     * <p class="body">
     * This property is only applicable for stock charts.
     * </p>
     * <p class="body">
     * Up/down bars depict gains or losses across a series for a stock chart.
     * </p>
     */
    get upDownBars(): UpDownBars;
    set upDownBars(a: UpDownBars);
    /**
     * Returns or sets a boolean value indicating whether the fill colors
     * for <see cref="Series">series</see> and <see cref="DataPoint">data points</see>
     * are automatically selected by Excel.
     * <p class="body">
     * This property defaults to <b>true</b>, causing fill colors for
     * series and data points to be automatically selected by Excel.
     * </p>
     * <p class="body">
     * The automatically selected color can always be overridden for individual series
     * and/or data points using the [[Series.fill]], [[Series.line]],
     * and [[DataPoint.fill]] properties.
     * </p>
     * <p class="body">
     * In cases where VaryColors is set to true, but a fill is explicitly assigned,
     * the assigned fill is used for the associated series or data point, while series
     * or data points which have no explicitly assigned fill will have a fill color
     * automatically selected.
     * </p>
     * @see [[Series.fill]]
     * @see [[Series.line]]
     * @see [[DataPoint.fill]]
     */
    get varyColors(): boolean;
    set varyColors(a: boolean);
    /**
     * Returns a [[Wall]] object which represents the back and side
     * walls, and floor of the chart. Applicable only for 3-D charts.
     * <p class="body">
     * Use this property to apply the same settings for the back wall, side wall, and floor.
     * </p>
     * <p class="body">
     * Use the [[backWall]] property to control the appearance of the back wall.
     * </p>
     * <p class="body">
     * Use the [[sideWall]] property to control the appearance of the side wall.
     * </p>
     * <p class="body">
     * Use the [[floor]] property to control the appearance of the bottom wall.
     * </p>
     * <p class="body">
     * The BackWall, SideWall, and Floor properties take precedence over this property.
     * </p>
     * @see [[backWall]]
     * @see [[sideWall]]
     * @see [[floor]]
     */
    get wallDefault(): Wall;
    /**
     * Gets the worksheet on which the shape resides.
     */
    protected get_sheet(): Sheet;
    /**
     * @hidden
     */
    get _ez(): ChartSolidFill;
    /**
     * @hidden
     */
    get _e0(): ChartSolidFill;
    /**
     * @hidden
     */
    get _ey(): ChartSolidFill;
    /**
     * @hidden
     */
    get _eq(): ChartEmptyFill;
    /**
     * @hidden
     */
    get _gc(): boolean;
    /**
     * @hidden
     */
    get _gu(): boolean;
    /**
     * @hidden
     */
    get _gv(): boolean;
    /**
     * @hidden
     */
    get _gt(): boolean;
    /**
     * Sets the source data range for a combo chart.
     * <p class="body">
     * Combo charts support multiple chart types within the main chart, with each different
     * chart type being associated with one or more [[Series]].
     * </p>
     * <p class="body">
     * Use this method to populate the [[seriesCollection]] for a combo chart.
     * </p>
     * <p class="body">
     * For example, given a 'dataRange' which yields three series, the caller
     * can specify an array with three elements as the value of the 'seriesChartTypes'
     * parameter. Each array element is then applied to the corresponding series, in the same order
     * in which they appear in the array.
     * </p>
     * <p class="body">
     * Duplicate ChartType values can appear in the 'seriesChartTypes' array,
     * in which case the corresponding series appear within the same chart. For example, specifying
     * an array with <i>ClusteredColumn</i>, <i>Line</i>, and <i>Line</i> results in a combo chart
     * with the first series appearing in a clustered column chart, and the remaining series appearing
     * in a line chart.
     * </p>
     * <p class="body">
     * Specifying null for the value of the 'seriesChartTypes' parameter
     * is treated the same as a two-element array containing 'ColumnClustered' and 'Line',
     * resulting in a clustered column chart for the first series, and a line chart for the
     * remaining series.
     * </p>
     * <p class="body">
     * If fewer values are present in the 'seriesChartTypes' array than the
     * number of series yielded from the specified 'dataRange', the remaining
     * series acquire the same ChartType and AxisGroup as the last element in the <i>seriesChartTypes</i>
     * array. If more values are present in the array than the number of series yielded, these values
     * are ignored.
     * </p>
     * <p class="body">
     * Certain chart type values are invalid for a combo chart; if any of these chart types
     * are present in the array, an exception is thrown, listing the invalid chart types.
     * </p>
     * <p class="body">
     * The following table lists the ChartType values which are supported in combo charts,
     * grouped by series type:
     * </p>
     * <p class="body">
     * <table border = "1" >
     * <tr><th> SeriesType </th ><th>ChartType (supported in combo charts)</th></tr>
     * <tr>
     *  <td>Area</td><td>Area, AreaStacked, AreaStacked100</td>
     * </tr>
     * 	<tr>
     * 		<td>Bar</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, BarClustered, BarStacked, BarStacked100, BarOfPie</td>
     * 	</tr>
     * 	<tr>
     * 		<td>Line</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100</td>
     * 	</tr>
     * 	<tr>
     * 		<td>Pie</td><td>Pie, PieExploded, PieOfPie, Doughnut, DoughnutExploded</td>
     * 	</tr>
     * 	<tr>
     * 		<td>Radar</td><td>Radar, RadarFilled, RadarMarkers</td>
     * 	</tr>
     * 	<tr>
     * 		<td>Scatter</td><td>XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td>
     * 	</tr>
     * 	<tr>
     * 		<td>Bubble</td><td><b>Not Supported</b></td>
     * 	</tr>
     * 	<tr>
     * 		<td>Surface</td><td><b>Not Supported</b></td>
     * 	</tr>
     * </table>
     * </p>
     * <p class="body">
     * Combo charts support a maximum of two axis groups. If the combination of values in the
     * 'seriesChartTypes' array necessitates more than two axis groups, an exception
     * is thrown.
     * </p>
     * <p class="body">
     * Combo charts require a minimum of two [[Series]]. If the specified 'dataRange'
     * yields less that two series, an exception is thrown.
     * </p>
     * <p class="body">
     * If the combination of series used in a combo chart is indistinguishable from a non-combo
     * chart, the chart may not be recognized by Excel as a combo chart. For example, adding two
     * series, one of type <i>Radar</i> and one of type <i>RadarMarkers</i>, is a valid combination.
     * When opened in Excel, however, such a chart will not be recognized as a combo chart, since the
     * combination of series does not necessitate multiple chart elements. All relevant property values
     * are persisted, however, and there is no distinguishable difference between the original chart
     * and the serialized one.
     * </p>
     * @param dataRange The data range for the combo chart
     * @param seriesChartTypes An array of [[chartType]] constants which specify the chart type for each series
     * yielded from the specified 'dataRange'.
     * @param plotByRows Optional. True to plot by rows where each row is a separate series or false to plot by columns where each column is a separate series. The default is false.
     * @param cellReferenceMode Optional. Determines how to parse the dataRange.
     * @see [[Series]]
     * @see [[Axis]]
     * @see [[Series.chartType]]
     * @see [[Series.axisGroup]]
     * @throws [[BaseError]] The current value of the [[chartType]] property is not <i>Combo</i>.
     * @throws [[NotSupportedException]] The specified 'seriesChartTypes' array contains one or more values which are not
     * supported within a combo chart.
     * @throws [[NotSupportedException]] The specified 'seriesChartTypes' array contains a combination of values which
     * would require more than the maximum allowable number of axes (two).
     */
    setComboChartSourceData(dataRange: string, seriesChartTypes: ChartType[], plotByRows?: boolean, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setComboChartSourceData$i(a: string, b: ChartType[], c?: boolean, d?: Nullable$1<CellReferenceMode>): void;
    /**
     * Sets the source data range for the chart.
     * <p class="data">
     * For combo charts, this method always displays the first series in a clustered column chart,
     * with all subsequent series displayed in line charts. Use the [[setComboChartSourceData]]
     * to customize the series charts for a combo chart.
     * </p>
     * @param dataRange The data range for the chart
     * @param plotByRows Optional. True to plot by rows where each row is a separate series or false to plot by columns where each column is a separate series. The default is false.
     * @param cellReferenceMode Optional. Determines how to parse the dataRange.
     */
    setSourceData(dataRange: string, plotByRows?: boolean, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setSourceData$i(a: string, b?: boolean, c?: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    private _jr;
    /**
     * @hidden
     */
    _jb(): void;
    /**
     * @hidden
     */
    _g5(): List$1<LegendEntry>;
    /**
     * @hidden
     */
    static _i0(a: ChartType): Nullable$1<number>;
    /**
     * @hidden
     */
    static _g0(a: Nullable$1<SeriesType>): HashSet$1<ChartType>;
    /**
     * @hidden
     */
    static _gm(a: ChartType[]): boolean;
    /**
     * @hidden
     */
    static _gn(a: ChartType[], b: ChartType[]): {
        ret: boolean;
        p1: ChartType[];
    };
    /**
     * @hidden
     */
    static _go(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _f8(a: ChartType, b: boolean, c: boolean): {
        ret: boolean;
        p1: boolean;
        p2: boolean;
    };
    /**
     * @hidden
     */
    static _gd(a: ChartType, b?: ChartTypeContext): boolean;
    /**
     * @hidden
     */
    static _ge(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gk(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _f7(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gl(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gf(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gg(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gh(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _f9(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _f3(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gr(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _f4(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _jd(a: ChartType, b: ChartFillBase, c: Nullable$1<MarkerStyle>): {
        p1: ChartFillBase;
        p2: Nullable$1<MarkerStyle>;
    };
    /**
     * @hidden
     */
    _i8(a?: Sheet): void;
    /**
     * @hidden
     */
    _ja(): void;
    /**
     * @hidden
     */
    static _gx(a: ChartType): boolean;
    /**
     * @hidden
     */
    _je(): void;
    /**
     * @hidden
     */
    static _jv(a: Sheet, b: ChartType): void;
    /**
     * @hidden
     */
    _jk(): void;
    /**
     * @hidden
     */
    private _jf;
    /**
     * @hidden
     */
    private _jg;
    /**
     * @hidden
     */
    _fr(a: ChartType, b: AxisGroup): ComboChartGroup;
    /**
     * @hidden
     */
    _fs(a: ChartType, b: AxisGroup): ComboChartGroup;
    /**
     * @hidden
     */
    _ft(a: SeriesChartTypeGroup, b: AxisGroup): ComboChartGroup;
    /**
     * @hidden
     */
    _gq(a: ChartType, b: AxisGroup): boolean;
    /**
     * @hidden
     */
    _eh(a: Axis, b?: boolean): AxisPosition;
    /**
     * @hidden
     */
    private _i6;
    /**
     * @hidden
     */
    private _i7;
    /**
     * @hidden
     */
    private _hl;
    /**
     * @hidden
     */
    private _hm;
    /**
     * @hidden
     */
    private static _i2;
    /**
     * @hidden
     */
    private static _ff;
    /**
     * @hidden
     */
    private static _fg;
    /**
     * @hidden
     */
    private static _fe;
    /**
     * @hidden
     */
    private static _ed;
    /**
     * @hidden
     */
    private static _ee;
    /**
     * @hidden
     */
    private static _ea;
    /**
     * @hidden
     */
    private _f2;
    /**
     * @hidden
     */
    private _i3;
    /**
     * @hidden
     */
    private _jj;
    /**
     * @hidden
     */
    private _jl;
    /**
     * @hidden
     */
    private _jm;
    /**
     * @hidden
     */
    private _jo;
    /**
     * @hidden
     */
    private _jp;
    /**
     * @hidden
     */
    private _js;
    /**
     * @hidden
     */
    _jt(): void;
    /**
     * @hidden
     */
    private _jc;
    /**
     * @hidden
     */
    private _jw;
    /**
     * @hidden
     */
    private _ju;
    /**
     * @hidden
     */
    private _jx;
    /**
     * @hidden
     */
    _jy(): void;
    /**
     * @hidden
     */
    private _jh;
    /**
     * @hidden
     */
    private _ji;
    /**
     * @hidden
     */
    private static _i1;
    /**
     * @hidden
     */
    static _f6(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gi(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gj(a: ChartType, b: boolean): {
        ret: boolean;
        p1: boolean;
    };
    /**
     * @hidden
     */
    static _ga(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _gb(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _f5(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _e5(a: SeriesType): ChartType;
    /**
     * @hidden
     */
    static _gy(a: ChartType): boolean;
    /**
     * @hidden
     */
    static _iz(a: ChartType): Nullable$1<MarkerStyle>;
    /**
     * @hidden
     */
    _i9(): void;
    /**
     * @hidden
     */
    static _gw(a: ChartType): boolean;
    /**
     * @hidden
     */
    get chart(): WorksheetChart;
    /**
     * @hidden
     */
    onPropertyChanged(): void;
    /**
     * @hidden
     */
    isReferencingAnythingInRegion(ws: Worksheet, region: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    iterateFormulas(callback: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    onShiftRegion(callback: (arg1: IChartObject, arg2: any) => void, shiftOperation: CellShiftOperation, operationOverride: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    undoChartShift(context: any): any;
    /**
     * @hidden
     */
    verifyFormulas(removedWorksheet: Worksheet): void;
    private _eb;
    private _fw;
    private _i4;
    private _g1;
    private _g2;
    constructor(a: number);
    constructor(a: number, b: UnknownShape);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    _dg(): void;
    /**
     * @hidden
     */
    get _g3(): List$1<Formula>;
    /**
     * @hidden
     */
    set _g3(a: List$1<Formula>);
    /**
     * @hidden
     */
    get _ec(): BinaryData;
    /**
     * @hidden
     */
    set _ec(a: BinaryData);
    /**
     * @hidden
     */
    get _fx(): Excel2007ChartData;
    /**
     * @hidden
     */
    set _fx(a: Excel2007ChartData);
    /**
     * @hidden
     */
    get _g4(): List$1<FontXInfo>;
    /**
     * @hidden
     */
    set _g4(a: List$1<FontXInfo>);
    /**
     * @hidden
     */
    get _i5(): number;
}
/**
 * @hidden
 */
export declare abstract class GenericCacheElementProxy$1<T extends GenericCacheElementEx> extends Base {
    static $t: Type;
    protected $t: Type;
    protected c: T;
    constructor($t: Type, a: number, b: T, c: GenericCachedCollectionEx$1<T>);
    constructor($t: Type, a: number, b: GenericCachedCollectionEx$1<T>);
    constructor($t: Type, a: number, ..._rest: any[]);
    equals(a: any): boolean;
    getHashCode(): number;
    g(a: GenericCachedCollection$1<T>): void;
    a(): GenericCachedCollection$1<T>;
    b(a: boolean): GenericCachedCollection$1<T>;
    h(a: GenericCachedCollection$1<T>): void;
    i(): void;
    protected k(a: T): void;
    private j;
    protected get_d(): T;
    get d(): T;
}
/**
 * @hidden
 */
export declare abstract class WorksheetCellFormatProxy extends GenericCacheElementProxy$1<WorksheetCellFormatData> implements IWorksheetCellFormat {
    static $t: Type;
    private static readonly _ah;
    private static readonly _ag;
    private static readonly _af;
    private _t;
    private _r;
    private _x;
    constructor(a: number, b: WorksheetCellFormatData, c: GenericCachedCollectionEx$1<WorksheetCellFormatData>, d: IWorksheetCellFormatProxyOwner);
    constructor(a: number, b: GenericCachedCollectionEx$1<WorksheetCellFormatData>, c: IWorksheetCellFormatProxyOwner);
    constructor(a: number, ..._rest: any[]);
    private static _am;
    private static _an;
    private static _al;
    private static _aq;
    protected static _m(a: ExcelChangeAction, b: WorksheetPermissions): ChangeInfo[];
    private static _ad;
    private static _ac;
    private _n;
    static _o(a: IWorksheetCellFormat, b: WorksheetCellFormatData): CellFormatValue;
    private static _ae;
    _ai(): Nullable$1<WorksheetCellAddress>;
    _aj(a: CellFormatValue): any;
    static _y(a: IWorksheetCellFormat, b: IWorksheetCellFormat, c: CellFormatValue): boolean;
    _aa(a: CellFormatValue): boolean;
    _ao(a: CellFormatValue, b: CellFormatValueChangedOptions): void;
    _ap(a: CellFormatValue): void;
    _ar(a?: CellFormatValueChangedOptions): void;
    _as(a: CellFormatValue, b: CellFormatValueChangedOptions): void;
    _at(a: Nullable$1<WorksheetCellAddress>): void;
    _a1(a: IWorkbookFont, b: boolean, c: CellFormatValueChangedOptions): void;
    _a2<TValue>($tValue: Type, a: TValue, b: CellFormatValue, c: boolean, d: CellFormatValueChangedOptions, e: (arg1: IWorkbookFont) => TValue, f: (arg1: IWorkbookFont, arg2: TValue) => void): void;
    private _ab;
    setFormatting(a: IWorksheetCellFormat): void;
    _setFormatting1(a: IWorksheetCellFormat, b: CellFormatValueChangedOptions): void;
    _a7(a: IWorksheetCellFormat): void;
    protected _bc(a: IWorksheetCellFormatProxyOwner): void;
    _bk(a: CellFormatValue, b: any): void;
    _bl(a: CellFormatValue, b: any, c: boolean, d: CellFormatValueChangedOptions): void;
    private static _bo;
    private static _bp;
    private static _bq;
    get alignment(): HorizontalCellAlignment;
    set alignment(a: HorizontalCellAlignment);
    _au(a: HorizontalCellAlignment, b: boolean, c: CellFormatValueChangedOptions): void;
    get bottomBorderColorInfo(): WorkbookColorInfo;
    set bottomBorderColorInfo(a: WorkbookColorInfo);
    _av(a: WorkbookColorInfo, b: boolean, c: CellFormatValueChangedOptions): void;
    get bottomBorderStyle(): CellBorderLineStyle;
    set bottomBorderStyle(a: CellBorderLineStyle);
    _aw(a: CellBorderLineStyle, b: boolean, c: CellFormatValueChangedOptions): void;
    get diagonalBorderColorInfo(): WorkbookColorInfo;
    set diagonalBorderColorInfo(a: WorkbookColorInfo);
    _ax(a: WorkbookColorInfo, b: boolean, c: CellFormatValueChangedOptions): void;
    get diagonalBorders(): DiagonalBorders;
    set diagonalBorders(a: DiagonalBorders);
    _ay(a: DiagonalBorders, b: boolean, c: CellFormatValueChangedOptions): void;
    get diagonalBorderStyle(): CellBorderLineStyle;
    set diagonalBorderStyle(a: CellBorderLineStyle);
    _az(a: CellBorderLineStyle, b: boolean, c: CellFormatValueChangedOptions): void;
    get fill(): CellFill;
    set fill(a: CellFill);
    _a0(a: CellFill, b: boolean, c: CellFormatValueChangedOptions): void;
    get font(): IWorkbookFont;
    get formatOptions(): WorksheetCellFormatOptions;
    set formatOptions(a: WorksheetCellFormatOptions);
    get _w(): WorksheetCellFormatOptions;
    private _a4;
    _a3(a: WorksheetCellFormatOptions, b: boolean, c: CellFormatValueChangedOptions): void;
    get formatString(): string;
    set formatString(a: string);
    _a5(a: string, b: boolean, c: CellFormatValueChangedOptions): void;
    get indent(): number;
    set indent(a: number);
    _a8(a: number, b: boolean, c: CellFormatValueChangedOptions): void;
    get leftBorderColorInfo(): WorkbookColorInfo;
    set leftBorderColorInfo(a: WorkbookColorInfo);
    _a9(a: WorkbookColorInfo, b: boolean, c: CellFormatValueChangedOptions): void;
    get leftBorderStyle(): CellBorderLineStyle;
    set leftBorderStyle(a: CellBorderLineStyle);
    _ba(a: CellBorderLineStyle, b: boolean, c: CellFormatValueChangedOptions): void;
    get locked(): boolean | null;
    set locked(a: boolean | null);
    get _locked$i(): Nullable$1<boolean>;
    set _locked$i(a: Nullable$1<boolean>);
    _bb(a: Nullable$1<boolean>, b: boolean, c: CellFormatValueChangedOptions): void;
    get rightBorderColorInfo(): WorkbookColorInfo;
    set rightBorderColorInfo(a: WorkbookColorInfo);
    _bd(a: WorkbookColorInfo, b: boolean, c: CellFormatValueChangedOptions): void;
    get rightBorderStyle(): CellBorderLineStyle;
    set rightBorderStyle(a: CellBorderLineStyle);
    _be(a: CellBorderLineStyle, b: boolean, c: CellFormatValueChangedOptions): void;
    get rotation(): number;
    set rotation(a: number);
    _bf(a: number, b: boolean, c: CellFormatValueChangedOptions): void;
    get shrinkToFit(): boolean | null;
    set shrinkToFit(a: boolean | null);
    get _shrinkToFit$i(): Nullable$1<boolean>;
    set _shrinkToFit$i(a: Nullable$1<boolean>);
    _bg(a: Nullable$1<boolean>, b: boolean, c: CellFormatValueChangedOptions): void;
    get style(): WorkbookStyle;
    set style(a: WorkbookStyle);
    _bh(a: WorkbookStyle, b: boolean, c: CellFormatValueChangedOptions): void;
    get topBorderColorInfo(): WorkbookColorInfo;
    set topBorderColorInfo(a: WorkbookColorInfo);
    _bi(a: WorkbookColorInfo, b: boolean, c: CellFormatValueChangedOptions): void;
    get topBorderStyle(): CellBorderLineStyle;
    set topBorderStyle(a: CellBorderLineStyle);
    _bj(a: CellBorderLineStyle, b: boolean, c: CellFormatValueChangedOptions): void;
    get verticalAlignment(): VerticalCellAlignment;
    set verticalAlignment(a: VerticalCellAlignment);
    _bm(a: VerticalCellAlignment, b: boolean, c: CellFormatValueChangedOptions): void;
    get wrapText(): boolean | null;
    set wrapText(a: boolean | null);
    get _wrapText$i(): Nullable$1<boolean>;
    set _wrapText$i(a: Nullable$1<boolean>);
    _bn(a: Nullable$1<boolean>, b: boolean, c: CellFormatValueChangedOptions): void;
    get _u(): WorkbookFontOwnerAccessor;
    get _z(): boolean;
    get _s(): IWorksheetCellFormatProxyOwner;
    protected abstract get _l(): ChangeInfo[];
    abstract get _q(): ExcelChangeAction;
    protected get__ak(): any;
    get _ak(): any;
    abstract get _v(): Worksheet;
}
/**
 * @hidden
 */
export interface IWorksheetCellFormatProxyContext extends IChangeInfoContext {
    readonly proxy: WorksheetCellFormatProxy;
}
/**
 * @hidden
 */
export declare let IWorksheetCellFormatProxyContext_$type: Type;
/**
 * @hidden
 */
export declare class WorksheetCellFormatProxy_FormatChangeContext extends ValueType implements IWorksheetCellFormatProxyContext {
    static $t: Type;
    constructor(a: number, b: WorksheetCellFormatProxy);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: WorksheetCellFormatProxy;
    readonly a: WorksheetCellFormatOptions;
    readonly c: Nullable$1<WorksheetCellAddress>;
    get proxy(): WorksheetCellFormatProxy;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class WorksheetCellFormatProxy_SetFormattingChangeContext extends ValueType implements IWorksheetCellFormatProxyContext {
    static $t: Type;
    constructor(a: number, b: WorksheetCellFormatProxy);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly c: WorksheetCellFormatProxy;
    readonly b: WorksheetCellFormatOptions;
    readonly a: WorksheetCellFormatData;
    readonly d: Nullable$1<WorksheetCellAddress>;
    get proxy(): WorksheetCellFormatProxy;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class WorksheetCellFormatProxy_SetFontFormattingChangeContext extends ValueType implements IWorksheetCellFormatProxyContext {
    static $t: Type;
    constructor(a: number, b: WorksheetCellFormatProxy);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: WorksheetCellFormatProxy;
    readonly a: WorkbookFontData;
    readonly c: Nullable$1<WorksheetCellAddress>;
    get proxy(): WorksheetCellFormatProxy;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Represents a font for the cell in the related context.
 * <p class="body">
 * If a property of a font has a default value, value of the previous font in resolution chain is used. The resolution priority
 * is the following:
 * <list type="number">
 * <item>Cell (highest priority)</item>
 * <item>Row</item>
 * <item>Column</item>
 * <item>Default Cell Format (lowest priority)</item>
 * </list>
 * For example, if a column font is set to blue and bold and a row font is set to italic and not bold, the font in the cell at
 * the intersection of the row and column would have blue, italic text in the saved workbook.
 * </p>
 */
export interface IWorkbookFont {
    setFontFormatting(source: IWorkbookFont): void;
    bold: boolean | null;
    _bold$i: Nullable$1<boolean>;
    colorInfo: WorkbookColorInfo;
    height: number;
    italic: boolean | null;
    _italic$i: Nullable$1<boolean>;
    name: string;
    strikeout: boolean | null;
    _strikeout$i: Nullable$1<boolean>;
    superscriptSubscriptStyle: FontSuperscriptSubscriptStyle;
    underlineStyle: FontUnderlineStyle;
}
/**
 * @hidden
 */
export declare let IWorkbookFont_$type: Type;
/**
 * @hidden
 */
export declare class WorkbookFontData extends GenericCacheElementEx implements IWorkbookFont {
    static $t: Type;
    static readonly _at: any;
    private _aq;
    private _al;
    private _an;
    private _ai;
    private _ao;
    private _ar;
    private _au;
    private _as;
    private _ag;
    private _ah;
    constructor(a: number, b: Workbook);
    constructor(a: number, b: WorkbookFontData);
    constructor(a: number, b: WorkbookFontData, c: Workbook);
    constructor(a: number, ..._rest: any[]);
    g(a: Workbook): any;
    _aj(a: Workbook): WorkbookFontData;
    aa(a: GenericCacheElement): void;
    equals(a: any): boolean;
    getHashCode(): number;
    c(a: GenericCacheElement): boolean;
    protected af(): void;
    setFontFormatting(a: IWorkbookFont): void;
    _ay(): void;
    _ak(a: IWorkbookFontDefaultsResolver): WorkbookFontData;
    get bold(): boolean | null;
    set bold(a: boolean | null);
    get _bold$i(): Nullable$1<boolean>;
    set _bold$i(a: Nullable$1<boolean>);
    get colorInfo(): WorkbookColorInfo;
    set colorInfo(a: WorkbookColorInfo);
    get height(): number;
    set height(a: number);
    get italic(): boolean | null;
    set italic(a: boolean | null);
    get _italic$i(): Nullable$1<boolean>;
    set _italic$i(a: Nullable$1<boolean>);
    get name(): string;
    set name(a: string);
    get strikeout(): boolean | null;
    set strikeout(a: boolean | null);
    get _strikeout$i(): Nullable$1<boolean>;
    set _strikeout$i(a: Nullable$1<boolean>);
    get superscriptSubscriptStyle(): FontSuperscriptSubscriptStyle;
    set superscriptSubscriptStyle(a: FontSuperscriptSubscriptStyle);
    get underlineStyle(): FontUnderlineStyle;
    set underlineStyle(a: FontUnderlineStyle);
    get _am(): boolean;
}
/**
 * @hidden
 */
export declare class ConditionalFormatOwnedFormatProxy extends WorksheetCellFormatProxy {
    static $t: Type;
    private static readonly _br;
    constructor(a: GenericCachedCollectionEx$1<WorksheetCellFormatData>, b: ConditionalFormatBase);
    g(a: GenericCachedCollection$1<WorksheetCellFormatData>): void;
    b(a: boolean): GenericCachedCollection$1<WorksheetCellFormatData>;
    protected get__l(): ChangeInfo[];
    protected get _l(): ChangeInfo[];
    protected get__q(): ExcelChangeAction;
    get _q(): ExcelChangeAction;
    protected get_d(): WorksheetCellFormatData;
    protected get__v(): Worksheet;
    get _v(): Worksheet;
}
/**
 * Represents a custom view in Microsoft Excel.
 * <p class="body">
 * Custom views provide a way to save display options and optionally print options for the workbook and each worksheet in the workbook.
 * These options can be different from the options currently set on the workbook and worksheets.
 * </p>
 * <p class="body">
 * Multiple custom views can be saved with a workbook, and the options from a custom view can be applied to its associated workbook by
 * calling the [[apply]] method on it.
 * </p>
 * @see [[Workbook.customViews]]
 */
export declare class CustomView extends Base {
    static $t: Type;
    private _i;
    private _s;
    private _m;
    private _k;
    private _u;
    private _b;
    private _o;
    private _q;
    private _r;
    private _p;
    constructor(a: Workbook, b: boolean, c: boolean);
    /**
     * Applies all options from the custom view to the associated workbook and its worksheets.
     * <p class="body">
     * There is no state of the workbook indicating the custom view currently applied, so applying a custom view
     * simply copies over all options saved with it to the workbook and its worksheet. If an applied custom view
     * is then changed, those changes will not be updated on the workbook or worksheets. Instead, the custom view will need
     * to be applied again for those changes to be reflected on the workbook or worksheet.
     * </p>
     * @throws [[InvalidOperationException]] The custom view has previously been removed from its associated workbook.
     */
    apply(): void;
    /**
     * Gets the display options associated with the specified worksheet.
     * <p class="body">
     * Setting properties on the returned [[DisplayOptions]] instance will not change the actual
     * display of the worksheet. After setting properties, the [[apply]] method of the
     * [[CustomView]] will apply them to the worksheet.
     * </p>
     * @param worksheet The worksheet whose associated display options are to be retrieved.
     * @param createIfNull True to create the display options if it has not yet been allocated. The options will be initialized based on the current state of the Worksheet. Note the options should only have been null if there were no options for the Worksheet when the Workbook was loaded.
     * @throws [[ArgumentNullException]] 'worksheet' is null.
     * @return Null if the worksheet does not belong to the workbook associated with this custom view;
     * otherwise, the display options associated with the worksheet.
     * @see [[Worksheet.displayOptions]]
     */
    getDisplayOptions(worksheet: Worksheet, createIfNull?: boolean): CustomViewDisplayOptions;
    /**
     * Gets the display options associated with the specified sheet.
     * <p class="body">
     * Setting properties on the returned [[DisplayOptionsBase]] instance will not change the actual
     * display of the sheet. After setting properties, the [[apply]] method of the
     * [[CustomView]] will apply them to the sheet.
     * </p>
     * @param sheet The sheet whose associated display options are to be retrieved.
     * @param createIfNull True to create the display options if it has not yet been allocated. The options will be initialized based on the current state of the Sheet. Note the options should only have been null if there were no options for the Sheet when the Workbook was loaded.
     * @throws [[ArgumentNullException]] 'sheet' is null.
     * @return Null if the sheet does not belong to the workbook associated with this custom view;
     * otherwise, the display options associated with the worksheet.
     * @see [[Worksheet.displayOptions]]
     * @see [[Chartsheet.displayOptions]]
     */
    getSheetDisplayOptions(sheet: Sheet, createIfNull?: boolean): DisplayOptionsBase;
    /**
     * Gets the hidden columns associated with the specified worksheet.
     * <p class="body">
     * Adding columns on the returned [[HiddenColumnCollection]] instance will not actually hide
     * columns in the worksheet. After modifying the hidden columns in this collection, the [[apply]]
     * method of the [[CustomView]] will hide or unhide the columns.
     * </p>
     * @param worksheet The worksheet whose associated hidden columns are to be retrieved.
     * @param createIfNull True to create the hidden column if it has not yet been allocated of the Worksheet. The options will be initialized based on the current state. Note the options should only have been null if there were no options for the Worksheet when the Workbook was loaded. Also this will not allocate the collection unless the [[saveHiddenRowsAndColumns]] is true.
     * @throws [[ArgumentNullException]] 'worksheet' is null.
     * @return Null if [[saveHiddenRowsAndColumns]] is False or if the worksheet does not belong to the workbook
     * associated with this custom view; otherwise, the collection of hidden columns associated with the worksheet.
     * @see [[RowColumnBase.hidden]]
     * @see [[saveHiddenRowsAndColumns]]
     */
    getHiddenColumns(worksheet: Worksheet, createIfNull?: boolean): HiddenColumnCollection;
    /**
     * Gets the hidden rows associated with the specified worksheet.
     * <p class="body">
     * Adding rows on the returned [[HiddenRowCollection]] instance will not actually hide
     * rows in the worksheet. After modifying the hidden rows in this collection, the [[apply]]
     * method of the [[CustomView]] will hide or unhide the rows.
     * </p>
     * @param worksheet The worksheet whose associated hidden rows are to be retrieved.
     * @param createIfNull True to create the hidden column if it has not yet been allocated. The options will be initialized based on the current state of the Worksheet. Note the options should only have been null if there were no options for the Worksheet when the Workbook was loaded. Also this will not allocate the collection unless the [[saveHiddenRowsAndColumns]] is true.
     * @throws [[ArgumentNullException]] 'worksheet' is null.
     * @return Null if [[saveHiddenRowsAndColumns]] is False or if the worksheet does not belong to the workbook
     * associated with this custom view; otherwise, the collection of hidden rows associated with the worksheet.
     * @see [[RowColumnBase.hidden]]
     * @see [[saveHiddenRowsAndColumns]]
     */
    getHiddenRows(worksheet: Worksheet, createIfNull?: boolean): HiddenRowCollection;
    /**
     * Gets the print options associated with the specified worksheet.
     * <p class="body">
     * Setting properties on the returned [[PrintOptions]] instance will not change the actual
     * print settings of the worksheet. After setting properties, the [[apply]] method of the
     * [[CustomView]] will apply them to the worksheet.
     * </p>
     * @param worksheet The worksheet whose associated print options are to be retrieved.
     * @param createIfNull True to create the print options if it has not yet been allocated. The options will be initialized based on the current state of the Worksheet. Note the options should only have been null if there were no options for the Worksheet when the Workbook was loaded. Also this will not allocate the collection unless the [[savePrintOptions]] is true.
     * @throws [[ArgumentNullException]] 'worksheet' is null.
     * @return Null if [[savePrintOptions]] is False or if the worksheet does not belong to the workbook associated
     * with this custom view; otherwise, the print options associated with the worksheet.
     * @see [[Worksheet.printOptions]]
     * @see [[savePrintOptions]]
     */
    getPrintOptions(worksheet: Worksheet, createIfNull?: boolean): PrintOptions;
    /**
     * Gets the print options associated with the specified sheet.
     * <p class="body">
     * Setting properties on the returned [[PrintOptionsBase]] instance will not change the actual
     * print settings of the sheet. After setting properties, the [[apply]] method of the
     * [[CustomView]] will apply them to the sheet.
     * </p>
     * @param sheet The sheet whose associated print options are to be retrieved.
     * @param createIfNull True to create the print options if it has not yet been allocated. The options will be initialized based on the current state of the Sheet. Note the options should only have been null if there were no options for the Sheet when the Workbook was loaded. Also this will not allocate the collection unless the [[savePrintOptions]] is true.
     * @throws [[ArgumentNullException]] 'sheet' is null.
     * @return Null if [[savePrintOptions]] is False or if the sheet does not belong to the workbook associated
     * with this custom view; otherwise, the print options associated with the sheet.
     * @see [[Worksheet.printOptions]]
     * @see [[Chartsheet.printOptions]]
     * @see [[savePrintOptions]]
     */
    getSheetPrintOptions(sheet: Sheet, createIfNull?: boolean): PrintOptionsBase;
    /**
     * @hidden
     */
    _x(): void;
    /**
     * @hidden
     */
    _y(a: Sheet): void;
    /**
     * @hidden
     */
    _z(a: Sheet): void;
    /**
     * @hidden
     */
    _aa(a: boolean): void;
    /**
     * @hidden
     */
    _ab(a: boolean): void;
    /**
     * @hidden
     */
    _ac(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * Gets or sets the name of the custom view.
     * <p class="body">
     * The name of the custom view is displayed in the custom views dialog of Microsoft Excel and must be
     * case-insensitively unique to other custom views in the workbook.
     * </p>
     * The name of the custom view.
     * @throws [[ArgumentNullException]] The value assigned is a null or empty.
     * @throws [[ArgumentException]] The value assigned is the name of another custom view in this custom view's associated workbook (custom view
     * names are compared case-insensitively).
     */
    get name(): string;
    set name(a: string);
    /**
     * Gets the value indicating whether hidden row and column settings are saved with the custom view.
     * <p class="body">
     * If the value is False, the return value of [[getHiddenColumns]] and [[getHiddenRows]]
     * will always be null, regardless of the worksheet specified.
     * </p>
     * The value indicating whether hidden row and column settings are saved with the custom view.
     * @see [[getHiddenColumns]]
     * @see [[getHiddenRows]]
     * @see [[HiddenColumnCollection]]
     * @see [[HiddenRowCollection]]
     */
    get saveHiddenRowsAndColumns(): boolean;
    /**
     * Gets the value indicating whether print options are saved with the custom view.
     * <p class="body">
     * If the value is False, the return value of [[getPrintOptions]] will always be null,
     * regardless of the worksheet specified.
     * </p>
     * The value indicating whether print options are saved with the custom view.
     * @see [[getPrintOptions]]
     * @see [[PrintOptions]]
     */
    get savePrintOptions(): boolean;
    /**
     * Gets the window options for the workbook associated with the custom view.
     * <p class="body">
     * Setting properties on the returned [[windowOptions]] instance will not change the actual
     * window options of the associated workbook. After setting properties, the [[apply]] method
     * of the [[CustomView]] will apply them to the workbook.
     * </p>
     * The window options for the workbook associated with the custom view..
     * @see */
    get windowOptions(): CustomViewWindowOptions;
    /**
     * @hidden
     */
    get _t(): Guid;
    /**
     * @hidden
     */
    set _t(a: Guid);
    /**
     * @hidden
     */
    get _j(): Workbook;
}
/**
 * Abstract base class which exposes the various display options available for a sheet which can be
 * saved with both a sheet and its custom view.
 * <p class="body">
 * This class provides a way to control how a sheet is displayed when it is viewed in Microsoft Excel.
 * </p>
 */
export declare abstract class DisplayOptionsBase extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _l;
    /**
     * @hidden
     */
    private static readonly _m;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static readonly _a;
    private _f;
    private _h;
    constructor(a: Sheet);
    /**
     * Resets the display options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank sheet.
     * </p>
     */
    reset(): void;
    /**
     * Resets the display options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank sheet.
     * </p>
     */
    protected resetCore(): void;
    /**
     * @hidden
     */
    _d(): DisplayOptionsBase;
    /**
     * @hidden
     */
    abstract _e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    _n(a: DisplayOptionsBase): void;
    /**
     * @hidden
     */
    _o(): void;
    /**
     * @hidden
     */
    _p(a: WorksheetVisibility, b: WorksheetVisibility): void;
    /**
     * @hidden
     */
    _s(a: DisplayOptionsBase): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * Gets or sets the visibility of the sheet.
     * <p class="body">
     * The visibility determines whether the sheet's tab will appear in the tab bar at the
     * bottom of Microsoft Excel.
     * </p>
     * The visibility of the worksheet.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[WorksheetVisibility]] enumeration.
     */
    get visibility(): WorksheetVisibility;
    set visibility(a: WorksheetVisibility);
    /**
     * @hidden
     */
    abstract get _j(): boolean;
    /**
     * @hidden
     */
    get _sheet(): Sheet;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
}
/**
 * Abstract base class which exposes the various display options available for a worksheet which can be
 * saved with both a worksheet and a custom view.
 * <p class="body">
 * This class provides a way to control how a worksheet is displayed when it is viewed in Microsoft Excel.
 * </p>
 * @see [[CustomViewDisplayOptions]]
 * @see [[WorksheetDisplayOptions]]
 */
export declare abstract class DisplayOptions extends DisplayOptionsBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _a4: number;
    /**
     * @hidden
     */
    static readonly _a5: number;
    /**
     * @hidden
     */
    static readonly _a3: number;
    /**
     * @hidden
     */
    private static readonly _a6;
    /**
     * @hidden
     */
    private static readonly _ba;
    /**
     * @hidden
     */
    private static readonly _bb;
    /**
     * @hidden
     */
    private static readonly _bc;
    /**
     * @hidden
     */
    private static readonly _bd;
    /**
     * @hidden
     */
    private static readonly _be;
    /**
     * @hidden
     */
    private static readonly _bf;
    /**
     * @hidden
     */
    private static readonly _bg;
    /**
     * @hidden
     */
    private static readonly _bh;
    /**
     * @hidden
     */
    private static readonly _bi;
    /**
     * @hidden
     */
    private static readonly _bj;
    /**
     * @hidden
     */
    private static readonly _a9;
    /**
     * @hidden
     */
    private static readonly _t;
    private _ac;
    private _w;
    private _a1;
    private _a7;
    private _aj;
    private _bk;
    private _bm;
    private _ap;
    private _ar;
    private _at;
    private _av;
    private _ax;
    private _az;
    private _aa;
    private _ag;
    private _ae;
    private _y;
    constructor(a: Worksheet);
    /**
     * Resets the display options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    protected resetCore(): void;
    /**
     * @hidden
     */
    _n(a: DisplayOptionsBase): void;
    /**
     * @hidden
     */
    _bq(a: WorksheetView): void;
    /**
     * @hidden
     */
    private static _v;
    /**
     * @hidden
     */
    private static _u;
    /**
     * Gets the settings which control the frozen panes in the worksheet.
     * <p class="body">
     * For these settings to be saved in the workbook file, [[panesAreFrozen]] must be True.
     * </p>
     * <p class="note">
     * <B>Note:</B> Frozen and unfrozen panes cannot be used simultaneously, so depending on whether the panes are
     * frozen or unfrozen, these settings may not be used.
     * </p>
     * The settings which control the frozen panes in the worksheet..
     * @see [[panesAreFrozen]]
     * @see [[unfrozenPaneSettings]]
     */
    get frozenPaneSettings(): FrozenPaneSettings;
    /**
     * Gets or sets the color of the gridlines on the worksheet.
     * <p class="body">
     * If the workbook is using a standard palette, the color set may be changed if it is not in the palette.
     * In this case, the closest color in the standard palette will be used.
     * </p>
     * The color of the gridlines on the worksheet.
     * @throws [[InvalidOperationException]] The workbook is using a custom palette and setting this color would cause the custom palette to use
     * too many colors.
     */
    get gridlineColor(): string | Color;
    set gridlineColor(a: string | Color);
    /**
     * @hidden
     */
    get _gridlineColor$i(): Color;
    /**
     * @hidden
     */
    set _gridlineColor$i(a: Color);
    /**
     * @hidden
     */
    private _bp;
    /**
     * Gets or sets the value which indicates if the panes in the worksheet are frozen.
     * <p class="body">
     * Depending on the value of this property, either the [[frozenPaneSettings]] or the
     * [[unfrozenPaneSettings]] will be used for the worksheet. The unused settings are
     * ignored and are not saved with the workbook stream.
     * </p>
     * The value which indicates if the panes in the worksheet are frozen.
     * @see [[frozenPaneSettings]]
     * @see [[unfrozenPaneSettings]]
     */
    get panesAreFrozen(): boolean;
    set panesAreFrozen(a: boolean);
    /**
     * Gets or sets the value which indicates whether the expansion indicators should be shown below grouped,
     * or indented rows.
     */
    get showExpansionIndicatorBelowGroupedRows(): boolean | null;
    set showExpansionIndicatorBelowGroupedRows(a: boolean | null);
    /**
     * @hidden
     */
    get _showExpansionIndicatorBelowGroupedRows$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _showExpansionIndicatorBelowGroupedRows$i(a: Nullable$1<boolean>);
    /**
     * Gets or sets the value which indicates whether the expansion indicators should be shown to the right of
     * grouped, or indented rows.
     */
    get showExpansionIndicatorToRightOfGroupedColumns(): boolean | null;
    set showExpansionIndicatorToRightOfGroupedColumns(a: boolean | null);
    /**
     * @hidden
     */
    get _showExpansionIndicatorToRightOfGroupedColumns$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _showExpansionIndicatorToRightOfGroupedColumns$i(a: Nullable$1<boolean>);
    /**
     * Gets or sets the value which indicates whether formulas are shown in cells.
     * <p class="body">
     * If this value is True, the formula string will be displayed in the cell. If the value is
     * False, the result of the formula will be displayed in the cell.
     * </p>
     * The value which indicates whether formulas are shown in cells.
     */
    get showFormulasInCells(): boolean;
    set showFormulasInCells(a: boolean);
    /**
     * Gets or sets the value which indicates whether gridlines are shown between cells.
     * The value which indicates whether gridlines are shown between cells.
     * @see [[PrintOptions.printGridlines]]
     */
    get showGridlines(): boolean;
    set showGridlines(a: boolean);
    /**
     * Gets or sets the value which indicates whether outline symbols are shown for outlined columns and rows.
     * <p class="body">
     * If the outline symbols are displayed, they provide a visual representation of the outline levels or rows
     * and columns in Microsoft Excel.  In addition, the outline symbols include the expansion indicators which
     * allow for the expanding and collapsing of outline groups.
     * </p>
     * The value which indicates whether outline symbols are shown for outlined columns and rows.
     * @see [[RowColumnBase.outlineLevel]]
     */
    get showOutlineSymbols(): boolean;
    set showOutlineSymbols(a: boolean);
    /**
     * Gets or sets the value which indicates whether to display row and column headers.
     * <p class="body">
     * The row and column headers show the identifier of the row or column. They also allow the user to easily select
     * all cells in a row or column by clicking them.
     * </p>
     * The value which indicates whether to display row and column headers.
     * @see [[PrintOptions.printRowAndColumnHeaders]]
     */
    get showRowAndColumnHeaders(): boolean;
    set showRowAndColumnHeaders(a: boolean);
    /**
     * Gets or sets the value which indicates whether to show rulers in the page layout view.
     * <p class="body">
     * When this value is True, one ruler will display above the column headers of the active page
     * in page layout view. Another ruler will also display before the row headers of the active page.
     * </p>
     * <p class="note">
     * <b>Note:</b> This property will only affect the worksheet view if the [[view]] is
     * PageLayout.
     * </p>
     * <p class="note">
     * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
     * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will
     * default to Normal view.
     * </p>
     * The value which indicates whether to show rulers in the page layout view.
     * @see [[view]]
     */
    get showRulerInPageLayoutView(): boolean;
    set showRulerInPageLayoutView(a: boolean);
    /**
     * Gets or sets the value which indicates whether zero values are shown in cells.
     * <p class="body">
     * If this value is True, cells with a value of zero will display their values; otherwise,
     * those cells will display as blanks.
     * </p>
     * The value which indicates whether zero values are shown in cells.
     */
    get showZeroValues(): boolean;
    set showZeroValues(a: boolean);
    /**
     * Gets the settings which control the unfrozen panes in the worksheet.
     * <p class="body">
     * For these settings to be saved in the workbook file, [[panesAreFrozen]] must be False.
     * </p>
     * <p class="note">
     * <B>Note:</B> Frozen and unfrozen panes cannot be used simultaneously, so depending on whether the panes are
     * frozen or unfrozen, these settings may not be used.
     * </p>
     * The settings which control the unfrozen panes in the worksheet.
     * @see [[panesAreFrozen]]
     * @see [[frozenPaneSettings]]
     */
    get unfrozenPaneSettings(): UnfrozenPaneSettings;
    /**
     * Gets or sets the current view of the worksheet.
     * <p class="body">
     * The view determines the overall display of the worksheet in Microsoft Excel.
     * </p>
     * <p class="note">
     * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
     * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will
     * default to Normal view.
     * </p>
     * The current view of the worksheet.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the WorksheetView enumeration.
     * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
     * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
     * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
     * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
     */
    get view(): WorksheetView;
    set view(a: WorksheetView);
    /**
     * @hidden
     */
    get _z(): PaneLocation;
    /**
     * @hidden
     */
    set _z(a: PaneLocation);
    /**
     * @hidden
     */
    get _a8(): number;
    /**
     * @hidden
     */
    set _a8(a: number);
    /**
     * @hidden
     */
    get _ai(): boolean;
    /**
     * @hidden
     */
    get _af(): WorksheetSelection;
    /**
     * @hidden
     */
    get _an(): boolean;
    /**
     * @hidden
     */
    get _ao(): boolean;
    /**
     * @hidden
     */
    get _a2(): boolean;
    /**
     * @hidden
     */
    set _a2(a: boolean);
    /**
     * @hidden
     */
    get _ad(): Worksheet;
    /**
     * Removes any saved selection information.
     */
    clearSelection(): void;
    /**
     * @hidden
     */
    _o(): void;
    /**
     * @hidden
     */
    _al(): boolean;
    /**
     * @hidden
     */
    _am(): boolean;
    /**
     * @hidden
     */
    _br(): void;
}
/**
 * Class which exposes the worksheet display options which can only be controlled through the custom view.
 * @see [[CustomView.getDisplayOptions]]
 * @see [[WorksheetDisplayOptions]]
 */
export declare class CustomViewDisplayOptions extends DisplayOptions {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _bz;
    /**
     * @hidden
     */
    private static readonly _b0;
    /**
     * @hidden
     */
    private static readonly _bt;
    private _bx;
    /**
     * @hidden
     */
    readonly _bw: CustomView;
    constructor(a: Worksheet, b: CustomView);
    /**
     * @hidden
     */
    _e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    _n(a: DisplayOptionsBase): void;
    /**
     * @hidden
     */
    protected get__j(): boolean;
    /**
     * @hidden
     */
    get _j(): boolean;
    /**
     * Resets the display options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    protected resetCore(): void;
    /**
     * @hidden
     */
    private static _bv;
    /**
     * @hidden
     */
    private static _bu;
    /**
     * Gets or sets the magnification level of the worksheet in the current [[DisplayOptions.view]].
     * <p class="body">
     * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
     * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
     * </p>
     * The magnification level of the worksheet in the current View.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
     * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
     * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
     * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
     */
    get magnificationInCurrentView(): number;
    set magnificationInCurrentView(a: number);
}
/**
 * A collection of [[CustomView]] instances in a workbook.
 */
export declare class CustomViewCollection extends Base implements IList$1<CustomView> {
    static $t: Type;
    private _d;
    private _h;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    add(item: CustomView): void;
    /**
     * Adds a new custom view to the collection.
     * @param name The name to give the newly created custom view.
     * @param savePrintOptions True to save print options for each worksheet with the custom view; False otherwise.
     * @param saveHiddenRowsAndColumns True to save information about hidden rows and columns for each worksheet with the custom view; False otherwise.
     * @throws [[ArgumentNullException]] 'name' is a null or empty.
     * @throws [[ArgumentException]] 'name' is the name of another custom view in the collection (custom view names are compared
     * case-insensitively).
     * @return The newly created [[CustomView]] instance.
     */
    add(name: string, savePrintOptions: boolean, saveHiddenRowsAndColumns: boolean): CustomView;
    /**
     * @hidden
     */
    _add$e(a: CustomView): void;
    /**
     * @hidden
     */
    copyTo(array: CustomView[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    remove(item: CustomView): boolean;
    [Symbol.iterator](): EnumeratorWrapper<CustomView>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<CustomView>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    insert(index: number, item: CustomView): void;
    /**
     * @hidden
     */
    item(index: number, value?: CustomView): CustomView;
    /**
     * Gets the custom view at the specified index.
     * The custom view at the specified index.
     * @param index The zero-based index of the custom view to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    item(index: number): CustomView;
    /**
     * @hidden
     */
    _item$e(a: number, b?: CustomView): CustomView;
    /**
     * @hidden
     */
    indexOf(item: CustomView): number;
    /**
     * @hidden
     */
    _add(a: string, b: boolean, c: boolean): CustomView;
    /**
     * @hidden
     */
    _add1(a: CustomView): void;
    /**
     * Clears all custom views from the collection.
     */
    clear(): void;
    /**
     * Determines whether a custom view is in this collection.
     * @param customView The custom view to locate in the collection.
     * @return True if the custom view is found; False otherwise.
     */
    contains(customView: CustomView): boolean;
    /**
     * Removes the specified custom view from the collection.
     * @param customView The custom view to remove from the collection.
     * @return True if the custom view was successfully removed; False if the custom view was not
     * in the collection.
     */
    remove_1(customView: CustomView): boolean;
    /**
     * Removes the custom view at the specified index from the collection.
     * @param index The zero-based index of the custom view in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * Gets the number of custom views in the collection.
     * The number of custom views in the collection.
     */
    get count(): number;
    /**
     * @hidden
     */
    _item1(a: number): CustomView;
    /**
     * @hidden
     */
    _item(a: Guid): CustomView;
    /**
     * @hidden
     */
    get _e(): Workbook;
}
/**
 * Abstract base class which exposes the various workbook window options available which can be saved with
 * both a workbook and a custom view.
 * <p class="body">
 * This class provides a way to control how a workbook is displayed when it is viewed in Microsoft Excel.
 * </p>
 * @see [[CustomViewWindowOptions]]
 * @see [[WorkbookWindowOptions]]
 */
export declare abstract class WindowOptions extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _r: number;
    /**
     * @hidden
     */
    private static readonly _u;
    /**
     * @hidden
     */
    private static readonly _t;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _x;
    /**
     * @hidden
     */
    private static readonly _aa;
    /**
     * @hidden
     */
    private static readonly _s;
    /**
     * @hidden
     */
    private static readonly _a;
    private _l;
    private _e;
    private _g;
    private _i;
    private _p;
    private _y;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    abstract _d(a: Sheet): DisplayOptionsBase;
    /**
     * Resets the window options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank workbook.
     * </p>
     */
    reset(): void;
    /**
     * @hidden
     */
    _ab(a: WindowOptions, b: boolean): void;
    /**
     * @hidden
     */
    _ad(): void;
    /**
     * @hidden
     */
    _ae(a: Sheet, b: boolean): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _af;
    /**
     * Gets or sets the way the objects and shapes are displayed in the workbook.
     * The way the objects and shapes are displayed in the workbook.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[objectDisplayStyle]] enumeration.
     * @see [[WorksheetShape]]
     * @see [[Worksheet.shapes]]
     */
    get objectDisplayStyle(): ObjectDisplayStyle;
    set objectDisplayStyle(a: ObjectDisplayStyle);
    /**
     * Gets or sets the scroll bars shown in the workbook window.
     * <p class="body">
     * The vertical scroll bar occupies the entire height of the application if it is visible.
     * </p>
     * <p class="body">
     * The horizontal scroll bar occupies the width of the application not used by the worksheet
     * tab bar, if it is visible. Otherwise, it occupies the entire width of the application.
     * </p>
     * The scroll bars shown in the workbook window.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[scrollBars]] enumeration.
     * @see [[tabBarWidth]]
     * @see [[tabBarVisible]]
     */
    get scrollBars(): ScrollBars;
    set scrollBars(a: ScrollBars);
    /**
     * Gets or sets the selected worksheet of the workbook.
     * <p class="body">
     * If this is an instance of [[CustomViewWindowOptions]] and the SelectedWorksheet value is null, the
     * workbook's selected worksheet will not be changed when the associated [[CustomView]] is applied.
     * </p>
     * <p class="note">
     * <B>Note:</B> If the selected worksheet does not have its [[DisplayOptionsBase.visibility]] set to Visible
     * when the workbook is saved, another worksheet will be selected.
     * </p>
     * The selected worksheet of the workbook.
     * @throws [[ArgumentNullException]] The assigned value is null and this is an instance of [[WorkbookWindowOptions]] whose associated
     * [[workbook]] has at least one [[Worksheet]].
     * @throws [[ArgumentException]] The assigned value does not belong to the workbook associated with this instance of [[WindowOptions]].
     */
    get selectedSheet(): Sheet;
    set selectedSheet(a: Sheet);
    /**
     * @hidden
     */
    get _k(): Sheet;
    /**
     * Gets or sets the selected worksheet of the workbook.
     * <p class="body">
     * If this is an instance of [[CustomViewWindowOptions]] and the SelectedWorksheet value is null, the
     * workbook's selected worksheet will not be changed when the associated [[CustomView]] is applied.
     * </p>
     * <p class="note">
     * <B>Note:</B> If the selected worksheet does not have its [[DisplayOptionsBase.visibility]] set to Visible
     * when the workbook is saved, another worksheet will be selected.
     * </p>
     * The selected worksheet of the workbook.
     * @throws [[ArgumentNullException]] The assigned value is null and this is an instance of [[WorkbookWindowOptions]] whose associated
     * [[workbook]] has at least one [[Worksheet]].
     * @throws [[ArgumentException]] The assigned value does not belong to the workbook associated with this instance of [[WindowOptions]].
     */
    get selectedWorksheet(): Worksheet;
    set selectedWorksheet(a: Worksheet);
    /**
     * Gets or sets the value indicating whether the worksheet tab bar is visible.
     * <p class="body">
     * If the value is False, the [[tabBarWidth]] will not be used, but it will still
     * be serialized with the workbook.
     * </p>
     * The value indicating whether the worksheet tab bar is visible.
     * @see [[tabBarWidth]]
     * @see [[WorkbookWindowOptions.firstVisibleTabIndex]]
     */
    get tabBarVisible(): boolean;
    set tabBarVisible(a: boolean);
    /**
     * Gets or sets the width of the worksheet tab bar, expressed in 1/1000ths of the application width.
     * <p class="body">
     * This value is only used if [[tabBarVisible]] is True. Regardless of whether the tab bar is
     * visible, the width value is always saved with the workbook.
     * </p>
     * <p class="body">
     * A value of 1000 indicates the worksheet tab bar occupies the entire width of the application, while
     * a value of 0 indicates the worksheet tab bar has no width.
     * </p>
     * <p class="body">
     * All space not occupied by the worksheet tab bar will be used by the horizontal scroll bar, if it is visible.
     * </p>
     * The width of the worksheet tab bar, expressed in 1/1000ths of the application width.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 1000.
     * @see [[tabBarVisible]]
     * @see [[scrollBars]]
     * @see [[WorkbookWindowOptions.firstVisibleTabIndex]]
     */
    get tabBarWidth(): number;
    set tabBarWidth(a: number);
    /**
     * @hidden
     */
    abstract get _o(): boolean;
    /**
     * @hidden
     */
    get _workbook(): Workbook;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
}
/**
 * Represents the workbook window options which are saved with custom views.
 * <p class="body">
 * The properties explicitly defined on this class and not inherited from the base class,
 * [[WindowOptions]], are options that can be saved with a custom view, but
 * not with a workbook. Therefore, these properties will not be applied when the
 * [[CustomView.apply]] method is called.
 * </p>
 * @see [[CustomView.windowOptions]]
 * @see [[WorkbookWindowOptions]]
 */
export declare class CustomViewWindowOptions extends WindowOptions {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ar: Rect;
    private _ag;
    private _ap;
    private _ah;
    private _aj;
    private _al;
    private _an;
    constructor(a: CustomView);
    /**
     * @hidden
     */
    protected get__o(): boolean;
    /**
     * @hidden
     */
    get _o(): boolean;
    /**
     * @hidden
     */
    _d(a: Sheet): DisplayOptionsBase;
    /**
     * Resets the window options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank workbook.
     * </p>
     */
    reset(): void;
    /**
     * Gets or sets the pixel bounds of the workbook's MDI child window when [[CustomView]]
     * owning these window options is applied.
     * <p class="note">
     * <b>Note:</b> This property will have no affect on the workbook if [[maximized]] is True. However, in this case,
     * the value of this property will still be saved with the workbook.
     * </p>
     * <p class="note">
     * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
     * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
     * calling  on the associated CustomView will not apply this property. Only by
     * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
     * </p>
     * The pixel bounds of the workbook's MDI child window when CustomView owning these
     * window options is applied.
     * @throws [[ArgumentException]] The left or top of the value assigned is outside the bounds of -32768 and 32767.
     * @throws [[ArgumentException]] The width or height of the value assigned is outside the bounds of 0 and 65535.
     * @see [[CustomView.apply]]
     */
    get boundsInPixels(): IgRect;
    set boundsInPixels(a: IgRect);
    /**
     * @hidden
     */
    get _boundsInPixels$i(): Rect;
    /**
     * @hidden
     */
    set _boundsInPixels$i(a: Rect);
    /**
     * Gets or sets the value indicating whether the workbook's MDI child window will be maximized
     * when the [[CustomView]] owning these window options is applied.
     * <p class="note">
     * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
     * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
     * calling  on the associated CustomView will not apply this property. Only by
     * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
     * </p>
     * The value indicating whether the workbook's MDI child window will be maximized when the CustomView owning these
     * window options is applied.
     * @see [[CustomView.apply]]
     * @see [[WorkbookWindowOptions.minimized]]
     */
    get maximized(): boolean;
    set maximized(a: boolean);
    /**
     * Gets or sets the value indicating whether Microsoft Excel will display the formula bar when
     * the [[CustomView]] owning these window options is applied.
     * <p class="note">
     * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
     * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
     * calling [[CustomView.apply]] on the associated CustomView will not apply this property. Only by
     * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
     * </p>
     * The value indicating whether Microsoft Excel will display the formula bar when the CustomView owning these window
     * options is applied.
     * @see [[CustomView.apply]]
     */
    get showFormulaBar(): boolean;
    set showFormulaBar(a: boolean);
    /**
     * Gets or sets the value indicating whether Microsoft Excel will display the status bar when
     * the [[CustomView]] owning these window options is applied.
     * <p class="note">
     * <b>Note:</b> This setting cannot be saved with a [[Workbook]] in the Excel file. It can only be saved
     * with a CustomView. Therefore, there is no corresponding property in [[WorkbookWindowOptions]] and
     * calling  on the associated CustomView will not apply this property. Only by
     * applying the custom view through the Microsoft Excel user interface will the setting on this property be applied.
     * </p>
     * The value indicating whether Microsoft Excel will display the status bar when the CustomView owning these window
     * options is applied.
     * @see [[CustomView.apply]]
     */
    get showStatusBar(): boolean;
    set showStatusBar(a: boolean);
    /**
     * @hidden
     */
    get _ao(): number;
    /**
     * @hidden
     */
    set _ao(a: number);
}
/**
 * Base class for all data validations rules which can be applied to a cell.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[AnyValueDataValidationRule]]
 * @see [[ListDataValidationRule]]
 * @see [[CustomDataValidationRule]]
 * @see [[OneConstraintDataValidationRule]]
 * @see [[TwoConstraintDataValidationRule]]
 */
export declare abstract class DataValidationRule extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _aa;
    /**
     * @hidden
     */
    private static readonly _ab;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _a;
    private _aj;
    private _al;
    private _d;
    private _an;
    private _ap;
    private _i;
    private _v;
    private _x;
    private _f;
    constructor();
    /**
     * Creates a copy of this rule which can be applied to other worksheets.
     */
    clone(): DataValidationRule;
    /**
     * @hidden
     */
    abstract _n(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    abstract _o(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    abstract _at(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    abstract _au(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    abstract _z(a: WorksheetCellAddress): boolean;
    /**
     * @hidden
     */
    abstract _aw(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    static _s(a: Formula, b: Formula): boolean;
    /**
     * @hidden
     */
    static _t(a: string, b: string): boolean;
    /**
     * Indicates if this rule is structurally equivalent to another.
     * @param other The rule to compare against
     * @return Returns true if the specified 'other' has the same settings as this rule.
     */
    isEquivalentTo(other: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _ar(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _as(): void;
    /**
     * @hidden
     */
    _av(a: string, b: string, c: number): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    abstract get _r(): boolean;
    /**
     * @hidden
     */
    abstract set _r(a: boolean);
    /**
     * @hidden
     */
    abstract get _l(): DataValidationOperatorType;
    /**
     * @hidden
     */
    abstract get _m(): DataValidationType;
    /**
     * Gets or sets the description which appears in the dialog box when an invalid value is applied to a cell
     * in Microsoft Excel.
     * <p class="body">
     * This value is only used when [[showErrorMessageForInvalidValue]] is True.
     * </p>
     * <p class="note">
     * <b>Note:</b> the title cannot be more than 225 characters.
     * </p>
     * The description to show the user or null to use a default error description.
     * @throws [[ArgumentException]] Occurs when the specified value is longer than 225 characters.
     * @see [[errorMessageTitle]]
     */
    get errorMessageDescription(): string;
    set errorMessageDescription(a: string);
    /**
     * Gets or sets the title which appears in the dialog box when an invalid value is applied to a cell
     * in Microsoft Excel.
     * <p class="body">
     * This value is only used when [[showErrorMessageForInvalidValue]] is True.
     * </p>
     * <p class="note">
     * <b>Note:</b> the title cannot be more than 32 characters.
     * </p>
     * The title to show the user or null to use a default error dialog title.
     * @throws [[ArgumentException]] Occurs when the specified value is longer than 32 characters.
     * @see [[errorMessageDescription]]
     */
    get errorMessageTitle(): string;
    set errorMessageTitle(a: string);
    /**
     * Gets or sets the value which indicates whether the value is allowed when it is invalid and which options are given to
     * the user in the error dialog shown by Microsoft Excel.
     * <p class="body">
     * This value is only used when [[showErrorMessageForInvalidValue]] is True.
     * </p>
     * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[DataValidationErrorStyle]] enumeration.
     * @see [[showErrorMessageForInvalidValue]]
     */
    get errorStyle(): DataValidationErrorStyle;
    set errorStyle(a: DataValidationErrorStyle);
    /**
     * Gets or sets the description of the Japanese input rules.
     * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[DataValidationImeMode]] enumeration.
     */
    get imeMode(): DataValidationImeMode;
    set imeMode(a: DataValidationImeMode);
    /**
     * Gets or sets the description in the tooltip which appears when the user selects the cell in Microsoft Excel.
     * <p class="body">
     * This value is only used when [[showInputMessage]] is True.
     * </p>
     * <p class="note">
     * <b>Note:</b> the description cannot be more than 255 characters.
     * </p>
     * The description to show the user in the tooltip.
     * @throws [[ArgumentException]] Occurs when the specified value is longer than 255 characters.
     * @see [[inputMessageTitle]]
     */
    get inputMessageDescription(): string;
    set inputMessageDescription(a: string);
    /**
     * Gets or sets the title in the tooltip which appears when the user selects the cell in Microsoft Excel.
     * <p class="body">
     * This value is only used when [[showInputMessage]] is True.
     * </p>
     * <p class="note">
     * <b>Note:</b> the title cannot be more than 32 characters.
     * </p>
     * The title to show the user in the tooltip.
     * @throws [[ArgumentException]] Occurs when the specified value is longer than 32 characters.
     * @see [[inputMessageDescription]]
     */
    get inputMessageTitle(): string;
    set inputMessageTitle(a: string);
    /**
     * Gets or sets the value which indicates whether the error dialog should appear in Microsoft Excel when invalid data
     * is entered in the cell.
     * <p class="body">
     * When the value is False, invalid data can be entered into cells, but when the user chooses to subsequently circle
     * invalid values in Microsoft Excel, the cell will be circled.
     * </p>
     * True to show the error dialog for invalid cell data; False otherwise.
     * @see [[errorMessageDescription]]
     * @see [[errorMessageTitle]]
     * @see [[errorStyle]]
     */
    get showErrorMessageForInvalidValue(): boolean;
    set showErrorMessageForInvalidValue(a: boolean);
    /**
     * Gets or sets the value which indicates whether to show the user an input prompt tooltip when the user selects
     * the cell in Microsoft Excel.
     * <p class="body">
     * The input prompt will only be shown if this value is True and the [[inputMessageDescription]] is not null.
     * </p>
     * @see [[inputMessageDescription]]
     * @see [[inputMessageTitle]]
     */
    get showInputMessage(): boolean;
    set showInputMessage(a: boolean);
    /**
     * @hidden
     */
    protected get__k(): FormulaType;
    /**
     * @hidden
     */
    get _k(): FormulaType;
    /**
     * @hidden
     */
    get _j(): DataValidationRuleCollection;
    /**
     * @hidden
     */
    get _workbook(): Workbook;
    /**
     * @hidden
     */
    get _q(): Worksheet;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
}
/**
 * Represents a data validation rule which allows any value to be set on the target cells.
 * This would be used to provide an input message to the user when the cell was selected.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 */
export declare class AnyValueDataValidationRule extends DataValidationRule {
    static $t: Type;
    constructor();
    /**
     * @hidden
     */
    protected get__r(): boolean;
    /**
     * @hidden
     */
    protected set__r(a: boolean): void;
    /**
     * @hidden
     */
    get _r(): boolean;
    /**
     * @hidden
     */
    set _r(a: boolean);
    /**
     * @hidden
     */
    _n(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    _o(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    protected get__l(): DataValidationOperatorType;
    /**
     * @hidden
     */
    get _l(): DataValidationOperatorType;
    /**
     * @hidden
     */
    _at(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _au(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _z(a: WorksheetCellAddress): boolean;
    /**
     * @hidden
     */
    protected get__m(): DataValidationType;
    /**
     * @hidden
     */
    get _m(): DataValidationType;
    /**
     * @hidden
     */
    _aw(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
}
/**
 * Base class for all data validations rules which prevent certain values form being applied to a cell.
 * @see [[ListDataValidationRule]]
 * @see [[CustomDataValidationRule]]
 * @see [[OneConstraintDataValidationRule]]
 * @see [[TwoConstraintDataValidationRule]]
 */
export declare abstract class LimitedValueDataValidationRule extends DataValidationRule {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _bd;
    /**
     * @hidden
     */
    private static readonly _be;
    /**
     * @hidden
     */
    private static readonly _ax;
    private _a6;
    constructor();
    /**
     * @hidden
     */
    protected get__r(): boolean;
    /**
     * @hidden
     */
    protected set__r(a: boolean): void;
    /**
     * @hidden
     */
    get _r(): boolean;
    /**
     * @hidden
     */
    set _r(a: boolean);
    /**
     * Indicates if this rule is structurally equivalent to another.
     * @param other The rule to compare against
     * @return Returns true if the specified 'other' has the same settings as this rule.
     */
    isEquivalentTo(other: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _z(a: WorksheetCellAddress): boolean;
    /**
     * @hidden
     */
    _az(a: SingleTargetFormula, b: WorksheetCellAddress, c?: boolean): ExcelCalcValue;
    /**
     * @hidden
     */
    _bg(a: SingleTargetFormula, b: WorksheetReferenceCollection): {
        p0?: SingleTargetFormula;
    };
    /**
     * @hidden
     */
    _a9(a: FormulaToken, b: boolean, c: boolean, d: boolean, e: WorkbookFormat): boolean;
    /**
     * @hidden
     */
    static _ba(a: FormulaToken, b: boolean, c: boolean, d: boolean): boolean;
    /**
     * @hidden
     */
    _bf(a: () => string, b: WorkbookFormat): Nullable$1<LimitedValueDataValidationRule_FormulaChangeContext>;
    /**
     * @hidden
     */
    _bh(a: ChangeInfo$2<LimitedValueDataValidationRule_FormulaChangeContext, string>, b: LimitedValueDataValidationRule_FormulaChangeContext, c: string): void;
    /**
     * @hidden
     */
    _a2(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): SingleTargetFormula;
    /**
     * @hidden
     */
    _a4(a: SingleTargetFormula, b: string, c: WorkbookFormat, d: CellReferenceMode, e: CultureInfo, f: boolean): SingleTargetFormula;
    /**
     * @hidden
     */
    private _a3;
    /**
     * @hidden
     */
    abstract _bb(a: WorksheetCellAddress, b: any): boolean;
    /**
     * @hidden
     */
    _bi(a: SingleTargetFormula, b: DataValidationRuleCollection, c: WorksheetReferenceCollection, d: string, e: boolean, f: boolean, g: WorkbookFormat): void;
    /**
     * @hidden
     */
    private static _bj;
    /**
     * @hidden
     */
    private static _a1;
    /**
     * @hidden
     */
    private static _ay;
    /**
     * @hidden
     */
    private static _a8;
    /**
     * Gets or sets the value which indicates whether a null, or blank, value is allowed to be set on a cell.
     * True if a null value can be set on the cell; False otherwise.
     */
    get allowNull(): boolean;
    set allowNull(a: boolean);
    /**
     * @hidden
     */
    get _a0(): CellReferenceMode;
    /**
     * @hidden
     */
    get _bc(): CultureInfo;
    /**
     * @hidden
     */
    get _a5(): WorkbookFormat;
}
/**
 * @hidden
 */
export declare class LimitedValueDataValidationRule_FormulaChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: LimitedValueDataValidationRule, c: string, d: WorkbookFormat);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: LimitedValueDataValidationRule;
    readonly c: string;
    readonly b: WorkbookFormat;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Represents a data validation rule which allows any formula to be used to validate the value applied to a cell.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 */
export declare class CustomDataValidationRule extends LimitedValueDataValidationRule {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _bp;
    /**
     * @hidden
     */
    private static readonly _bq;
    /**
     * @hidden
     */
    private static readonly _bk;
    private _bn;
    constructor();
    /**
     * @hidden
     */
    _n(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    _o(a: string): SingleTargetFormula;
    /**
     * Indicates if this rule is structurally equivalent to another.
     * @param other The rule to compare against
     * @return Returns true if the specified 'other' has the same settings as this rule.
     */
    isEquivalentTo(other: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _a9(a: FormulaToken, b: boolean, c: boolean, d: boolean, e: WorkbookFormat): boolean;
    /**
     * @hidden
     */
    _ar(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _as(): void;
    /**
     * @hidden
     */
    protected get__l(): DataValidationOperatorType;
    /**
     * @hidden
     */
    get _l(): DataValidationOperatorType;
    /**
     * @hidden
     */
    _at(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _au(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _bb(a: WorksheetCellAddress, b: any): boolean;
    /**
     * @hidden
     */
    protected get__m(): DataValidationType;
    /**
     * @hidden
     */
    get _m(): DataValidationType;
    /**
     * @hidden
     */
    _aw(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * Gets the formula used to validate the value applied to a cell.
     * <p class="body">
     * The formula will indicate the value is invalid by evaluating to False, 0, any [[ErrorValue]] (such as #VALUE!),
     * or any string other than "True" (case-insensitive).
     * True, "True" (case-insensitive), null, and non-zero numeric values will indicate a valid value has been applied.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @return A formula used to validate the value applied to a cell.
     * @see [[getFormula]]
     * @see [[setFormula]]
     * @see [[setFormula]]
     */
    getFormula(address: string): string;
    /**
     * Gets the formula used to validate the value applied to a cell.
     * <p class="body">
     * The formula will indicate the value is invalid by evaluating to False, 0, any [[ErrorValue]] (such as #VALUE!),
     * or any string other than "True" (case-insensitive).
     * True, "True" (case-insensitive), null, and non-zero numeric values will indicate a valid value has been applied.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when generating the formula string.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @return A formula used to validate the value applied to a cell.
     * @see [[getFormula]]
     * @see [[setFormula]]
     * @see [[setFormula]]
     */
    getFormula(address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): string;
    /**
     * @hidden
     */
    _getFormula(a: string): string;
    /**
     * @hidden
     */
    _getFormula1(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): string;
    /**
     * Sets the formula used to validate the value applied to a cell.
     * <p class="body">
     * The formula will indicate the value is invalid by evaluating to False, 0, any [[ErrorValue]] (such as #VALUE!),
     * or any string other than "True" (case-insensitive).
     * True, "True" (case-insensitive), null, and non-zero numeric values will indicate a valid value has been applied.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param formula The validation formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'formula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'formula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @see [[getFormula]]
     * @see [[getFormula]]
     * @see [[setFormula]]
     */
    setFormula(formula: string, address: string): void;
    /**
     * Sets the formula used to validate the value applied to a cell.
     * <p class="body">
     * The formula will indicate the value is invalid by evaluating to False, 0, any [[ErrorValue]] (such as #VALUE!),
     * or any string other than "True" (case-insensitive).
     * True, "True" (case-insensitive), null, and non-zero numeric values will indicate a valid value has been applied.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param formula The validation formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when parsing the formula string.
     * @throws [[ArgumentNullException]] Occurs when 'formula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'formula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @see [[getFormula]]
     * @see [[getFormula]]
     * @see [[setFormula]]
     */
    setFormula(formula: string, address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): void;
    /**
     * @hidden
     */
    _setFormula(a: string, b: string): void;
    /**
     * @hidden
     */
    _setFormula1(a: string, b: string, c: WorkbookFormat, d: CellReferenceMode, e: CultureInfo): void;
    /**
     * @hidden
     */
    _bo(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): SingleTargetFormula;
    /**
     * @hidden
     */
    private _bv;
    /**
     * @hidden
     */
    private static _bm;
    /**
     * @hidden
     */
    private static _bl;
}
/**
 * Represents an error value in Microsoft Excel.
 */
export declare class ErrorValue extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _v: number;
    /**
     * @hidden
     */
    static readonly _u: number;
    /**
     * @hidden
     */
    static readonly _ab: number;
    /**
     * @hidden
     */
    static readonly _w: number;
    /**
     * @hidden
     */
    static readonly _aa: number;
    /**
     * @hidden
     */
    static readonly _z: number;
    /**
     * @hidden
     */
    static readonly _s: number;
    /**
     * @hidden
     */
    static readonly _t: number;
    /**
     * @hidden
     */
    private static _h;
    /**
     * @hidden
     */
    private static _f;
    /**
     * @hidden
     */
    private static _q;
    /**
     * @hidden
     */
    private static _k;
    /**
     * @hidden
     */
    private static _o;
    /**
     * @hidden
     */
    private static _m;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static readonly _ac;
    private _x;
    constructor(a: number);
    /**
     * Gets the string representation of the error value.
     * @return The string representation of the error value.
     */
    toString(): string;
    /**
     * @hidden
     */
    static _j(a: number): ErrorValue;
    /**
     * @hidden
     */
    _a(): ExcelCalcErrorValue;
    /**
     * Gets the ErrorValue representing the #N/A error.
     * <p class="body">
     * This error occurs when a value isn't available for some part of a formula.
     * </p>
     * The ErrorValue representing the #N/A error.
     */
    static get argumentOrFunctionNotAvailable(): ErrorValue;
    /**
     * Gets the ErrorValue representing a circularity error.
     * <p class="body">
     * There is no error constant for a circularity in Microsoft Excel and a circularity cannot be the result of a formula in Microsoft Excel.
     * However, for run-time purposes, after loading or before saving a workbook, this error value will be used for the result of formulas
     * which cause circular references when the owning workbook has [[Workbook.iterativeCalculationsEnabled]] set to False.
     * </p>
     * <p class="body">
     * In Microsoft Excel, setting a circular reference formula on a cell will show an error dialog the first time the problem occurs. Subsequent
     * formulas violating the circular reference restriction will just evaluate to zero. Therefore, when this value is encountered in a cell, it
     * can be treated as a zero for calculation purposes. This error value will be returned though so an actual zero value in a cell can be
     * differentiated from a circularity error.
     * </p>
     * <p class="note">
     * <B>Note:</B> Because there is no circularity error constant in Microsoft Excel, this error value cannot be assigned to a cell manually.
     * Attempting to assign this error value to a cell will result in an InvalidOperationException to be thrown. This error value will only be
     * valid as the result of a formula which has been applied to a cell.
     * </p>
     * The ErrorValue representing a circularity error.
     */
    static get circularity(): ErrorValue;
    /**
     * Gets the ErrorValue representing the #DIV/0! error.
     * <p class="body">
     * This error occurs when a number is divided by zero.
     * </p>
     * The ErrorValue representing the #DIV/0! error.
     */
    static get divisionByZero(): ErrorValue;
    /**
     * Gets the ErrorValue representing the #NULL! error.
     * <p class="body">
     * This error occurs when there is an intersection of two references that do not contain any common cells.
     * The intersection operator is a space between two references.
     * </p>
     * The ErrorValue representing the #NULL! error.
     */
    static get emptyCellRangeIntersection(): ErrorValue;
    /**
     * Gets the ErrorValue representing the #REF! error.
     * <p class="body">
     * This error occurs when a cell reference or cell range reference is not valid.
     * </p>
     * The ErrorValue representing the #REF! error.
     */
    static get invalidCellReference(): ErrorValue;
    /**
     * Gets the ErrorValue representing the #NUM! error.
     * <p class="body">
     * This error occurs when there are invalid numeric values in a formula.
     * </p>
     * The ErrorValue representing the #NUM! error.
     */
    static get valueRangeOverflow(): ErrorValue;
    /**
     * Gets the ErrorValue representing the #NAME? error.
     * <p class="body">
     * This error occurs when text in a formula is not recognized.
     * </p>
     * The ErrorValue representing the #NAME? error.
     */
    static get wrongFunctionName(): ErrorValue;
    /**
     * Gets the ErrorValue representing the #VALUE! error.
     * <p class="body">
     * This error occurs when an incorrect argument or operand is used in a function.
     * </p>
     * The ErrorValue representing the #VALUE! error.
     */
    static get wrongOperandType(): ErrorValue;
    /**
     * @hidden
     */
    get _y(): number;
}
/**
 * @hidden
 */
export declare class StringElement extends GenericCacheElement implements IComparable$1<StringElement> {
    static $t: Type;
    static readonly _p: number[];
    private _z;
    private _x;
    constructor(a: string);
    g(a: Workbook): any;
    equals(a: any): boolean;
    getHashCode(): number;
    c(a: GenericCacheElement): boolean;
    toString(): string;
    compareTo(a: StringElement): number;
    _t<TArg, TResult>($tArg: Type, $tResult: Type, a: IStringElementVisitor$2<TArg, TResult>, b?: TArg): TResult;
    private static _v;
    static _r(a: string): StringElement;
    _ab(): void;
    _q(): StringElement;
    protected _ac(): void;
    _s(a: Workbook): StringElement;
    static _ad(a: Workbook, b: GenericCachedCollection$1<StringElement>, c: StringElement): {
        p1?: GenericCachedCollection$1<StringElement>;
        p2?: StringElement;
    };
    static _ae(a: Workbook, b: IFormattedStringOwner, c: GenericCachedCollection$1<StringElement>, d: StringElement): {
        p2?: GenericCachedCollection$1<StringElement>;
        p3?: StringElement;
    };
    protected get__u(): boolean;
    get _u(): boolean;
    get _aa(): number;
    set _aa(a: number);
    get _y(): string;
    set _y(a: string);
    get _w(): number;
}
/**
 * @hidden
 */
export declare class FormattedStringElement extends StringElement implements IFormattedRunOwner {
    static $t: Type;
    private _ag;
    constructor(a: number);
    constructor(a: number, b: string);
    constructor(a: number, ..._rest: any[]);
    _t<TArg, TResult>($tArg: Type, $tResult: Type, a: IStringElementVisitor$2<TArg, TResult>, b?: TArg): TResult;
    g(a: Workbook): any;
    equals(a: any): boolean;
    _ab(): void;
    getHashCode(): number;
    c(a: GenericCacheElement): boolean;
    protected _ac(): void;
    addRun(a: FormattingRunBase): void;
    createRun(a: number): FormattingRunBase;
    getFormattingRuns(a: Workbook): List$1<FormattingRunBase>;
    insertRun(a: number, b: FormattingRunBase): void;
    get startIndex(): number;
    _ai(): void;
    static _af(a: StringElement): FormattedStringElement;
    get _ah(): List$1<FormattingRunBase>;
    protected get__u(): boolean;
    get unformattedString(): string;
}
/**
 * @hidden
 */
export interface IRegionBlockingSingleCellComponent {
    readonly owningValue: IRegionBlockingValue;
}
/**
 * @hidden
 */
export declare let IRegionBlockingSingleCellComponent_$type: Type;
/**
 * @hidden
 */
export declare class ArrayInteriorFormula extends SingleTargetFormula implements IRegionBlockingSingleCellComponent {
    static $t: Type;
    private readonly _cz;
    constructor(a: ArrayFormula);
    get owningValue(): IRegionBlockingValue;
    _g(): Formula;
    protected get__i(): Formula;
    protected get__ak(): boolean;
    protected get__ck(): boolean;
    get _c0(): ArrayFormula;
}
/**
 * @hidden
 */
export declare class DataTableInteriorFormula extends SingleTargetFormula implements IRegionBlockingSingleCellComponent {
    static $t: Type;
    private readonly _cz;
    constructor(a: WorksheetDataTable);
    get owningValue(): IRegionBlockingValue;
    _g(): Formula;
    protected get__am(): boolean;
    protected get__ck(): boolean;
    get _c0(): WorksheetDataTable;
}
/**
 * @hidden
 */
export interface ICellFormatOwner {
    readonly cellFormat: IWorksheetCellFormat;
    readonly cellFormatInternal: WorksheetCellFormatProxy;
    getResolvedCellFormat(): IWorksheetCellFormat;
    readonly hasCellFormat: boolean;
}
/**
 * @hidden
 */
export declare let ICellFormatOwner_$type: Type;
/**
 * @hidden
 */
export interface IWorksheetCellFormatProxyOwner {
    getAdjacentFormatForBorderResolution(a: WorksheetCellFormatProxy, b: CellFormatValue): WorksheetCellFormatData;
    onCellFormatValueChanged(a: WorksheetCellFormatProxy, b: CellFormatValue, c: CellFormatValueChangedOptions): void;
    onCellFormatValueChanging(a: WorksheetCellFormatProxy, b: CellFormatValue): void;
    verifyFormatOptions(a: WorksheetCellFormatProxy, b: WorksheetCellFormatOptions): void;
}
/**
 * @hidden
 */
export declare let IWorksheetCellFormatProxyOwner_$type: Type;
/**
 * Abstract base class for worksheet row and worksheet column.
 * @see [[WorksheetColumn]]
 * @see [[WorksheetRow]]
 */
export declare abstract class RowColumnBase extends Base implements ICellFormatOwner, IWorksheetCellFormatProxyOwner {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _p: number;
    /**
     * @hidden
     */
    static readonly _s: number;
    /**
     * @hidden
     */
    static readonly _o: number;
    private _f;
    private _c;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    get cellFormatInternal(): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    get hasCellFormat(): boolean;
    /**
     * @hidden
     */
    getAdjacentFormatForBorderResolution(sender: WorksheetCellFormatProxy, borderValue: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    onCellFormatValueChanged(sender: WorksheetCellFormatProxy, values: CellFormatValue, options: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    onCellFormatValueChanging(sender: WorksheetCellFormatProxy, values: CellFormatValue): void;
    /**
     * @hidden
     */
    _onCellFormatValueChanging(a: WorksheetCellFormatProxy, b: CellFormatValue): void;
    /**
     * @hidden
     */
    verifyFormatOptions(sender: WorksheetCellFormatProxy, formatOptions: WorksheetCellFormatOptions): void;
    /**
     * @hidden
     */
    abstract _h(a: GenericCachedCollectionEx$1<WorksheetCellFormatData>): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    abstract _getAdjacentFormatForBorderResolution(a: WorksheetCellFormatProxy, b: CellFormatValue): WorksheetCellFormatData;
    /**
     * Gets the resolved cell formatting for the cells in the row or column.
     * @return A format object describing the actual formatting that will be used when displayed the row or column in Microsoft Excel.
     * @throws [[InvalidOperationException]] If the object was removed from the worksheet.
     * @see [[cellFormat]]
     */
    getResolvedCellFormat(): IWorksheetCellFormat;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * @hidden
     */
    _u(): void;
    /**
     * @hidden
     */
    abstract _onCellFormatValueChanged(a: WorksheetCellFormatProxy, b: CellFormatValue, c: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    _x(): void;
    /**
     * @hidden
     */
    _y(): void;
    /**
     * @hidden
     */
    static _z(a: ChangeInfo[], b: ExcelChangeAction): void;
    /**
     * @hidden
     */
    abstract _ad(): void;
    /**
     * Gets the default cell format for cells in this row or column.
     * <p class="body">
     * Any default properties of the cell's format will take their value from this format when getting a resolved format.
     * </p>
     * The default cell format for cells in this row or column.
     */
    get cellFormat(): IWorksheetCellFormat;
    /**
     * @hidden
     */
    get _hasCellFormat(): boolean;
    /**
     * Gets or sets the value indicating whether the row or column is hidden.
     * The Hidden state also controls the expanded state of rows or columns in outline groups. Basically, an outline group
     * simply provides an easy way to hide and unhide all rows or columns in the group at the same time, via the expansion
     * indicator.
     * The value indicating whether the row or column is hidden.
     * @throws [[InvalidOperationException]] From the stter if the object was removed from the worksheet.
     * @see [[outlineLevel]]
     * @see [[CustomView.getHiddenColumns]]
     * @see [[CustomView.getHiddenRows]]
     */
    get hidden(): boolean;
    set hidden(a: boolean);
    /**
     * @hidden
     */
    _aa(a: boolean, b?: boolean): void;
    /**
     * Gets the 0-based index of the row or column in the worksheet.
     * The 0-based index of the row or column in the worksheet.
     */
    abstract get index(): number;
    /**
     * Gets or sets the outline level for the row or column.
     * <p class="body">
     * Microsoft Excel supports hierarchical grouping of rows and columns with a maximum of seven levels of hierarchy.
     * To create a group, set adjacent rows or columns to same outline level. When rows or columns are grouped, an
     * outline indicator will provide a visual representation of the outline level.  In addition, an outline group has
     * an expansion indicator at one end of the group, which allows the user to easily hide and unhide all rows or column
     * in the group with a single click.
     * </p>
     * The outline level for the row or column.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid outline level range of 0 and 7.
     * @throws [[InvalidOperationException]] From the stter if the object was removed from the worksheet.
     * @see [[hidden]]
     */
    get outlineLevel(): number;
    set outlineLevel(a: number);
    /**
     * @hidden
     */
    private _ab;
    /**
     * Gets the worksheet to which the row or column belongs.
     * The worksheet to which the row or column belongs.
     */
    get worksheet(): Worksheet;
    /**
     * @hidden
     */
    get _cellFormatInternal(): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    abstract get _a(): ChangeInfo[];
    /**
     * @hidden
     */
    protected get__j(): boolean;
    /**
     * @hidden
     */
    get _j(): boolean;
    /**
     * @hidden
     */
    abstract get _l(): boolean;
    /**
     * @hidden
     */
    abstract set _l(a: boolean);
    /**
     * @hidden
     */
    abstract get _n(): number;
    /**
     * @hidden
     */
    abstract set _n(a: number);
    /**
     * @hidden
     */
    _ac(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    abstract get _m(): boolean;
}
/**
 * @hidden
 */
export interface IWorksheetRegionAddressContext {
    getRegionAddress(): WorksheetRegionAddress;
}
/**
 * @hidden
 */
export declare let IWorksheetRegionAddressContext_$type: Type;
/**
 * Represents a row in a Microsoft Excel worksheet.
 */
export declare class WorksheetRow extends RowColumnBase implements IChangeInfoContext, IWorksheetRegionAddressContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _cr: number;
    /**
     * @hidden
     */
    static readonly _cy: number;
    /**
     * @hidden
     */
    private static readonly _cv;
    /**
     * @hidden
     */
    private static readonly _cz;
    /**
     * @hidden
     */
    private static readonly _ae;
    private _a3;
    private _cl;
    private _af;
    private _bq;
    private _ag;
    private _cn;
    private _cw;
    private _cc;
    private _ce;
    private _bn;
    private _cd;
    constructor(a: Worksheet, b: number);
    /**
     * @hidden
     */
    protected get__a(): ChangeInfo[];
    /**
     * @hidden
     */
    get _a(): ChangeInfo[];
    /**
     * @hidden
     */
    _h(a: GenericCachedCollectionEx$1<WorksheetCellFormatData>): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    _getAdjacentFormatForBorderResolution(a: WorksheetCellFormatProxy, b: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    protected get__j(): boolean;
    /**
     * @hidden
     */
    protected get__l(): boolean;
    /**
     * @hidden
     */
    protected set__l(a: boolean): void;
    /**
     * @hidden
     */
    get _l(): boolean;
    /**
     * @hidden
     */
    set _l(a: boolean);
    /**
     * Gets the 0-based index of the row in the worksheet.
     * The 0-based index of the row in the worksheet.
     */
    protected get_index(): number;
    /**
     * Gets the 0-based index of the row in the worksheet.
     * The 0-based index of the row in the worksheet.
     */
    get index(): number;
    /**
     * @hidden
     */
    get _cx(): number;
    /**
     * @hidden
     */
    _u(): void;
    /**
     * @hidden
     */
    _onCellFormatValueChanged(a: WorksheetCellFormatProxy, b: CellFormatValue, c: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    _onCellFormatValueChanging(a: WorksheetCellFormatProxy, b: CellFormatValue): void;
    /**
     * @hidden
     */
    _y(): void;
    /**
     * @hidden
     */
    protected get__n(): number;
    /**
     * @hidden
     */
    protected set__n(a: number): void;
    /**
     * @hidden
     */
    get _n(): number;
    /**
     * @hidden
     */
    set _n(a: number);
    /**
     * @hidden
     */
    _ac(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    _ad(): void;
    /**
     * Applies a formula to the cell at the specified column index.
     * <p class="body">
     * 'formula' is parsed based on the [[CellReferenceMode]] of the [[Workbook]]
     * to which the row belongs. If the row's [[Worksheet]] has been removed from its parent collection,
     * the A1 CellReferenceMode will be used to parse the formula.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @param formula The formula to parse and apply to the cell.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[FormulaParseException]] 'formula' is not a valid formula.
     * @throws [[InvalidOperationException]] The cell is part of an array formula or data table which is not confined to just the cell.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @see [[getCellFormula]]
     * @see [[WorksheetCell.applyFormula]]
     */
    applyCellFormula(columnIndex: number, formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _applyCellFormula$i(a: number, b: string, c?: Nullable$1<CellReferenceMode>): void;
    /**
     * Gets the data table to which the cell at the specified index belongs.
     * <p class="body">
     * The cells in the left-most column and top-most row of the data table will return null for the associated data table.
     * </p>
     * <p class="body">
     * If a data table is associated with the cell, getting the value of the cell with [[getCellValue]]
     * will return the calculated value for the cell.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The data table to which the cell belongs or null if the cell does not belong to a data table.
     * @see [[Worksheet.dataTables]]
     * @see [[WorksheetDataTableCollection.add]]
     * @see [[getCellValue]]
     * @see [[WorksheetCell.associatedDataTable]]
     */
    getCellAssociatedDataTable(columnIndex: number): WorksheetDataTable;
    /**
     * @hidden
     */
    _bg(a: number): WorksheetDataTable;
    /**
     * Gets the merged cells region which contains the cell at the specified index, or null if the cell is not merged.
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The merged cells region which contains the cell at the specified index, or null if the cell is not merged.
     * @see [[WorksheetCell.associatedMergedCellsRegion]]
     */
    getCellAssociatedMergedCellsRegion(columnIndex: number): WorksheetMergedCellsRegion;
    /**
     * @hidden
     */
    _bl(a: number): WorksheetMergedCellsRegion;
    /**
     * Gets the [[WorksheetTable]] to which the cell at the specified index belongs.
     * <p class="body">
     * A cell belongs to a table if it exists in any area of the table. It can be a header cell, total cell, or a cell in the data area.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @see [[WorksheetTable]]
     * @see [[Worksheet.tables]]
     */
    getCellAssociatedTable(columnIndex: number): WorksheetTable;
    /**
     * @hidden
     */
    _bp(a: number): WorksheetTable;
    /**
     * Gets the bounds of the cell at the specified column index in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before the cell are resized, these bounds will no longer reflect the
     * position of the cell.
     * </p>
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The bounds of the cell at the specified column index on its worksheet.
     * @see [[WorksheetCell.getBoundsInTwips]]
     */
    getCellBoundsInTwips(columnIndex: number): IgRect;
    /**
     * Gets the bounds of the cell at the specified column index in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before the cell are resized, these bounds will no longer reflect the
     * position of the cell.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @param options The options to use when getting the bounds of the cell.
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The bounds of the cell at the specified column index on its worksheet.
     * @see [[WorksheetCell.getBoundsInTwips]]
     */
    getCellBoundsInTwips(columnIndex: number, options: PositioningOptions): IgRect;
    /**
     * @hidden
     */
    _getCellBoundsInTwips(a: number): Rect;
    /**
     * @hidden
     */
    _el(a: number): Rect;
    /**
     * @hidden
     */
    _getCellBoundsInTwips1(a: number, b: PositioningOptions): Rect;
    /**
     * @hidden
     */
    _em(a: number, b: PositioningOptions): Rect;
    /**
     * Gets or sets the comment applied to the cell at the specified column index.
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The comment applied to the cell.
     * @see [[WorksheetCell.comment]]
     */
    getCellComment(columnIndex: number): WorksheetCellComment;
    /**
     * @hidden
     */
    _a6(a: number): WorksheetCellComment;
    /**
     * Gets the display text in the cell at the specified index.
     * <p class="body">
     * The display text is based on the value of the cell and the format string applied to the cell.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @see [[getCellValue]]
     * @see [[IWorksheetCellFormat.formatString]]
     */
    getCellText(columnIndex: number): string;
    /**
     * Gets the text in the cell at the specified index.
     * <p class="body">
     * The text is based on the value of the cell and the format string applied to the cell.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @param textFormatMode The format mode to use when getting the cell text.
     * @throws [[InvalidEnumArgumentException]] 'textFormatMode' is not defined in the [[TextFormatMode]] enumeration.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @see [[getCellValue]]
     * @see [[IWorksheetCellFormat.formatString]]
     */
    getCellText(columnIndex: number, textFormatMode: TextFormatMode): string;
    /**
     * @hidden
     */
    _getCellText(a: number): string;
    /**
     * @hidden
     */
    _getCellText1(a: number, b: TextFormatMode): string;
    /**
     * @hidden
     */
    _da(a: number, b: TextFormatMode): string;
    /**
     * @hidden
     */
    _av(a: GetCellTextParameters): GetCellTextResult;
    /**
     * @hidden
     */
    _aw(a: WorksheetCellBlock, b: GetCellTextParameters): GetCellTextResult;
    /**
     * Gets the cell conditional format for the cell at the specified column index.
     * <para class="note"><b>Note:</b> if the cell is contained in one or more conditional format regions but doesn't match any of the criteria an instance of [[CellConditionalFormat]]
     * will still be returned but its [[CellConditionalFormat.hasConditionFormatting]] property will return null. However, if the sell is not contained in any
     * conditional format region then this method will return null.</para>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The aggregated condition format for the cell at the specified column index or null if the cell is not contained in any conditional format region.
     * @see [[Worksheet.conditionalFormats]]
     * @see [[CellConditionalFormat]]
     */
    getCellConditionalFormat(columnIndex: number): CellConditionalFormat;
    /**
     * Gets the cell formatting for the cell at the specified column index.
     * <p class="body">
     * Use this method to set cell formatting specific to the cell. If you will be applying the format to numerous cells,
     * see the [[Workbook.createNewWorksheetCellFormat]] method for performance considerations.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The cell formatting for the cell at the specified column index.
     * @see [[getResolvedCellFormat]]
     * @see [[WorksheetCell.cellFormat]]
     * @see [[tryGetCellFormat]]
     */
    getCellFormat(columnIndex: number): IWorksheetCellFormat;
    /**
     * Gets the formula which has been applied to the cell at the specified column index.
     * <p class="body">
     * If a formula has been applied to the cell, getting the value with the [[getCellValue]] method will return the
     * calculated value of the formula.
     * </p>
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return The formula which has been applied to the cell or null if no formula has been applied.
     * @see [[Formula.applyTo]]
     * @see [[Formula.applyTo]]
     * @see [[Formula.applyTo]]
     * @see [[applyCellFormula]]
     * @see [[WorksheetRegion.applyFormula]]
     * @see [[WorksheetRegion.applyArrayFormula]]
     * @see [[WorksheetCell.formula]]
     */
    getCellFormula(columnIndex: number): Formula;
    /**
     * @hidden
     */
    _ar(a: number): Formula;
    /**
     * @hidden
     */
    _bi(a: number): WorksheetHyperlink;
    /**
     * Gets the effective hyperlink on the cell at the specified index.
     * <p class="body">
     * If multiple hyperlinks are applied to the cell, the last one in the [[Worksheet.hyperlinks]]
     * collection will be used.
     * </p>
     * <p class="body">
     * If the cell has one or more hyperlinks in the [[Worksheet.hyperlinks]] collection as well
     * as a formula containing a HYPERLINK function, the last hyperlink from the collection will be used.
     * </p>
     * <p class="body">
     * If the cell has a hyperlink due to the HYPERLINK function being used in a formula, the returned value will be sealed.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @see [[Worksheet.hyperlinks]]
     * @see [[WorksheetHyperlink]]
     * @see [[WorksheetHyperlink.isSealed]]
     */
    getCellHyperlink(columnIndex: number): WorksheetHyperlink;
    /**
     * Gets the value of the cell at the specified column index.
     * <p class="body">
     * If this cell belongs to a merged cell region and it is the top-left cell of the region, getting and setting the value
     * will get and set the value of the associated merged cell region. Getting the value of other cells in a merged cell region
     * will always return null. Setting the value of other cells in a merged cell region will have no effect.
     * </p>
     * <p class="body">
     * If a formula has been applied to the cell or a data table is associated with the cell, getting the Value will return the
     * calculated value of the cell.
     * </p>
     * <p class="body">
     * The types supported for the value are:
     * <BR/>
     * <ul>
     * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
     * </ul>
     * </p>
     * The value of the cell.
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @see [[setCellValue]]
     * @see [[getCellAssociatedMergedCellsRegion]]
     * @see [[WorksheetCell.isCellTypeSupported]]
     * @see [[WorksheetMergedCellsRegion.value]]
     * @see [[getCellFormula]]
     * @see [[getCellAssociatedDataTable]]
     * @see [[WorksheetCell.value]]
     */
    getCellValue(columnIndex: number): any;
    /**
     * @hidden
     */
    _getCellValue1(a: number): any;
    /**
     * @hidden
     */
    _c5(a: number): any;
    /**
     * @hidden
     */
    _bh(a: number): WorksheetDataTable;
    /**
     * Gets the resolved cell formatting for the cells in the row or column.
     * @return A format object describing the actual formatting that will be used when displayed the row or column in Microsoft Excel.
     * @throws [[InvalidOperationException]] If the object was removed from the worksheet.
     * @see [[cellFormat]]
     */
    getResolvedCellFormat(): IWorksheetCellFormat;
    /**
     * Gets the resolved cell formatting for the cell at the specified column index.
     * <p class="body">
     * If any cell format properties are the default values on the cell, the values from the owning row's cell format will be used.
     * If those are default, then the values from the owning column's cell format will be used. Otherwise, the workbook default values
     * will be used.
     * </p>
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @return A format object describing the actual formatting that will be used when displayed the cell in Microsoft Excel.
     * @see [[getCellFormat]]
     * @see [[RowColumnBase.cellFormat]]
     * @see [[WorksheetCell.getResolvedCellFormat]]
     */
    getResolvedCellFormat(columnIndex: number): IWorksheetCellFormat;
    /**
     * @hidden
     */
    _getResolvedCellFormat1(a: number): IWorksheetCellFormat;
    /**
     * @hidden
     */
    _az(a: number): IWorksheetCellFormat;
    /**
     * Sets the comment applied to the cell at the specified column index.
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @param comment The comment to apply to the cell.
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[InvalidOperationException]] The value applied only has only one anchor cell set. It should have both or neither anchor cells set.
     * @throws [[InvalidOperationException]] The value has its [[WorksheetShape.topLeftCornerCell]] and [[WorksheetShape.bottomRightCornerCell]]
     * anchors set but they are from different worksheets.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @see [[WorksheetCell.comment]]
     */
    setCellComment(columnIndex: number, comment: WorksheetCellComment): void;
    /**
     * @hidden
     */
    _d2(a: number, b: WorksheetCellComment): void;
    /**
     * Sets the value of a cell at the specified column index.
     * <p class="body">
     * If this cell belongs to a merged cell region and it is the top-left cell of the region, getting and setting the value
     * will get and set the value of the associated merged cell region. Getting the value of other cells in a merged cell region
     * will always return null. Setting the value of other cells in a merged cell region will have no effect.
     * </p>
     * <p class="body">
     * If a formula has been applied to the cell or a data table is associated with the cell, getting the Value will return the
     * calculated value of the cell.
     * </p>
     * <p class="body">
     * The types supported for the value are:
     * <BR/>
     * <ul>
     * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
     * </ul>
     * </p>
     * The value of the cell.
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @param value The value to assign to the cell.
     * @throws [[ArgumentOutOfRangeException]] 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @throws [[NotSupportedException]] The assigned value's type is not supported and can't be exported to Excel.
     * @throws [[InvalidOperationException]] The value assigned is a [[Formula]]. Instead, [[Formula.applyTo]]
     * should be called on the Formula, passing in the cell.
     * @throws [[InvalidOperationException]] The value assigned is a [[WorksheetDataTable]]. Instead, the [[WorksheetDataTable.cellsInTable]]
     * should be set to a region containing the cell.
     * @throws [[InvalidOperationException]] The value assigned is a FormattedString which is the value another cell or merged cell region.
     * @throws [[InvalidOperationException]] The value is assigned and this cell is part of an [[ArrayFormula]] or WorksheetDataTable.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @see [[getCellValue]]
     * @see [[getCellAssociatedMergedCellsRegion]]
     * @see [[WorksheetCell.isCellTypeSupported]]
     * @see [[WorksheetMergedCellsRegion.value]]
     * @see [[getCellFormula]]
     * @see [[getCellAssociatedDataTable]]
     * @see [[WorksheetCell.value]]
     */
    setCellValue(columnIndex: number, value: any): void;
    /**
     * @hidden
     */
    _b9(a: number, b: IWorksheetCellFormat): {
        ret: boolean;
        p1: IWorksheetCellFormat;
    };
    /**
     * Returns a boolean indicating if the value of the cell is valid considering its associated [[WorksheetCell.dataValidationRule]]
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @return Returns false if the cell has an associated [[WorksheetCell.dataValidationRule]] and the current [[WorksheetCell.value]] does not pass the validation defined by that rule; otherwise true is returned.
     * @see [[getCellValue]]
     * @see [[setCellValue]]
     * @see [[Worksheet.dataValidationRules]]
     * @see [[DataValidationRule]]
     * @see [[WorksheetCell.dataValidationRule]]
     */
    validateCellValue(columnIndex: number): boolean;
    /**
     * @hidden
     */
    private _cj;
    /**
     * @hidden
     */
    private _cq;
    /**
     * @hidden
     */
    private _db;
    /**
     * @hidden
     */
    _de(): void;
    /**
     * @hidden
     */
    _df(a: number, b: number, c: boolean, d?: WorksheetRow, e?: Nullable$1<number>, f?: boolean, g?: boolean, h?: Nullable$1<number>, i?: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    _dg(): void;
    /**
     * @hidden
     */
    _dh(): void;
    /**
     * @hidden
     */
    _di(a?: boolean, b?: boolean): void;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    static _bs(a: CellFormatValue): boolean;
    /**
     * @hidden
     */
    _bt(a: number): boolean;
    /**
     * @hidden
     */
    _a1(a: number): WorksheetCellBlock;
    /**
     * @hidden
     */
    private __cf;
    _cf(): IEnumerable$1<KeyValuePair$2<number, WorksheetCellBlock>>;
    /**
     * @hidden
     */
    _as(a: number): CellCalcReference;
    /**
     * @hidden
     */
    _am(a: number, b?: boolean): CellDataContext;
    /**
     * @hidden
     */
    private _al;
    /**
     * @hidden
     */
    _aj(a: number): WorksheetCellFormatData[];
    /**
     * @hidden
     */
    _bc(a: number): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    _bb(a: WorksheetCellFormatData[], b: number): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    _c7(a: number, b: CellReferenceMode, c: boolean, d?: boolean, e?: boolean): string;
    /**
     * @hidden
     */
    _a7(a: number): WorksheetCellFormatData;
    /**
     * @hidden
     */
    _be(a: number, b: WorksheetCellFormatData, c: WorksheetCellFormatData[], d: boolean): WorksheetCellOwnedFormatProxy;
    /**
     * @hidden
     */
    _dj(a: number, b: number, c: (arg1: WorksheetRow, arg2: WorksheetCellFormatData, arg3: number) => void): void;
    /**
     * @hidden
     */
    _bv(a: number): boolean;
    /**
     * @hidden
     */
    private __ch;
    _ch(a?: number, b?: number, c?: boolean): IEnumerable$1<CellDataContext>;
    /**
     * @hidden
     */
    static _c2(a: WorksheetRow, b: number): any;
    /**
     * @hidden
     */
    private _c4;
    /**
     * @hidden
     */
    _c6(a: number): any;
    /**
     * @hidden
     */
    private __ci;
    _ci(a: boolean): IEnumerable$1<number>;
    /**
     * @hidden
     */
    private _dv;
    /**
     * @hidden
     */
    _dn(a: number, b: boolean): void;
    /**
     * @hidden
     */
    _c0(a: number, b: number): Nullable$1<number>;
    /**
     * @hidden
     */
    _ck(a: number, b: number, c?: Nullable$1<HorizontalCellAlignment>): number;
    /**
     * @hidden
     */
    _c1(a: number, b: boolean): Nullable$1<number>;
    /**
     * @hidden
     */
    _ct(a?: boolean): number;
    /**
     * @hidden
     */
    private static _bm;
    /**
     * @hidden
     */
    _dm(a: WorksheetRow): void;
    /**
     * @hidden
     */
    _ds(a: WorksheetCellOwnedFormatProxy, b: CellFormatValue, c: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    _x(): void;
    /**
     * @hidden
     */
    _dr(a: Worksheet, b: number): void;
    /**
     * @hidden
     */
    _dt(a: Worksheet, b: Dictionary$2<WorksheetCellAddress, SingleTargetFormula>): void;
    /**
     * @hidden
     */
    _du(a: Dictionary$2<WorksheetCellAddress, SingleTargetFormula>): void;
    /**
     * @hidden
     */
    _dw(a: number, b: WorksheetCellBlock): void;
    /**
     * @hidden
     */
    _dx(a?: boolean): void;
    /**
     * @hidden
     */
    _dy(a: WorksheetCellFormatCollection): void;
    /**
     * @hidden
     */
    _dz(a: number, b: WorksheetMergedCellsRegion): void;
    /**
     * @hidden
     */
    _d0(a: number, b: ExcelCalcValue, c?: boolean): void;
    /**
     * @hidden
     */
    _d3(a: number, b: WorksheetCellFormatData): void;
    /**
     * @hidden
     */
    _d4(a: number, b: boolean): void;
    /**
     * @hidden
     */
    _d6(a: number, b: any, c?: boolean): void;
    /**
     * @hidden
     */
    _d9(a: number, b: WorksheetMergedCellsRegion): void;
    /**
     * @hidden
     */
    _a2(a: number): WorksheetCellBlock;
    /**
     * @hidden
     */
    _at(a: number, b?: boolean): CellCalcReference;
    /**
     * @hidden
     */
    _a8(a: number): WorksheetCellFormatData;
    /**
     * @hidden
     */
    _bd(a: number): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    private _ak;
    /**
     * @hidden
     */
    private _a9;
    /**
     * @hidden
     */
    _eb(): void;
    /**
     * @hidden
     */
    _ea(a: SharedStringTable, b?: Dictionary$2<WorksheetCellAddress, SingleTargetFormula>): void;
    /**
     * @hidden
     */
    _ec(a: number, b: StringElement): void;
    /**
     * @hidden
     */
    _ed(a: number, b: any, c: boolean, d?: boolean): void;
    /**
     * @hidden
     */
    _a0(a: MutableItemRange, b: number, c: number): MutableItemRange;
    /**
     * @hidden
     */
    _cb(): boolean;
    /**
     * @hidden
     */
    private _co;
    /**
     * @hidden
     */
    private _cp;
    /**
     * @hidden
     */
    private _dd;
    /**
     * @hidden
     */
    private static _ao;
    /**
     * @hidden
     */
    private static _ai;
    /**
     * @hidden
     */
    private _bu;
    /**
     * @hidden
     */
    private _ba;
    /**
     * @hidden
     */
    private __cg;
    private _cg;
    /**
     * @hidden
     */
    private _bw;
    /**
     * @hidden
     */
    private _dk;
    /**
     * @hidden
     */
    private _dl;
    /**
     * @hidden
     */
    private _dp;
    /**
     * @hidden
     */
    private _dq;
    /**
     * @hidden
     */
    private static _b7;
    /**
     * @hidden
     */
    private static _b8;
    /**
     * @hidden
     */
    private _d7;
    /**
     * @hidden
     */
    private _ee;
    /**
     * @hidden
     */
    private _ef;
    /**
     * @hidden
     */
    private _eg;
    /**
     * @hidden
     */
    private _eh;
    /**
     * @hidden
     */
    private _ei;
    /**
     * Gets the cell at the specified column index in the owning row.
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all cells. It will only iterate the cells which have already
     * been used.  To create and iterate all cells in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum column count, and pass in each index to the collection's indexer.
     * </p>
     * The cell at the specified column index in the owning row.
     * @param index The zero-based column index of the cell to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelColumnCount]]
     * or [[Workbook.maxExcel2007ColumnCount]], depending on the [[Workbook.currentFormat]].
     */
    cells(index: number): WorksheetCell;
    /**
     * Gets the collection of cells in the row.
     * <p class="body">
     * The collection of cells is a fixed length collection, with the maximum number of cells in the collection being
     * [[Workbook.maxExcelColumnCount]] or [[Workbook.maxExcel2007ColumnCount]],
     * depending on the <see cref="Workbook.CurrentFormat">Workbook.CurrentFormat</see>.  Internally, the cells
     * are only created and added to the collection when they are requested.
     * </p>
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all cells. It will only iterate the cells which have already
     * been used.  To create and iterate all cells in the worksheet use a For loop, iterating from 0 to one less than
     * MaxExcelColumnCount, and pass in each index to the collection's indexer.
     * </p>
     * The collection of cells in the row.
     */
    cells(): WorksheetCellCollection;
    /**
     * @hidden
     */
    get _cells$i(): WorksheetCellCollection;
    /**
     * Gets or sets the height of the row in twips (1/20th of a point).
     * <p class="body">
     * If the height of the row is less than zero, the [[Worksheet.defaultRowHeight]] of the
     * owning worksheet will be used as the row's height.
     * </p>
     * <p class="body">
     * The value assigned must be between -1 and 8192. Invalid values will be automatically adjusted to valid values.
     * </p>
     * The height of the row in twips (1/20th of a point).
     * @throws [[InvalidOperationException]] From the setter if the row was removed from the worksheet.
     */
    get height(): number;
    set height(a: number);
    /**
     * @hidden
     */
    private _d8;
    /**
     * @hidden
     */
    _cs(a?: boolean): number;
    /**
     * @hidden
     */
    get _cm(): number;
    /**
     * @hidden
     */
    set _cm(a: number);
    /**
     * @hidden
     */
    get _br(): SortedList$2<number, CellCalcReference[]>;
    /**
     * @hidden
     */
    get _bx(): boolean;
    /**
     * @hidden
     */
    get _ah(): WorksheetCellFormatBlock[];
    /**
     * @hidden
     */
    get _by(): boolean;
    /**
     * @hidden
     */
    get _bz(): boolean;
    /**
     * @hidden
     */
    set _bz(a: boolean);
    /**
     * @hidden
     */
    get _b0(): boolean;
    /**
     * @hidden
     */
    get _b1(): boolean;
    /**
     * @hidden
     */
    set _b1(a: boolean);
    /**
     * @hidden
     */
    get _b4(): boolean;
    /**
     * @hidden
     */
    set _b4(a: boolean);
    /**
     * @hidden
     */
    protected get__m(): boolean;
    /**
     * @hidden
     */
    get _m(): boolean;
    /**
     * @hidden
     */
    get _au(): GenericCachedCollection$1<StringElement>;
    /**
     * @hidden
     */
    private get _b2();
    /**
     * @hidden
     */
    private set _b2(value);
    /**
     * @hidden
     */
    get _b6(): boolean;
    /**
     * @hidden
     */
    set _b6(a: boolean);
    /**
     * @hidden
     */
    private get _b5();
    /**
     * @hidden
     */
    private set _b5(value);
    /**
     * @hidden
     */
    get _b3(): boolean;
    /**
     * @hidden
     */
    set _b3(a: boolean);
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    getRegionAddress(): WorksheetRegionAddress;
}
/**
 * @hidden
 */
export interface IWorksheetProvider {
    readonly worksheet: Worksheet;
}
/**
 * @hidden
 */
export declare let IWorksheetProvider_$type: Type;
/**
 * @hidden
 */
export interface ISortSettingsOwner extends IWorkbookProvider, IWorksheetProvider {
    onSortSettingsModified(): void;
    readonly culture: string | CultureInfo;
    readonly _culture$i: CultureInfo;
    readonly sortRegion: WorksheetRegion;
}
/**
 * @hidden
 */
export declare let ISortSettingsOwner_$type: Type;
/**
 * @hidden
 */
export interface ISupportFormulaShifts {
    shiftFormulas(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    undoFormulaShift(a: any, b: string): string;
}
/**
 * @hidden
 */
export declare let ISupportFormulaShifts_$type: Type;
/**
 * @hidden
 */
export declare class ConditionBase_RegionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: ConditionBase, c: boolean);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: ConditionBase;
    readonly c: string;
    readonly b: boolean;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Abstract base class which encapsulates the condition for a formatting rule.
 */
export declare abstract class ConditionBase extends Base implements ISupportFormulaShifts, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _a2: string;
    /**
     * @hidden
     */
    static readonly _az: string;
    /**
     * @hidden
     */
    private static readonly _ax;
    /**
     * @hidden
     */
    private static readonly _ay;
    /**
     * @hidden
     */
    private static readonly _av;
    /**
     * @hidden
     */
    private static _a;
    private _k;
    private _w;
    private _v;
    private _ap;
    private _aq;
    private _q;
    private _u;
    private _t;
    static staticInit(): void;
    constructor();
    constructor(regions: IList$1<WorksheetRegion>, conditionType: FormatConditionType);
    constructor(..._rest: any[]);
    /**
     * Returns a reference to the associated worksheet.
     */
    get worksheet(): Worksheet;
    /**
     * Returns a reference to the associated workbook.
     */
    get workbook(): Workbook;
    /**
     * Returns the [[WorksheetRegion]] which identifies the cell range
     * with which this condition is associated.
     */
    get regions(): ReadOnlyCollection$1<WorksheetRegion>;
    /**
     * @hidden
     */
    protected get__x(): boolean;
    /**
     * @hidden
     */
    get _x(): boolean;
    /**
     * Returns a [[FormatConditionType]] value which identifies the
     * type of condition for this instance.
     */
    get conditionType(): FormatConditionType;
    /**
     * @hidden
     */
    get _ag(): boolean;
    /**
     * @hidden
     */
    protected get__j(): FormatConditionNotificationType;
    /**
     * @hidden
     */
    get _j(): FormatConditionNotificationType;
    /**
     * Returns or sets a value which determines the order of evaluation
     * when multiple conditional formatting rules exist.
     * <p class="body">
     * By default, <see cref="ConditionalFormatBase">conditions</see> are evaluated
     * in the order in which they appear within the containing
     * <see cref="ConditionalFormatCollection">collection</see>.
     * </p>
     * <p class="body">
     * This property makes it possible to weight one condition over another, essentially
     * overriding the condition's ordinal position within the collection.
     * </p>
     * <p class="body">
     * A lower number means a higher priority; for example, a condition with a
     * priority of 1 is evaluated before one with a priority of 2.
     * </p>
     * <p class="body">
     * If a cell value meets more than one condition, the format defined by the first
     * condition to be evaluated takes precedence.
     * </p>
     * <p class="body">
     * Setting the priority on one condition may cause the value of other conditions
     * in the collection to be changed to ensure that each condition has a unique value.
     * </p>
     */
    get priority(): number;
    set priority(a: number);
    /**
     * @hidden
     */
    protected get__ah(): boolean;
    /**
     * @hidden
     */
    get _ah(): boolean;
    /**
     * @hidden
     */
    protected get__ai(): boolean;
    /**
     * @hidden
     */
    get _ai(): boolean;
    /**
     * Returns or sets a boolean indicating whether additional formatting rules
     * are evaluated if this rule evaluates to true. Applicable only in the case
     * where the containing <see cref="ConditionalFormatCollection">collection</see>
     * contains more than one element.
     * <p class="body">
     * If a cell value meets more than one condition, the format defined by the
     * first condition takes precedence. Individual format properties are "merged"
     * during the resolution process; for example, if one format has red borders
     * and another has a red foreground color, a cell value which meets both conditions
     * may be formatted with both red borders <b>and</b> a red foreground color.
     * </p>
     * <p class="body">
     * This property makes it possible to short-circuit the resolution process, so that
     * no other conditional formats are applied after the first condition evaluates to true.
     * </p>
     * <p class="body">
     * Using the above example, assume <i>StopIfTrue</i> is set to a value of true on the
     * conditional format with red borders, a second conditional format exists with a red
     * foreground color, and a cell value meets both conditions. Because the StopIfTrue
     * setting prevents additional formats from being evaluated, the cell will not show
     * a red foreground color, whereas with <i>StopIfTrue</i> being set to false, it
     * would show both red borders and a red foreground color.
     * </p>
     * <p class="body">
     * In addition to preventing subsequent conditions from being evaluated, the order
     * in which conditions are evaluated can be controlled using the [[priority]]
     * property.
     * </p>
     */
    get stopIfTrue(): boolean;
    set stopIfTrue(a: boolean);
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    get _al(): boolean;
    /**
     * @hidden
     */
    protected get__am(): boolean;
    /**
     * @hidden
     */
    get _am(): boolean;
    /**
     * @hidden
     */
    get _af(): boolean;
    /**
     * @hidden
     */
    set _af(a: boolean);
    /**
     * @hidden
     */
    protected get__z(): boolean;
    /**
     * @hidden
     */
    get _z(): boolean;
    /**
     * @hidden
     */
    get _ao(): string;
    /**
     * @hidden
     */
    static _an(a: Worksheet): string;
    /**
     * @hidden
     */
    _g(a: IEnumerable$1<WorksheetRegion>, b?: boolean): ConditionBase;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _e;
    /**
     * @hidden
     */
    private static _f;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    abstract _h(): ConditionBase;
    /**
     * @hidden
     */
    abstract _a5(): void;
    /**
     * @hidden
     */
    _y(a: number, b: number, c: boolean): boolean;
    /**
     * @hidden
     */
    _a6(a: IEnumerable$1<WorksheetRegionAddress>): void;
    /**
     * @hidden
     */
    static _at(a: Workbook, b: any): number;
    /**
     * @hidden
     */
    static _as(a: Workbook, b: any, c: RefBase, d: SingleTargetFormula): number;
    /**
     * @hidden
     */
    _au(a: SingleTargetFormula, b: number, c: number, d: RefBase): {
        ret: number;
        p3?: RefBase;
    };
    /**
     * @hidden
     */
    _s(): WorksheetCellAddress;
    /**
     * @hidden
     */
    _p(): Workbook;
    /**
     * @hidden
     */
    static _aa(a: Formula, b: Worksheet): boolean;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    private _a8;
    /**
     * @hidden
     */
    _ac(a: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _ab(a: WorksheetRegionAddress[]): boolean;
    /**
     * @hidden
     */
    _ad(a: number, b: number): boolean;
    /**
     * @hidden
     */
    static _ae(a: number): boolean;
    /**
     * @hidden
     */
    _a9(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    abstract _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    _ba(): void;
    /**
     * @hidden
     */
    _bb(): void;
    /**
     * @hidden
     */
    _bc(): void;
    /**
     * @hidden
     */
    _be(a: string): void;
    /**
     * @hidden
     */
    _bf(): void;
    /**
     * @hidden
     */
    _bg(): void;
    /**
     * @hidden
     */
    _o(a: string, b: Nullable$1<CellReferenceMode>): SingleTargetFormula;
    /**
     * @hidden
     */
    _m(a: SingleTargetFormula): SingleTargetFormula;
    /**
     * @hidden
     */
    static _n(a: string, b: Workbook, c: Nullable$1<CellReferenceMode>, d?: FormulaType, e?: number, f?: number, g?: List$1<WorkbookReferenceBase>): SingleTargetFormula;
    /**
     * @hidden
     */
    _bh(a: WorksheetCellAddress, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _bi(a: string): void;
    /**
     * @hidden
     */
    _bj(): void;
    /**
     * @hidden
     */
    _bk(a: Worksheet, b: WorksheetRegionAddress[]): void;
    /**
     * @hidden
     */
    private _bl;
    /**
     * @hidden
     */
    _bd(): void;
    /**
     * @hidden
     */
    _bs(a: IEnumerable$1<WorksheetRegionAddress>): void;
    /**
     * Sets the [[priority]] value for this rule such that it
     * is the first condition to be evaluated. Applicable only in the case
     * where there is more than one element contained within the associated
     * <see cref="ConditionalFormatCollection">collection</see>.
     * <p class="body">
     * When multiple <see cref="ConditionalFormatBase">conditions</see> exist
     * in the same <see cref="ConditionalFormatCollection">collection</see>,
     * the order in which they are evaluated has bearing on which format is applied
     * to cells which meet those conditions.
     * </p>
     * <p class="body">
     * This method ensures that the associated condition is the first one to be
     * evaluated.
     * </p>
     * <p class="body">
     * To make a condition the last one to be evaluated, use the [[setLastPriority]]
     * method.
     * </p>
     * @see [[priority]]
     * @see [[setLastPriority]]
     */
    setFirstPriority(): void;
    /**
     * Sets the [[priority]] value for this rule such that it
     * is the last condition to be evaluated. Applicable only in the case
     * where there is more than one element contained within the associated
     * [[ConditionalFormatCollection]].
     * <p class="body">
     * Just as the [[setFirstPriority]] method ensures that the associated
     * condition is evalulated first, the <i>SetLastPriority</i> method ensures that
     * the associated condition is evaluated last.
     * </p>
     * <p class="body">
     * Calling this method on more than one condition essentially replaces the previously
     * designated condition as the last one to be evaluated with this one.
     * </p>
     * @see [[priority]]
     * @see [[setLastPriority]]
     * @see [[stopIfTrue]]
     */
    setLastPriority(): void;
    /**
     * Replaces the existing regions with new ones
     * @param regionAddress A string with one or more comma separated region address
     * @param cellReferenceMode An optional cell reference mode
     * @throws [[ArgumentException]] If regionAddress is invalid or contains a region from another worksheet
     */
    setRegions(regionAddress: string, cellReferenceMode: CellReferenceMode | null): void;
    /**
     * @hidden
     */
    _setRegions$i(a: string, b: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    _aj(a: boolean, b: CellShiftOperation, c: ICellShiftOperationOverride, d: List$1<WorksheetRegionAddress>): boolean;
    /**
     * @hidden
     */
    _bq(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _bp(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: any, c: SingleTargetFormula, d: CellShiftOperation, e: ICellShiftOperationOverride): {
        p2?: SingleTargetFormula;
    };
    /**
     * @hidden
     */
    _a0(a?: CellReferenceMode, b?: boolean): string;
    /**
     * @hidden
     */
    static _a1(a: Worksheet, b: IList$1<WorksheetRegion>, c?: CellReferenceMode, d?: boolean, e?: boolean, f?: IList$1<string>, g?: Nullable$1<string>): string;
    /**
     * @hidden
     */
    static _c(a: Nullable$1<CellReferenceMode>, b: Workbook): CellReferenceMode;
    /**
     * @hidden
     */
    _a4(a: any, b: string): string;
    /**
     * @hidden
     */
    _a3(a: string, b: SingleTargetFormula): {
        ret: string;
        p1?: SingleTargetFormula;
    };
    /**
     * @hidden
     */
    private static _br;
    /**
     * @hidden
     */
    shiftFormulas(callback: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, shiftOperation: CellShiftOperation, operationOverride: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    undoFormulaShift(context: any, originalFormula: string): string;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    get sheet(): Sheet;
}
/**
 * @hidden
 */
export declare class Worksheet_CellCommentDeleteChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: Worksheet, c: List$1<KeyValuePair$2<WorksheetCellAddress, WorksheetCellComment>>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: Worksheet;
    readonly a: KeyValuePair$2<WorksheetCellAddress, WorksheetCellComment>[];
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class Worksheet_CellInsertDeleteChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: Worksheet, c: WorksheetRegionAddress, d: boolean);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: Worksheet;
    readonly b: WorksheetRegionAddress;
    readonly c: boolean;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class Worksheet_HideUnhideChangeContext extends ValueType implements IChangeInfoContext, IWorksheetRegionAddressContext, IWorksheetElementResizeContext {
    static $t: Type;
    constructor(a: number, b: Worksheet, c: number, d: number, e: boolean, f: boolean, g: List$1<IndexRange>, h: WorksheetResizeInfo);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly a;
    private readonly f;
    private readonly g;
    private readonly d;
    private readonly h;
    private c;
    private readonly e;
    i(): string;
    private b;
    j(a: ChangeInfo, b: boolean): void;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
    getRegionAddress(): WorksheetRegionAddress;
    get hasHiddenChanges(): boolean;
}
/**
 * @hidden
 */
export declare class Worksheet_SharedFormulaGroupChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetRegionAddress, c: any, d: Worksheet);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly c;
    private readonly b;
    private readonly a;
    d(): void;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class Worksheet_SharedFormulasShiftChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: Worksheet, c: List$1<KeyValuePair$2<any, WorksheetRegionAddress>>, d: List$1<KeyValuePair$2<any, WorksheetRegionAddress>>, e: List$1<any>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly d;
    private readonly b;
    private readonly c;
    private readonly a;
    e(): void;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class Worksheet_ResizeItemChangeContext extends ValueType implements IChangeInfoContext, IWorksheetRegionAddressContext, IWorksheetElementResizeContext {
    static $t: Type;
    constructor(a: number, b: Worksheet, c: List$1<WorksheetElementResizeState>, d: boolean, e: WorksheetResizeInfo, f: boolean);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly a;
    private readonly e;
    private readonly d;
    private readonly b;
    private readonly c;
    f(): void;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
    getRegionAddress(): WorksheetRegionAddress;
    get hasHiddenChanges(): boolean;
}
/**
 * @hidden
 */
export declare class WorksheetShapePosition extends Base {
    static $t: Type;
    e: Point;
    d: Point;
    b: WorksheetCellAddress;
    a: WorksheetCellAddress;
    constructor(a: WorksheetShape);
    c(a: WorksheetShape): void;
}
/**
 * @hidden
 */
export declare class WorksheetResizeInfo extends Base {
    static $t: Type;
    private c;
    private d;
    private b;
    constructor();
    h(): void;
    private static e;
    private static g;
    private static a;
    i(a: WorksheetShape, b: Rect): void;
    j(): void;
}
/**
 * Represents one worksheet in a Microsoft Excel workbook.
 * <p class="body">
 * An Excel worksheet is essentially a table with a limited number of rows and columns. To create new worksheet, use
 * [[WorksheetCollection.add]] method of the [[Workbook.worksheets]]
 * collection on a [[Workbook]] instance.
 * </p>
 */
export declare class Worksheet extends Sheet implements IWorksheetShapeOwner, ISortSettingsOwner {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _fz;
    /**
     * @hidden
     */
    private static readonly _f2;
    /**
     * @hidden
     */
    private static readonly _f3;
    /**
     * @hidden
     */
    private static readonly _f4;
    /**
     * @hidden
     */
    private static readonly _f5;
    /**
     * @hidden
     */
    private static readonly _gi;
    /**
     * @hidden
     */
    private static readonly _gj;
    /**
     * @hidden
     */
    private static readonly _gk;
    /**
     * @hidden
     */
    private static readonly _gn;
    /**
     * @hidden
     */
    private static readonly _gx;
    /**
     * @hidden
     */
    private static readonly _gy;
    /**
     * @hidden
     */
    private static readonly _gz;
    /**
     * @hidden
     */
    private static readonly _gv;
    /**
     * @hidden
     */
    static readonly _gw: number;
    /**
     * @hidden
     */
    private static readonly _gs;
    /**
     * @hidden
     */
    private static readonly _gu;
    /**
     * @hidden
     */
    private static readonly _gt;
    /**
     * @hidden
     */
    private static readonly _f7;
    /**
     * @hidden
     */
    private static readonly _f6;
    /**
     * @hidden
     */
    private static readonly _gr;
    /**
     * @hidden
     */
    static _ax: ChangeInfo[];
    private _fa;
    private _er;
    private _et;
    private _ev;
    private _ce;
    private _cg;
    private _fx;
    private _go;
    private _gq;
    private _f0;
    private _du;
    private _ci;
    private _jd;
    private _cs;
    private _bn;
    /**
     * @hidden
     */
    readonly _c7: WorksheetRowCollection;
    private _db;
    private _bq;
    private _el;
    private _bj;
    /**
     * @hidden
     */
    _d7: boolean;
    private _df;
    private _fb;
    private _fe;
    private _ej;
    private _b1;
    private _bw;
    private _g2;
    private _e5;
    private _e6;
    private _dj;
    private _dk;
    private _ay;
    private _az;
    private _dn;
    /**
     * @hidden
     */
    _g1: Nullable$1<WorksheetRegionAddress>;
    private _cl;
    private _e9;
    private readonly _cu;
    private _jf;
    private _e4;
    /**
     * @hidden
     */
    readonly _eq: Dictionary$2<any, WorksheetRegionAddress>;
    private _bl;
    private _bs;
    private _di;
    /**
     * @hidden
     */
    readonly _bp: RegionLookupTable$1<WorksheetShape>;
    private _bg;
    private _bu;
    static staticInit(): void;
    constructor(a: string, b: Workbook, c: number);
    /**
     * @hidden
     */
    onSortSettingsModified(): void;
    /**
     * @hidden
     */
    get culture(): string | CultureInfo;
    /**
     * @hidden
     */
    get _culture$i(): CultureInfo;
    /**
     * @hidden
     */
    get sortRegion(): WorksheetRegion;
    /**
     * @hidden
     */
    get worksheet(): Worksheet;
    /**
     * @hidden
     */
    get areChildrenTopMost(): boolean;
    /**
     * @hidden
     */
    onChildShapeBoundsChanged(childShape: WorksheetShape, oldTopLeftCell: WorksheetCellAddress, oldBottomRightCell: WorksheetCellAddress, isNotifyOnly: boolean): void;
    /**
     * @hidden
     */
    onShapeAdded(shape: WorksheetShape): void;
    /**
     * @hidden
     */
    onShapeRemoved(shape: WorksheetShape): void;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * Clears all conditional formatting rules from the [[Worksheet]] so they do not get saved.
     * <para class="note"><b>Note:</b> this method is obsolete. Use the Worksheet.ConditionalFormats.Clear() method instead.</para>
     */
    clearConditionalFormattingData(): void;
    /**
     * Deletes a region of cells.
     * @param region The region to delete
     * @param shiftCellsLeft If true will shift cells left from the right of the region to occupy the deleted region, otherwise will shift cells up from below the region.
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it the range intersects with a protected region.
     * @throws [[ArgumentNullException]] If region is null.
     * @see [[deleteCells]]
     * @see [[insertCells]]
     * @see [[insertCells]]
     */
    deleteCells(region: WorksheetRegion, shiftCellsLeft: boolean): void;
    /**
     * Deletes a region of cells.
     * @param address The address of the region to delete
     * @param shiftCellsLeft If true will shift cells left from the right of the region to occupy the deleted region, otherwise will shift cells up from below the region.
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it the range intersects with a protected region.
     * @throws [[ArgumentException]] If address is not valid.
     * @see [[deleteCells]]
     * @see [[insertCells]]
     * @see [[insertCells]]
     */
    deleteCells(address: string, shiftCellsLeft: boolean): void;
    /**
     * @hidden
     */
    _deleteCells(a: WorksheetRegion, b: boolean): void;
    /**
     * @hidden
     */
    _deleteCells3(a: string, b: boolean): void;
    /**
     * @hidden
     */
    _he(a: WorksheetRegionAddress, b: boolean): void;
    /**
     * @hidden
     */
    private _hf;
    /**
     * Gets the cell at the specified address or name.
     * <p class="body">
     * The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the cell address.
     * </p>
     * <p class="body">
     * If one or more region references are specified instead of a cell reference, the top-left cell of the first region will be returned.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the cell.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the workbook's cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address. The overload taking an origin cell must be used to resolve relative R1C1 references.
     * @return A cell represented by the specified address or name.
     * @see [[Workbook.cellReferenceMode]]
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getCell(address: string): WorksheetCell;
    /**
     * Gets the cell at the specified address or name.
     * <p class="body">
     * If one or more region references are specified instead of a cell reference, the top-left cell of the first region will be returned.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the cell.
     * @param cellReferenceMode The cell reference mode to use to parse the cell address.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the specified cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address. The overload taking an origin cell must be used to resolve relative R1C1 references.
     * @return A cell represented by the specified address or name.
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getCell(address: string, cellReferenceMode: CellReferenceMode): WorksheetCell;
    /**
     * Gets the cell at the specified address or name.
     * <p class="body">
     * If one or more region references are specified instead of a cell reference, the top-left cell of the first region will be returned.
     * </p>
     * <p class="body">
     * The origin cell specified will not be used if a name is specified, if the workbook has an A1 cell reference mode, or if an absolute R1C1
     * address is specified.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the cell.
     * @param cellReferenceMode The cell reference mode to use to parse the cell address.
     * @param originCell The origin for resolving relative R1C1 references.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the specified cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address and 'originCell' is null. An origin cell must be specified to resolve relative
     * R1C1 references.
     * @return A cell represented by the specified address or name.
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getCell(address: string, cellReferenceMode: CellReferenceMode, originCell: WorksheetCell): WorksheetCell;
    /**
     * Gets the cell at the specified address or name.
     * <p class="body">
     * The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the cell address.
     * </p>
     * <p class="body">
     * If one or more region references are specified instead of a cell reference, the top-left cell of the first region will be returned.
     * </p>
     * <p class="body">
     * The origin cell specified will not be used if a name is specified, if the workbook has an A1 cell reference mode, or if an absolute R1C1
     * address is specified.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the cell.
     * @param originCell The origin for resolving relative R1C1 references.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the workbook's cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address and 'originCell' is null. An origin cell must be specified to resolve relative
     * R1C1 references.
     * @return A cell represented by the specified address or name.
     * @see [[Workbook.cellReferenceMode]]
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getCell(address: string, originCell: WorksheetCell): WorksheetCell;
    /**
     * @hidden
     */
    _getCell(a: string): WorksheetCell;
    /**
     * @hidden
     */
    _getCell1(a: string, b: CellReferenceMode): WorksheetCell;
    /**
     * @hidden
     */
    _getCell3(a: string, b: WorksheetCell): WorksheetCell;
    /**
     * @hidden
     */
    _getCell2(a: string, b: CellReferenceMode, c: WorksheetCell): WorksheetCell;
    /**
     * Gets the cell conditional format for the cell at the specified row and column index.
     * <para class="note"><b>Note:</b> if the cell is contained in one or more conditional format regions but doesn't match any of thse criteria an instance of [[CellConditionalFormat]]
     * will still be returned but its [[CellConditionalFormat.hasConditionFormatting]] property will return null. However, if the sell is not contained in any
     * conditional format region then this method will return null.</para>
     * @param rowIndex The 0-based index of the WorksheetRow within the [[rows]] collection.
     * @param columnIndex The 0-based index of the cell within the [[WorksheetRow]].
     * @throws [[ArgumentOutOfRangeException]] 'rowIndex' is less than zero or greater than or equal to the number of rows in the worksheet.
     * 'columnIndex' is less than zero or greater than or equal to the number of columns in the worksheet.
     * @return The aggregated condition format for the cell at the specified column index or null if the cell is not contained in any conditional format region.
     * @see [[conditionalFormats]]
     * @see [[CellConditionalFormat]]
     */
    getCellConditionalFormat(rowIndex: number, columnIndex: number): CellConditionalFormat;
    /**
     * @hidden
     */
    _getCellConditionalFormat1(a: number, b: number): CellConditionalFormat;
    /**
     * @hidden
     */
    private static _e8;
    /**
     * @hidden
     */
    _be(a: number, b: number, c: boolean): CellConditionalFormat;
    /**
     * Gets the default column width in the specified units.
     * <p class="body">
     * If 'units' is Character256th, the value returned will be the same as the value of the
     * [[defaultColumnWidth]] property.
     * </p>
     * @param units The units in which the width should be returned.
     * @throws [[InvalidEnumArgumentException]] 'units' is not defined in the [[WorksheetColumnWidthUnit]] enumeration.
     * @return The default column width in the specified units.
     * @see [[defaultColumnWidth]]
     * @see [[setDefaultColumnWidth]]
     * @see [[WorksheetColumn.getWidth]]
     */
    getDefaultColumnWidth(units: WorksheetColumnWidthUnit): number;
    /**
     * Gets the region at the specified address or name.
     * <p class="body">
     * The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the region address.
     * </p>
     * <p class="body">
     * If a cell reference is specified instead of a region reference, a 1x1 region containing the cell at the address will be returned.
     * </p>
     * <p class="body">
     * If a list of references is specified, the region specified by the first reference will be returned.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the workbook's cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address. The overload taking an origin cell must be used to resolve relative R1C1 references.
     * @return A region represented by the specified address or name.
     * @see [[Workbook.cellReferenceMode]]
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegion(address: string): WorksheetRegion;
    /**
     * Gets the region at the specified address or name.
     * <p class="body">
     * If a cell reference is specified instead of a region reference, a 1x1 region containing the cell at the address will be returned.
     * </p>
     * <p class="body">
     * If a list of references is specified, the region specified by the first reference will be returned.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @param cellReferenceMode The cell reference mode to use to parse the region address.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the specified cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address. The overload taking an origin cell must be used to resolve relative R1C1 references.
     * @return A region represented by the specified address or name.
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegion(address: string, cellReferenceMode: CellReferenceMode): WorksheetRegion;
    /**
     * Gets the region at the specified address or name.
     * <p class="body">
     * If a cell reference is specified instead of a region reference, a 1x1 region containing the cell at the address will be returned.
     * </p>
     * <p class="body">
     * If a list of references is specified, the region specified by the first reference will be returned.
     * </p>
     * <p class="body">
     * The origin cell specified will not be used if a name is specified, if the workbook has an A1 cell reference mode, or if an absolute R1C1
     * address is specified.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @param cellReferenceMode The cell reference mode to use to parse the region address.
     * @param originCell The origin for resolving relative R1C1 references.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the specified cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address and 'originCell' is null. An origin cell must be specified to resolve relative
     * R1C1 references.
     * @return A region represented by the specified address or name.
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegion(address: string, cellReferenceMode: CellReferenceMode, originCell: WorksheetCell): WorksheetRegion;
    /**
     * Gets the region at the specified address or name.
     * <p class="body">
     * The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the region address.
     * </p>
     * <p class="body">
     * If a cell reference is specified instead of a region reference, a 1x1 region containing the cell at the address will be returned.
     * </p>
     * <p class="body">
     * If a list of references is specified, the region specified by the first reference will be returned.
     * </p>
     * <p class="body">
     * The origin cell specified will not be used if a name is specified, if the workbook has an A1 cell reference mode, or if an absolute R1C1
     * address is specified.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to a cell or region in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @param originCell The origin for resolving relative R1C1 references.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the workbook's cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address and 'originCell' is null. An origin cell must be specified to resolve relative
     * R1C1 references.
     * @return A region represented by the specified address or name.
     * @see [[Workbook.cellReferenceMode]]
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegion(address: string, originCell: WorksheetCell): WorksheetRegion;
    /**
     * @hidden
     */
    _getRegion(a: string): WorksheetRegion;
    /**
     * @hidden
     */
    _getRegion1(a: string, b: CellReferenceMode): WorksheetRegion;
    /**
     * @hidden
     */
    _getRegion3(a: string, b: WorksheetCell): WorksheetRegion;
    /**
     * @hidden
     */
    _getRegion2(a: string, b: CellReferenceMode, c: WorksheetCell): WorksheetRegion;
    /**
     * Gets the regions at the specified address or name.
     * <p class="body">
     * The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the region address.
     * </p>
     * <p class="body">
     * The address can be a list of references, each one referring to a separate region on the Worksheet.
     * </p>
     * <p class="body">
     * If a cell or single region reference is specified instead, an array of one region at the address will be returned.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to cells or regions in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the workbook's cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address. The overload taking an origin cell must be used to resolve relative R1C1 references.
     * @return An array of regions represented by the specified address or name.
     * @see [[Workbook.cellReferenceMode]]
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegions(address: string): WorksheetRegion[];
    /**
     * Gets the regions at the specified address or name.
     * <p class="body">
     * The address can be a list of references, each one referring to a separate region on the Worksheet.
     * </p>
     * <p class="body">
     * If a cell or single region reference is specified instead, an array of one region at the address will be returned.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to cells or regions in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @param cellReferenceMode The cell reference mode to use to parse the region address.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the specified cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address. The overload taking an origin cell must be used to resolve relative R1C1 references.
     * @return An array of regions represented by the specified address or name.
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegions(address: string, cellReferenceMode: CellReferenceMode): WorksheetRegion[];
    /**
     * Gets the regions at the specified address or name.
     * <p class="body">
     * The address can be a list of references, each one referring to a separate region on the Worksheet.
     * </p>
     * <p class="body">
     * If a cell or single region reference is specified instead, an array of one region at the address will be returned.
     * </p>
     * <p class="body">
     * The origin cell specified will not be used if a name is specified, if the workbook has an A1 cell reference mode, or if an absolute R1C1
     * address is specified.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to cells or regions in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @param cellReferenceMode The cell reference mode to use to parse the region address.
     * @param originCell The origin for resolving relative R1C1 references.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the specified cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address and 'originCell' is null. An origin cell must be specified to resolve relative
     * R1C1 references.
     * @return An array of regions represented by the specified address or name.
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegions(address: string, cellReferenceMode: CellReferenceMode, originCell: WorksheetCell): WorksheetRegion[];
    /**
     * Gets the regions at the specified address or name.
     * <p class="body">
     * The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the region address.
     * </p>
     * <p class="body">
     * The address can be a list of references, each one referring to a separate region on the Worksheet.
     * </p>
     * <p class="body">
     * If a cell or single region reference is specified instead, an array of one region at the address will be returned.
     * </p>
     * <p class="body">
     * The origin cell specified will not be used if a name is specified, if the workbook has an A1 cell reference mode, or if an absolute R1C1
     * address is specified.
     * </p>
     * <p class="body">
     * If a name is specified, it must refer to cells or regions in the [[Worksheet]] and it must be scoped to the [[Workbook]]
     * or the Worksheet or null will be returned.
     * </p>
     * @param address The address or name of the region.
     * @param originCell The origin for resolving relative R1C1 references.
     * @throws [[ArgumentNullException]] 'address' is null.
     * @throws [[ArgumentException]] 'address' is not a valid name or a valid cell or region address in the workbook's cell reference mode.
     * @throws [[InvalidOperationException]] 'address' is a relative R1C1 address and 'originCell' is null. An origin cell must be specified to resolve relative
     * R1C1 references.
     * @return An array of regions represented by the specified address or name.
     * @see [[Workbook.cellReferenceMode]]
     * @see [[NamedReference.referencedCell]]
     * @see [[NamedReference.referencedRegion]]
     * @see [[NamedReference.referencedRegions]]
     */
    getRegions(address: string, originCell: WorksheetCell): WorksheetRegion[];
    /**
     * @hidden
     */
    _getRegions(a: string): WorksheetRegion[];
    /**
     * @hidden
     */
    _getRegions1(a: string, b: CellReferenceMode): WorksheetRegion[];
    /**
     * @hidden
     */
    _getRegions3(a: string, b: WorksheetCell): WorksheetRegion[];
    /**
     * @hidden
     */
    _getRegions2(a: string, b: CellReferenceMode, c: WorksheetCell): WorksheetRegion[];
    /**
     * Inserts a region of cells.
     * @param region The region to insert
     * @param shiftCellsRight If true will shift existing cells right to make room for the newly inserted cells, otherwise will shift existing cells down below the region.
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[ArgumentNullException]] If region is null.
     * @see [[insertCells]]
     * @see [[deleteCells]]
     * @see [[deleteCells]]
     */
    insertCells(region: WorksheetRegion, shiftCellsRight: boolean): void;
    /**
     * Inserts a region of cells.
     * @param address The region to insert
     * @param shiftCellsRight If true will shift existing cells right to make room for the newly inserted cells, otherwise will shift existing cells down below the region.
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[ArgumentException]] If address is not valid.
     * @see [[insertCells]]
     * @see [[deleteCells]]
     * @see [[deleteCells]]
     */
    insertCells(address: string, shiftCellsRight: boolean): void;
    /**
     * @hidden
     */
    _insertCells(a: WorksheetRegion, b: boolean): void;
    /**
     * @hidden
     */
    _insertCells3(a: string, b: boolean): void;
    /**
     * @hidden
     */
    _hr(a: WorksheetRegionAddress, b: boolean): void;
    /**
     * @hidden
     */
    private _hs;
    /**
     * Hides the columns in the specified range.
     * @param startIndex The index of the first column to hide, or null to start hiding at the first column.
     * @param count The number of columns to hide. If null, a single column will be hidden when 'startIndex' is specified and
     * otherwise, all columns will be hidden.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'count' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' plus 'count' is greater than the number of columns in the worksheet.
     */
    hideColumns(startIndex?: number, count?: number): void;
    /**
     * @hidden
     */
    _hideColumns$i(a?: Nullable$1<number>, b?: Nullable$1<number>): void;
    /**
     * Hides the rows in the specified range.
     * @param startIndex The index of the first row to hide, or null to start hiding at the first row.
     * @param count The number of rows to hide. If null, a single row will be hidden when 'startIndex' is specified and
     * otherwise, all rows will be hidden.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'count' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' plus 'count' is greater than the number of rows in the worksheet.
     */
    hideRows(startIndex?: number, count?: number): void;
    /**
     * @hidden
     */
    _hideRows$i(a?: Nullable$1<number>, b?: Nullable$1<number>): void;
    /**
     * Moves the worksheet to a new position in the owning workbook's collections of worksheets.
     * @param index The new 0-based index to where the worksheet should be moved.
     * @throws [[InvalidOperationException]] The worksheet has previously been removed from its workbook.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to the number of worksheets in the owning workbook.
     * @see [[Workbook.worksheets]]
     * @see [[WorksheetCollection.indexOf]]
     * @see [[index]]
     */
    moveToIndex(index: number): void;
    /**
     * Protects the worksheet without a password.
     * <p class="body">When a Worksheet is protected without a password, the end user may unprotect the Worksheet in Excel without
     * having to supply a password. To programatically unprotect a Worksheet, one may use the Unprotect() method.</p>
     * <p class="body">The optional parameters are used to update the property values of the [[WorksheetProtection]] instance from
     * this Worksheet's [[protection]] property. If the parameter is null, the current value of the associated property will
     * be retained; otherwise the property will be updated with the specified value. For example, if the [[WorksheetProtection.allowDeletingColumns]]
     * is currently true and the 'allowDeletingColumns' is null, then the property will continue to be true but if the
     * 'allowDeletingColumns' is false the [[WorksheetProtection.allowDeletingColumns]] will be changed to false.</p>
     * <p class="body">When one protects a Worksheet in Excel, the UI allows one to choose which cells may be selected. To affect this state one would
     * change the [[WorksheetProtection.selectionMode]] property before or after protecting the Worksheet.</p>
     * <p class="note"><b>Note:</b> If IsProtected is already true, the method will be ignored.</p>
     * @param allowDeletingColumns Optional boolean indicating the new value for the [[WorksheetProtection.allowDeletingColumns]].
     * @param allowDeletingRows Optional boolean indicating the new value for the [[WorksheetProtection.allowDeletingRows]].
     * @param allowEditObjects Optional boolean indicating the new value for the [[WorksheetProtection.allowEditObjects]].
     * @param allowEditScenarios Optional boolean indicating the new value for the [[WorksheetProtection.allowEditScenarios]].
     * @param allowFiltering Optional boolean indicating the new value for the [[WorksheetProtection.allowFiltering]].
     * @param allowFormattingCells Optional boolean indicating the new value for the [[WorksheetProtection.allowFormattingCells]].
     * @param allowFormattingColumns Optional boolean indicating the new value for the [[WorksheetProtection.allowFormattingColumns]].
     * @param allowFormattingRows Optional boolean indicating the new value for the [[WorksheetProtection.allowFormattingRows]].
     * @param allowInsertingColumns Optional boolean indicating the new value for the [[WorksheetProtection.allowInsertingColumns]].
     * @param allowInsertingHyperlinks Optional boolean indicating the new value for the [[WorksheetProtection.allowInsertingHyperlinks]].
     * @param allowInsertingRows Optional boolean indicating the new value for the [[WorksheetProtection.allowInsertingRows]].
     * @param allowSorting Optional boolean indicating the new value for the [[WorksheetProtection.allowSorting]].
     * @param allowUsingPivotTables Optional boolean indicating the new value for the [[WorksheetProtection.allowUsingPivotTables]].
     * @see@see@see [[protection]]
     * @see [[WorksheetProtection]]
     * @see */
    protect(allowDeletingColumns?: boolean, allowDeletingRows?: boolean, allowEditObjects?: boolean, allowEditScenarios?: boolean, allowFiltering?: boolean, allowFormattingCells?: boolean, allowFormattingColumns?: boolean, allowFormattingRows?: boolean, allowInsertingColumns?: boolean, allowInsertingHyperlinks?: boolean, allowInsertingRows?: boolean, allowSorting?: boolean, allowUsingPivotTables?: boolean): void;
    /**
     * @hidden
     */
    _protect$i(a?: Nullable$1<boolean>, b?: Nullable$1<boolean>, c?: Nullable$1<boolean>, d?: Nullable$1<boolean>, e?: Nullable$1<boolean>, f?: Nullable$1<boolean>, g?: Nullable$1<boolean>, h?: Nullable$1<boolean>, i?: Nullable$1<boolean>, j?: Nullable$1<boolean>, k?: Nullable$1<boolean>, l?: Nullable$1<boolean>, m?: Nullable$1<boolean>): void;
    /**
     * Sets the default column width in the specified units.
     * @param value The default column width to set on the worksheet, expressed in the specified 'units'.
     * @param units The units in which the 'value' is expressed.
     * @throws [[ArgumentException]] 'value' is infinity or NaN.
     * @throws [[InvalidEnumArgumentException]] 'units' is not defined in the [[WorksheetColumnWidthUnit]] enumeration.
     * @see [[defaultColumnWidth]]
     * @see [[getDefaultColumnWidth]]
     * @see [[WorksheetColumn.setWidth]]
     */
    setDefaultColumnWidth(value: number, units: WorksheetColumnWidthUnit): void;
    /**
     * @hidden
     */
    _iq(a: number, b: WorksheetColumnWidthUnit, c: boolean, d: boolean): void;
    /**
     * Unhides the columns in the specified range.
     * @param startIndex The index of the first column to unhide, or null to start unhiding at the first column.
     * @param count The number of columns to unhide. If null, a single column will be unhidden when 'startIndex' is specified and
     * otherwise, all columns will be unhidden.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'count' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' plus 'count' is greater than the number of columns in the worksheet.
     */
    unhideColumns(startIndex?: number, count?: number): void;
    /**
     * @hidden
     */
    _unhideColumns$i(a?: Nullable$1<number>, b?: Nullable$1<number>): void;
    /**
     * Unhides the rows in the specified range.
     * @param startIndex The index of the first row to unhide, or null to start unhiding at the first row.
     * @param count The number of rows to unhide. If null, a single row will be unhidden when 'startIndex' is specified and
     * otherwise, all rows will be unhidden.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'count' is less than 0.
     * @throws [[ArgumentException]] Occurs when the 'startIndex' plus 'count' is greater than the number of rows in the worksheet.
     */
    unhideRows(startIndex?: number, count?: number): void;
    /**
     * @hidden
     */
    _unhideRows$i(a?: Nullable$1<number>, b?: Nullable$1<number>): void;
    /**
     * @hidden
     */
    _g5(a: WorksheetRegion, b: WorksheetRegion, c?: boolean): {
        p1: WorksheetRegion;
    };
    /**
     * @hidden
     */
    _dp(a: number, b: number, c: number): boolean;
    /**
     * @hidden
     */
    private _dq;
    /**
     * @hidden
     */
    _g6(a: PivotTableInfo): void;
    /**
     * @hidden
     */
    _g7(a: BinaryData): void;
    /**
     * @hidden
     */
    _hc(): void;
    /**
     * @hidden
     */
    _a0(a: number, b: number): WorksheetColumnBlock[];
    /**
     * @hidden
     */
    _fj(a: number): number;
    /**
     * @hidden
     */
    _fk(a: number, b: boolean): number;
    /**
     * @hidden
     */
    _fl(a: number, b: WorksheetColumnWidthUnit, c?: boolean): number;
    /**
     * @hidden
     */
    _fm(a: number): number;
    /**
     * @hidden
     */
    _fn(a: number): number;
    /**
     * @hidden
     */
    _fw(a: number, b: WorksheetColumnWidthUnit, c?: boolean): number;
    /**
     * @hidden
     */
    _d(a: CustomView): DisplayOptionsBase;
    /**
     * @hidden
     */
    _f(): PrintOptionsBase;
    /**
     * @hidden
     */
    _b6(a: number, b: number, c: number): WorksheetCellShiftResult;
    /**
     * @hidden
     */
    _hh(): void;
    /**
     * @hidden
     */
    _hi(a: WorksheetRegionAddress, b?: HashSet$1<WorksheetMergedCellsRegion>): {
        p0?: WorksheetRegionAddress;
    };
    /**
     * @hidden
     */
    _cw(a: WorksheetRegionAddress): WorksheetRegion;
    /**
     * @hidden
     */
    _cx(a: number, b: number, c: number, d: number): WorksheetRegion;
    /**
     * @hidden
     */
    _de(a: number, b: number): WorksheetTable;
    /**
     * @hidden
     */
    _b4(a: WorksheetRow, b: number): WorksheetCellFormatData;
    /**
     * @hidden
     */
    _ck(a: WorksheetRow, b: number, c: number): WorksheetHyperlink;
    /**
     * @hidden
     */
    _cb(a: number): WorksheetColumnBlock;
    /**
     * @hidden
     */
    _f9(a: number): number;
    /**
     * @hidden
     */
    _cn(a: number): WorksheetItemPosition;
    /**
     * @hidden
     */
    _co(a: number): WorksheetItemPosition;
    /**
     * @hidden
     */
    _e1(a: number, b: number, c?: number): IList$1<WorksheetItemPosition>;
    /**
     * @hidden
     */
    _e0(a: number, b: number, c?: number): IList$1<WorksheetItemPosition>;
    /**
     * @hidden
     */
    private __ex;
    _ex(a: number, b: number, c: boolean): IEnumerable$1<WorksheetColumn>;
    /**
     * @hidden
     */
    _gb(a: number, b?: boolean): number;
    /**
     * @hidden
     */
    _ga(a: WorksheetColumnBlock, b?: boolean): number;
    /**
     * @hidden
     */
    _gd(a: number, b?: boolean): number;
    /**
     * @hidden
     */
    _gc(a: WorksheetColumnBlock, b: boolean): number;
    /**
     * @hidden
     */
    _fp(a: number, b?: boolean): number;
    /**
     * @hidden
     */
    _fo(a: WorksheetColumnBlock, b: boolean): number;
    /**
     * @hidden
     */
    _fq(a: number, b: number, c?: boolean): number;
    /**
     * @hidden
     */
    _ge(): number;
    /**
     * @hidden
     */
    _cr(a: number, b: number): WorksheetMergedCellsRegion;
    /**
     * @hidden
     */
    _ey(): IEnumerable$1<PivotTableInfo>;
    /**
     * @hidden
     */
    _gh(a: number, b?: boolean, c?: boolean): number;
    /**
     * @hidden
     */
    _gg(a: WorksheetRow, b: boolean): number;
    /**
     * @hidden
     */
    _fs(a: number, b?: boolean): number;
    /**
     * @hidden
     */
    _ft(a: number, b: number, c: boolean): number;
    /**
     * @hidden
     */
    _cp(a: number): WorksheetItemPosition;
    /**
     * @hidden
     */
    _cq(a: number): WorksheetItemPosition;
    /**
     * @hidden
     */
    _e3(a: number, b: number, c?: number): IList$1<WorksheetItemPosition>;
    /**
     * @hidden
     */
    _e2(a: number, b: number, c?: number): IList$1<WorksheetItemPosition>;
    /**
     * @hidden
     */
    _da(a: number, b: WorksheetShapeCollection): {
        ret: WorksheetShape;
        p1: WorksheetShapeCollection;
    };
    /**
     * @hidden
     */
    static _c9(a: WorksheetShapeCollection, b: number, c: WorksheetShapeCollection): {
        ret: WorksheetShape;
        p2: WorksheetShapeCollection;
    };
    /**
     * @hidden
     */
    _c2(a: Formula): WorksheetRegion;
    /**
     * @hidden
     */
    _c3(a: any): WorksheetRegion;
    /**
     * @hidden
     */
    _ez(): IEnumerable$1<BinaryData>;
    /**
     * @hidden
     */
    _fg(): List$1<IEscherRecord>;
    /**
     * @hidden
     */
    static _hm(a: WorksheetShapeCollection, b: List$1<IEscherRecord>): void;
    /**
     * @hidden
     */
    _b5(a: WorksheetCellFormatData, b: number, c: number): WorksheetCellFormatData;
    /**
     * @hidden
     */
    _c4(a: number, b: number, c: number, d: number, e: boolean): WorksheetRegionAddress;
    /**
     * @hidden
     */
    _dd(a: WorksheetTable, b: boolean, c: string, d?: Nullable$1<CellReferenceMode>, e?: boolean): WorksheetTable;
    /**
     * @hidden
     */
    _g8(): void;
    /**
     * @hidden
     */
    _b7(a: number, b: number, c: number, d: CellShiftInitializeFormatType): WorksheetCellShiftResult;
    /**
     * @hidden
     */
    _ec(a: number): boolean;
    /**
     * @hidden
     */
    _ed(a: number, b: number, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _eg(a: number): boolean;
    /**
     * @hidden
     */
    _ef(a: WorksheetRow): boolean;
    /**
     * @hidden
     */
    _hw(a: number, b: number, c: number, d: boolean, e: number, f: WorksheetCellFormatData, g?: boolean): void;
    /**
     * @hidden
     */
    _hx(a: number, b: number): void;
    /**
     * @hidden
     */
    _hy(a: number, b: number): void;
    /**
     * @hidden
     */
    _ao(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    _hz(a: boolean): void;
    /**
     * @hidden
     */
    _h0(): void;
    /**
     * @hidden
     */
    _aq(): void;
    /**
     * @hidden
     */
    _h2(a: Formula, b: WorksheetRegion): void;
    /**
     * @hidden
     */
    _h3(a: Formula, b?: boolean): void;
    /**
     * @hidden
     */
    _g4(a: ExcelChangeAction, b?: string): any;
    /**
     * @hidden
     */
    _h4(a: any): void;
    /**
     * @hidden
     */
    _h5(): void;
    /**
     * @hidden
     */
    _h7(): void;
    /**
     * @hidden
     */
    private _h6;
    /**
     * @hidden
     */
    _ia(a: WorksheetColumnBlock[]): void;
    /**
     * @hidden
     */
    private _h9;
    /**
     * @hidden
     */
    _ib(a: number, b: number, c: List$1<IFilterable>): void;
    /**
     * @hidden
     */
    _ic(a: WorksheetRegionAddress): {
        p0?: WorksheetRegionAddress;
    };
    /**
     * @hidden
     */
    _ei(a: number, b: number): boolean;
    /**
     * @hidden
     */
    _ie(): void;
    /**
     * @hidden
     */
    _ig(): void;
    /**
     * @hidden
     */
    _ih(a: WorksheetRegionAddress, b?: HashSet$1<WorksheetMergedCellsRegion>): void;
    /**
     * @hidden
     */
    _ii(a: WorksheetRow, b: number): void;
    /**
     * @hidden
     */
    _ik(a: List$1<IndexRange>, b: number): void;
    /**
     * @hidden
     */
    _il(a: List$1<WorksheetElementResizeState>, b: WorksheetResizeInfo): void;
    /**
     * @hidden
     */
    _im(a: List$1<IndexRange>, b: number): void;
    /**
     * @hidden
     */
    _io(a: List$1<WorksheetElementResizeState>, b: WorksheetResizeInfo): void;
    /**
     * @hidden
     */
    _b8(a: CellShiftOperation, b: CellShiftInitializeFormatType, c?: ICellShiftOperationOverride, d?: boolean, e?: CellFormatValueChangedOptions): WorksheetCellShiftResult;
    /**
     * @hidden
     */
    _b9(a: number, b: number, c: number, d: number, e: number, f: CellShiftInitializeFormatType): WorksheetCellShiftResult;
    /**
     * @hidden
     */
    _cc(a: number, b: number): WorksheetColumnBlock;
    /**
     * @hidden
     */
    _en(a: WorksheetRow, b: number, c: Date, d?: boolean): {
        ret: boolean;
        p2: Date;
    };
    /**
     * @hidden
     */
    _cd(a: number): WorksheetColumnBlock;
    /**
     * @hidden
     */
    _bi(a: number, b: number): DataValidationRule;
    /**
     * @hidden
     */
    _eo(a: WorksheetRow, b: number, c: number): {
        ret: boolean;
        p0?: WorksheetRow;
        p1?: number;
        p2?: number;
    };
    /**
     * @hidden
     */
    _a7(a: number, b: number, c: number, d: number, e: number, f: CellShiftType): CellShiftResult;
    /**
     * @hidden
     */
    private _a6;
    /**
     * @hidden
     */
    private _ep;
    /**
     * @hidden
     */
    _av(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    _jc(a: Formula, b: WorksheetRow, c: number): void;
    /**
     * @hidden
     */
    private _ca;
    /**
     * @hidden
     */
    private _fu;
    /**
     * @hidden
     */
    private _ha;
    /**
     * @hidden
     */
    _g9(): void;
    /**
     * @hidden
     */
    private static _a9;
    /**
     * @hidden
     */
    private static _a8;
    /**
     * @hidden
     */
    private static _ba;
    /**
     * @hidden
     */
    private static _bb;
    /**
     * @hidden
     */
    private static _bc;
    /**
     * @hidden
     */
    private static _bd;
    /**
     * @hidden
     */
    private static _a1;
    /**
     * @hidden
     */
    private _hj;
    /**
     * @hidden
     */
    private _f8;
    /**
     * @hidden
     */
    private _hk;
    /**
     * @hidden
     */
    private _hl;
    /**
     * @hidden
     */
    private static _gf;
    /**
     * @hidden
     */
    private _hp;
    /**
     * @hidden
     */
    private _hu;
    /**
     * @hidden
     */
    _h1(): void;
    /**
     * @hidden
     */
    private _id;
    /**
     * @hidden
     */
    private static _i4;
    /**
     * @hidden
     */
    private static _i2;
    /**
     * @hidden
     */
    private static _i3;
    /**
     * @hidden
     */
    private static _i5;
    /**
     * @hidden
     */
    private static _i6;
    /**
     * @hidden
     */
    private static _i7;
    /**
     * @hidden
     */
    private static _i8;
    /**
     * @hidden
     */
    private static _jb;
    /**
     * Gets the column at the specified index.
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all columns. It will only iterate the columns which have already
     * been used.  To create and iterate all columns in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum column count, and pass in each index to the collection's indexer.
     * </p>
     * The column at the specified index.
     * @param index The zero-based index of the column to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
     * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelColumnCount]]
     * or [[Workbook.maxExcel2007ColumnCount]], depending on the [[Workbook.currentFormat]].
     */
    columns(index: number): WorksheetColumn;
    /**
     * Gets the collection of columns in the worksheet.
     * <p class="body">
     * The collection of columns is a fixed length collection, with the maximum number of columns in the collection being
     * [[Workbook.maxExcelColumnCount]] or [[Workbook.maxExcel2007ColumnCount]],
     * depending on the <see cref="Excel.Workbook.CurrentFormat">Workbook.CurrentFormat</see>. Internally, the columns
     * are only created and added to the collection when they are requested.
     * </p>
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all columns. It will only iterate the columns which have already
     * been used.  To create and iterate all columns in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum column count, and pass in each index to the collection's indexer.
     * </p>
     * The collection of columns in the worksheet.
     * @see [[WorksheetColumn]]
     */
    columns(): WorksheetColumnCollection;
    /**
     * @hidden
     */
    get _columns$i(): WorksheetColumnCollection;
    /**
     * Indexer
     * @param index The zer-based index of an item
     * @return The item at the specified index
     * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
     */
    conditionalFormats(index: number): ConditionBase;
    /**
     * Returns a <see cref="ConditionalFormatting.ConditionalFormatCollection">collection</see>
     * to which <see cref="ConditionalFormatting.ConditionBase">conditions</see> can be added to
     * control the visual attributes of a [[WorksheetCell]] based on user-defined criteria.
     * @see [[ConditionalFormatCollection]]
     * @see [[ConditionalFormatCollection.addAverageCondition]]
     * @see [[ConditionalFormatCollection.addBlanksCondition]]
     * @see [[ConditionalFormatCollection.addColorScaleCondition]]
     * @see [[ConditionalFormatCollection.addDataBarCondition]]
     * @see [[ConditionalFormatCollection.addDateTimeCondition]]
     * @see [[ConditionalFormatCollection.addDuplicateCondition]]
     * @see [[ConditionalFormatCollection.addErrorsCondition]]
     * @see [[ConditionalFormatCollection.addFormulaCondition]]
     * @see [[ConditionalFormatCollection.addIconSetCondition]]
     * @see [[ConditionalFormatCollection.addNoBlanksCondition]]
     * @see [[ConditionalFormatCollection.addNoErrorsCondition]]
     * @see [[ConditionalFormatCollection.addOperatorCondition]]
     * @see [[ConditionalFormatCollection.addRankCondition]]
     * @see [[ConditionalFormatCollection.addTextCondition]]
     * @see [[ConditionalFormatCollection.addUniqueCondition]]
     * @see [[ConditionBase]]
     */
    conditionalFormats(): ConditionalFormatCollection;
    /**
     * @hidden
     */
    get _conditionalFormats$i(): ConditionalFormatCollection;
    /**
     * Gets the data table at the specified index in the collection.
     * The data table at the specified index.
     * @param index The zero-based index of the data table to get.
     */
    dataTables(index: number): WorksheetDataTable;
    /**
     * Gets the collection of data tables in the worksheet.
     * The collection of data tables in the worksheet.
     * @see [[WorksheetDataTable]]
     */
    dataTables(): WorksheetDataTableCollection;
    /**
     * @hidden
     */
    get _dataTables$i(): WorksheetDataTableCollection;
    /**
     * @hidden
     */
    get _d5(): boolean;
    /**
     * Gets or sets the references which have the data validation rule applied to it.
     * @param rule A data validation rule.
     * @throws [[ArgumentNullException]] Occurs when the 'rule' is null.
     * @throws [[KeyNotFoundException]] Occurs when the property is retrieved and the 'rule' is not applied to the [[worksheet]].
     * @throws [[ArgumentException]] Occurs when the property is set and the value is from a Worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the property is set and the 'rule' is invalid based on its rule type's requirements.
     */
    dataValidationRules(rule: DataValidationRule, value?: WorksheetReferenceCollection): WorksheetReferenceCollection;
    /**
     * Gets the collection of data validation rules applied to cells in the Worksheet.
     * @see [[DataValidationRule]]
     * @see [[WorksheetCell.dataValidationRule]]
     */
    dataValidationRules(): DataValidationRuleCollection;
    /**
     * @hidden
     */
    get _dataValidationRules$i(): DataValidationRuleCollection;
    /**
     * @hidden
     */
    get _d6(): boolean;
    /**
     * Gets or sets the default column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
     * <p class="body">
     * The default column width is the width of all columns which do not have their width set.
     * </p>
     * <p class="body">
     * The value assigned must be between 0 and 65535. Invalid values will be automatically adjusted to valid values.
     * </p>
     * <p class="body">
     * Setting or getting this property is equivalent to calling [[setDefaultColumnWidth]]
     * or [[getDefaultColumnWidth]] using the [[WorksheetColumnWidthUnit]] value of Character256th.
     * </p>
     * The default column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
     * @see [[getDefaultColumnWidth]]
     * @see [[setDefaultColumnWidth]]
     * @see [[WorksheetColumn.width]]
     * @see [[Workbook.characterWidth256thsToPixels]]
     * @see [[Workbook.pixelsToCharacterWidth256ths]]
     */
    get defaultColumnWidth(): number;
    set defaultColumnWidth(a: number);
    /**
     * @hidden
     */
    private _ir;
    /**
     * @hidden
     */
    private _is;
    /**
     * Gets or sets the default row height in twips (1/20th of a point).
     * <p class="body">
     * The default row height is the height of all rows which do not have their height explicitly set
     * to a positive number.
     * </p>
     * <p class="body">
     * If the assigned value is -1, the default row height will then be calculated based on the default font
     * for the workbook, and subsequently getting this property will return the font-based default row height.
     * </p>
     * The default row height in twips (1/20th of a point).
     * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the value range of -1 and 8192.
     */
    get defaultRowHeight(): number;
    set defaultRowHeight(a: number);
    /**
     * @hidden
     */
    private _it;
    /**
     * @hidden
     */
    get _d4(): boolean;
    /**
     * Gets the object which controls the display of the worksheet.
     * <p class="body">
     * The display options include any settings which affect the display of the worksheet when viewed in Microsoft Excel.
     * These settings will not affect the printed worksheet or the data stored in the worksheet.
     * </p>
     * The object which controls the display of the worksheet.
     * @see [[CustomView.getDisplayOptions]]
     */
    get displayOptions(): WorksheetDisplayOptions;
    /**
     * Exposes methods to identify a region in the worksheet and to apply filters and optionally sort criteria to that region.
     */
    get filterSettings(): WorksheetFilterSettings;
    /**
     * Gets the hyperlink at the specified index in the collection.
     * The hyperlink at the specified index.
     * @param index The zero-based index of the hyperlink to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    hyperlinks(index: number): WorksheetHyperlink;
    /**
     * Gets the collection of hyperlinks applied to cells and regions in the Worksheet.
     * @see [[WorksheetHyperlink]]
     * @see [[WorksheetCell.getHyperlink]]
     * @see [[WorksheetRow.getCellHyperlink]]
     */
    hyperlinks(): WorksheetHyperlinkCollection;
    /**
     * @hidden
     */
    get _hyperlinks$i(): WorksheetHyperlinkCollection;
    /**
     * @hidden
     */
    get _d8(): boolean;
    /**
     * @hidden
     */
    get _je(): WBitmap;
    /**
     * @hidden
     */
    set _je(a: WBitmap);
    /**
     * @hidden
     */
    private _iz;
    /**
     * Gets the zero-based index of this worksheet in its parent [[Workbook.worksheets]] collection.
     * <p class="body">
     * Negative one indicates the worksheet has been removed from its parent collection.
     * </p>
     * The zero-based index of this worksheet in its parent Worksheets collection.
     * @see [[WorksheetCollection.indexOf]]
     * @see [[moveToIndex]]
     */
    get index(): number;
    /**
     * Gets the merged cell region at the specified index.
     * The merged cell region at the specified index.
     * @param index The zero-based index of the merged cell region to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    mergedCellsRegions(index: number): WorksheetMergedCellsRegion;
    /**
     * Gets the collection of merged cell ranges in this worksheet.
     * <p class="body">Use [[WorksheetMergedCellsRegionCollection.add]] method to add new merged cell ranges to the worksheet.</p>
     * The collection of merged cell ranges in this worksheet.
     * @see [[WorksheetMergedCellsRegion]]
     */
    mergedCellsRegions(): WorksheetMergedCellsRegionCollection;
    /**
     * @hidden
     */
    get _mergedCellsRegions$i(): WorksheetMergedCellsRegionCollection;
    /**
     * @hidden
     */
    get _d9(): boolean;
    /**
     * Gets the object which controls how the worksheet prints.
     * <p class="body">
     * The print options include any settings which affect the printed appearance of the worksheet.  These settings will
     * not affect the data in the worksheet.  Although these are not display settings, some worksheet display styles will
     * display all or some of the print options, so these settings may affect the display of the worksheet when viewed in
     * Microsoft Excel.
     * </p>
     * The object which controls how the worksheet prints.
     * @see [[CustomView.getPrintOptions]]
     */
    get printOptions(): PrintOptions;
    /**
     * Returns an object that provides information used when the Worksheet has been protected.
     * @see@see@see [[WorksheetProtection]]
     * @see [[protect]]
     * @see */
    get protection(): WorksheetProtection;
    /**
     * Gets the row at the specified index.
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all rows. It will only iterate the rows which have already
     * been used.  To create and iterate all rows in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum row count, and pass in each index to the collection's indexer.
     * </p>
     * The row at the specified index.
     * @param index The zero-based index of the row to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
     * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelRowCount]]
     * or [[Workbook.maxExcel2007RowCount]], depending on the [[Workbook.currentFormat]].
     */
    rows(index: number): WorksheetRow;
    /**
     * Gets the collection of rows in the worksheet.
     * <p class="body">
     * The collection of rows is a fixed length collection, with the maximum number of rows in the collection being
     * [[Workbook.maxExcelRowCount]] or [[Workbook.maxExcel2007RowCount]],
     * depending on the <see cref="Excel.Workbook.CurrentFormat">Workbook.CurrentFormat</see>.  Internally, the rows are only created and added to the collection
     * when they are requested.
     * </p>
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all rows. It will only iterate the rows which have already
     * been used.  To create and iterate all rows in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum row count, and pass in each index to the collection's indexer.
     * </p>
     * The collection of rows in the worksheet.
     * @see [[WorksheetRow]]
     */
    rows(): WorksheetRowCollection;
    /**
     * @hidden
     */
    get _rows$i(): WorksheetRowCollection;
    /**
     * Exposes methods to identify a region in the worksheet and to apply sort criteria to that region.
     */
    get sortSettings(): WorksheetSortSettings;
    /**
     * Gets the shape at the specified index in the collection.
     * The shape at the specified index.
     * @param index The zero-based index of the shape to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    shapes(index: number): WorksheetShape;
    /**
     * Gets the collection of shapes on the worksheet.
     * The collection of shapes on the worksheet.
     * @see [[WorksheetShape]]
     */
    shapes(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    get _shapes$i(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    get ChildShapes(): WorksheetShapeCollection;
    /**
     * Indexer
     * @param index The zer-based index of an item
     * @return The item at the specified index
     * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
     */
    sparklineGroups(index: number): SparklineGroup;
    /**
     * Returns a collection of [[SparklineGroup]]s (read-only)
     */
    sparklineGroups(): SparklineGroupCollection;
    /**
     * @hidden
     */
    get _sparklineGroups$i(): SparklineGroupCollection;
    /**
     * Gets the [[WorksheetTable]] at the specified index.
     * The WorksheetTable at the specified index.
     * @param index The zero-based index of the WorksheetTable to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    tables(index: number): WorksheetTable;
    /**
     * Gets the [[WorksheetTable]] with the specified name.
     * <p class="body">
     * Worksheet names are compared case-insensitively.
     * </p>
     * The WorksheetTable with the specified name.
     * @param name The name of the WorksheetTable to get.
     * @throws [[InvalidOperationException]] A WorksheetTable with the specified name does not exist in the collection.
     * @see [[NamedReferenceBase.name]]
     */
    tables(name: string): WorksheetTable;
    /**
     * Gets the collection of [[WorksheetTable]] instances, or regions formatted as tables, in the worksheet.
     * @see [[WorksheetTable]]
     */
    tables(): WorksheetTableCollection;
    /**
     * @hidden
     */
    get _tables$i(): WorksheetTableCollection;
    /**
     * Returns a value indicating the type of sheet
     */
    protected get_type(): SheetType;
    /**
     * Returns a value indicating the type of sheet
     */
    get type(): SheetType;
    /**
     * @hidden
     */
    get _dr(): boolean;
    /**
     * @hidden
     */
    set _dr(a: boolean);
    /**
     * @hidden
     */
    get _es(): Dictionary$2<WorksheetCellAddress, WorksheetMergedCellsRegion>;
    /**
     * @hidden
     */
    get _d1(): boolean;
    /**
     * @hidden
     */
    get _fc(): List$1<CellShiftOperation>;
    /**
     * @hidden
     */
    get _fv(): number;
    /**
     * @hidden
     */
    get _eu(): Dictionary$2<WorksheetCellAddress, WorksheetCellComment>;
    /**
     * @hidden
     */
    get _d2(): boolean;
    /**
     * @hidden
     */
    get _ew(): Dictionary$2<ValueTuple$2<WorksheetRow, number>, any>;
    /**
     * @hidden
     */
    get _d3(): boolean;
    /**
     * @hidden
     */
    get _fd(): List$1<WorksheetCell>;
    /**
     * @hidden
     */
    get _ff(): List$1<WorksheetColumnBlock>;
    /**
     * @hidden
     */
    get _b2(): WorksheetCellFormatData;
    /**
     * @hidden
     */
    set _b2(a: WorksheetCellFormatData);
    /**
     * @hidden
     */
    get _b3(): WorksheetCellFormatData;
    /**
     * @hidden
     */
    protected get__e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    get _e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    get _gp(): number;
    /**
     * @hidden
     */
    _ij(): void;
    /**
     * @hidden
     */
    get _ds(): boolean;
    /**
     * @hidden
     */
    set _ds(a: boolean);
    /**
     * @hidden
     */
    get _dt(): boolean;
    /**
     * @hidden
     */
    set _dt(a: boolean);
    /**
     * @hidden
     */
    get _dv(): boolean;
    /**
     * @hidden
     */
    set _dv(a: boolean);
    /**
     * @hidden
     */
    _iu(a: boolean, b?: boolean): void;
    private _dl;
    /**
     * @hidden
     */
    get _dw(): boolean;
    /**
     * @hidden
     */
    _iv(a: boolean, b: boolean): void;
    /**
     * @hidden
     */
    private _iw;
    private _dm;
    /**
     * @hidden
     */
    get _dx(): boolean;
    /**
     * @hidden
     */
    _ix(a: boolean, b: boolean): void;
    /**
     * @hidden
     */
    private _iy;
    /**
     * @hidden
     */
    _dy(a: RowColumnBase): boolean;
    /**
     * @hidden
     */
    _dz(a: boolean): boolean;
    /**
     * @hidden
     */
    private get _d0();
    /**
     * @hidden
     */
    get _ea(): boolean;
    /**
     * @hidden
     */
    get _eb(): boolean;
    /**
     * @hidden
     */
    get _gl(): number;
    /**
     * @hidden
     */
    get _ee(): boolean;
    /**
     * @hidden
     */
    get _g3(): any;
    /**
     * @hidden
     */
    set _g3(a: any);
    /**
     * @hidden
     */
    protected get__g(): PrintOptionsBase;
    /**
     * @hidden
     */
    get _g(): PrintOptionsBase;
    /**
     * @hidden
     */
    _dh: ImageFormat;
    /**
     * @hidden
     */
    _eh: boolean;
    private _c5;
    /**
     * @hidden
     */
    get _c6(): WorksheetResizeInfo;
    /**
     * @hidden
     */
    _i0(a: WorksheetResizeInfo, b: boolean): void;
    /**
     * @hidden
     */
    private _i1;
    /**
     * @hidden
     */
    protected get__p(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    get _p(): WorksheetShapeCollection;
    /**
     * @hidden
     */
    protected get__i(): SheetProtection;
    /**
     * @hidden
     */
    get _i(): SheetProtection;
    /**
     * @hidden
     */
    get _ek(): boolean;
    /**
     * @hidden
     */
    set _ek(a: boolean);
    /**
     * @hidden
     */
    get _em(): boolean;
    /**
     * @hidden
     */
    set _em(a: boolean);
    /**
     * @hidden
     */
    private static _e7;
    /**
     * @hidden
     */
    static get _fh(): List$1<Tuple$3<Worksheet, WorksheetRegionAddress, string>>;
    /**
     * @hidden
     */
    get _br(): BiffSheetType;
    /**
     * @hidden
     */
    set _br(a: BiffSheetType);
    /**
     * @hidden
     */
    protected get__ag(): number;
    /**
     * @hidden
     */
    get _jg(): Point;
    /**
     * @hidden
     */
    set _jg(a: Point);
    /**
     * @hidden
     */
    get _fi(): List$1<WorksheetCell>;
    /**
     * @hidden
     */
    get _g0(): number;
}
/**
 * Represents a cell in a Microsoft Excel worksheet.
 */
export declare class WorksheetCell extends Base implements ICellFormatOwner, IComparable$1<WorksheetCell>, IFormattedStringOwner {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _d: WorksheetCell;
    private _h;
    private _ac;
    private _aa;
    private _n;
    constructor(a: WorksheetRow, b: number);
    /**
     * @hidden
     */
    get cellFormatInternal(): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    compareTo(other: WorksheetCell): number;
    /**
     * @hidden
     */
    get allowDefaultValues(): boolean;
    /**
     * @hidden
     */
    getDefaultFont(): IWorkbookFont;
    /**
     * @hidden
     */
    getFontDefaultsResolver(): IWorkbookFontDefaultsResolver;
    /**
     * @hidden
     */
    onUnformattedStringChanged(sender: FormattedString): void;
    /**
     * @hidden
     */
    onFormattingChanged(): void;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * Determines whether the specified object is another [[WorksheetCell]] instance which refers
     * to the same location on the same worksheet as this cell.
     * @param obj The instance to check for equality.
     * @return True if the cells refer to the same location on the same worksheet; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code of the [[WorksheetCell]].
     * @return The hash code of the [[WorksheetCell]].
     */
    getHashCode(): number;
    /**
     * Gets the string representation of the address of the cell.
     * @return The string representation of the address of the cell.
     */
    toString(): string;
    /**
     * Gets the string representation of the address of the cell.
     * @param cellReferenceMode The mode used to generate cell references.
     * @param includeWorksheetName The value indicating whether to include the worksheet name in the cell address.
     * @return The string representation of the address of the cell.
     */
    toString(cellReferenceMode: CellReferenceMode, includeWorksheetName: boolean): string;
    /**
     * Gets the string representation of the address of the cell.
     * @param cellReferenceMode The mode used to generate cell references.
     * @param includeWorksheetName The value indicating whether to include the worksheet name in the cell address.
     * @param useRelativeColumn The value indicating whether to use a relative column address.
     * @param useRelativeRow The value indicating whether to use a relative row address.
     * @return The string representation of the address of the cell.
     */
    toString(cellReferenceMode: CellReferenceMode, includeWorksheetName: boolean, useRelativeColumn: boolean, useRelativeRow: boolean): string;
    /**
     * @hidden
     */
    _toString(): string;
    /**
     * Applies a formula to the cell.
     * <p class="body">
     * 'value' is parsed based on the [[CellReferenceMode]] of the [[Workbook]]
     * to which the cell belongs. If the cell's [[worksheet]] has been removed from its parent collection,
     * the A1 CellReferenceMode will be used to parse the formula.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.applyCellFormula]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this method is equivalent to using the WorksheetRow.ApplyCellFormula method.
     * </p>
     * @param value The formula to parse and apply to the cell.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @throws [[InvalidOperationException]] The cell is part of an array formula or data table which is not confined to just the cell.
     * @see [[formula]]
     * @see [[WorksheetRow.applyCellFormula]]
     */
    applyFormula(value: string): void;
    /**
     * Removes the comment associated with the cell.
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.setCellComment]] method and pass in null as the
     * comment parameter, which does not create a [[WorksheetCell]] instance internally. However, if a reference to the
     * WorksheetCell instance already exists, using this method is equivalent to using the WorksheetRow.SetCellComment method and
     * passing in null as the comment parameter.
     * </p>
     * @see [[comment]]
     * @see [[hasComment]]
     * @see [[WorksheetRow.setCellComment]]
     */
    clearComment(): void;
    /**
     * Gets the bounds of the cell in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before the cell are resized, these bounds will no longer reflect the
     * position of the cell.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellBoundsInTwips]] method, which
     * does not create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this method is equivalent to using the WorksheetRow.GetBoundsInTwips method.
     * </p>
     * @return The bounds of the cell on its worksheet.
     * @see [[WorksheetRow.getCellBoundsInTwips]]
     */
    getBoundsInTwips(): IgRect;
    /**
     * Gets the bounds of the cell in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before the cell are resized, these bounds will no longer reflect the
     * position of the cell.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellBoundsInTwips]] method,
     * which does not create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this method is equivalent to using the WorksheetRow.GetBoundsInTwips method.
     * </p>
     * @param options The options to use when getting the bounds of the cell.
     * @return The bounds of the cell on its worksheet.
     * @see [[WorksheetRow.getCellBoundsInTwips]]
     */
    getBoundsInTwips(options: PositioningOptions): IgRect;
    /**
     * @hidden
     */
    _getBoundsInTwips(): Rect;
    /**
     * @hidden
     */
    _getBoundsInTwips1(a: PositioningOptions): Rect;
    /**
     * Gets the string representation of the address of the cell.
     * @param worksheetRow The WorksheetRow of the cell.
     * @param columnIndex The index of the column of the cell.
     * @param cellReferenceMode The mode used to generate cell references.
     * @param includeWorksheetName The value indicating whether to include the worksheet name in the cell address.
     * @return The string representation of the address of the cell.
     */
    static getCellAddressString(worksheetRow: WorksheetRow, columnIndex: number, cellReferenceMode: CellReferenceMode, includeWorksheetName: boolean): string;
    /**
     * Gets the string representation of the address of the cell.
     * @param worksheetRow The WorksheetRow of the cell.
     * @param columnIndex The index of the column of the cell.
     * @param cellReferenceMode The mode used to generate cell references.
     * @param includeWorksheetName The value indicating whether to include the worksheet name in the cell address.
     * @param useRelativeColumn The value indicating whether to use a relative column address.
     * @param useRelativeRow The value indicating whether to use a relative row address.
     * @return The string representation of the address of the cell.
     */
    static getCellAddressString(worksheetRow: WorksheetRow, columnIndex: number, cellReferenceMode: CellReferenceMode, includeWorksheetName: boolean, useRelativeColumn: boolean, useRelativeRow: boolean): string;
    /**
     * @hidden
     */
    static _getCellAddressString(a: WorksheetRow, b: number, c: CellReferenceMode, d: boolean): string;
    /**
     * @hidden
     */
    static _getCellAddressString1(a: WorksheetRow, b: number, c: CellReferenceMode, d: boolean, e: boolean, f: boolean): string;
    /**
     * Gets the effective hyperlink on the cell.
     * <p class="body">
     * If multiple hyperlinks are applied to the cell, the last one in the [[Worksheet.hyperlinks]]
     * collection will be used.
     * </p>
     * <p class="body">
     * If the cell has one or more hyperlinks in the [[Worksheet.hyperlinks]] collection as well
     * as a formula containing a HYPERLINK function, the last hyperlink from the collection will be used.
     * </p>
     * <p class="body">
     * If the cell has a hyperlink due to the HYPERLINK function being used in a formula, the returned value will be sealed.
     * </p>
     * @see [[Worksheet.hyperlinks]]
     * @see [[WorksheetHyperlink]]
     * @see [[WorksheetHyperlink.isSealed]]
     */
    getHyperlink(): WorksheetHyperlink;
    /**
     * Gets the text displayed in the cell.
     * <p class="body">
     * The display text is based on the value of the cell and the format string applied to the cell.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellText]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetText method.
     * </p>
     * @see [[value]]
     * @see [[IWorksheetCellFormat.formatString]]
     */
    getText(): string;
    /**
     * Gets the text of the cell.
     * <p class="body">
     * The text is based on the value of the cell and the format string applied to the cell.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellText]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetText method.
     * </p>
     * @param textFormatMode The format mode to use when getting the cell text.
     * @throws [[InvalidEnumArgumentException]] 'textFormatMode' is not defined in the [[TextFormatMode]] enumeration.
     * @see [[value]]
     * @see [[IWorksheetCellFormat.formatString]]
     */
    getText(textFormatMode: TextFormatMode): string;
    /**
     * @hidden
     */
    _getText(): string;
    /**
     * @hidden
     */
    _getText1(a: TextFormatMode): string;
    /**
     * Gets the resolved cell formatting for this cell.
     * <p class="body">
     * If any cell format properties are the default values on the cell, the values from the owning row's cell format will be used.
     * If those are default, then the values from the owning column's cell format will be used. Otherwise, the workbook default values
     * will be used.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getResolvedCellFormat]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this method is equivalent to using the WorksheetRow.GetResolvedCellFormat method.
     * </p>
     * @return A format object describing the actual formatting that will be used when displayed this cell in Microsoft Excel.
     * @see [[cellFormat]]
     * @see [[RowColumnBase.cellFormat]]
     * @see [[WorksheetRow.getResolvedCellFormat]]
     */
    getResolvedCellFormat(): IWorksheetCellFormat;
    /**
     * Returns True if a particular type of value can be exported to excel.
     * @param cellType The type to test.
     * @throws [[ArgumentNullException]] 'cellType' is null.
     * @return True if the type is supported as a cell value, False otherwise.
     */
    static isCellTypeSupported(cellType: Type): boolean;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    _toString1(a: CellReferenceMode, b: boolean): string;
    /**
     * @hidden
     */
    _toString2(a: CellReferenceMode, b: boolean, c: boolean, d: boolean): string;
    /**
     * Returns a boolean indicating if the value of the cell is valid considering the associated [[dataValidationRule]]
     * @return Returns false if the cell has an associated [[dataValidationRule]] and the current [[value]] does not pass the validation defined by that rule; otherwise true is returned.
     * @see [[value]]
     * @see [[dataValidationRule]]
     * @see [[Worksheet.dataValidationRules]]
     */
    validateValue(): boolean;
    /**
     * @hidden
     */
    _l(): WorksheetRegion;
    /**
     * @hidden
     */
    private _aq;
    /**
     * @hidden
     */
    private _ar;
    /**
     * Gets the data table to which the cell belongs.
     * <p class="body">
     * The cells in the left-most column and top-most row of the data table will return null for the associated data table.
     * </p>
     * <p class="body">
     * If a data table is associated with the cell, getting the [[value]] will return the calculated value for the cell.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellAssociatedDataTable]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetCellAssociatedDataTable method.
     * </p>
     * The data table to which the cell belongs or null if the cell does not belong to a data table.
     * @see [[Worksheet.dataTables]]
     * @see [[WorksheetDataTableCollection.add]]
     * @see [[WorksheetRow.getCellAssociatedDataTable]]
     */
    get associatedDataTable(): WorksheetDataTable;
    /**
     * Gets the merged cells region which contains the cell, or null if the cell is not merged.
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellAssociatedMergedCellsRegion]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetCellAssociatedMergedCellsRegion method.
     * </p>
     * The merged cells region which contains the cell, or null if the cell is not merged.
     * @see [[WorksheetRow.getCellAssociatedMergedCellsRegion]]
     */
    get associatedMergedCellsRegion(): WorksheetMergedCellsRegion;
    /**
     * Gets the [[WorksheetTable]] to which this cell belongs.
     * <p class="body">
     * A cell belongs to a table if it exists in any area of the table. It can be a header cell, total cell, or a cell in the data area.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellAssociatedTable]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetCellAssociatedTable method.
     * </p>
     * @see [[WorksheetTable]]
     * @see [[Worksheet.tables]]
     */
    get associatedTable(): WorksheetTable;
    /**
     * Gets the cell formatting for this cell.
     * <p class="body">
     * Use this property to set cell formatting specific to the cell. If you will be applying the format to numerous cells,
     * see the [[Workbook.createNewWorksheetCellFormat]] method for performance considerations.
     * </p>
     * <p class="body">
     * If this cell belongs to a merged cell region, getting the CellFormat will get the CellFormat of the associated merged
     * cell region.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellFormat]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetCellFormat method.
     * </p>
     * The cell formatting for this cell.
     * @see [[getResolvedCellFormat]]
     * @see [[WorksheetRow.getCellFormat]]
     */
    get cellFormat(): IWorksheetCellFormat;
    /**
     * @hidden
     */
    get _cellFormatInternal(): WorksheetCellFormatProxy;
    /**
     * Gets the value which indicates whether the cell's format has been initialized yet.
     * @see [[cellFormat]]
     */
    get hasCellFormat(): boolean;
    /**
     * Gets the column index of the cell.
     * The column index of the cell.
     */
    get columnIndex(): number;
    /**
     * @hidden
     */
    get _ab(): number;
    /**
     * Gets or sets the comment applied to the cell.
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellComment]] or
     * [[WorksheetRow.setCellComment]] methods, which do not create [[WorksheetCell]] instances internally. However,
     * if a reference to the WorksheetCell instance already exists, using this property is equivalent to using the
     * WorksheetRow.GetCellComment or WorksheetRow.SetCellComment methods.
     * </p>
     * The comment applied to the cell.
     * @throws [[InvalidOperationException]] The value applied only has only one anchor cell set. It should have both or neither anchor cells set.
     * @throws [[InvalidOperationException]] The value has its [[WorksheetShape.topLeftCornerCell]] and [[WorksheetShape.bottomRightCornerCell]]
     * anchors set but they are from different worksheets.
     * @see [[WorksheetRow.getCellComment]]
     * @see [[WorksheetRow.setCellComment]]
     */
    get comment(): WorksheetCellComment;
    set comment(a: WorksheetCellComment);
    /**
     * Gets or sets the data validation rule for the [[WorksheetCell]].
     * @throws [[ArgumentException]] Occurs when the value specified is already applied to cells in another worksheet.
     * @throws [[ArgumentException]] Occurs when the value specified is invalid based on its rule type's requirements.
     * @see [[Worksheet.dataValidationRules]]
     * @see [[AnyValueDataValidationRule]]
     * @see [[ListDataValidationRule]]
     * @see [[CustomDataValidationRule]]
     * @see [[OneConstraintDataValidationRule]]
     * @see [[TwoConstraintDataValidationRule]]
     */
    get dataValidationRule(): DataValidationRule;
    set dataValidationRule(a: DataValidationRule);
    /**
     * Get the value indicating whether the cell has an associated comment.
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellComment]] method and check for a non null
     * return value, which does not create a [[WorksheetCell]] instance internally. However, if a reference to the
     * WorksheetCell instance already exists, using this property is equivalent to using the WorksheetRow.GetCellComment method
     * and checking for a non null return value.
     * </p>
     * True if the cell has an associated comment; False otherwise.
     * @see [[comment]]
     * @see [[WorksheetRow.getCellComment]]
     */
    get hasComment(): boolean;
    /**
     * Gets the formula which has been applied to the cell.
     * <p class="body">
     * If a formula has been applied to the cell, getting the [[value]] will return the calculated value of the formula.
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellFormula]] method, which does not
     * create a [[WorksheetCell]] instance internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetCellFormula method.
     * </p>
     * The formula which has been applied to the cell or null if no formula has been applied.
     * @see [[Formula.applyTo]]
     * @see [[Formula.applyTo]]
     * @see [[Formula.applyTo]]
     * @see [[applyFormula]]
     * @see [[WorksheetRegion.applyFormula]]
     * @see [[WorksheetRegion.applyArrayFormula]]
     * @see [[WorksheetRow.getCellFormula]]
     */
    get formula(): Formula;
    /**
     * Gets the row index of the cell.
     * The row index of the cell.
     */
    get rowIndex(): number;
    /**
     * Gets or sets the value of the cell.
     * <p class="body">
     * If this cell belongs to a merged cell region and it is the top-left cell of the region, getting and setting the value
     * will get and set the value of the associated merged cell region. Getting the value of other cells in a merged cell region
     * will always return null. Setting the value of other cells in a merged cell region will have no effect.
     * </p>
     * <p class="body">
     * If a formula has been applied to the cell or a data table is associated with the cell, getting the Value will return the
     * calculated value of the cell.
     * </p>
     * <p class="body">
     * The types supported for the value are:
     * <BR/>
     * <ul>
     * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
     * </ul>
     * </p>
     * <p class="note">
     * <B>Note:</B> it is slightly faster to use the [[WorksheetRow.getCellValue]] or [[WorksheetRow.setCellValue]]
     * methods, which do not create [[WorksheetCell]] instances internally. However, if a reference to the WorksheetCell instance
     * already exists, using this property is equivalent to using the WorksheetRow.GetCellComment or WorksheetRow.SetCellComment methods.
     * </p>
     * The value of the cell.
     * @throws [[NotSupportedException]] The assigned value's type is not supported and can't be exported to Excel.
     * @throws [[InvalidOperationException]] The value assigned is a [[formula]]. Instead, [[Formula.applyTo]]
     * should be called on the Formula, passing in the cell.
     * @throws [[InvalidOperationException]] The value assigned is a [[WorksheetDataTable]]. Instead, the [[WorksheetDataTable.cellsInTable]]
     * should be set to a region containing the cell.
     * @throws [[InvalidOperationException]] The value assigned is a FormattedString which is the value another cell or merged cell region.
     * @throws [[InvalidOperationException]] The value is assigned and this cell is part of an [[ArrayFormula]] or WorksheetDataTable.
     * @see [[associatedMergedCellsRegion]]
     * @see [[WorksheetCell.isCellTypeSupported]]
     * @see [[WorksheetMergedCellsRegion.value]]
     * @see [[formula]]
     * @see [[associatedDataTable]]
     * @see [[WorksheetRow.getCellValue]]
     * @see [[WorksheetRow.setCellValue]]
     */
    get value(): any;
    set value(a: any);
    /**
     * Gets the worksheet to which the cell belongs.
     * The worksheet to which the cell belongs.
     */
    get worksheet(): Worksheet;
    /**
     * @hidden
     */
    get _e(): WorksheetCellAddress;
    /**
     * @hidden
     */
    get _m(): WorksheetRegionAddress;
    /**
     * @hidden
     */
    get _o(): WorksheetRow;
    /**
     * @hidden
     */
    static l_op_Equality(a: WorksheetCell, b: WorksheetCell): boolean;
    /**
     * @hidden
     */
    static l_op_Inequality(a: WorksheetCell, b: WorksheetCell): boolean;
}
/**
 * Represents a rectangular region of cells on a worksheet.
 */
export declare class WorksheetRegion extends Base implements IEnumerable$1<WorksheetCell> {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _a: WorksheetRegion[];
    private _b;
    private _i;
    private _j;
    private _e;
    constructor(worksheet: Worksheet, firstRow: number, firstColumn: number, lastRow: number, lastColumn: number);
    constructor(worksheet: Worksheet, firstRow: number, firstColumn: number, lastRow: number, lastColumn: number, addCachedRegion: boolean);
    constructor(..._rest: any[]);
    /**
     * Determines whether the specified value equals this [[WorksheetRegion]].
     * @param obj The value to test for equality.
     */
    equals(obj: any): boolean;
    /**
     * Gtes the hash code for the [[WorksheetRegion]].
     */
    getHashCode(): number;
    /**
     * Gets the string representation of the range of cells in the region.
     * @return The string representation of the range of cells in the region.
     */
    toString(): string;
    /**
     * Gets the string representation of the range of cells in the region.
     * @param cellReferenceMode The mode used to generate cell references.
     * @param includeWorksheetName The value indicating whether to include the worksheet name in the range address.
     * @return The string representation of the range of cells in the region.
     */
    toString(cellReferenceMode: CellReferenceMode, includeWorksheetName: boolean): string;
    /**
     * Gets the string representation of the range of cells in the region.
     * @param cellReferenceMode The mode used to generate cell references.
     * @param includeWorksheetName The value indicating whether to include the worksheet name in the range address.
     * @param useRelativeColumn The value indicating whether to use a relative column address for the cells in the range.
     * @param useRelativeRow The value indicating whether to use a relative row address for the cells in the range.
     * @return The string representation of the range of cells in the region.
     */
    toString(cellReferenceMode: CellReferenceMode, includeWorksheetName: boolean, useRelativeColumn: boolean, useRelativeRow: boolean): string;
    /**
     * @hidden
     */
    _toString(): string;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetCell>;
    /**
     * @hidden
     */
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<WorksheetCell>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Applies a array formula to the region of cells.
     * <p class="body">
     * 'value' is parsed based on the [[CellReferenceMode]] of the [[Workbook]]
     * to which the region belongs. If the region's [[worksheet]] has been removed from its parent collection,
     * the A1 CellReferenceMode will be used to parse the formula.
     * </p>
     * @param value The array formula to parse and apply to the region.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @throws [[InvalidOperationException]] The region contains another array formula or data table which extends outside the region.
     * @see [[ArrayFormula]]
     */
    applyArrayFormula(value: string): void;
    /**
     * Applies a formula to the region of cells.
     * <p class="body">
     * 'value' is parsed based on the [[CellReferenceMode]] of the [[Workbook]]
     * to which the region belongs. If the region's [[worksheet]] has been removed from its parent collection,
     * the A1 CellReferenceMode will be used to parse the formula.
     * </p>
     * @param value The formula to parse and apply to the region.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @throws [[InvalidOperationException]] The region contains an array formula or data table which extends outside the region.
     * @see [[Formula]]
     */
    applyFormula(value: string): void;
    /**
     * Formats the region as a table and adds an associated [[WorksheetTable]] to the [[Worksheet.tables]]
     * collection.
     * <p class="body">
     * When the table is created, the [[Workbook.defaultTableStyle]] will be applied to the
     * value.
     * </p>
     * <p class="body">
     * When the table is created, the column names will be taken from the cells in the header row if 'tableHasHeaders'
     * is True. If it is False, the column names will be generated and the cells for the header row will be inserted into the worksheet.
     * </p>
     * <p class="body">
     * The column names are unique within the owning WorksheetTable. If, when the table is created, there are two or more columns with
     * the same name, the second and subsequent duplicate column names will have a number appended to make them unique. If any cells in
     * the header row have a non-string value, their value will be changed to a string (the current display text of the cell). If any
     * cells in the header row have no value, they will be given a generated column name.
     * </p>
     * <p class="body">
     * If the region partially contains any merged cell regions, they will be removed from the worksheet and the table region will be expanded
     * to include all cells from the merged region.
     * </p>
     * @param tableHasHeaders A value which indicates whether the top row of the region contains the headers for the table.
     * @see [[WorksheetTable.style]]
     * @throws [[InvalidOperationException]] The region contains one or more cells from another [[WorksheetTable]].
     * @throws [[InvalidOperationException]] The region contains one or more cells which have a multi-cell [[ArrayFormula]] applied.
     * @throws [[InvalidOperationException]] The region contains one or more cells which are part of a [[WorksheetDataTable]].
     * @return The [[WorksheetTable]] created the represent the formatted table for the region.
     * @see [[WorksheetTable]]
     * @see [[Worksheet.tables]]
     * @see [[WorksheetTableColumn.name]]
     * @see [[WorksheetTable.isHeaderRowVisible]]
     * @see [[WorksheetTableCollection.add]]
     */
    formatAsTable(tableHasHeaders: boolean): WorksheetTable;
    /**
     * Formats the region as a table and adds an associated [[WorksheetTable]] to the [[Worksheet.tables]]
     * collection.
     * <p class="body">
     * When the table is created, the specified 'tableStyle' will be applied to the
     * value.
     * </p>
     * <p class="body">
     * When the table is created, the column names will be taken from the cells in the header row if 'tableHasHeaders'
     * is True. If it is False, the column names will be generated and the cells for the header row will be inserted into the worksheet.
     * </p>
     * <p class="body">
     * The column names are unique within the owning WorksheetTable. If, when the table is created, there are two or more columns with
     * the same name, the second and subsequent duplicate column names will have a number appended to make them unique. If any cells in
     * the header row have a non-string value, their value will be changed to a string (the current display text of the cell). If any
     * cells in the header row have no value, they will be given a generated column name.
     * </p>
     * <p class="body">
     * If the region partially contains any merged cell regions, they will be removed from the worksheet and the table region will be expanded
     * to include all cells from the merged region.
     * </p>
     * @param tableHasHeaders A value which indicates whether the top row of the region contains the headers for the table.
     * @param tableStyle The [[WorksheetTableStyle]] to apply to the table or null to use the [[Workbook.defaultTableStyle]].
     * @see [[WorksheetTable.style]]
     * @throws [[ArgumentException]] The specified 'tableStyle' does not exist in the [[Workbook.customTableStyles]] or
     * [[Workbook.standardTableStyles]] collections.
     * @throws [[InvalidOperationException]] The region contains one or more cells from another [[WorksheetTable]].
     * @throws [[InvalidOperationException]] The region contains one or more cells which have a multi-cell [[ArrayFormula]] applied.
     * @throws [[InvalidOperationException]] The region contains one or more cells which are part of a [[WorksheetDataTable]].
     * @return The [[WorksheetTable]] created the represent the formatted table for the region.
     * @see [[WorksheetTable]]
     * @see [[Worksheet.tables]]
     * @see [[WorksheetTableColumn.name]]
     * @see [[Workbook.customTableStyles]]
     * @see [[Workbook.standardTableStyles]]
     * @see [[WorksheetTable.style]]
     * @see [[WorksheetTable.isHeaderRowVisible]]
     * @see [[WorksheetTableCollection.add]]
     */
    formatAsTable(tableHasHeaders: boolean, tableStyle: WorksheetTableStyle): WorksheetTable;
    /**
     * @hidden
     */
    _formatAsTable(a: boolean): WorksheetTable;
    /**
     * @hidden
     */
    _formatAsTable1(a: boolean, b: WorksheetTableStyle): WorksheetTable;
    /**
     * Gets the bounds of the region in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before the region are resized, these bounds will no longer reflect the
     * position of the region.
     * </p>
     * @return The bounds of the region on its worksheet.
     */
    getBoundsInTwips(): IgRect;
    /**
     * Gets the bounds of the region in twips (1/20th of a point).
     * <p class="body">
     * The bounds returned by this method are only valid with the current configuration of the worksheet.
     * If any rows or columns before the region are resized, these bounds will no longer reflect the
     * position of the region.
     * </p>
     * @param options The options to use when getting the bounds of the region.
     * @return The bounds of the region on its worksheet.
     */
    getBoundsInTwips(options: PositioningOptions): IgRect;
    /**
     * @hidden
     */
    _getBoundsInTwips(): Rect;
    /**
     * @hidden
     */
    _getBoundsInTwips1(a: PositioningOptions): Rect;
    /**
     * @hidden
     */
    _toString1(a: CellReferenceMode, b: boolean): string;
    /**
     * @hidden
     */
    _toString2(a: CellReferenceMode, b: boolean, c: boolean, d: boolean): string;
    /**
     * @hidden
     */
    _aj(a: Formula, b: WorksheetRow, c: number, d?: ApplyFormulaFlags): {
        p1?: WorksheetRow;
        p2?: number;
    };
    /**
     * @hidden
     */
    _q(a: number, b: number): boolean;
    /**
     * @hidden
     */
    _n(a: WorksheetCell): boolean;
    /**
     * @hidden
     */
    _o(a: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _p(a: WorksheetRow, b: number): boolean;
    /**
     * @hidden
     */
    _s(a: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _t(a: number, b: number, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _al(a: WorksheetRegionAddress): void;
    /**
     * @hidden
     */
    _d(a: CellShiftOperation, b: boolean): ShiftAddressResult;
    /**
     * @hidden
     */
    static _g(a: WorksheetRegion, b: WorksheetRegion): WorksheetRegion;
    /**
     * @hidden
     */
    static _am(a: number, b: number): void;
    /**
     * @hidden
     */
    _an(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    static _ap(a: number, b: number): void;
    /**
     * @hidden
     */
    private _ak;
    /**
     * @hidden
     */
    private _ao;
    /**
     * @hidden
     */
    get _h(): WorksheetRegionAddress;
    /**
     * @hidden
     */
    get _c(): RefBase;
    /**
     * Gets the index of the first column in the region.
     * The index of the first column in the region.
     */
    get firstColumn(): number;
    /**
     * @hidden
     */
    get _v(): number;
    /**
     * Gets the index of the first row in the region.
     * The index of the first row in the region.
     */
    get firstRow(): number;
    /**
     * @hidden
     */
    get _aa(): number;
    /**
     * @hidden
     */
    get _u(): boolean;
    /**
     * Gets the index of the last column in the region.
     * The index of the last column in the region.
     */
    get lastColumn(): number;
    /**
     * @hidden
     */
    get _w(): number;
    /**
     * Gets the index of the last row in the region.
     * The index of the last row in the region.
     */
    get lastRow(): number;
    /**
     * @hidden
     */
    get _k(): WorksheetRow;
    /**
     * @hidden
     */
    get _ad(): number;
    /**
     * Gets the worksheet on which the region resides.
     * The worksheet on which the region resides or null if the region has been shifted off the worksheet.
     */
    get worksheet(): Worksheet;
}
/**
 * A collection of cells or regions which are all on the same [[worksheet]].
 */
export declare class WorksheetReferenceCollection extends Base implements ICollection$1<WorksheetRegion> {
    static $t: Type;
    private _w;
    private _x;
    private _y;
    private _u;
    private _a;
    private _b;
    constructor(worksheet: Worksheet);
    constructor(worksheet: Worksheet, references: string);
    constructor(cell: WorksheetCell);
    constructor(region: WorksheetRegion);
    constructor(..._rest: any[]);
    /**
     * Returns the string value represent the cell and region addresses in the collection.
     */
    toString(): string;
    /**
     * Returns the string value represent the cell and region addresses in the collection.
     * @param cellReferenceMode The cell reference mode with which to get the region strings.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     */
    toString(cellReferenceMode: CellReferenceMode): string;
    /**
     * @hidden
     */
    _toString(): string;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    copyTo(array: WorksheetRegion[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get count(): number;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetRegion>;
    /**
     * @hidden
     */
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<WorksheetRegion>;
    /**
     * Adds a region to the collection of references.
     * <p class="body">
     * The region added to the collection must be from the same [[worksheet]] as the collection.
     * </p>
     * <p class="body">
     * If the region is already contained in the collection, or there is a region in the collection which fully contains the specified region,
     * this call will have no effect on the collection.
     * </p>
     * @param region The region to add to the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a Worksheet other than the references collection.
     */
    add(region: WorksheetRegion): void;
    /**
     * Adds a cell to the collection of references.
     * <p class="body">
     * The cell added to the collection must be from the same [[worksheet]] as the collection.
     * </p>
     * <p class="body">
     * If the cell is already contained in the collection, or there is a region in the collection which contains the cell, this call
     * will have no effect on the collection.
     * </p>
     * @param cell The cell to add to the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a Worksheet other than the references collection.
     */
    add(cell: WorksheetCell): void;
    /**
     * Adds a list of references to the collection of references.
     * <p class="body">
     * The references must be separated by one or more space (' ') characters.
     * </p>
     * <p class="body">
     * The references in the list cannot contain the worksheet name. They are all assumed to be from the worksheet of this collection.
     * </p>
     * <p class="body">
     * If all references are already contained in the collection this call will have no effect on the collection.
     * </p>
     * @param references The space delimited list of references to add to the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'references' is null.
     * @throws [[ArgumentException]] Occurs when the list of reference is not well formed.
     */
    add(references: string): void;
    /**
     * Adds a list of references to the collection of references.
     * <p class="body">
     * The references must be separated by one or more space (' ') characters.
     * </p>
     * <p class="body">
     * The references in the list cannot contain the worksheet name. They are all assumed to be from the worksheet of this collection.
     * </p>
     * <p class="body">
     * If all references are already contained in the collection this call will have no effect on the collection.
     * </p>
     * @param references The space delimited list of references to add to the collection.
     * @param cellReferenceMode The cell reference mode with which to parse the 'references'.
     * @throws [[ArgumentNullException]] Occurs when the 'references' is null.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] Occurs when the list of reference is not well formed.
     */
    add(references: string, cellReferenceMode: CellReferenceMode): void;
    /**
     * @hidden
     */
    _add3(a: string): void;
    /**
     * @hidden
     */
    _add4(a: string, b: CellReferenceMode): void;
    /**
     * @hidden
     */
    _add1(a: WorksheetCell): void;
    /**
     * @hidden
     */
    _add(a: WorksheetRegion): void;
    /**
     * Clears all references from the collection.
     */
    clear(): void;
    /**
     * Determines whether the collection contains the specified region.
     * @param region The region to search for in the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'region' is null.
     * @return True if the region is contained in the collection or a region which fully contains the specified region is contained in the collection;
     * False otherwise.
     */
    contains(region: WorksheetRegion): boolean;
    /**
     * Determines whether the collection contains the specified cell.
     * @param cell The cell to search for in the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'cell' is null.
     * @return True if the cell is contained in the collection or a region which contains the cell is contained in the collection; False otherwise.
     */
    contains(cell: WorksheetCell): boolean;
    /**
     * @hidden
     */
    _contains1(a: WorksheetCell): boolean;
    /**
     * @hidden
     */
    _contains(a: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _contains2(a: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _k(a: WorksheetRegionAddress): boolean;
    /**
     * Removes a region from the collection of references.
     * <p class="body">
     * If the region is not contained in the collection, this call will have no effect on the collection.
     * </p>
     * @param region The region to remove from the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'region' is null.
     * @return True if any cells in the region were found and removed. False otherwise.
     */
    remove(region: WorksheetRegion): boolean;
    /**
     * Removes a cell from the collection of references.
     * <p class="body">
     * If the cell is not contained in the collection, this call will have no effect on the collection.
     * </p>
     * @param cell The cell to remove from the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'cell' is null.
     * @return True if the cell was found and removed. False otherwise.
     */
    remove(cell: WorksheetCell): boolean;
    /**
     * Removes a list of references from the collection of references.
     * <p class="body">
     * The references must be separated by one or more space (' ') characters.
     * </p>
     * <p class="body">
     * The references in the list cannot contain the worksheet name. They are all assumed to be from the worksheet of this collection.
     * </p>
     * <p class="body">
     * If the references are not contained in the collection, this call will have no effect on the collection.
     * </p>
     * @param references The space delimited list of references to remove from the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'references' is null.
     * @throws [[ArgumentException]] Occurs when the list of reference is not well formed.
     * @return True if any cells in the references were found and removed. False otherwise.
     */
    remove(references: string): boolean;
    /**
     * Removes a list of references from the collection of references.
     * <p class="body">
     * The references must be separated by one or more space (' ') characters.
     * </p>
     * <p class="body">
     * The references in the list cannot contain the worksheet name. They are all assumed to be from the worksheet of this collection.
     * </p>
     * <p class="body">
     * If the references are not contained in the collection, this call will have no effect on the collection.
     * </p>
     * @param references The space delimited list of references to remove from the collection.
     * @param cellReferenceMode The cell reference mode with which to parse the 'references'.
     * @throws [[ArgumentNullException]] Occurs when the 'references' is null.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] Occurs when the list of reference is not well formed.
     * @return True if any cells in the references were found and removed. False otherwise.
     */
    remove(references: string, cellReferenceMode: CellReferenceMode): boolean;
    /**
     * @hidden
     */
    _remove3(a: string): boolean;
    /**
     * @hidden
     */
    _remove4(a: string, b: CellReferenceMode): boolean;
    /**
     * @hidden
     */
    _remove1(a: WorksheetCell): boolean;
    /**
     * @hidden
     */
    _remove(a: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _remove2(a: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _toString1(a: CellReferenceMode): string;
    /**
     * @hidden
     */
    static _e(a: WorksheetCell): WorksheetReferenceCollection;
    /**
     * @hidden
     */
    static _f(a: WorksheetRegion): WorksheetReferenceCollection;
    /**
     * @hidden
     */
    _al(a: WorksheetCell, b: WorksheetCell): {
        p0: WorksheetCell;
        p1: WorksheetCell;
    };
    /**
     * @hidden
     */
    _l(a: CellShiftOperation, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _ap(a: CellShiftOperation, b: boolean): {
        p1: boolean;
    };
    /**
     * @hidden
     */
    _add2(a: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    private _ah;
    /**
     * @hidden
     */
    private _ai;
    /**
     * @hidden
     */
    private _h;
    /**
     * @hidden
     */
    private _aj;
    /**
     * @hidden
     */
    private _ak;
    /**
     * @hidden
     */
    private _g;
    /**
     * @hidden
     */
    private _s;
    /**
     * @hidden
     */
    static _r(a: Worksheet, b: string, c: CellReferenceMode, d: CultureInfo): List$1<WorksheetRegion>;
    /**
     * @hidden
     */
    private _am;
    /**
     * @hidden
     */
    private _an;
    /**
     * @hidden
     */
    private _ao;
    /**
     * @hidden
     */
    private _aq;
    /**
     * @hidden
     */
    private _ar;
    /**
     * @hidden
     */
    private _q;
    /**
     * @hidden
     */
    private _as;
    /**
     * @hidden
     */
    private static _at;
    /**
     * @hidden
     */
    private _ac;
    /**
     * @hidden
     */
    static _ab(a: CellReferenceMode, b: Worksheet, c: IEnumerable$1<WorksheetRegionAddress>, d?: string): string;
    /**
     * Gets the number of cells contains in all references in this collection.
     */
    get cellsCount(): number;
    /**
     * Gets the worksheet for which this collection contains references.
     */
    get worksheet(): Worksheet;
    /**
     * @hidden
     */
    get _t(): List$1<WorksheetRegionAddress>;
    /**
     * @hidden
     */
    get _d(): WorksheetCell;
}
/**
 * @hidden
 */
export declare class DataValidationRuleCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: DataValidationRuleCollection, c: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: DataValidationRuleCollection;
    readonly b: Nullable$1<KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>>;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of [[DataValidationRule]] instances in a worksheet.
 * @see [[Worksheet.dataValidationRules]]
 */
export declare class DataValidationRuleCollection extends Base implements IDictionary$2<DataValidationRule, WorksheetReferenceCollection> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _t;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    private static readonly _u;
    /**
     * @hidden
     */
    private static _a;
    private _s;
    /**
     * @hidden
     */
    _f: Worksheet;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    addItem(key: DataValidationRule, value: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    containsKey(key: DataValidationRule): boolean;
    /**
     * @hidden
     */
    tryGetValue(key: DataValidationRule, value: WorksheetReferenceCollection): {
        ret: boolean;
        p1: WorksheetReferenceCollection;
    };
    /**
     * @hidden
     */
    get keys(): ICollection$1<DataValidationRule>;
    /**
     * @hidden
     */
    get values(): ICollection$1<WorksheetReferenceCollection>;
    /**
     * @hidden
     */
    add(item: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>): void;
    /**
     * Applies an [[AnyValueDataValidationRule]] to a [[WorksheetCell]].
     * @param rule The data validation rule to apply to the cell.
     * @param cell The cell to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the 'cell' already has a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the 'cell' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: AnyValueDataValidationRule, cell: WorksheetCell): void;
    /**
     * Applies an [[AnyValueDataValidationRule]] to the cells in a [[WorksheetRegion]].
     * @param rule The data validation rule to apply to the region.
     * @param region The region to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' already have a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: AnyValueDataValidationRule, region: WorksheetRegion): void;
    /**
     * Applies an [[CustomDataValidationRule]] to a [[WorksheetCell]].
     * @param rule The data validation rule to apply to the cell.
     * @param cell The cell to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the 'cell' already has a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the 'cell' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: CustomDataValidationRule, cell: WorksheetCell): void;
    /**
     * Applies an [[CustomDataValidationRule]] to the cells in a [[WorksheetRegion]].
     * @param rule The data validation rule to apply to the region.
     * @param region The region to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' already have a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: CustomDataValidationRule, region: WorksheetRegion): void;
    /**
     * Applies a data validation rule to the a set of references.
     * @param rule The data validation rule to apply to the set of references.
     * @param references The reference to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'references' is null.
     * @throws [[ArgumentException]] Occurs when the 'references' are from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'references' collection are in the totals row of a table.
     */
    add(rule: DataValidationRule, references: WorksheetReferenceCollection): void;
    /**
     * Applies a data validation rule to the a set of references.
     * @param rule The data validation rule to apply to the set of references.
     * @param references The reference to which the data validation rule should be applied.
     * @param overwriteExistingRules Indicates whether cells in the references collection which already have data validation rules should have the rules overwritten.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'references' is null.
     * @throws [[ArgumentException]] Occurs when the 'references' are from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when 'overwriteExistingRules' is False and the one or more of the cells in the 'references'
     * collection already have a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'references' collection are in the totals row of a table.
     */
    add(rule: DataValidationRule, references: WorksheetReferenceCollection, overwriteExistingRules: boolean): void;
    /**
     * Applies an [[ListDataValidationRule]] to a [[WorksheetCell]].
     * @param rule The data validation rule to apply to the cell.
     * @param cell The cell to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the 'cell' already has a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the 'cell' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: ListDataValidationRule, cell: WorksheetCell): void;
    /**
     * Applies an [[ListDataValidationRule]] to the cells in a [[WorksheetRegion]].
     * @param rule The data validation rule to apply to the region.
     * @param region The region to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' already have a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: ListDataValidationRule, region: WorksheetRegion): void;
    /**
     * Applies an [[OneConstraintDataValidationRule]] to a [[WorksheetCell]].
     * @param rule The data validation rule to apply to the cell.
     * @param cell The cell to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the 'cell' already has a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the 'cell' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: OneConstraintDataValidationRule, cell: WorksheetCell): void;
    /**
     * Applies an [[OneConstraintDataValidationRule]] to the cells in a [[WorksheetRegion]].
     * @param rule The data validation rule to apply to the region.
     * @param region The region to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' already have a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: OneConstraintDataValidationRule, region: WorksheetRegion): void;
    /**
     * Applies an [[TwoConstraintDataValidationRule]] to a [[WorksheetCell]].
     * @param rule The data validation rule to apply to the cell.
     * @param cell The cell to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the 'cell' already has a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the 'cell' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: TwoConstraintDataValidationRule, cell: WorksheetCell): void;
    /**
     * Applies an [[TwoConstraintDataValidationRule]] to the cells in a [[WorksheetRegion]].
     * @param rule The data validation rule to apply to the region.
     * @param region The region to which the data validation rule should be applied.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @throws [[ArgumentNullException]] Occurs when 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the 'rule' already applied to another worksheet.
     * @throws [[ArgumentException]] Occurs when the 'rule' is invalid based on its rule type's requirements.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' already have a data validation rule applied to it.
     * @throws [[ArgumentException]] Occurs when the one or more of the cells in the 'region' is a total cell of a table.
     * @see [[add]]
     */
    add(rule: TwoConstraintDataValidationRule, region: WorksheetRegion): void;
    /**
     * @hidden
     */
    _add$e(a: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>): void;
    /**
     * @hidden
     */
    contains(item: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>): boolean;
    /**
     * Determines whether the specified data validation rule exists on the [[worksheet]].
     * @param rule The rule to test.
     * @return True if the rule is applied to one or more cells on the Worksheet; False otherwise.
     */
    contains(rule: DataValidationRule): boolean;
    /**
     * Determines whether the specified cell has a data validation rule applied to it.
     * @param cell The cell to test.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @return True if the cell has a data validation rule applied; False otherwise.
     */
    contains(cell: WorksheetCell): boolean;
    /**
     * Determines whether the specified references collection has a data validation rule applied to any of it's cells.
     * @param references The references collection to test.
     * @throws [[ArgumentNullException]] Occurs when 'references' is null.
     * @throws [[ArgumentException]] Occurs when the 'references' are from a worksheet other than this collection.
     * @return True if the any cell from the references collection has a data validation rule applied; False otherwise.
     */
    contains(references: WorksheetReferenceCollection): boolean;
    /**
     * Determines whether the specified region has a data validation rule applied to any of it's cells.
     * @param region The region to test.
     * @throws [[ArgumentNullException]] Occurs when 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a worksheet other than this collection.
     * @return True if the any cell from the region has a data validation rule applied; False otherwise.
     */
    contains(region: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _contains$e(a: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>): boolean;
    /**
     * @hidden
     */
    copyTo(array: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    remove(item: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>): boolean;
    /**
     * Removes the data validation rule form the cell if one is applied.
     * <p class="body">
     * If the rule is only applied to the specified cell, it will be removed from the collection.
     * </p>
     * @param cell The cell which should have its data validation rule cleared.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @return True if the data validation rule was found and removed from the cell; False if the cell had no data validation rule applied.
     */
    remove(cell: WorksheetCell): boolean;
    /**
     * Removes the data validation rule form all cells in the specified collection.
     * <p class="body">
     * If any rules in the collection are not applied to any cells after this operation, they will be removed from the collection.
     * </p>
     * @param references The collection of references which should have its data validation rules cleared.
     * @throws [[ArgumentNullException]] Occurs when 'references' is null.
     * @throws [[ArgumentException]] Occurs when the 'references' are from a worksheet other than this collection.
     * @return True if the data validation rule was found and removed from any cells in the collection; False if the cells had no data validation rule applied.
     */
    remove(references: WorksheetReferenceCollection): boolean;
    /**
     * Removes the data validation rule form all cells in the specified region.
     * <p class="body">
     * If any rules in the collection are not applied to any cells after this operation, they will be removed from the collection.
     * </p>
     * @param region The region which should have its data validation rules cleared.
     * @throws [[ArgumentNullException]] Occurs when 'region' is null.
     * @throws [[ArgumentException]] Occurs when the 'region' is from a worksheet other than this collection.
     * @return True if the data validation rule was found and removed from any cells in the region; False if the region had no data validation rule applied.
     */
    remove(region: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _remove$e(a: KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>): boolean;
    [Symbol.iterator](): EnumeratorWrapper<KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<KeyValuePair$2<DataValidationRule, WorksheetReferenceCollection>>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    _add5(a: DataValidationRule, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _add6(a: DataValidationRule, b: WorksheetReferenceCollection, c: boolean): void;
    /**
     * @hidden
     */
    _add1(a: AnyValueDataValidationRule, b: WorksheetCell): void;
    /**
     * @hidden
     */
    _add2(a: AnyValueDataValidationRule, b: WorksheetRegion): void;
    /**
     * @hidden
     */
    _add3(a: CustomDataValidationRule, b: WorksheetCell): void;
    /**
     * @hidden
     */
    _add4(a: CustomDataValidationRule, b: WorksheetRegion): void;
    /**
     * @hidden
     */
    _add7(a: ListDataValidationRule, b: WorksheetCell): void;
    /**
     * @hidden
     */
    _add8(a: ListDataValidationRule, b: WorksheetRegion): void;
    /**
     * @hidden
     */
    _add9(a: OneConstraintDataValidationRule, b: WorksheetCell): void;
    /**
     * @hidden
     */
    _add10(a: OneConstraintDataValidationRule, b: WorksheetRegion): void;
    /**
     * @hidden
     */
    _add11(a: TwoConstraintDataValidationRule, b: WorksheetCell): void;
    /**
     * @hidden
     */
    _add12(a: TwoConstraintDataValidationRule, b: WorksheetRegion): void;
    /**
     * Removes all data validation rules from the [[worksheet]].
     */
    clear(): void;
    /**
     * @hidden
     */
    _contains1(a: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _contains2(a: WorksheetCell): boolean;
    /**
     * @hidden
     */
    _contains3(a: WorksheetReferenceCollection): boolean;
    /**
     * @hidden
     */
    _contains4(a: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _contains5(a: WorksheetRegionAddress): boolean;
    /**
     * Find the data validation rule applied to the specified cell.
     * @param cell The cell to test.
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when the 'cell' is from a worksheet other than this collection.
     * @return A [[DataValidationRule]]-derived instance or null if the cell has no rule applied.
     */
    findRule(cell: WorksheetCell): DataValidationRule;
    /**
     * Gets a collection of all the references which have the specified or an equivalent rule applied to them.
     * @param rule The rule to test.
     * @return A collection of references in the [[worksheet]] with a rule applied to it that is equivalent to the specified 'rule'.
     */
    getAllReferences(rule: DataValidationRule): WorksheetReferenceCollection;
    /**
     * Removes the specified rule from the [[worksheet]].
     * @param rule The rule which should be removed.
     * @throws [[ArgumentNullException]] Occurs when 'rule' is null.
     * @return True if the rule was contained on the Worksheet before removal; False otherwise.
     */
    removeItem(rule: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _remove2(a: WorksheetCell): boolean;
    /**
     * @hidden
     */
    _remove3(a: WorksheetReferenceCollection): boolean;
    /**
     * @hidden
     */
    _remove4(a: WorksheetRegion): boolean;
    /**
     * @hidden
     */
    _remove5(a: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _r(a: DataValidationRule, b: WorksheetReferenceCollection): {
        ret: boolean;
        p1: WorksheetReferenceCollection;
    };
    /**
     * @hidden
     */
    _aj(a: DataValidationRule, b: WorksheetCell): void;
    /**
     * @hidden
     */
    _ak(a: DataValidationRule, b: WorksheetRegion): void;
    /**
     * @hidden
     */
    _al(a: DataValidationRule, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _e(a: WorksheetRegionAddress): DataValidationRule;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _w;
    /**
     * @hidden
     */
    private _am;
    /**
     * @hidden
     */
    private static _an;
    /**
     * @hidden
     */
    private static _ao;
    /**
     * @hidden
     */
    private _ap;
    /**
     * @hidden
     */
    private _aq;
    /**
     * @hidden
     */
    private _ar;
    /**
     * @hidden
     */
    private _as;
    /**
     * Gets the number of data validation rules applied on the [[worksheet]].
     */
    get count(): number;
    /**
     * Gets or sets the references which have the data validation rule applied to it.
     * @param rule A data validation rule.
     * @throws [[ArgumentNullException]] Occurs when the 'rule' is null.
     * @throws [[KeyNotFoundException]] Occurs when the property is retrieved and the 'rule' is not applied to the [[worksheet]].
     * @throws [[ArgumentException]] Occurs when the property is set and the value is from a Worksheet other than this collection.
     * @throws [[ArgumentException]] Occurs when the property is set and the 'rule' is invalid based on its rule type's requirements.
     */
    item(a: DataValidationRule, b?: WorksheetReferenceCollection): WorksheetReferenceCollection;
    /**
     * @hidden
     */
    get _g(): Worksheet;
}
/**
 * Represents a data validation rule which allows a value from a list of accepted values to be applied to a cell.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 */
export declare class ListDataValidationRule extends LimitedValueDataValidationRule {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _by;
    /**
     * @hidden
     */
    private static readonly _bz;
    /**
     * @hidden
     */
    private static readonly _bx;
    /**
     * @hidden
     */
    private static readonly _bk;
    private _bt;
    private _br;
    constructor();
    /**
     * @hidden
     */
    protected get__k(): FormulaType;
    /**
     * @hidden
     */
    _n(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    _o(a: string): SingleTargetFormula;
    /**
     * Indicates if this rule is structurally equivalent to another.
     * @param other The rule to compare against
     * @return Returns true if the specified 'other' has the same settings as this rule.
     */
    isEquivalentTo(other: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _a9(a: FormulaToken, b: boolean, c: boolean, d: boolean, e: WorkbookFormat): boolean;
    /**
     * @hidden
     */
    _ar(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _as(): void;
    /**
     * @hidden
     */
    protected get__l(): DataValidationOperatorType;
    /**
     * @hidden
     */
    get _l(): DataValidationOperatorType;
    /**
     * @hidden
     */
    _at(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _au(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _bb(a: WorksheetCellAddress, b: any): boolean;
    /**
     * @hidden
     */
    protected get__m(): DataValidationType;
    /**
     * @hidden
     */
    get _m(): DataValidationType;
    /**
     * @hidden
     */
    _bi(a: SingleTargetFormula, b: DataValidationRuleCollection, c: WorksheetReferenceCollection, d: string, e: boolean, f: boolean, g: WorkbookFormat): void;
    /**
     * @hidden
     */
    _aw(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * Gets the formula which specifies the accepted values.
     * <p class="body">
     * The is a string containing the list of accepted values or a reference to a cell or region in the same Workbook which contains
     * the accepted values.
     * </p>
     * <p class="body">
     * If the formula equals a string, it will be a list of accepted value, such as ="A,B,C". If one of the values must contain a double
     * quote ("), the character will be repeated in the list, like so: ="A,""B"",C". This will allow the values A, "B", and C. The
     * separator between values will be a comma (,), unless the decimal separator for the current culture is a comma, in which case the
     * separator will be a semicolon (;).
     * </p>
     * <p class="body">
     * If the formula equals one or more references, it will be a reference to a single cell or region in the same Workbook. Union,
     * intersection, and range operators are not allowed. An formula might be something like =$A$1 or =Sheet2!$A$1:$A$5. In addition to a
     * single cell or region, a named reference can also be used, but only if it refers to a single cell or region. If a region is specified,
     * or a named reference that refers to a region, the region will consist of a single row or column. A formula that equals an error value
     * can also be returned, but will cause the cell to not accept any values and the drop down to be empty, so it is not very useful.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @return A formula used to validate the value applied to a cell.
     * @see [[tryGetValues]]
     * @see [[getValuesFormula]]
     * @see [[setValuesFormula]]
     * @see [[setValuesFormula]]
     */
    getValuesFormula(address: string): string;
    /**
     * Gets the formula which specifies the accepted values.
     * <p class="body">
     * The is a string containing the list of accepted values or a reference to a cell or region in the same Workbook which contains
     * the accepted values.
     * </p>
     * <p class="body">
     * If the formula equals a string, it will be a list of accepted value, such as ="A,B,C". If one of the values must contain a double
     * quote ("), the character will be repeated in the list, like so: ="A,""B"",C". This will allow the values A, "B", and C. The
     * separator between values will be a comma (,), unless the decimal separator for the current culture is a comma, in which case the
     * separator will be a semicolon (;).
     * </p>
     * <p class="body">
     * If the formula equals one or more references, it will be a reference to a single cell or region in the same Workbook. Union,
     * intersection, and range operators are not allowed. An formula might be something like =$A$1 or =Sheet2!$A$1:$A$5. In addition to a
     * single cell or region, a named reference can also be used, but only if it refers to a single cell or region. If a region is specified,
     * or a named reference that refers to a region, the region will consist of a single row or column. A formula that equals an error value
     * can also be returned, but will cause the cell to not accept any values and the drop down to be empty, so it is not very useful.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when generating the formula string.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @return A formula used to validate the value applied to a cell.
     * @see [[tryGetValues]]
     * @see [[getValuesFormula]]
     * @see [[setValuesFormula]]
     * @see [[setValuesFormula]]
     */
    getValuesFormula(address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): string;
    /**
     * @hidden
     */
    _getValuesFormula(a: string): string;
    /**
     * @hidden
     */
    _getValuesFormula1(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): string;
    /**
     * Sets the list of accepted values the cell can accept.
     * <p class="body">
     * If [[LimitedValueDataValidationRule.allowNull]] is True, null values are allowed in addition to the list of accepted values.
     * </p>
     * <p class="body">
     * All values will have ToString called on them to covert the accepted values list to a formula.
     * </p>
     * <p class="note">
     * <b>Note:</b> the formula of accepted values is created by separating each value with a function parameter separator and concatenating
     * them into a single string. So a list of 1, 2, and 3 would have the following formula created: ="1,2,3". However, if the decimal separator
     * of the current culture is a comma (,) then a semicolon (;) will be used to separate the values instead. Because of this, if the ToString
     * of a value returns a string which contains one of these separators, the value will be split into two or more allowed values.
     * </p>
     * @param values The list of accepted values.
     * @throws [[ArgumentNullException]] Occurs when 'values' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[ArgumentException]] Occurs when the 'values' array is empty.
     * @see [[getValuesFormula]]
     * @see [[getValuesFormula]]
     * @see [[setValuesFormula]]
     * @see [[setValuesFormula]]
     */
    setValues(...values: any[]): void;
    /**
     * Sets the formula which specifies the accepted values.
     * <p class="body">
     * The formula must be a string containing the list of accepted values or a reference to a cell or region in the same Workbook
     * which contains the accepted values.
     * </p>
     * <p class="body">
     * If a formula equaling a string is specified, it must be a string literal and it cannot be concatenated. For example, an
     * acceptable formula would be ="A,B,C". If one of the values must contain a double quote ("), the character should be repeated
     * in the list, like so: ="A,""B"",C". This will allow the values A, "B", and C. The separator between values must be a comma (,),
     * unless the decimal separator for the current culture is a comma, in which case the separator must be a semicolon (;).
     * </p>
     * <p class="body">
     * If a formula equaling one or more references is specified, it must be a reference to a single cell or region in the same Workbook.
     * Union, intersection, and range operators are not allowed. An acceptable formula might be =$A$1 or =Sheet2!$A$1:$A$5. In addition
     * to a single cell or region, a named reference can also be used, but only if it refers to a single cell or region. If a region is
     * specified, or a named reference that refers to a region, the region must consist of a single row or column. A formula that equals
     * an error value is also allowed, but will cause the cell to not accept any values and the drop down to be empty, so it is not very
     * useful.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param valuesFormula The formula which provides the accepted values for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'valuesFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'valuesFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when the specified value contains something other than a string or reference.
     * @throws [[ArgumentException]] Occurs when the specified value contains a region reference which has more than one row and column.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @see [[setValues]]
     * @see [[getValuesFormula]]
     * @see [[getValuesFormula]]
     * @see [[setValuesFormula]]
     */
    setValuesFormula(valuesFormula: string, address: string): void;
    /**
     * Sets the formula which specifies the accepted values.
     * <p class="body">
     * The formula must be a string containing the list of accepted values or a reference to a cell or region in the same Workbook
     * which contains the accepted values.
     * </p>
     * <p class="body">
     * If a formula equaling a string is specified, it must be a string literal and it cannot be concatenated. For example, an
     * acceptable formula would be ="A,B,C". If one of the values must contain a double quote ("), the character should be repeated
     * in the list, like so: ="A,""B"",C". This will allow the values A, "B", and C. The separator between values must be a comma (,),
     * unless the decimal separator for the current culture is a comma, in which case the separator must be a semicolon (;).
     * </p>
     * <p class="body">
     * If a formula equaling one or more references is specified, it must be a reference to a single cell or region in the same Workbook.
     * Union, intersection, and range operators are not allowed. An acceptable formula might be =$A$1 or =Sheet2!$A$1:$A$5. In addition
     * to a single cell or region, a named reference can also be used, but only if it refers to a single cell or region. If a region is
     * specified, or a named reference that refers to a region, the region must consist of a single row or column. A formula that equals
     * an error value is also allowed, but will cause the cell to not accept any values and the drop down to be empty, so it is not very
     * useful.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param valuesFormula The formula which provides the accepted values for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when parsing the formula string.
     * @throws [[ArgumentNullException]] Occurs when 'valuesFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'valuesFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when the specified value contains something other than a string or reference.
     * @throws [[ArgumentException]] Occurs when the specified value contains a region reference which has more than one row and column.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @see [[setValues]]
     * @see [[getValuesFormula]]
     * @see [[getValuesFormula]]
     * @see [[setValuesFormula]]
     */
    setValuesFormula(valuesFormula: string, address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): void;
    /**
     * @hidden
     */
    _setValuesFormula(a: string, b: string): void;
    /**
     * @hidden
     */
    _setValuesFormula1(a: string, b: string, c: WorkbookFormat, d: CellReferenceMode, e: CultureInfo): void;
    /**
     * @hidden
     */
    _bv(a: any[]): {
        ret: boolean;
        p0: any[];
    };
    /**
     * @hidden
     */
    _bm(a?: (arg1: string) => any): any[];
    /**
     * @hidden
     */
    private static _b0;
    /**
     * @hidden
     */
    _bo(a: WorksheetCellAddress, b?: boolean): ArrayProxy;
    /**
     * @hidden
     */
    _bq(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): SingleTargetFormula;
    /**
     * @hidden
     */
    private static _bn;
    /**
     * @hidden
     */
    private _b7;
    /**
     * @hidden
     */
    private static _bw;
    /**
     * @hidden
     */
    private static _bp;
    /**
     * @hidden
     */
    private static _bl;
    /**
     * @hidden
     */
    private static _bs;
    /**
     * @hidden
     */
    private static _b3;
    /**
     * Gets or sets the value which indicates whether a drop down should be displayed in Microsoft Excel with the list of accepted values.
     * <p class="body">
     * If this is True, a drop down arrow will be displayed next to the cell when it is selected. When the user clicks the drop down arrow,
     * a drop down will be displayed with the list of accepted values.
     * </p>
     */
    get showDropdown(): boolean;
    set showDropdown(a: boolean);
}
/**
 * Base class for all data validations rules which compare the cell value against one or more constraint when determining
 * the validity of the cell value.
 * @see [[OneConstraintDataValidationRule]]
 * @see [[TwoConstraintDataValidationRule]]
 */
export declare abstract class ValueConstraintDataValidationRule extends LimitedValueDataValidationRule {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _br;
    /**
     * @hidden
     */
    private static readonly _bq;
    /**
     * @hidden
     */
    private static readonly _bk;
    private _bn;
    constructor();
    /**
     * Indicates if this rule is structurally equivalent to another.
     * @param other The rule to compare against
     * @return Returns true if the specified 'other' has the same settings as this rule.
     */
    isEquivalentTo(other: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _a9(a: FormulaToken, b: boolean, c: boolean, d: boolean, e: WorkbookFormat): boolean;
    /**
     * @hidden
     */
    _bb(a: WorksheetCellAddress, b: any): boolean;
    /**
     * @hidden
     */
    protected get__m(): DataValidationType;
    /**
     * @hidden
     */
    get _m(): DataValidationType;
    /**
     * @hidden
     */
    _bi(a: SingleTargetFormula, b: DataValidationRuleCollection, c: WorksheetReferenceCollection, d: string, e: boolean, f: boolean, g: WorkbookFormat): void;
    /**
     * @hidden
     */
    _bt(a: DataValidationCriteria, b: string): void;
    /**
     * @hidden
     */
    static _bs(a: Formula): Nullable$1<number>;
    /**
     * @hidden
     */
    abstract _bp(a: WorksheetCellAddress, b: number): boolean;
    /**
     * @hidden
     */
    private static _bm;
    /**
     * @hidden
     */
    private static _bl;
    /**
     * Gets or sets the criteria to use when validating the cell value against the constraint(s).
     * <p class="body">
     * Depending on the value specified, either then cell value or the length of its text equivalent will be compared against the
     * constraint(s). In addition, certain ValidationCriteria values may disallow a cell value even if it is valid when compared to
     * the constraint. For example, the ValidationCriteria.WholeNumber value will not allow any number with a fractional portion.
     * </p>
     * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[DataValidationCriteria]] enumeration.
     */
    get validationCriteria(): DataValidationCriteria;
    set validationCriteria(a: DataValidationCriteria);
    /**
     * @hidden
     */
    private _bu;
}
/**
 * Represents a data validation rule which can validate the cell value against a single constraint value or formula.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[OneConstraintDataValidationOperator]]
 */
export declare class OneConstraintDataValidationRule extends ValueConstraintDataValidationRule {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _b4;
    /**
     * @hidden
     */
    private static readonly _b6;
    /**
     * @hidden
     */
    private static readonly _b5;
    /**
     * @hidden
     */
    private static readonly _bv;
    private _b0;
    private _by;
    constructor();
    constructor(validationOperator: OneConstraintDataValidationOperator, validationCriteria: DataValidationCriteria);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _n(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    _o(a: string): SingleTargetFormula;
    /**
     * Indicates if this rule is structurally equivalent to another.
     * @param other The rule to compare against
     * @return Returns true if the specified 'other' has the same settings as this rule.
     */
    isEquivalentTo(other: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _ar(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _as(): void;
    /**
     * @hidden
     */
    protected get__l(): DataValidationOperatorType;
    /**
     * @hidden
     */
    get _l(): DataValidationOperatorType;
    /**
     * @hidden
     */
    _at(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _au(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _bp(a: WorksheetCellAddress, b: number): boolean;
    /**
     * @hidden
     */
    _aw(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * Gets the constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent is
     * compared to the constraint formula's value.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @return A formula used to validate the value applied to a cell.
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     * @see [[getConstraintFormula]]
     * @see [[setConstraintFormula]]
     * @see [[setConstraintFormula]]
     */
    getConstraintFormula(address: string): string;
    /**
     * Gets the constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent is
     * compared to the constraint formula's value.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when generating the formula string.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @return A formula used to validate the value applied to a cell.
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     * @see [[getConstraintFormula]]
     * @see [[setConstraintFormula]]
     * @see [[setConstraintFormula]]
     */
    getConstraintFormula(address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): string;
    /**
     * @hidden
     */
    _getConstraintFormula(a: string): string;
    /**
     * @hidden
     */
    _getConstraintFormula1(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): string;
    /**
     * Sets the constraint value used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the constraint value is determined by the [[validationOperator]] as well
     * as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent is
     * compared to the constraint value.
     * </p>
     * <p class="body">
     * This overload is preferred when the ValidationCriteria is Date. When the ValidationCriteria is WholeNumber, Decimal, Time, or TextLength,
     * the [[setConstraint]] overload is preferred.
     * </p>
     * @param value The constraint value used to compare against the cell value.
     * @throws [[ArgumentException]] Occurs when 'value' cannot be represented as a date in Excel.
     * @see [[setConstraint]]
     * @see [[setConstraintFormula]]
     * @see [[setConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setConstraint(value: Date): void;
    /**
     * Sets the constraint value used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the constraint value is determined by the [[validationOperator]] as well
     * as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent is
     * compared to the constraint value.
     * </p>
     * <p class="body">
     * This overload is preferred when the ValidationCriteria is WholeNumber, Decimal, Time, or TextLength. When the ValidationCriteria is Date, the
     * [[setConstraint]] overload is preferred.
     * </p>
     * @param value The constraint value used to compare against the cell value.
     * @see [[setConstraint]]
     * @see [[setConstraintFormula]]
     * @see [[setConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setConstraint(value: number): void;
    /**
     * @hidden
     */
    _setConstraint1(a: number): void;
    /**
     * @hidden
     */
    _setConstraint(a: Date): void;
    /**
     * Sets the constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent is
     * compared to the constraint formula's value.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param constraintFormula The validation formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'constraintFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'constraintFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @see [[setConstraint]]
     * @see [[setConstraint]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     * @see [[getConstraintFormula]]
     * @see [[getConstraintFormula]]
     * @see [[setConstraintFormula]]
     */
    setConstraintFormula(constraintFormula: string, address: string): void;
    /**
     * Sets the constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent is
     * compared to the constraint formula's value.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param constraintFormula The validation formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when parsing the formula string.
     * @throws [[ArgumentNullException]] Occurs when 'constraintFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'constraintFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @see [[setConstraint]]
     * @see [[setConstraint]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     * @see [[getConstraintFormula]]
     * @see [[getConstraintFormula]]
     * @see [[setConstraintFormula]]
     */
    setConstraintFormula(constraintFormula: string, address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): void;
    /**
     * @hidden
     */
    _setConstraintFormula(a: string, b: string): void;
    /**
     * @hidden
     */
    _setConstraintFormula1(a: string, b: string, c: WorkbookFormat, d: CellReferenceMode, e: CultureInfo): void;
    /**
     * @hidden
     */
    _b3(a: number): {
        ret: boolean;
        p0: number;
    };
    /**
     * @hidden
     */
    _b2(a: Date): {
        ret: boolean;
        p0: Date;
    };
    /**
     * @hidden
     */
    _b1(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): SingleTargetFormula;
    /**
     * @hidden
     */
    private _cd;
    /**
     * @hidden
     */
    private static _bx;
    /**
     * @hidden
     */
    private static _bw;
    /**
     * Gets or sets the validation operator to use when comparing the cell value against the constraint value or formula.
     * <p class="body">
     * Depending on the [[ValueConstraintDataValidationRule.validationCriteria]] of the rule, either the cell value itself or the
     * length of the cell value's text equivalent is compared to the constraint value or formula.
     * </p>
     * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[OneConstraintDataValidationOperator]] enumeration.
     * @see [[setConstraint]]
     * @see [[setConstraint]]
     * @see [[getConstraintFormula]]
     * @see [[getConstraintFormula]]
     * @see [[setConstraintFormula]]
     * @see [[setConstraintFormula]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    get validationOperator(): OneConstraintDataValidationOperator;
    set validationOperator(a: OneConstraintDataValidationOperator);
}
/**
 * Represents a data validation rule which can validate the cell value against two constraint values or formulas.
 * @see [[Worksheet.dataValidationRules]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[DataValidationRuleCollection.add]]
 * @see [[TwoConstraintDataValidationOperator]]
 */
export declare class TwoConstraintDataValidationRule extends ValueConstraintDataValidationRule {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _b8;
    /**
     * @hidden
     */
    private static readonly _ca;
    /**
     * @hidden
     */
    private static readonly _cb;
    /**
     * @hidden
     */
    private static readonly _b9;
    /**
     * @hidden
     */
    private static readonly _bv;
    private _b0;
    private _b1;
    private _b2;
    constructor();
    constructor(validationOperator: TwoConstraintDataValidationOperator, validationCriteria: DataValidationCriteria);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _n(a: string): SingleTargetFormula;
    /**
     * @hidden
     */
    _o(a: string): SingleTargetFormula;
    /**
     * Indicates if this rule is structurally equivalent to another.
     * @param other The rule to compare against
     * @return Returns true if the specified 'other' has the same settings as this rule.
     */
    isEquivalentTo(other: DataValidationRule): boolean;
    /**
     * @hidden
     */
    _ar(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * @hidden
     */
    _as(): void;
    /**
     * @hidden
     */
    protected get__l(): DataValidationOperatorType;
    /**
     * @hidden
     */
    get _l(): DataValidationOperatorType;
    /**
     * @hidden
     */
    _at(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _au(a: SingleTargetFormula, b: string): void;
    /**
     * @hidden
     */
    _bp(a: WorksheetCellAddress, b: number): boolean;
    /**
     * @hidden
     */
    _aw(a: DataValidationRuleCollection, b: WorksheetReferenceCollection): void;
    /**
     * Gets the lower constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the lower constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the lower constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @return A formula used to validate the value applied to a cell.
     * @see [[getLowerConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    getLowerConstraintFormula(address: string): string;
    /**
     * Gets the lower constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the lower constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the lower constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when generating the formula string.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @return A formula used to validate the value applied to a cell.
     * @see [[getLowerConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    getLowerConstraintFormula(address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): string;
    /**
     * @hidden
     */
    _getLowerConstraintFormula(a: string): string;
    /**
     * @hidden
     */
    _getLowerConstraintFormula1(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): string;
    /**
     * Gets the upper constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the upper constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the upper constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @return A formula used to validate the value applied to a cell.
     * @see [[getLowerConstraintFormula]]
     * @see [[getLowerConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    getUpperConstraintFormula(address: string): string;
    /**
     * Gets the upper constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the upper constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the upper constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. For example, consider the formula
     * applied is =B1, and the data validation rule is applied to the region A1:A5. If you get the formula for A1, the formula
     * =B1 will be returned. If you get the formula for A2, =B2 will be returned. Similarly, for cell A5, =B5 will be returned.
     * However, if the formula contains no references or all absolute references, the 'address' is ignored. So
     * in the previous example, if the original formula was =$B$1, the same formula will be returned regardless of the specified
     * address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when generating the formula string.
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @return A formula used to validate the value applied to a cell.
     * @see [[getLowerConstraintFormula]]
     * @see [[getLowerConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    getUpperConstraintFormula(address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): string;
    /**
     * @hidden
     */
    _getUpperConstraintFormula(a: string): string;
    /**
     * @hidden
     */
    _getUpperConstraintFormula1(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): string;
    /**
     * Sets the lower constraint value used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the lower constraint value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the lower constraint value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * This overload is preferred when the ValidationCriteria is Date. When the ValidationCriteria is WholeNumber, Decimal, Time, or TextLength,
     * the [[setLowerConstraint]] overload is preferred.
     * </p>
     * @param value The lower constraint value used to compare against the cell value.
     * @throws [[ArgumentException]] Occurs when 'value' cannot be represented as a date in Excel.
     * @throws [[ArgumentException]] Occurs when the specified value is greater than the upper constraint value. If the upper constraint formula does not equal
     * a constant, this verification is not performed.
     * @see [[setLowerConstraint]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setUpperConstraint]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setLowerConstraint(value: Date): void;
    /**
     * Sets the lower constraint value used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the lower constraint value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the lower constraint value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * This overload is preferred when the ValidationCriteria is WholeNumber, Decimal, Time, or TextLength. When the ValidationCriteria is Date, the
     * [[setLowerConstraint]] overload is preferred.
     * </p>
     * @param value The lower constraint value used to compare against the cell value.
     * @throws [[ArgumentException]] Occurs when the specified value is greater than the upper constraint value. If the upper constraint formula does not equal
     * a constant, this verification is not performed.
     * @see [[setLowerConstraint]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setUpperConstraint]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setLowerConstraint(value: number): void;
    /**
     * @hidden
     */
    _setLowerConstraint1(a: number): void;
    /**
     * @hidden
     */
    _setLowerConstraint(a: Date): void;
    /**
     * Gets the lower constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the lower constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the lower constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param lowerConstraintFormula The lower constraint formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'lowerConstraintFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[ArgumentException]] Occurs when 'lowerConstraintFormula' is an [[ArrayFormula]].
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[ArgumentNullException]] Occurs when the specified value is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'lowerConstraintFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when the specified value equals a constant, such as =5, and the constant value is greater than the upper constraint value.
     * If the upper constraint formula does not equal a constant, this verification is not performed.
     * @see [[setLowerConstraint]]
     * @see [[setLowerConstraint]]
     * @see [[getLowerConstraintFormula]]
     * @see [[getLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setLowerConstraintFormula(lowerConstraintFormula: string, address: string): void;
    /**
     * Gets the lower constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the lower constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the lower constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param lowerConstraintFormula The lower constraint formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when parsing the formula string.
     * @throws [[ArgumentNullException]] Occurs when 'lowerConstraintFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[ArgumentException]] Occurs when 'lowerConstraintFormula' is an [[ArrayFormula]].
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[ArgumentNullException]] Occurs when the specified value is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'lowerConstraintFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when the specified value equals a constant, such as =5, and the constant value is greater than the upper constraint value.
     * If the upper constraint formula does not equal a constant, this verification is not performed.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @see [[setLowerConstraint]]
     * @see [[setLowerConstraint]]
     * @see [[getLowerConstraintFormula]]
     * @see [[getLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setLowerConstraintFormula(lowerConstraintFormula: string, address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): void;
    /**
     * @hidden
     */
    _setLowerConstraintFormula(a: string, b: string): void;
    /**
     * @hidden
     */
    _setLowerConstraintFormula1(a: string, b: string, c: WorkbookFormat, d: CellReferenceMode, e: CultureInfo): void;
    /**
     * Sets the upper constraint value used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the upper constraint value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the upper constraint value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * This overload is preferred when the ValidationCriteria is Date. When the ValidationCriteria is WholeNumber, Decimal, Time, or TextLength,
     * the [[setUpperConstraint]] overload is preferred.
     * </p>
     * @param value The lower constraint value used to compare against the cell value.
     * @throws [[ArgumentException]] Occurs when 'value' cannot be represented as a date in Excel.
     * @throws [[ArgumentException]] Occurs when the specified value is less than the lower constraint value. If the lower constraint formula does not equal
     * a constant, this verification is not performed.
     * @see [[setLowerConstraint]]
     * @see [[setUpperConstraint]]
     * @see [[setUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setUpperConstraint(value: Date): void;
    /**
     * Sets the upper constraint value used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the upper constraint value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the upper constraint value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * This overload is preferred when the ValidationCriteria is WholeNumber, Decimal, Time, or TextLength. When the ValidationCriteria is Date, the
     * [[setUpperConstraint]] overload is preferred.
     * </p>
     * @param value The lower constraint value used to compare against the cell value.
     * @throws [[ArgumentException]] Occurs when the specified value is less than the lower constraint value. If the lower constraint formula does not equal
     * a constant, this verification is not performed.
     * @see [[setLowerConstraint]]
     * @see [[setUpperConstraint]]
     * @see [[setUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setUpperConstraint(value: number): void;
    /**
     * @hidden
     */
    _setUpperConstraint1(a: number): void;
    /**
     * @hidden
     */
    _setUpperConstraint(a: Date): void;
    /**
     * Gets the upper constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the upper constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the upper constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * <p class="body">
     * The cell reference mode with which to parse 'address' will be assumed to be A1, unless the data validation
     * rule is applied to a worksheet which is in a workbook, in which case the [[Workbook.cellReferenceMode]] will be used.
     * </p>
     * @param upperConstraintFormula The upper constraint formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'upperConstraintFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[ArgumentException]] Occurs when 'upperConstraintFormula' is an [[ArrayFormula]].
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[ArgumentNullException]] Occurs when the specified value is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'upperConstraintFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when the specified value equals a constant, such as =5, and the constant value is greater than the upper constraint value.
     * If the upper constraint formula does not equal a constant, this verification is not performed.
     * @see [[setUpperConstraint]]
     * @see [[setUpperConstraint]]
     * @see [[getUpperConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setUpperConstraintFormula(upperConstraintFormula: string, address: string): void;
    /**
     * Gets the upper constraint formula used to validate the cell value.
     * <p class="body">
     * The way in which the cell value is compared to the upper constraint formula's value is determined by the [[validationOperator]]
     * as well as the [[ValueConstraintDataValidationRule.validationCriteria]].
     * </p>
     * <p class="body">
     * Depending on the ValidationCriteria of the rule, either the cell value itself or the length of the cell value's text equivalent
     * is compared to the upper constraint formula's value.
     * </p>
     * <p class="body">
     * When the [[validationOperator]] is Between, the value must be greater than or equal to the lower constraint and less
     * than or equal to the upper constraint. When the ValidationOperator is NotBetween, the value must be less than the lower constraint
     * or greater than the upper constraint.
     * </p>
     * <p class="body">
     * The address passed in is only needed if relative addresses are used in the the formula. When the data validation rule is
     * applied to cells or regions, the references in the formula used by each individual cell will be shifted by the offset of
     * the cell to the passed in 'address'. For example, consider the formula specified is =B1 and the specified
     * address is A1. If the data validation rule is then applied to the A5 cell, the formula is will use is =B5. However, if the
     * references in the formula are absolute, such as =$B$1, the same formula will be applied regardless of the specified address.
     * </p>
     * <p class="body">
     * 'address' can be any valid cell or region reference on a worksheet. If a region address is specified, the
     * top-left cell or the region is used. The cell or region specified does not need to have the data validation rule applied to it.
     * Any reference is allowed.
     * </p>
     * @param upperConstraintFormula The upper constraint formula to use for the rule.
     * @param address The address of the cell or region that serves as the basis for relative references, or null to use the top-left cell of
     * the worksheet.
     * @param format The workbook format with which to parse 'address'.
     * @param cellReferenceMode The cell reference mode with which to parse 'address'.
     * @param culture The culture to use when parsing the formula string.
     * @throws [[ArgumentNullException]] Occurs when 'upperConstraintFormula' is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[ArgumentException]] Occurs when 'upperConstraintFormula' is an [[ArrayFormula]].
     * @throws [[ArgumentException]] Occurs when 'address' is not a valid cell or regions address.
     * @throws [[ArgumentNullException]] Occurs when the specified value is null and the rule is currently applied to a [[Worksheet]].
     * @throws [[FormulaParseException]] Occurs when 'upperConstraintFormula' is not a valid formula.
     * @throws [[ArgumentException]] Occurs when the specified value equals a constant, such as =5, and the constant value is greater than the upper constraint value.
     * If the upper constraint formula does not equal a constant, this verification is not performed.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'format' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[InvalidEnumArgumentException]] Occurs when 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @see [[setUpperConstraint]]
     * @see [[setUpperConstraint]]
     * @see [[getUpperConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[validationOperator]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    setUpperConstraintFormula(upperConstraintFormula: string, address: string, format: WorkbookFormat, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): void;
    /**
     * @hidden
     */
    _setUpperConstraintFormula(a: string, b: string): void;
    /**
     * @hidden
     */
    _setUpperConstraintFormula1(a: string, b: string, c: WorkbookFormat, d: CellReferenceMode, e: CultureInfo): void;
    /**
     * @hidden
     */
    _b5(a: number): {
        ret: boolean;
        p0: number;
    };
    /**
     * @hidden
     */
    _b4(a: Date): {
        ret: boolean;
        p0: Date;
    };
    /**
     * @hidden
     */
    _b7(a: number): {
        ret: boolean;
        p0: number;
    };
    /**
     * @hidden
     */
    _b6(a: Date): {
        ret: boolean;
        p0: Date;
    };
    /**
     * @hidden
     */
    _by(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): SingleTargetFormula;
    /**
     * @hidden
     */
    _bz(a: string, b: WorkbookFormat, c: CellReferenceMode, d: CultureInfo): SingleTargetFormula;
    /**
     * @hidden
     */
    private _ck;
    /**
     * @hidden
     */
    private _cp;
    /**
     * @hidden
     */
    private static _bx;
    /**
     * @hidden
     */
    private static _bw;
    /**
     * Gets or sets the validation operator to use when comparing the cell value against the constraint values or formulas.
     * <p class="body">
     * Depending on the [[ValueConstraintDataValidationRule.validationCriteria]] of the rule, either the cell value itself or the
     * length of the cell value's text equivalent is compared to the constraint values or formulas.
     * </p>
     * @throws [[InvalidEnumArgumentException]] Occurs when the value is not a member of the [[TwoConstraintDataValidationOperator]] enumeration.
     * @see [[setLowerConstraint]]
     * @see [[setLowerConstraint]]
     * @see [[setUpperConstraint]]
     * @see [[setUpperConstraint]]
     * @see [[getLowerConstraintFormula]]
     * @see [[getLowerConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[getUpperConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setLowerConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[setUpperConstraintFormula]]
     * @see [[ValueConstraintDataValidationRule.validationCriteria]]
     */
    get validationOperator(): TwoConstraintDataValidationOperator;
    set validationOperator(a: TwoConstraintDataValidationOperator);
}
/**
 * @hidden
 */
export declare class DisplayValueCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: DisplayValueCollection, c: string, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: DisplayValueCollection;
    readonly c: string;
    readonly b: number;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of display text values.
 * @see [[WorksheetCell.getText]]
 * @see [[WorksheetRow.getCellText]]
 * @see [[FixedValuesFilter.displayValues]]
 */
export declare class DisplayValueCollection extends Base implements IList$1<string> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _f;
    /**
     * @hidden
     */
    private static readonly _h;
    /**
     * @hidden
     */
    private static readonly _i;
    /**
     * @hidden
     */
    private static readonly _g;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    _d: FixedValuesFilter;
    private _e;
    static staticInit(): void;
    constructor(a: FixedValuesFilter);
    /**
     * @hidden
     */
    copyTo(array: string[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    [Symbol.iterator](): EnumeratorWrapper<string>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<string>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a display text value to the collection.
     * @param item The display text value to add to the collection.
     * @throws [[ArgumentNullException]] 'item' is null or empty.
     * @throws [[ArgumentException]] 'item' matches another value in the collection. Values are compared case-insensitively.
     */
    add(item: string): void;
    /**
     * Clears the collection.
     * @throws [[InvalidOperationException]] The collection is owned by a [[FixedValuesFilter]] which only allowed the values in the collection.
     * Clearing the collection would prevent the filter from including any values, which is not allowed for a FixedValuesFilter.
     */
    clear(): void;
    /**
     * Determines whether the specified value is in the collection.
     * <p class="body">
     * Display text values are compared case-insensitively.
     * </p>
     * @param item The display text value to find in the collection.
     * @return
     */
    contains(item: string): boolean;
    /**
     * Gets the index of the specified display text value in the collection.
     * @param item The display text value to find in the collection.
     * @return The 0-based index of the specified display text value in the collection or -1 if the item is not in the collection.
     */
    indexOf(item: string): number;
    /**
     * Inserts a display text value into the collection.
     * @param index The 0-based index where the value should be inserted.
     * @param item The display text value to insert into the collection.
     * @throws [[ArgumentNullException]] 'item' is null or empty.
     * @throws [[ArgumentException]] 'item' matches another value in the collection. Values are compared case-insensitively.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than [[count]].
     */
    insert(index: number, item: string): void;
    /**
     * Removes a display text value from the collection.
     * <p class="body">
     * Display text values are compared case-insensitively.
     * </p>
     * @param item The display text value to remove from the collection.
     * @return True if the value was found and removed; False otherwise.
     */
    remove(item: string): boolean;
    /**
     * Removes the display text value at the specified index.
     * @param index The 0-based index of the value to remove.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @throws [[InvalidOperationException]] This operation removes the last item in the collection and it is owned by a [[FixedValuesFilter]] which only
     * allowed the values in the collection. Clearing the collection would prevent the filter from including any values, which
     * is not allowed for a FixedValuesFilter.
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _k;
    /**
     * @hidden
     */
    private _l;
    /**
     * @hidden
     */
    private _m;
    /**
     * @hidden
     */
    private _n;
    /**
     * @hidden
     */
    private _j;
    /**
     * @hidden
     */
    private _o;
    /**
     * @hidden
     */
    private static _p;
    /**
     * @hidden
     */
    private static _q;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private _s;
    /**
     * Gets the number of display text values in the collection.
     */
    get count(): number;
    /**
     * Gets or sets the display text value at the specified index.
     * @param index The 0-based index of the value to get or set.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @throws [[ArgumentException]] The value assigned matches another value in the collection. Values are compared case-insensitively.
     */
    item(a: number, b?: string): string;
}
/**
 * Class which exposes the document level properties for a Microsoft Excel file.
 * <p class="body">
 * The properties exposed by this class can be changed on a Microsoft Excel file by right-clicking it
 * in Windows Explorer and editing the properties on the Summary tab.
 * </p>
 */
export declare class DocumentProperties extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _e;
    /**
     * @hidden
     */
    private static readonly _f;
    /**
     * @hidden
     */
    private static readonly _g;
    /**
     * @hidden
     */
    private static readonly _h;
    /**
     * @hidden
     */
    private static readonly _i;
    /**
     * @hidden
     */
    private static readonly _j;
    /**
     * @hidden
     */
    private static readonly _l;
    /**
     * @hidden
     */
    private static readonly _m;
    /**
     * @hidden
     */
    private static readonly _n;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static readonly _a;
    private _d;
    private _o;
    private _p;
    private _q;
    private _r;
    private _s;
    private _t;
    private _u;
    private _v;
    private _w;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    _ag(a: SummaryInformation, b: DocumentSummaryInformation): void;
    /**
     * @hidden
     */
    _ah(a: StructuredStorageManager): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * Gets or sets the author of the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the author of the document.
     */
    get author(): string;
    set author(a: string);
    /**
     * Gets or sets the category of the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the category of the document.
     */
    get category(): string;
    set category(a: string);
    /**
     * Gets or sets the comments associated with the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the comments associated with the document.
     */
    get comments(): string;
    set comments(a: string);
    /**
     * Gets or sets the company to which the document belongs.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the company to which the document belongs.
     */
    get company(): string;
    set company(a: string);
    /**
     * Gets or sets the keywords which describe the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the keywords which describe the document.
     */
    get keywords(): string;
    set keywords(a: string);
    /**
     * Gets or sets the manager associated with the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the manager associated with the document.
     */
    get manager(): string;
    set manager(a: string);
    /**
     * Gets or sets the current status of the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string representing the current status of the document.
     */
    get status(): string;
    set status(a: string);
    /**
     * Gets or sets the subject of the contents of the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the subject of the contents of the document.
     */
    get subject(): string;
    set subject(a: string);
    /**
     * Gets or sets the title of the document.
     * <p class="body">
     * The value of the property has no effect on the contents of the file when opened in a host application.
     * It is simply extra data associated with the document.
     * </p>
     * A string specifying the title of the document.
     */
    get title(): string;
    set title(a: string);
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
}
/**
 * @hidden
 */
export declare class FixedLengthSegmentTree$1<T extends IRegionAddress> extends Base {
    static $t: Type;
    protected $t: Type;
    private b;
    private readonly k;
    readonly c: RegionLookupTable$1<T>;
    m: number;
    constructor($t: Type, a: RegionLookupTable$1<T>, b: number);
    n(): void;
    private a;
    o(a: number, b: number): {
        p0: number;
        p1: number;
    };
    h(a: number, b: number, c: HashSet$1<T>, d: (arg1: T) => boolean): List$1<T>;
    e(a: number, b: number, c: (arg1: T) => boolean): HashSet$1<T>;
    i(a: number, b: HashSet$1<T>, c: (arg1: T) => boolean): List$1<T>;
    f(a: number, b: (arg1: T) => boolean): HashSet$1<T>;
    j(a: number, b: number, c: HashSet$1<T>, d: (arg1: T) => boolean): List$1<T>;
    g(a: number, b: number, c: (arg1: T) => boolean): HashSet$1<T>;
    p(a: T, b: number, c: number): void;
    q(a: T, b: number, c: number): void;
    get d(): boolean;
    get l(): number;
}
/**
 * @hidden
 */
export declare class FixedLengthSegmentTree_SegmentTreeNode$1<T extends IRegionAddress> extends Base {
    static $t: Type;
    protected $t: Type;
    k: number;
    j: number;
    private h;
    private a;
    private b;
    constructor($t: Type, a: number, b: number);
    private c;
    private static d;
    i(a: boolean, b: number): number;
    e<TCol extends ICollection$1<T>>($tCol: Type, a: FixedLengthSegmentTree$1<T>, b: number, c: number, d: HashSet$1<T>, e: TCol, f: () => TCol, g: (arg1: T) => boolean): TCol;
    f<TCol extends ICollection$1<T>>($tCol: Type, a: number, b: HashSet$1<T>, c: TCol, d: () => TCol, e: (arg1: T) => boolean): TCol;
    g<TCol extends ICollection$1<T>>($tCol: Type, a: number, b: number, c: HashSet$1<T>, d: TCol, e: () => TCol, f: (arg1: T) => boolean): TCol;
    l(a: FixedLengthSegmentTree$1<T>, b: T, c: number, d: number): void;
    m(a: FixedLengthSegmentTree$1<T>, b: T, c: number, d: number): void;
    n(a: FixedLengthSegmentTree_SegmentTreeNode$1<T>): void;
}
/**
 * @hidden
 */
export declare class FormatLimitErrors extends Base {
    static $t: Type;
    private c;
    private e;
    private readonly a;
    constructor(a: Workbook);
    g(a: string): void;
    h(): void;
    get f(): List$1<string>;
    get d(): boolean;
    get b(): Workbook;
}
/**
 * Abstract base class which controls the formatting of a range of characters in a [[FormattedString]] or [[FormattedText]].
 * @see [[FormattedStringFont]]
 * @see [[FormattedTextFont]]
 */
export declare abstract class FormattedFontBase extends Base implements IWorkbookFont, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _m;
    /**
     * @hidden
     */
    private static readonly _n;
    /**
     * @hidden
     */
    private static readonly _o;
    /**
     * @hidden
     */
    private static readonly _p;
    /**
     * @hidden
     */
    private static readonly _s;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _x;
    /**
     * @hidden
     */
    private static readonly _y;
    /**
     * @hidden
     */
    private static readonly _t;
    /**
     * @hidden
     */
    private static readonly _a;
    private readonly _f;
    private readonly _u;
    private readonly _q;
    constructor(a: IFormattedItem, b: number, c: number);
    /**
     * Sets all properties of this font to the properties of the specified font.
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, any default values on the specified font will be ignored.
     * </p>
     * @throws [[ArgumentNullException]] 'source' is null.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     * @param source The font whose properties should be copied over to this font.
     */
    setFontFormatting(source: IWorkbookFont): void;
    /**
     * @hidden
     */
    _z(): void;
    /**
     * @hidden
     */
    _aa(): void;
    /**
     * @hidden
     */
    _h(a: Workbook): IWorkbookFontDefaultsResolver;
    /**
     * @hidden
     */
    abstract _ac(a: Workbook, b: List$1<FormattingRunBase>, c: number, d: IWorkbookFontDefaultsResolver, e: FormattingRunBase): {
        p4: FormattingRunBase;
    };
    /**
     * @hidden
     */
    _ab(a: IFormattedRunOwner, b: Workbook, c: List$1<FormattingRunBase>, d: number, e: IWorkbookFontDefaultsResolver, f: FormattingRunBase): {
        p5?: FormattingRunBase;
    };
    /**
     * @hidden
     */
    _ad(): void;
    /**
     * @hidden
     */
    _e(a: List$1<FormattingRunBase>, b: number): FormattingRunBase;
    /**
     * @hidden
     */
    private static _ae;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _l;
    /**
     * @hidden
     */
    private _c;
    /**
     * @hidden
     */
    private _af;
    /**
     * @hidden
     */
    private _ag;
    /**
     * Gets or sets the value indicating whether the font is bold.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The value indicating whether the font is bold.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    get bold(): boolean | null;
    set bold(a: boolean | null);
    /**
     * @hidden
     */
    get _bold$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _bold$i(a: Nullable$1<boolean>);
    /**
     * Gets or sets the fore color of the font.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The fore color of the font.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    get colorInfo(): WorkbookColorInfo;
    set colorInfo(a: WorkbookColorInfo);
    /**
     * Gets or sets the height of the font.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The height of the font.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is positive and outside the valid font height range of 20 and 8180.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    get height(): number;
    set height(a: number);
    /**
     * Gets or sets the value indicating whether the font is italic.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The value indicating whether the font is italic.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    get italic(): boolean | null;
    set italic(a: boolean | null);
    /**
     * @hidden
     */
    get _italic$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _italic$i(a: Nullable$1<boolean>);
    /**
     * Gets the number of characters covered by this font. Zero indicates the font controls from
     * the [[startIndex]] to the end of the string.
     * The number of characters covered by this font. Zero indicates the font controls from the
     * StartIndex to the end of the string.
     */
    get length(): number;
    /**
     * Gets or sets the name of the font.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The name of the font.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    get name(): string;
    set name(a: string);
    /**
     * Gets the index of the first character covered by this font.
     * The index of the first character covered by this font.
     */
    get startIndex(): number;
    /**
     * Gets or sets the value indicating whether the font is struck out.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The value indicating whether the font is struck out.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the ExcelDefaultableBoolean enumeration.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    get strikeout(): boolean | null;
    set strikeout(a: boolean | null);
    /**
     * @hidden
     */
    get _strikeout$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _strikeout$i(a: Nullable$1<boolean>);
    /**
     * Gets or sets the value indicating whether the font is superscript or subscript.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The value indicating whether the font is superscript or subscript.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[FontSuperscriptSubscriptStyle]] enumeration.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    get superscriptSubscriptStyle(): FontSuperscriptSubscriptStyle;
    set superscriptSubscriptStyle(a: FontSuperscriptSubscriptStyle);
    /**
     * Gets or sets the underline style of the font.
     * <p class="body">
     * All characters in the selection range of this font will be affected by setting this property.
     * Getting this property will return a value which indicates the formatting of the first character
     * in this font's range.
     * </p>
     * <p class="note">
     * <b>Note:</b> default values cannot be used in [[FormattedString]] values applied to cells. If this font belongs to a FormattedString
     * which is the value of a cell, and a default value is assigned, it will be ignored.
     * </p>
     * The underline style of the font.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[FontUnderlineStyle]] enumeration.
     * @throws [[InvalidOperationException]] The formatted string or text associated with the font is not assigned to a cell, comment, or shape.
     * @throws [[InvalidOperationException]] The font's selection range is outside the valid character range of the associated formatted string or text.
     */
    get underlineStyle(): FontUnderlineStyle;
    set underlineStyle(a: FontUnderlineStyle);
    /**
     * @hidden
     */
    protected get__k(): boolean;
    /**
     * @hidden
     */
    get _k(): boolean;
    /**
     * @hidden
     */
    get _g(): IFormattedItem;
    /**
     * @hidden
     */
    abstract get _d(): FormattingRunBase;
    /**
     * @hidden
     */
    abstract get _workbook(): Workbook;
    /**
     * @hidden
     */
    abstract get _sheet(): Sheet;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
}
/**
 * @hidden
 */
export declare class FormattedStringValueReference extends Base implements IFormattedString {
    static $t: Type;
    private b;
    private a;
    private d;
    constructor(a: any, b: Workbook);
    setWorkbook(a: Workbook): void;
    toString(): string;
    get c(): StringElement;
    get e(): any;
}
/**
 * @hidden
 */
export interface IStringElementVisitor$2<TArg, TResult> {
    _visitFormattedStringElement$i(a: FormattedStringElement, b: TArg): TResult;
    _visitStringElement$i(a: StringElement, b: TArg): TResult;
}
/**
 * @hidden
 */
export declare let IStringElementVisitor$2_$type: Type;
/**
 * Controls the formatting of a range of characters in a [[formattedString]].
 * <p class="body">
 * The formatting of the string is controlled in a similar fashion as it would be in Microsoft Excel. In Excel, the user
 * must select a portion of the text and set the various formatting properties of that selected text.
 * </p>
 * <p class="body">
 * With the [[formattedString]], a portion of the string is "selected" by calling either
 * <see cref="Excel.FormattedString.GetFont(int)">GetFont(int)</see> or
 * <see cref="Excel.FormattedString.GetFont(int,int)">GetFont(int,int)</see>. Formatting properties
 * are then set on the returned FormattedStringFont and all characters in the font's selection range are given these
 * properties.
 * </p>
 * <p class="body">
 * Getting the formatting properties of a FormattedStringFont will return the formatting of the first character in font's
 * selection range. This is similar to Excel, which will update the formatting interface to reflect the formatting of the
 * first character in a selection range when a cell's text is selected.
 * </p>
 * @see@see@see */
export declare class FormattedStringFont extends FormattedFontBase {
    static $t: Type;
    constructor(a: FormattedString, b: number, c: number);
    /**
     * @hidden
     */
    protected get__k(): boolean;
    /**
     * @hidden
     */
    _h(a: Workbook): IWorkbookFontDefaultsResolver;
    /**
     * @hidden
     */
    _ac(a: Workbook, b: List$1<FormattingRunBase>, c: number, d: IWorkbookFontDefaultsResolver, e: FormattingRunBase): {
        p4: FormattingRunBase;
    };
    /**
     * @hidden
     */
    protected get__d(): FormattingRunBase;
    /**
     * @hidden
     */
    get _d(): FormattingRunBase;
    /**
     * @hidden
     */
    protected get__sheet(): Sheet;
    /**
     * @hidden
     */
    get _sheet(): Sheet;
    /**
     * @hidden
     */
    protected get__workbook(): Workbook;
    /**
     * @hidden
     */
    get _workbook(): Workbook;
    /**
     * @hidden
     */
    _z(): void;
    /**
     * @hidden
     */
    _aa(): void;
    /**
     * Gets the formatted string which is controlled by this font.
     * The formatted string which is controlled by this font.
     */
    get formattedString(): FormattedString;
}
/**
 * @hidden
 */
export declare class FormattedStringRun extends FormattingRunBase implements IComparable$1<FormattedStringRun> {
    static $t: Type;
    private _n;
    constructor(a: FormattedStringElement, b: number);
    equals(a: any): boolean;
    d(a: Workbook): IWorkbookFont;
    f(a: Workbook): WorkbookFontProxy;
    getHashCode(): number;
    protected get_h(): boolean;
    get h(): boolean;
    compareTo(a: FormattedStringRun): number;
    protected get_i(): number;
    protected set_i(a: number): void;
    get i(): number;
    set i(a: number);
}
/**
 * Represents text with multiple paragraphs and mixed formatting in a shape.
 * <p class="body">
 * The formatting of the string is controlled in a similar fashion as it would be in Microsoft Excel. In Excel, the user
 * must select a portion of the text and set the various formatting properties of that selected text.
 * </p>
 * <p class="body">
 * With the FormattedText, a portion of the text is "selected" by calling either [[getFont]]
 * or [[getFont]]. Formatting properties are then set on the returned
 * [[FormattedTextFont]] and all characters in the font's selection range are given these properties.
 * </p>
 * <p class="body">
 * Getting the formatting properties of a [[FormattedTextFont]] will return the formatting of the first
 * character in font's selection range.
 * </p>
 * @see [[WorksheetShapeWithText.text]]
 */
export declare class FormattedText extends Base implements IFormattedItem, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _u: string;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static readonly _a;
    private _t;
    private _h;
    private _f;
    private _n;
    private _k;
    constructor();
    constructor(unformattedString: string);
    constructor(..._rest: any[]);
    /**
     * Returns the string that represents the [[FormattedText]], which is the unformatted string.
     * @return The string that represents the FormattedText.
     */
    toString(): string;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    get owner(): any;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    getOwnerAt(startIndex: number): IFormattedRunOwner;
    /**
     * @hidden
     */
    onFormattingChanged(): void;
    /**
     * Creates a new [[FormattedText]] that is a copy of this one.
     * <p class="body">
     * This should be used if the same formatted text needs to be used in multiple shapes.
     * The FormattedText class can only exist as the [[WorksheetShapeWithText.text]]
     * of one shape at a time. If the FormattedText is already the text of a shape, and needs
     * to be set as the text of another shape, clone the FormattedText and set the returned
     * clone as text of the shape.
     * </p>
     * <p class="body">
     * The cloned FormattedText only takes its original configuration for this instance.
     * If this instance is cloned and than changed, the clone will not be changed as well; it will
     * remain as it was when it was cloned.
     * </p>
     * @return A new FormattedText that is a copy of this one.
     */
    clone(): FormattedText;
    /**
     * Gets the font which controls the formatting properties in the string from the specified start index to
     * the end of the string.
     * <p class="body">
     * If the start index is greater than or equal to the length of the unformatted string, no exception
     * will be thrown. It will be thrown later when one of the formatting properties of the returned
     * [[FormattedTextFont]] is set.
     * </p>
     * @param startIndex The index of the first character the returned font controls.
     * @throws [[ArgumentOutOfRangeException]] 'startIndex' is less than zero.
     * @return A FormattedTextFont instance which controls the formatting of the end portion of the string.
     */
    getFont(startIndex: number): FormattedTextFont;
    /**
     * Gets the font which controls the formatting properties in the string from the specified start index for
     * the specified number of characters.
     * <p class="body">
     * If the start index is greater than or equal to the length of the unformatted string, no exception
     * will be thrown. It will be thrown later when one of the formatting properties of the returned
     * [[FormattedTextFont]] is set.
     * </p>
     * @param startIndex The index of the first character the returned font controls.
     * @param length The number of characters after the start index controlled by the returned font.
     * @throws [[ArgumentOutOfRangeException]] 'startIndex' is less than zero.
     * @throws [[ArgumentOutOfRangeException]] 'length' is less than one. A zero length string cannot be controlled by a formatting font.
     * @return A FormattedTextFont instance which controls the formatting of a portion of the string.
     */
    getFont(startIndex: number, length: number): FormattedTextFont;
    /**
     * @hidden
     */
    _getFont(a: number): FormattedTextFont;
    /**
     * @hidden
     */
    _getFont1(a: number, b: number): FormattedTextFont;
    /**
     * Gets the collection of formatting runs representing contiguous blocks of similar formatting starting at the beginning of the string.
     */
    private _getFormattingRuns;
    getFormattingRuns(): IEnumerable$1<FormattedTextFont>;
    /**
     * @hidden
     */
    _w(): void;
    /**
     * @hidden
     */
    _onFormattingChanged(): void;
    /**
     * @hidden
     */
    _y(a: FormattedTextParagraph, b: number, c: number): void;
    /**
     * @hidden
     */
    _aa(a: Sheet): void;
    /**
     * @hidden
     */
    _ac(a: WorksheetShapeWithText): void;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _b;
    /**
     * Gets the paragraph at the specified zero-based index.
     * @param index The zero-based index of the paragraph to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or greater than or equal to the number of paragraphs in the collection.
     * @return The [[FormattedTextParagraph]] representing the paragraph at the specified index.
     */
    paragraphs(index: number): FormattedTextParagraph;
    /**
     * Gets the paragraphs in the formatted text.
     */
    paragraphs(): FormattedTextParagraphCollection;
    /**
     * @hidden
     */
    get _paragraphs$i(): FormattedTextParagraphCollection;
    /**
     * Gets or sets the vertical alignment of the formatted text in the owning shape.
     * @throws [[InvalidEnumArgumentException]] The specified value is not defined in the [[VerticalTextAlignment]] enumeration.
     */
    get verticalAlignment(): VerticalTextAlignment;
    set verticalAlignment(a: VerticalTextAlignment);
    /**
     * @hidden
     */
    private _ab;
    /**
     * @hidden
     */
    _s: Nullable$1<HorizontalTextAlignment>;
    /**
     * @hidden
     */
    get _owner(): IFormattedTextOwner;
    /**
     * @hidden
     */
    set _owner(a: IFormattedTextOwner);
    /**
     * @hidden
     */
    get _o(): CT_TextBodyPropertiesBase;
    /**
     * @hidden
     */
    set _o(a: CT_TextBodyPropertiesBase);
    /**
     * @hidden
     */
    get _sheet(): Sheet;
    /**
     * @hidden
     */
    get _workbook(): Workbook;
}
/**
 * Controls the formatting of a range of characters in .
 * <p class="body">
 * The formatting of the string is controlled in a similar fashion as it would be in Microsoft Excel. In Excel, the user
 * must select a portion of the text and set the various formatting properties of that selected text.
 * </p>
 * <p class="body">
 * With the , a portion of the string is "selected" by calling either
 *  or .
 * Formatting properties are then set on the returned FormattedTextFont and all characters in the font's
 * selection range are given these properties.
 * </p>
 * <p class="body">
 * Getting the formatting properties of a FormattedTextFont will return the formatting of the first character
 * in font's selection range.
 * </p>
 * @see@see@see */
export declare class FormattedTextFont extends FormattedFontBase {
    static $t: Type;
    constructor(a: FormattedText, b: number, c: number);
    /**
     * @hidden
     */
    _ac(a: Workbook, b: List$1<FormattingRunBase>, c: number, d: IWorkbookFontDefaultsResolver, e: FormattingRunBase): {
        p4: FormattingRunBase;
    };
    /**
     * @hidden
     */
    protected get__d(): FormattingRunBase;
    /**
     * @hidden
     */
    get _d(): FormattingRunBase;
    /**
     * @hidden
     */
    protected get__sheet(): Sheet;
    /**
     * @hidden
     */
    get _sheet(): Sheet;
    /**
     * @hidden
     */
    protected get__workbook(): Workbook;
    /**
     * @hidden
     */
    get _workbook(): Workbook;
    /**
     * Gets the  which is controlled by this font.
     * The FormattedText which is controlled by this font.
     */
    get formattedText(): FormattedText;
}
/**
 * Represents a paragraph in .
 * @see */
export declare class FormattedTextParagraph extends Base implements IFormattedRunOwner, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _l;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static readonly _o;
    /**
     * @hidden
     */
    private static readonly _a;
    private _f;
    private readonly _r;
    private _j;
    private _c;
    private _p;
    private _t;
    constructor(a: FormattedText, b: number, c: string, d: string);
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    addRun(run: FormattingRunBase): void;
    /**
     * @hidden
     */
    createRun(absoluteStartIndex: number): FormattingRunBase;
    /**
     * @hidden
     */
    getFormattingRuns(workbook: Workbook): List$1<FormattingRunBase>;
    /**
     * @hidden
     */
    insertRun(runIndex: number, run: FormattingRunBase): void;
    /**
     * @hidden
     */
    _u(a: FormattedTextRun): void;
    /**
     * @hidden
     */
    _e(a: FormattedText): FormattedTextParagraph;
    /**
     * @hidden
     */
    _getFormattingRuns(a: Workbook): List$1<FormattingRunBase>;
    /**
     * @hidden
     */
    _v(a: number, b: FormattedTextRun): void;
    /**
     * @hidden
     */
    _w(a: FormattedText): void;
    /**
     * @hidden
     */
    _x(): void;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _ab;
    /**
     * Gets or sets the alignment of the paragraph.
     */
    get alignment(): HorizontalTextAlignment;
    set alignment(a: HorizontalTextAlignment);
    /**
     * @hidden
     */
    private _z;
    /**
     * Gets the owning  to which the paragraph belongs or null if the
     * paragraph has been removed from its owning formatted text.
     */
    get formattedText(): FormattedText;
    /**
     * Gets the zero-based index of the paragraph's first character in the overall formatted text.
     */
    get startIndex(): number;
    set startIndex(a: number);
    /**
     * Gets or sets the raw string of the paragraph.
     * <p class="body">
     * If the new unformatted string assigned is shorter than the previous unformatted string, all formatting
     * outside the range of the new value will be lost.
     * </p>
     * The unformatted string.
     * @throws [[ArgumentNullException]] The value assigned is a null string.
     */
    get unformattedString(): string;
    set unformattedString(a: string);
    /**
     * @hidden
     */
    private _aa;
    /**
     * @hidden
     */
    get _s(): string;
    /**
     * @hidden
     */
    get _n(): number;
    /**
     * @hidden
     */
    _m(a: Nullable$1<boolean>): number;
    /**
     * @hidden
     */
    get _sheet(): Sheet;
    /**
     * @hidden
     */
    get _workbook(): Workbook;
}
/**
 * @hidden
 */
export declare class FormattedTextParagraphCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: FormattedTextParagraphCollection, c: FormattedTextParagraph, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: FormattedTextParagraphCollection;
    readonly a: FormattedTextParagraph;
    readonly c: number;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of [[FormattedTextParagraph]] instances in .
 * @see [[FormattedText.paragraphs]]
 */
export declare class FormattedTextParagraphCollection extends Base implements ICollection$1<FormattedTextParagraph> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _i;
    /**
     * @hidden
     */
    private static readonly _l;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    _d: FormattedText;
    private _h;
    static staticInit(): void;
    constructor(a: FormattedText);
    /**
     * @hidden
     */
    add(paragraph: FormattedTextParagraph): void;
    /**
     * Adds a paragraph with the specified text and returns the [[FormattedTextParagraph]]
     * representing the new paragraph.
     * @param paragraphText The text in the paragraph.
     * @return The FormattedTextParagraph representing the new paragraph.
     */
    add(paragraphText: string): FormattedTextParagraph;
    /**
     * @hidden
     */
    _add$e(a: FormattedTextParagraph): void;
    /**
     * @hidden
     */
    copyTo(array: FormattedTextParagraph[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    _add1(a: string): FormattedTextParagraph;
    /**
     * Removes all paragraphs from the formatted text.
     */
    clear(): void;
    /**
     * Determines whether the specified paragraph exists in the collection.
     * @param paragraph The paragraph to find in the collection.
     * @return True if the paragraph exists in the collection; False otherwise.
     */
    contains(paragraph: FormattedTextParagraph): boolean;
    [Symbol.iterator](): EnumeratorWrapper<FormattedTextParagraph>;
    /**
     * Gets the enumerator to iterate over all paragraphs.
     */
    getEnumerator(): IEnumerator$1<FormattedTextParagraph>;
    /**
     * Gets the zero-based index of the specified paragraph in the collection.
     * @param paragraph The paragraph to find in the collection.
     * @return The zero-based index of the paragraph in the collection or -1 if the paragraph doesn't exist in the collection.
     */
    indexOf(paragraph: FormattedTextParagraph): number;
    /**
     * Inserts a paragraph with the specified text and returns the [[FormattedTextParagraph]]
     * representing the new paragraph.
     * @param index The zero-based index in the collection where the paragraph should be inserted.
     * @param paragraphText The text in the paragraph.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or greater than the number of paragraphs in the collection.
     * @return The FormattedTextParagraph representing the new paragraph.
     */
    insert(index: number, paragraphText: string): FormattedTextParagraph;
    /**
     * Removes the specified paragraph from the collection.
     * @param paragraph The paragraph to remove from the collection.
     * @return True if the paragraph was in the collection and was removed; False otherwise.
     */
    remove(paragraph: FormattedTextParagraph): boolean;
    /**
     * Removes the paragraph at the specified zero-based index in the collection.
     * @param index The zero-based index of the paragraph to remove.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or greater than or equal to the number of paragraphs in the collection.
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _n(a: FormattedTextParagraphCollection): void;
    /**
     * @hidden
     */
    _o(a: number, b: FormattedTextParagraph, c: string): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _m;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _s;
    /**
     * Gets the number of paragraphs in the collection.
     */
    get count(): number;
    /**
     * Gets the paragraph at the specified zero-based index.
     * @param index The zero-based index of the paragraph to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or greater than or equal to the number of paragraphs in the collection.
     * @return The [[FormattedTextParagraph]] representing the paragraph at the specified index.
     */
    item(a: number): FormattedTextParagraph;
}
/**
 * @hidden
 */
export declare class FormattedTextRun extends FormattingRunBase {
    static $t: Type;
    private q;
    private n;
    constructor(a: FormattedTextParagraph, b: number);
    d(a: Workbook): IWorkbookFont;
    f(a: Workbook): WorkbookFontProxy;
    protected get_h(): boolean;
    get h(): boolean;
    m(a: FormattingRunBase, b: Workbook): void;
    protected get_i(): number;
    protected set_i(a: number): void;
    get i(): number;
    set i(a: number);
    get p(): FormattedTextParagraph;
    get o(): IShallowCloneable;
    set o(a: IShallowCloneable);
}
/**
 * @hidden
 */
export interface IRegionBlockingValue {
    removeFromRegion(): void;
    throwBlockingException(): void;
    throwExceptionWhenMergedCellsInRegion(): void;
    throwExceptionWhenTableInRegion(): void;
    readonly blockedRegion: WorksheetRegion;
}
/**
 * @hidden
 */
export declare let IRegionBlockingValue_$type: Type;
/**
 * @hidden
 */
export declare class ArrayFormula_FormulaChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: ArrayFormula, c: WorksheetRegion);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: ArrayFormula;
    readonly b: Worksheet;
    readonly d: WorksheetRegionAddress;
    c(): WorksheetRegion;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Represents an array formula for a group of cells.
 * <p class="body">
 * Array formulas are similar to regular formula in that they have the same grammar. However, array formulas must be set
 * on a single region of cells only. When the array formula is applied to a region of cells, each cell's
 * <see cref="WorksheetCell.Formula">Formula</see> property will be the array formula. The
 * <see cref="WorksheetCell.Formula">Value</see> of each cell cannot be changed unless [[clearCellRange]] is
 * called on the array formula or another value is applied to a region of cells which completely contains the array
 * formula's region.
 * </p>
 * <p class="body">
 * Because the array formula stores the region of the cells to which it is applied in the [[cellRange]] property,
 * the array formula can only be applied to one region of cells.
 * </p>
 * <p class="body">
 * Array formulas are created through Microsoft Excel by selecting a region of cells, entering a formula for
 * that range, and pressing Ctrl+Shift+Enter. This causes the formula of each cell in the region to appear as follows:
 * {=Formula}.
 * </p>
 * <p class="body">
 * See the Microsoft Excel documentation for more information on array formulas.
 * </p>
 */
export declare class ArrayFormula extends Formula implements IRegionBlockingValue {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _cw;
    /**
     * @hidden
     */
    private static readonly _cx;
    /**
     * @hidden
     */
    private static readonly _cy;
    /**
     * @hidden
     */
    private static readonly _cc;
    private _ck;
    constructor(a: number, b: number);
    constructor(a: number, b: ArrayFormula);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _bp(a: WorksheetRow, b: number, c?: ApplyFormulaFlags): void;
    /**
     * @hidden
     */
    _bm(a: WorksheetRegion[], b: WorksheetRow, c: number, d?: ApplyFormulaFlags): void;
    /**
     * @hidden
     */
    _br(a: WorksheetRow, b: number, c: WorksheetCellBlock): void;
    /**
     * @hidden
     */
    _g(): Formula;
    /**
     * @hidden
     */
    protected get__z(): WorkbookFormat;
    /**
     * @hidden
     */
    protected set__z(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    protected get__ap(): boolean;
    /**
     * @hidden
     */
    protected get__bb(): number;
    /**
     * @hidden
     */
    get _bb(): number;
    /**
     * @hidden
     */
    protected get__ab(): WorksheetRow;
    /**
     * @hidden
     */
    get _ab(): WorksheetRow;
    /**
     * @hidden
     */
    protected get__aa(): WorksheetCellAddress;
    /**
     * @hidden
     */
    get _aa(): WorksheetCellAddress;
    /**
     * @hidden
     */
    _b7(): void;
    /**
     * @hidden
     */
    protected get__t(): Sheet;
    /**
     * @hidden
     */
    get _t(): Sheet;
    /**
     * @hidden
     */
    removeFromRegion(): void;
    /**
     * @hidden
     */
    throwBlockingException(): void;
    /**
     * @hidden
     */
    throwExceptionWhenMergedCellsInRegion(): void;
    /**
     * @hidden
     */
    throwExceptionWhenTableInRegion(): void;
    /**
     * @hidden
     */
    get blockedRegion(): WorksheetRegion;
    /**
     * Removes this array formula as the formula for the cells to which it was applied.
     * <p class="body">
     * After this method returns, the [[cellRange]] will be null.
     * </p>
     */
    clearCellRange(): void;
    /**
     * @hidden
     */
    static _ci(a: string, b: Workbook): ArrayFormula;
    /**
     * Parses the specified formula value and returns the array formula which was created from it.
     * @param value The string which defines the array formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the array formula.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return An [[ArrayFormula]] instance which represents the array formula value specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode): ArrayFormula;
    /**
     * Parses the specified formula value and returns the array formula which was created from it.
     * @param value The string which defines the array formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the array formula.
     * @param fileFormat The file format to use when parsing the array formula. This will be used to determine certain limits which are format dependant.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[InvalidEnumArgumentException]] 'fileFormat' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return An [[ArrayFormula]] instance which represents the array formula value specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode, fileFormat: WorkbookFormat): ArrayFormula;
    /**
     * Parses the specified formula value and returns the array formula which was created from it.
     * @param value The string which defines the array formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the array formula.
     * @param fileFormat The file format to use when parsing the array formula. This will be used to determine certain limits which are format dependant.
     * @param culture The culture used to parse the formula.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[InvalidEnumArgumentException]] 'fileFormat' is not defined in the [[WorkbookFormat]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return An [[ArrayFormula]] instance which represents the array formula value specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode, fileFormat: WorkbookFormat, culture: string | CultureInfo): ArrayFormula;
    /**
     * Parses the specified formula value and returns the array formula which was created from it.
     * @param value The string which defines the array formula to parse.
     * @param cellReferenceMode The mode used to interpret cell references in the array formula.
     * @param culture The culture used to parse the formula.
     * @throws [[ArgumentNullException]] 'value' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[FormulaParseException]] 'value' is not a valid formula.
     * @return An [[ArrayFormula]] instance which represents the array formula value specified.
     */
    static parse(value: string, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): ArrayFormula;
    /**
     * @hidden
     */
    static _parse7(a: string, b: CellReferenceMode): ArrayFormula;
    /**
     * @hidden
     */
    static _parse10(a: string, b: CellReferenceMode, c: CultureInfo): ArrayFormula;
    /**
     * @hidden
     */
    static _parse8(a: string, b: CellReferenceMode, c: WorkbookFormat): ArrayFormula;
    /**
     * @hidden
     */
    static _parse9(a: string, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo): ArrayFormula;
    /**
     * @hidden
     */
    static _cn(a: string, b: CellReferenceMode, c: ArrayFormula): {
        ret: boolean;
        p2: ArrayFormula;
    };
    /**
     * @hidden
     */
    static _cu(a: string, b: CellReferenceMode, c: CultureInfo, d: ArrayFormula): {
        ret: boolean;
        p3: ArrayFormula;
    };
    /**
     * @hidden
     */
    static _co(a: string, b: CellReferenceMode, c: ArrayFormula, d: FormulaParseException): {
        ret: boolean;
        p2: ArrayFormula;
        p3: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _cv(a: string, b: CellReferenceMode, c: CultureInfo, d: ArrayFormula, e: FormulaParseException): {
        ret: boolean;
        p3: ArrayFormula;
        p4: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _cp(a: string, b: CellReferenceMode, c: WorkbookFormat, d: ArrayFormula): {
        ret: boolean;
        p3: ArrayFormula;
    };
    /**
     * @hidden
     */
    static _cr(a: string, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo, e: ArrayFormula): {
        ret: boolean;
        p4: ArrayFormula;
    };
    /**
     * @hidden
     */
    static _cq(a: string, b: CellReferenceMode, c: WorkbookFormat, d: ArrayFormula, e: FormulaParseException): {
        ret: boolean;
        p3: ArrayFormula;
        p4: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _cs(a: string, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo, e: ArrayFormula, f: FormulaParseException): {
        ret: boolean;
        p4: ArrayFormula;
        p5: FormulaParseException;
    };
    /**
     * @hidden
     */
    static _ct(a: string, b: CellReferenceMode, c: WorkbookFormat, d: CultureInfo, e: ArrayFormula, f: FormulaParseException, g: List$1<WorkbookReferenceBase>): {
        ret: boolean;
        p4: ArrayFormula;
        p5: FormulaParseException;
    };
    /**
     * @hidden
     */
    _c1(a: CellShiftOperation, b: ICellShiftOperationOverride, c: ShiftingArrayFormulaInfo): void;
    /**
     * @hidden
     */
    _cm(a: CellShiftOperation, b: Nullable$1<WorksheetRegionAddress>, c: ShiftingArrayFormulaInfo): {
        ret: boolean;
        p2: ShiftingArrayFormulaInfo;
    };
    /**
     * @hidden
     */
    private _cz;
    /**
     * @hidden
     */
    private static _cj;
    /**
     * @hidden
     */
    private static _cd;
    /**
     * @hidden
     */
    private static _c2;
    /**
     * @hidden
     */
    private static _c3;
    /**
     * Gets the cells to which the array formula is applied.
     * <p class="body">
     * If this is null, the formula has not yet been applied.
     * </p>
     * The cells to which the array formula is applied.
     */
    get cellRange(): WorksheetRegion;
}
/**
 * @hidden
 */
export declare class ShiftingArrayFormulaInfo extends Base {
    static $t: Type;
    private readonly b;
    private readonly a;
    constructor(a: ArrayFormula);
    c(a: CellShiftOperation, b: ArrayFormula): void;
}
/**
 * @hidden
 */
export declare abstract class FormulaTokenVisitor extends Base {
    static $t: Type;
    private a;
    private c;
    constructor();
    e(a: FormulaToken): void;
    g(): void;
    protected f(): void;
    h(): void;
    i(a: Area3DNToken): void;
    j(a: Area3DToken): void;
    k(a: AreaErr3DToken): void;
    l(a: AreaErrToken): void;
    m(a: AreaNToken): void;
    n(a: AreaToken): void;
    o(a: ArrayToken): void;
    p(a: AttrChooseToken): void;
    q(a: AttrIfToken): void;
    r(a: AttrSkipToken): void;
    s(a: AttrSpaceToken): void;
    t(a: AttrSumToken): void;
    u(a: AttrVolatileToken): void;
    v(a: BinaryOperatorToken): void;
    w(a: BoolToken): void;
    x(a: CellReferenceToken): void;
    y(a: ErrToken): void;
    z(a: ExpToken): void;
    aa(a: FunctionOperator): void;
    ab(a: IFunctionToken): void;
    ac(a: FunctionVOperator): void;
    ad(a: IntToken): void;
    ae(a: MemAreaOperator): void;
    af(a: MemErrOperator): void;
    ag(a: MemFuncOperator): void;
    ah(a: MemNoMemOperator): void;
    ai(a: MissArgToken): void;
    aj(a: NameToken): void;
    ak(a: NameXToken): void;
    al(a: NumberToken): void;
    am(a: OperandToken): void;
    an(a: ParenToken): void;
    aq(a: ReferenceToken): void;
    ao(a: Ref3DNToken): void;
    ap(a: Ref3DToken): void;
    ar(a: RefErr3dToken): void;
    as(a: RefErrToken): void;
    at(a: RefNToken): void;
    au(a: RefToken): void;
    av(a: StrToken): void;
    aw(a: StructuredTableReference): void;
    ax(a: TblToken): void;
    ay(a: UnaryOperatorToken): void;
    get b(): FormulaContext;
    set b(a: FormulaContext);
    protected get d(): number;
    protected set d(a: number);
}
/**
 * @hidden
 */
export declare class Formula_CanShiftSafelyChecker extends FormulaTokenVisitor {
    static $t: Type;
    private static az;
    private a1;
    private a3;
    constructor();
    g(): void;
    n(a: AreaToken): void;
    au(a: RefToken): void;
    static a2(a: FormulaContext, b: Point): boolean;
    private static a0;
}
/**
 * @hidden
 */
export declare abstract class FormulaTokenVisitor$1<TResult> extends Base {
    static $t: Type;
    protected $tResult: Type;
    private b;
    protected az: number;
    private av;
    constructor($tResult: Type);
    d(a: FormulaToken): TResult;
    protected a0(): void;
    a1(): void;
    ax(): boolean;
    protected ay(a: Nullable$1<number>): {
        ret: boolean;
        p0: Nullable$1<number>;
    };
    e(a: Area3DNToken): TResult;
    f(a: Area3DToken): TResult;
    g(a: AreaErr3DToken): TResult;
    h(a: AreaErrToken): TResult;
    i(a: AreaNToken): TResult;
    j(a: AreaToken): TResult;
    k(a: ArrayToken): TResult;
    l(a: AttrChooseToken): TResult;
    m(a: AttrIfToken): TResult;
    n(a: AttrSkipToken): TResult;
    o(a: AttrSpaceToken): TResult;
    p(a: AttrSumToken): TResult;
    q(a: AttrVolatileToken): TResult;
    r(a: BinaryOperatorToken): TResult;
    s(a: BoolToken): TResult;
    t(a: CellReferenceToken): TResult;
    u(a: ErrToken): TResult;
    v(a: ExpToken): TResult;
    w(a: FunctionOperator): TResult;
    x(a: IFunctionToken): TResult;
    y(a: FunctionVOperator): TResult;
    z(a: IntToken): TResult;
    aa(a: MemAreaOperator): TResult;
    ab(a: MemErrOperator): TResult;
    ac(a: MemFuncOperator): TResult;
    ad(a: MemNoMemOperator): TResult;
    ae(a: MissArgToken): TResult;
    af(a: NameToken): TResult;
    ag(a: NameXToken): TResult;
    ah(a: NumberToken): TResult;
    ai(a: OperandToken): TResult;
    aj(a: ParenToken): TResult;
    am(a: ReferenceToken): TResult;
    ak(a: Ref3DNToken): TResult;
    al(a: Ref3DToken): TResult;
    an(a: RefErr3dToken): TResult;
    ao(a: RefErrToken): TResult;
    ap(a: RefNToken): TResult;
    aq(a: RefToken): TResult;
    ar(a: StrToken): TResult;
    as(a: StructuredTableReference): TResult;
    at(a: TblToken): TResult;
    au(a: UnaryOperatorToken): TResult;
    get c(): FormulaContext;
    set c(a: FormulaContext);
    protected get aw(): boolean;
    protected get_a(): FormulaToken[];
    protected get a(): FormulaToken[];
}
/**
 * @hidden
 */
export declare abstract class FormulaTokenModifierVisitor extends FormulaTokenVisitor$1<boolean> {
    static $t: Type;
    private a2;
    private a4;
    private readonly a7;
    private readonly a6;
    constructor();
    a1(): void;
    protected ay(a: Nullable$1<number>): {
        ret: boolean;
        p0: Nullable$1<number>;
    };
    protected get a3(): FormulaToken;
    protected set a3(a: FormulaToken);
    get a5(): boolean;
}
/**
 * @hidden
 */
export declare class Formula_ConnectReferencesVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a8;
    private ba;
    constructor();
    a1(): void;
    f(a: Area3DToken): boolean;
    j(a: AreaToken): boolean;
    t(a: CellReferenceToken): boolean;
    af(a: NameToken): boolean;
    ag(a: NameXToken): boolean;
    al(a: Ref3DToken): boolean;
    aq(a: RefToken): boolean;
    as(a: StructuredTableReference): boolean;
    static bb(a: FormulaContext, b: NameToken): boolean;
    static bc(a: FormulaContext, b: NameXToken): boolean;
    static a9(a: FormulaContext, b: boolean): Formula_ConnectReferencesVisitor;
    bd(a: CellReferenceToken): boolean;
}
/**
 * @hidden
 */
export declare class Formula_ConvertTableReferencesToRangesVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a8;
    private ba;
    constructor();
    a1(): void;
    af(a: NameToken): boolean;
    as(a: StructuredTableReference): boolean;
    static a9(a: FormulaContext, b: WorksheetTable): Formula_ConvertTableReferencesToRangesVisitor;
}
/**
 * @hidden
 */
export declare class Formula_AllReferencedRegionsChecker extends FormulaTokenVisitor {
    static $t: Type;
    private static a0;
    private a3;
    private a2;
    constructor();
    g(): void;
    x(a: CellReferenceToken): void;
    static az(a: FormulaContext, b: Worksheet): WorksheetRegionAddress[];
    private static a1;
}
/**
 * @hidden
 */
export declare class Formula_FixPasteReferencesVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a9;
    private bc;
    private bf;
    private bb;
    private be;
    private readonly bd;
    private a8;
    private bg;
    constructor();
    a1(): void;
    f(a: Area3DToken): boolean;
    t(a: CellReferenceToken): boolean;
    af(a: NameToken): boolean;
    ag(a: NameXToken): boolean;
    al(a: Ref3DToken): boolean;
    as(a: StructuredTableReference): boolean;
    static ba(a: Worksheet, b: WorkbookReferenceBase, c: FormulaContext, d: Nullable$1<boolean>, e: (arg1: string) => string, f: (arg1: NamedReferenceBase, arg2: (arg1: Formula) => void) => NamedReferenceBase): Formula_FixPasteReferencesVisitor;
    private bh;
}
/**
 * @hidden
 */
export declare class Formula_IsReferencingAnythingInRegionChecker extends FormulaTokenVisitor {
    static $t: Type;
    private static az;
    private a3;
    private a2;
    private a1;
    constructor();
    g(): void;
    x(a: CellReferenceToken): void;
    static a4(a: FormulaContext, b: Worksheet, c: WorksheetRegionAddress): boolean;
    private static a0;
}
/**
 * @hidden
 */
export declare class Formula_OffsetReferencesVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a8;
    private ba;
    constructor();
    a1(): void;
    j(a: AreaToken): boolean;
    v(a: ExpToken): boolean;
    aa(a: MemAreaOperator): boolean;
    aq(a: RefToken): boolean;
    at(a: TblToken): boolean;
    static a9(a: FormulaContext, b: Point): Formula_OffsetReferencesVisitor;
}
/**
 * @hidden
 */
export declare class Formula_CellsShiftedVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a9;
    private a8;
    private bb;
    constructor();
    a1(): void;
    j(a: AreaToken): boolean;
    aq(a: RefToken): boolean;
    private bc;
    private bd;
    private be;
    static ba(a: FormulaContext, b: CellShiftOperation, c: ReferenceShiftType): Formula_CellsShiftedVisitor;
}
/**
 * @hidden
 */
export declare class Formula_CurrentFormatChangedVisitor extends FormulaTokenVisitor {
    static $t: Type;
    private static az;
    private a2;
    private a1;
    constructor();
    g(): void;
    n(a: AreaToken): void;
    at(a: RefNToken): void;
    static a0(a: FormulaContext, b: WorkbookFormat, c: WorkbookFormat): Formula_CurrentFormatChangedVisitor;
}
/**
 * @hidden
 */
export declare class Formula_NamedReferenceRemovedVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a9;
    private a8;
    private bb;
    constructor();
    a1(): void;
    af(a: NameToken): boolean;
    as(a: StructuredTableReference): boolean;
    static ba(a: FormulaContext, b: NamedReferenceBase): Formula_NamedReferenceRemovedVisitor;
    private bc;
}
/**
 * @hidden
 */
export declare class Formula_TableResizingVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a8;
    private bd;
    private bb;
    private ba;
    constructor();
    a1(): void;
    protected ay(a: Nullable$1<number>): {
        ret: boolean;
        p0: Nullable$1<number>;
    };
    af(a: NameToken): boolean;
    as(a: StructuredTableReference): boolean;
    static a9(a: FormulaContext, b: WorksheetTable, c: List$1<WorksheetTableColumn>): Formula_TableResizingVisitor;
    get bc(): boolean;
}
/**
 * @hidden
 */
export declare class Formula_WorksheetMovedVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a8;
    private bb;
    private ba;
    constructor();
    a1(): void;
    t(a: CellReferenceToken): boolean;
    static a9(a: FormulaContext, b: Worksheet, c: number): Formula_WorksheetMovedVisitor;
}
/**
 * @hidden
 */
export declare class Formula_WorksheetRemovedVisitor extends FormulaTokenModifierVisitor {
    static $t: Type;
    private static a8;
    private bb;
    private ba;
    constructor();
    a1(): void;
    af(a: NameToken): boolean;
    t(a: CellReferenceToken): boolean;
    static a9(a: FormulaContext, b: Worksheet, c: number): Formula_WorksheetRemovedVisitor;
}
/**
 * @hidden
 */
export declare class Formula_VerifyFormatLimitsVisitor extends FormulaTokenVisitor {
    static $t: Type;
    private static a0;
    private az;
    private a2;
    constructor();
    g(): void;
    n(a: AreaToken): void;
    au(a: RefToken): void;
    static a1(a: FormulaContext, b: FormatLimitErrors, c: WorkbookFormat): Formula_VerifyFormatLimitsVisitor;
}
/**
 * @hidden
 */
export declare abstract class FormulaToken extends Base {
    static $t: Type;
    static readonly a: FormulaToken[];
    private g;
    constructor(a: TokenClass);
    toString(): string;
    abstract m(a: FormulaTokenVisitor): void;
    abstract d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    abstract e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    abstract l(a: FormulaContext, b: GetFormulaStringInfo): string;
    abstract get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    get h(): TokenClass;
    set h(a: TokenClass);
    static c(a: IBiffRecordStream, b: number): FormulaToken;
    static b(a: IBiffRecordStream, b: number, c: number[], d: number): {
        ret: FormulaToken;
        p2?: number[];
        p3?: number;
    };
    static i(a: number): TokenClass;
}
/**
 * @hidden
 */
export declare class SharedTokenConverter extends FormulaTokenVisitor$1<FormulaToken> {
    static $t: Type;
    private static a2;
    private a4;
    constructor();
    d(a: FormulaToken): FormulaToken;
    e(a: Area3DNToken): FormulaToken;
    f(a: Area3DToken): FormulaToken;
    i(a: AreaNToken): FormulaToken;
    j(a: AreaToken): FormulaToken;
    ak(a: Ref3DNToken): FormulaToken;
    al(a: Ref3DToken): FormulaToken;
    ap(a: RefNToken): FormulaToken;
    aq(a: RefToken): FormulaToken;
    static a3(a: FormulaContext, b: boolean): SharedTokenConverter;
}
/**
 * The exception thrown when a formula parse error occurs.
 */
export declare class FormulaParseException extends BaseError {
    static $t: Type;
    private _c;
    private _e;
    private _g;
    constructor();
    constructor(message: string);
    constructor(message: string, innerException: BaseError);
    constructor(charIndexOfError: number, formulaValue: string, message: string, portionWithError: string);
    constructor(..._rest: any[]);
    /**
     * Gets the character index in the [[formulaValue]] at which the parse error occurred.
     * The character index in the FormulaValue at which the parse error occurred.
     */
    get charIndexOfError(): number;
    /**
     * Gets the formula string which had the error being parsed.
     * The formula string which had the error being parsed.
     */
    get formulaValue(): string;
    /**
     * Gets the error message and the portion of the formula with the error.
     */
    protected get_message(): string;
    /**
     * Gets the portion of the formula which contains the error.
     */
    get portionWithError(): string;
}
/**
 * @hidden
 */
export declare class NamedReferenceFormula extends SingleTargetFormula {
    static $t: Type;
    constructor(a: number, b: number, c: FormulaType);
    constructor(a: number, b: NamedReferenceFormula);
    constructor(a: number, b: SingleTargetFormula);
    constructor(a: number, ..._rest: any[]);
    _g(): Formula;
    _b7(): void;
}
/**
 * @hidden
 */
export declare class To3DTokenConverter extends FormulaTokenVisitor$1<FormulaToken> {
    static $t: Type;
    private static a3;
    private a2;
    constructor();
    d(a: FormulaToken): FormulaToken;
    i(a: AreaNToken): FormulaToken;
    j(a: AreaToken): FormulaToken;
    ap(a: RefNToken): FormulaToken;
    aq(a: RefToken): FormulaToken;
    static a4(a: FormulaContext): To3DTokenConverter;
}
/**
 * @hidden
 */
export declare class SingleTargetFormula_SimpleBitArray extends Base {
    static $t: Type;
    private d;
    private a;
    constructor(a: number, b: boolean);
    h(a: boolean): void;
    get f(): number;
    set f(a: number);
    item(a: number, b?: boolean): boolean;
    b(a: number): boolean;
    g(a: number, b: boolean): void;
    private static e;
    i(a: number): void;
}
/**
 * @hidden
 */
export declare class SingleTargetFormula_DynamicReferenceCollection extends Base implements IExcelCalcReferenceCollection {
    static $t: Type;
    private readonly _a;
    constructor(a: SingleTargetFormula);
    private _getEnumeratorObject;
    getEnumeratorObject(): IEnumerator;
    equals(a: any): boolean;
    getHashCode(): number;
}
/**
 * @hidden
 */
export declare class SingleTargetFormula_StaticReferenceCollection extends Base implements IExcelCalcReferenceCollection {
    static $t: Type;
    private readonly _a;
    constructor(a: SingleTargetFormula);
    private _getEnumeratorObject;
    getEnumeratorObject(): IEnumerator;
    equals(a: any): boolean;
    getHashCode(): number;
}
/**
 * @hidden
 */
export declare class SingleTargetFormula_StaticReferenceFinder extends FormulaTokenVisitor {
    static $t: Type;
    private static a2;
    private a1;
    private a0;
    private readonly a5;
    private az;
    private readonly a4;
    constructor();
    g(): void;
    protected f(): void;
    p(a: AttrChooseToken): void;
    q(a: AttrIfToken): void;
    r(a: AttrSkipToken): void;
    v(a: BinaryOperatorToken): void;
    aa(a: FunctionOperator): void;
    ab(a: IFunctionToken): void;
    ac(a: FunctionVOperator): void;
    aj(a: NameToken): void;
    am(a: OperandToken): void;
    ay(a: UnaryOperatorToken): void;
    private a6;
    static a3(a: FormulaContext, b: SingleTargetFormula): SingleTargetFormula_StaticReferenceFinder;
    private a7;
    private a8;
}
/**
 * Abstract base class for classes which control pane settings.
 * @see [[FrozenPaneSettings]]
 * @see [[UnfrozenPaneSettings]]
 */
export declare abstract class PaneSettingsBase extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    private static readonly _m;
    /**
     * @hidden
     */
    private static readonly _p;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static readonly _a;
    private _d;
    private _k;
    private _n;
    constructor(a: DisplayOptions);
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    abstract _g(): PaneSettingsBase;
    /**
     * @hidden
     */
    _s(a: PaneSettingsBase): void;
    /**
     * Resets the pane settings to their defaults.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    reset(): void;
    /**
     * Resets the pane settings to their defaults.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    resetCore(): void;
    /**
     * Gets or sets the first visible column in the right pane(s) of the worksheet.
     * <p class="body">
     * This affects the scroll position for the right pane(s) of the worksheet and
     * is only used if the worksheet is split vertically.
     * </p>
     * The zero-based index of the first visible column in the right pane(s).
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid column range (0 to one less than [[Workbook.maxExcelColumnCount]] or
     * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
     * [[Workbook.currentFormat]]).
     */
    get firstColumnInRightPane(): number;
    set firstColumnInRightPane(a: number);
    /**
     * Gets or sets the first visible row in the bottom pane(s) of the worksheet.
     * <p class="body">
     * This affects the scroll position for the bottom pane(s) of the worksheet and
     * is only used if the worksheet is split horizontally.
     * </p>
     * The zero-based index of the first visible row in the bottom pane(s).
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid row range (0 to one less than [[Workbook.maxExcelRowCount]] or
     * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
     * [[Workbook.currentFormat]]).
     */
    get firstRowInBottomPane(): number;
    set firstRowInBottomPane(a: number);
    /**
     * @hidden
     */
    abstract get _h(): boolean;
    /**
     * @hidden
     */
    abstract get _i(): boolean;
    /**
     * @hidden
     */
    get _e(): DisplayOptions;
    /**
     * @hidden
     */
    _f(): PaneSettingsBase;
    /**
     * @hidden
     */
    _j(): boolean;
    /**
     * @hidden
     */
    _v(a: PaneSettingsBase): void;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
}
/**
 * Class which controls the way frozen panes are arranged and used for a worksheet.
 * <p class="note">
 * <B>Note:</B> Frozen and unfrozen panes cannot be used simultaneously, so depending whether the panes are
 * frozen or unfrozen, these settings may not be used or saved.
 * </p>
 * @see [[DisplayOptions.panesAreFrozen]]
 * @see [[UnfrozenPaneSettings]]
 */
export declare class FrozenPaneSettings extends PaneSettingsBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _w;
    private _aa;
    private _ad;
    constructor(a: DisplayOptions);
    /**
     * @hidden
     */
    _g(): PaneSettingsBase;
    /**
     * @hidden
     */
    protected get__h(): boolean;
    /**
     * @hidden
     */
    get _h(): boolean;
    /**
     * @hidden
     */
    protected get__i(): boolean;
    /**
     * @hidden
     */
    get _i(): boolean;
    /**
     * @hidden
     */
    _s(a: PaneSettingsBase): void;
    /**
     * Resets the frozen pane settings to their defaults.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    resetCore(): void;
    /**
     * Gets or sets the number of columns frozen at the left of the worksheet.
     * <p class="body">
     * The frozen columns will always remain in view, regardless of the horizontal scroll position of
     * the worksheet.
     * </p>
     * <p class="note">
     * <B>Note:</B> If the number of frozen columns specified is more than the amount of visible columns
     * in the worksheet, the worksheet may not scroll correctly.
     * </p>
     * The number of columns frozen at the left of the worksheet.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is not a valid column count (0 to [[Workbook.maxExcelColumnCount]] or
     * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
     * [[Workbook.currentFormat]]).
     */
    get frozenColumns(): number;
    set frozenColumns(a: number);
    /**
     * Gets or sets the number of rows frozen at the top of the worksheet.
     * <p class="body">
     * The frozen rows will always remain in view, regardless of the vertical scroll position of
     * the worksheet.
     * </p>
     * <p class="note">
     * <B>Note:</B> If the number of frozen rows specified is more than the amount of visible rows
     * in the worksheet, the worksheet may not scroll correctly.
     * </p>
     * The number of rows frozen at the top of the worksheet.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is not a valid row count (0 to [[Workbook.maxExcelRowCount]] or
     * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
     * [[Workbook.currentFormat]]).
     */
    get frozenRows(): number;
    set frozenRows(a: number);
    /**
     * @hidden
     */
    _z: boolean;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    _j(): boolean;
}
/**
 * @hidden
 */
export declare class GenericCachedCollection$1<T extends GenericCacheElement> extends Base implements ICollection$1<T> {
    static $t: Type;
    protected $t: Type;
    _b: GenericElementHashSet$1<T>;
    private _c;
    private _h;
    constructor($t: Type, a: number, b: Workbook, c: number);
    constructor($t: Type, a: number, b: Workbook, c: number, d: number);
    constructor($t: Type, a: number, ..._rest: any[]);
    add(a: T): void;
    clear(): void;
    contains(a: T): boolean;
    copyTo(a: T[], b: number): void;
    get count(): number;
    get isReadOnly(): boolean;
    remove(a: T): boolean;
    getEnumerator(): IEnumerator$1<T>;
    getEnumeratorObject(): IEnumerator;
    _add(a: T): void;
    _a(a: T): T;
    _g(a: T): number;
    _k(a: T, b: T): {
        p1: T;
    };
    protected _l(a: T): void;
    _n(a: boolean): void;
    _m(): void;
    _remove(a: T): boolean;
    get _count(): number;
    get _i(): number;
    set _i(a: number);
    get _d(): Workbook;
}
/**
 * @hidden
 */
export interface IGenericCachedCollectionEx extends IWorkbookProvider {
}
/**
 * @hidden
 */
export declare let IGenericCachedCollectionEx_$type: Type;
/**
 * @hidden
 */
export declare class GenericCachedCollectionEx$1<T extends GenericCacheElementEx> extends GenericCachedCollection$1<T> implements IGenericCachedCollectionEx {
    static $t: Type;
    protected $t: Type;
    private _o;
    constructor($t: Type, a: T, b: Workbook, c: number);
    protected _l(a: T): void;
    _remove(a: T): boolean;
    get _p(): T;
    set _p(a: T);
    get workbook(): Workbook;
}
/**
 * @hidden
 */
export declare class GenericElementHashSet$1<T extends GenericCacheElement> extends Base {
    static $t: Type;
    protected $t: Type;
    private l;
    private a;
    private b;
    private c;
    private h;
    private k;
    private o;
    constructor($t: Type, a: number);
    private s;
    f(a: T, b: T): {
        ret: boolean;
        p1: T;
    };
    g(a: T, b: T): {
        ret: boolean;
        p1: T;
    };
    p(a: T[], b: number): void;
    d(a: number, b: number): {
        ret: GenericElementHashSet_Entry$1<T>[];
        p1: number;
    };
    e(a: number, b: number, c: number): {
        ret: GenericElementHashSet_Entry$1<T>[];
        p1: number;
        p2: number;
    };
    private _j;
    j(): IEnumerator$1<T>;
    u(a: boolean): void;
    t(): void;
    i(a: T): boolean;
    private static q;
    private n;
    private r;
    get m(): number;
}
/**
 * @hidden
 */
export declare class GenericElementHashSet_Entry$1<T extends GenericCacheElement> extends ValueType {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: number, b: T, c: number);
    constructor($t: Type);
    constructor($t: Type, a: number, ..._rest: any[]);
    readonly b: number;
    readonly a: T;
}
/**
 * Represents a column in a Microsoft Excel worksheet.
 */
export declare class WorksheetColumn extends RowColumnBase implements IChangeInfoContext, IWorksheetRegionAddressContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ax;
    /**
     * @hidden
     */
    private static readonly _av;
    /**
     * @hidden
     */
    static readonly _au: number;
    /**
     * @hidden
     */
    private static readonly _ae;
    private _ap;
    private _an;
    private _ai;
    private _al;
    constructor(a: Worksheet, b: number);
    /**
     * @hidden
     */
    protected get__a(): ChangeInfo[];
    /**
     * @hidden
     */
    get _a(): ChangeInfo[];
    /**
     * @hidden
     */
    _h(a: GenericCachedCollectionEx$1<WorksheetCellFormatData>): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    _getAdjacentFormatForBorderResolution(a: WorksheetCellFormatProxy, b: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    protected get__l(): boolean;
    /**
     * @hidden
     */
    protected set__l(a: boolean): void;
    /**
     * @hidden
     */
    get _l(): boolean;
    /**
     * @hidden
     */
    set _l(a: boolean);
    /**
     * Gets the 0-based index of the column in the worksheet.
     * The 0-based index of the column in the worksheet.
     */
    protected get_index(): number;
    /**
     * Gets the 0-based index of the column in the worksheet.
     * The 0-based index of the column in the worksheet.
     */
    get index(): number;
    /**
     * @hidden
     */
    _onCellFormatValueChanging(a: WorksheetCellFormatProxy, b: CellFormatValue): void;
    /**
     * @hidden
     */
    _onCellFormatValueChanged(a: WorksheetCellFormatProxy, b: CellFormatValue, c: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    protected get__n(): number;
    /**
     * @hidden
     */
    protected set__n(a: number): void;
    /**
     * @hidden
     */
    get _n(): number;
    /**
     * @hidden
     */
    set _n(a: number);
    /**
     * @hidden
     */
    _ad(): void;
    /**
     * Sets the [[width]] to the extent required to display the contents of this column.
     * @throws [[InvalidOperationException]] The column is not associated with a [[Worksheet]] such as when the column has been deleted or the Worksheet is not associated with a [[Workbook]] such as when the Worksheet has been deleted.
     */
    autoFitWidth(): void;
    /**
     * Sets the width to the extent required to display all of the contents for the specified range of rows.
     * @param startRowIndex A 0-based index of the first row whose contents are to be calculated
     * @param endRowIndex A 0-based index of the last row whose contents are to be calculated
     * @throws [[InvalidOperationException]] The column is not associated with a [[Worksheet]] such as when the column has been deleted or the Worksheet is not associated with a [[Workbook]] such as when the Worksheet has been deleted.
     * @throws [[ArgumentOutOfRangeException]] The 'startRowIndex' must be greater than or equal to 0, less than or equal to the 'endRowIndex' and less than or equal to the Count of the Rows in the Worksheet. Similarly the 'endRowIndex' must be greater than or equal to the 'startRowIndex' and less than the [[WorksheetRowCollection.maxCount]] of the Worksheet's [[Worksheet.rows]] collection which depends upon the [[Workbook.currentFormat]]
     */
    autoFitWidth(startRowIndex: number, endRowIndex: number): void;
    /**
     * @hidden
     */
    _autoFitWidth(): void;
    /**
     * @hidden
     */
    _autoFitWidth1(a: number, b: number): void;
    /**
     * Returns the width required for the column to display all of its contents.
     * @return The width needed for the column to display all of its contents. The value is the same units as used for the [[width]] property.
     * @throws [[InvalidOperationException]] The column is not associated with a [[Worksheet]] such as when the column has been deleted or the Worksheet is not associated with a [[Workbook]] such as when the Worksheet has been deleted.
     */
    calculateAutoFitWidth(): number;
    /**
     * Returns the width required for the column to display all of the contents for the specified range of rows.
     * @param startRowIndex A 0-based index of the first row whose contents are to be calculated
     * @param endRowIndex A 0-based index of the last row whose contents are to be calculated
     * @return The width needed for the column to display the contents of the rows in the specified range. The value is the same units as used for the [[width]] property.
     * @throws [[InvalidOperationException]] The column is not associated with a [[Worksheet]] such as when the column has been deleted or the Worksheet is not associated with a [[Workbook]] such as when the Worksheet has been deleted.
     * @throws [[ArgumentOutOfRangeException]] The 'startRowIndex' must be greater than or equal to 0, less than or equal to the 'endRowIndex' and less than or equal to the Count of the Rows in the Worksheet. Similarly the 'endRowIndex' must be greater than or equal to the 'startRowIndex' and less than the [[WorksheetRowCollection.maxCount]] of the Worksheet's [[Worksheet.rows]] collection which depends upon the [[Workbook.currentFormat]]
     */
    calculateAutoFitWidth(startRowIndex: number, endRowIndex: number): number;
    /**
     * @hidden
     */
    _calculateAutoFitWidth(): number;
    /**
     * @hidden
     */
    _calculateAutoFitWidth1(a: number, b: number): number;
    /**
     * Gets the column width in the specified units, or NaN if the column has the default width.
     * <p class="body">
     * If 'units' is Character256th, the value returned will be the same as the value of the [[width]]
     * property, with one exception: if the column has the default width, this method will return NaN and Width will return -1.
     * </p>
     * @param units The units in which the width should be returned.
     * @throws [[InvalidEnumArgumentException]] 'units' is not defined in the [[WorksheetColumnWidthUnit]] enumeration.
     * @return The column width in the specified units, or NaN if the column has the default width.
     * @see [[width]]
     * @see [[setWidth]]
     * @see [[Worksheet.getDefaultColumnWidth]]
     */
    getWidth(units: WorksheetColumnWidthUnit): number;
    /**
     * Sets the column width in the specified units.
     * <p class="body">
     * Setting a value of NaN will reset the column width so that the column uses the default column width of the worksheet.
     * </p>
     * @param value The width to set on the column, expressed in the specified 'units'.
     * @param units The units in which the 'value' is expressed.
     * @throws [[ArgumentException]] 'value' is infinity.
     * @throws [[InvalidEnumArgumentException]] 'units' is not defined in the [[WorksheetColumnWidthUnit]] enumeration.
     * @throws [[InvalidOperationException]] If the column was removed from the worksheet.
     * @see [[width]]
     * @see [[getWidth]]
     * @see [[Worksheet.setDefaultColumnWidth]]
     */
    setWidth(value: number, units: WorksheetColumnWidthUnit): void;
    /**
     * @hidden
     */
    _ay(a: number, b: number, c: CellSizeMeasurementContext): Nullable$1<number>;
    /**
     * @hidden
     */
    _a1(a: WorksheetColumn): void;
    /**
     * @hidden
     */
    _a2(a: number, b: boolean): void;
    /**
     * @hidden
     */
    _aj(): WorksheetColumnBlock;
    /**
     * @hidden
     */
    _ak(): WorksheetColumnBlock;
    /**
     * @hidden
     */
    _a3(a: Worksheet, b: number): void;
    /**
     * @hidden
     */
    _a4(): void;
    /**
     * @hidden
     */
    private static _ag;
    /**
     * @hidden
     */
    private static _af;
    /**
     * @hidden
     */
    private static _ah;
    /**
     * @hidden
     */
    private _am;
    /**
     * @hidden
     */
    private _a5;
    /**
     * Gets or sets the column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
     * <p class="body">
     * If the width of the column is less than zero, the [[Worksheet.defaultColumnWidth]] of the
     * owning worksheet will be used as the column's width.
     * </p>
     * <p class="body">
     * The value assigned must be between -1 and 65535. Invalid values will be automatically adjusted to valid values.
     * </p>
     * <p class="body">
     * Setting or getting this property is equivalent to calling [[setWidth]] or [[getWidth]] using the
     * [[WorksheetColumnWidthUnit]] value of Character256th.
     * </p>
     * The column width including padding, in 256ths of the '0' digit character width in the workbook's default font.
     * @throws [[InvalidOperationException]] From the setter if the column was removed from the worksheet.
     * @see [[getWidth]]
     * @see [[setWidth]]
     * @see [[Workbook.characterWidth256thsToPixels]]
     * @see [[Workbook.pixelsToCharacterWidth256ths]]
     */
    get width(): number;
    set width(a: number);
    /**
     * @hidden
     */
    private _a7;
    /**
     * @hidden
     */
    get _at(): number;
    /**
     * @hidden
     */
    get _aq(): number;
    /**
     * @hidden
     */
    protected get__m(): boolean;
    /**
     * @hidden
     */
    get _m(): boolean;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    getRegionAddress(): WorksheetRegionAddress;
}
/**
 * A collection of hidden [[WorksheetColumn]] instances.
 * <p class="body">
 * The columns in this collection do not necessarily have their [[RowColumnBase.hidden]] property
 * set to True. This collection applies to a [[worksheet]], but belongs to a [[CustomView]].
 * When the CustomView which owns this collection is applied, the columns in this collection will have their
 * [[RowColumnBase.hidden]] property set to True. All other columns in the associated worksheet will
 * be made visible.
 * </p>
 * @see [[CustomView.getHiddenColumns]]
 */
export declare class HiddenColumnCollection extends Base implements ICollection$1<WorksheetColumn> {
    static $t: Type;
    private _d;
    private _a;
    private _c;
    constructor(a: Worksheet, b: CustomView);
    /**
     * @hidden
     */
    add(item: WorksheetColumn): void;
    /**
     * @hidden
     */
    copyTo(array: WorksheetColumn[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    remove(item: WorksheetColumn): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetColumn>;
    /**
     * @hidden
     */
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<WorksheetColumn>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a column to the collection.
     * <p class="body">
     * This collection does not allow duplicate values. If the specified column already exists in the collection,
     * nothing will happen. This collection also keeps itself sorted, so the column added will not necessarily be
     * added at the end of the collection.
     * </p>
     * @throws [[ArgumentNullException]] 'column' is null.
     * @throws [[ArgumentException]] 'column' does not belong to the same worksheet this collection is associated with.
     * @param column The column to be added to the hidden columns collection.
     */
    add_1(column: WorksheetColumn): void;
    /**
     * Clears all columns from the collection.
     */
    clear(): void;
    /**
     * Determines whether the specified column exists in the collection.
     * @param column The column to search for in the collection.
     * @return True if the column exists in the collection; False otherwise or if the specified column is null.
     */
    contains(column: WorksheetColumn): boolean;
    /**
     * Removes the specified column from the collection if it exists.
     * @param column The column to removed from the collection.
     * @return True if the column existed in the collection and was removed; False otherwise or if the
     * specified column is null.
     */
    remove_1(column: WorksheetColumn): boolean;
    /**
     * Removes the column at the specified index in the collection.
     * @param index The zero-based index of the column in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _l(a: number, b: number): void;
    /**
     * @hidden
     */
    _b(): NamedReference;
    /**
     * @hidden
     */
    _n(a: Worksheet): void;
    /**
     * @hidden
     */
    private _k;
    /**
     * Gets the number of columns in the collection.
     * The number of columns in the collection.
     */
    get count(): number;
    /**
     * Gets the column at the specified index.
     * The column at the specified index.
     * @param index The zero-based index of the column to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    item(a: number): WorksheetColumn;
    /**
     * Gets the worksheet associated with this collection.
     * The worksheet associated with this collection.
     */
    get worksheet(): Worksheet;
}
/**
 * A collection of hidden [[WorksheetRow]] instances.
 * <p class="body">
 * The rows in this collection do not necessarily have their [[RowColumnBase.hidden]] property
 * set to True. This collection applies to a [[worksheet]], but belongs to a [[CustomView]].
 * When the CustomView which owns this collection is applied, the rows in this collection will have their
 * [[RowColumnBase.hidden]] property set to True. All other rows in the associated worksheet will
 * be made visible.
 * </p>
 * @see [[CustomView.getHiddenRows]]
 */
export declare class HiddenRowCollection extends Base implements ICollection$1<WorksheetRow> {
    static $t: Type;
    private _d;
    private _a;
    private _c;
    constructor(a: Worksheet, b: CustomView);
    /**
     * @hidden
     */
    add(item: WorksheetRow): void;
    /**
     * @hidden
     */
    copyTo(array: WorksheetRow[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    remove(item: WorksheetRow): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetRow>;
    /**
     * @hidden
     */
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<WorksheetRow>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a row to the collection.
     * <p class="body">
     * This collection does not allow duplicate values. If the specified row already exists in the collection,
     * nothing will happen. This collection also keeps itself sorted, so the row added will not necessarily be
     * added at the end of the collection.
     * </p>
     * @throws [[ArgumentNullException]] 'row' is null.
     * @throws [[ArgumentException]] 'row' does not belong to the same worksheet this collection is associated with.
     * @param row The row to be added to the hidden rows collection.
     */
    add_1(row: WorksheetRow): void;
    /**
     * Clears all rows from the collection.
     */
    clear(): void;
    /**
     * Determines whether the specified row exists in the collection.
     * @param row The row to search for in the collection.
     * @return True if the row exists in the collection; False otherwise or if the specified row is null.
     */
    contains(row: WorksheetRow): boolean;
    /**
     * Removes the specified row from the collection if it exists.
     * @param row The row to removed from the collection.
     * @return True if the row existed in the collection and was removed; False otherwise or if the
     * specified row is null.
     */
    remove_1(row: WorksheetRow): boolean;
    /**
     * Removes the row at the specified index in the collection.
     * @param index The zero-based index of the row in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _l(a: number, b: number): void;
    /**
     * @hidden
     */
    _b(): NamedReference;
    /**
     * @hidden
     */
    _n(a: Worksheet): void;
    /**
     * @hidden
     */
    private _k;
    /**
     * Gets the number of rows in the collection.
     * The number of rows in the collection.
     */
    get count(): number;
    /**
     * Gets the row at the specified index.
     * The row at the specified index.
     * @param index The zero-based index of the row to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    item(a: number): WorksheetRow;
    /**
     * Gets the worksheet associated with this collection.
     * The worksheet associated with this collection.
     */
    get worksheet(): Worksheet;
}
/**
 * @hidden
 */
export interface IFormattedTextOwner extends ISheetProvider {
    onFormattingChanged(a: FormattedText): void;
    onUnformattedStringChanged(a: FormattedText): void;
}
/**
 * @hidden
 */
export declare let IFormattedTextOwner_$type: Type;
/**
 * @hidden
 */
export declare class SheetCollection_ChangeInfoContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: Workbook);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly a;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of sheets in a workbook.
 * @see [[Sheet]]
 * @see [[Worksheet]]
 * @see@see */
export declare class SheetCollection extends Base implements IList$1<Sheet> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _o;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static _a;
    private readonly _i;
    private _n;
    private _j;
    static staticInit(): void;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    add(item: Sheet): void;
    /**
     * Creates a new [[Sheet]] and adds it to the collection.
     * <p class="body">
     * If the workbook originally had no sheets, the newly added sheet will become the selected sheet of
     * the workbook.  This can be changed after more sheets are added by setting the [[WindowOptions.selectedSheet]]
     * of the Workbook.
     * </p>
     * @param name The name to give the new Sheet.
     * @param type An enumeration indicating the type of sheet to create
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentException]] 'name' contains the invalid characters: ':', '\', '/', '?', '*', '[', or ']'.
     * @throws [[ArgumentException]] 'name' exceeds 31 characters in length.
     * @throws [[ArgumentException]] 'name' is being used as the name of another sheet (sheet names are case-insensitively compared).
     * @return The Sheet created with the specified name.
     */
    add(name: string, type: SheetType): Sheet;
    /**
     * @hidden
     */
    _add$e(a: Sheet): void;
    /**
     * @hidden
     */
    copyTo(array: Sheet[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    remove(item: Sheet): boolean;
    [Symbol.iterator](): EnumeratorWrapper<Sheet>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<Sheet>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    insert(index: number, item: Sheet): void;
    /**
     * @hidden
     */
    item(index: number, value?: Sheet): Sheet;
    /**
     * Gets the sheet at the specified index.
     * The sheet at the specified index.
     * @param index The zero-based index of the sheet to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    item(index: number): Sheet;
    /**
     * Gets the sheet with the specified name.
     * <p class="body">
     * Sheet names are compared case-insensitively.
     * </p>
     * The sheet with the specified name.
     * @param name The name of the sheet to get.
     * @throws [[InvalidOperationException]] A sheet with the specified name does not exist in the collection.
     * @see [[Sheet.name]]
     */
    item(name: string): Sheet;
    /**
     * @hidden
     */
    _item$e(a: number, b?: Sheet): Sheet;
    /**
     * @hidden
     */
    _add1(a: string, b: SheetType): Sheet;
    /**
     * @hidden
     */
    _add2(a: string, b: number, c: SheetType): Sheet;
    /**
     * Clears all sheets from the collection.
     * <p class="body">
     * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
     * with a worksheet for a scope, they will be removed from the [[Workbook]].
     * </p>
     */
    clear(): void;
    /**
     * @hidden
     */
    _t(): void;
    /**
     * Determines whether a sheet is in the collection.
     * @param sheet The sheet to locate in the collection.
     * @return True if the sheet is found; False otherwise.
     */
    contains(sheet: Sheet): boolean;
    /**
     * Determines whether a sheet with the specified name exists in the collection.
     * @param name The name of the sheet to search for. The name is compared case-insensitively.
     * @return True if a sheet with the specified name is found; False otherwise.
     */
    exists(name: string): boolean;
    /**
     * Gets the index of the specified sheet in the collection.
     * @param sheet The sheet of which to get the index.
     * @return The index of the specified sheet in the collection.
     * @see [[Sheet.sheetIndex]]
     */
    indexOf(sheet: Sheet): number;
    /**
     * @hidden
     */
    _insert1(a: number, b: string, c: number, d: SheetType): Sheet;
    /**
     * @hidden
     */
    private _u;
    /**
     * @hidden
     */
    _v(a: number, b: number): void;
    /**
     * Removes the specified sheet from the collection.
     * <p class="body">
     * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
     * with the worksheet to remove as their scope, they will be removed from the [[Workbook]].
     * </p>
     * @param sheet The sheet to remove from the collection.
     * @return True if the sheet was successfully removed from the collection;
     * False if the sheet did not exist in the collection.
     */
    remove_1(sheet: Sheet): boolean;
    /**
     * Removes the sheet at the specified index from the collection.
     * <p class="body">
     * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
     * with the worksheet to remove as their scope, they will be removed from the [[Workbook]].
     * </p>
     * @param index The index of the sheet to remove from the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    private _w;
    /**
     * @hidden
     */
    _x(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * Gets the number of sheets in the collection.
     * The number of sheets in the collection.
     */
    get count(): number;
    /**
     * @hidden
     */
    _item(a: number): Sheet;
    /**
     * @hidden
     */
    _item1(a: string): Sheet;
}
/**
 * @hidden
 */
export interface IWorkbookOwner {
    readonly isUndoEnabled: boolean;
    onCellValueChange(a: WorksheetRow, b: number): void;
    onConditionalFormatChange(a: WorksheetRegion): void;
    _onChange$2$i<TContext extends IChangeInfoContext, TValue>($tContext: Type, $tValue: Type, a: TContext, b: boolean, c: TValue, d: TValue, e: ChangeInfo$2<TContext, TValue>): void;
    onCustomViewApplied(a: CustomView): void;
    onTransactionalChangeBegin(a: ExcelChangeAction, b: string): any;
    onTransactionalChangeEnd(a: any): void;
    onTransactionalChangeRollback(a: any): void;
    onSheetRemoving(a: Sheet): void;
}
/**
 * @hidden
 */
export declare let IWorkbookOwner_$type: Type;
/**
 * Abstract base class for a named reference defined in the workbook.
 */
export declare abstract class NamedReferenceBase extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ab: number;
    /**
     * @hidden
     */
    static readonly _ac: number;
    /**
     * @hidden
     */
    static readonly _aa: number;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    private static readonly _ar;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    static readonly _ax: string;
    /**
     * @hidden
     */
    static readonly _ay: string;
    /**
     * @hidden
     */
    private static readonly _az;
    /**
     * @hidden
     */
    private static readonly _aq;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static readonly _a0;
    /**
     * @hidden
     */
    private static readonly _as;
    /**
     * @hidden
     */
    static readonly _ak: string;
    private _i;
    private _at;
    private _ad;
    private _q;
    private _b;
    private _al;
    private _o;
    private _u;
    private _w;
    constructor(a: any, b: boolean);
    /**
     * @hidden
     */
    private static _e;
    /**
     * @hidden
     */
    static _a3(a: NamedReference, b: PrintOptions): void;
    /**
     * @hidden
     */
    static _a4(a: NamedReference, b: PrintOptions): void;
    /**
     * @hidden
     */
    static _a5(a: NamedReference, b: PrintOptions): void;
    /**
     * @hidden
     */
    static _av(a: BuiltInName): string;
    /**
     * @hidden
     */
    _a6(a: boolean): void;
    /**
     * @hidden
     */
    _a7(a: string): void;
    /**
     * @hidden
     */
    _a8(a: string): void;
    /**
     * @hidden
     */
    static _a9(a: NamedReference, b: PrintOptions): void;
    /**
     * @hidden
     */
    _aw(): string;
    /**
     * @hidden
     */
    static _ba(a: ChangeInfo[], b: ExcelChangeAction): void;
    /**
     * @hidden
     */
    _bd(a: string, b: boolean): void;
    /**
     * @hidden
     */
    _be(a: string, b: string, c: WorkbookFormat, d?: boolean): void;
    /**
     * @hidden
     */
    _a1(a: GetFormulaStringInfo, b?: boolean): string;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private _a2;
    /**
     * @hidden
     */
    static _s(a: string): boolean;
    /**
     * @hidden
     */
    abstract get _f(): RefBase;
    /**
     * @hidden
     */
    protected get__a(): ChangeInfo[];
    /**
     * @hidden
     */
    get _a(): ChangeInfo[];
    /**
     * @hidden
     */
    abstract get _z(): CultureInfo;
    /**
     * @hidden
     */
    protected get__l(): WorkbookFormat;
    /**
     * @hidden
     */
    get _l(): WorkbookFormat;
    /**
     * @hidden
     */
    abstract get _k(): Workbook;
    /**
     * Gets or sets the comment associated with the named reference or table.
     * The comment associated with the named reference or table.
     * @throws [[ArgumentException]] The value assigned is greater than 255 characters in length.
     */
    get comment(): string;
    set comment(a: string);
    /**
     * Gets or sets the name of the reference.
     * <p class="body">
     * See the overview on [[scope]] for details on how to access a named reference by name in formulas.
     * </p>
     * The name of the reference.
     * @throws [[ArgumentNullException]] The value assigned is null or empty.
     * @throws [[ArgumentException]] The value assigned is longer than 255 characters.
     * @throws [[ArgumentException]] The value assigned is not a valid named reference. The name must begin with a letter, underscore (_), or a backslash (\).
     * All other characters in the name must be letters, numbers, periods, underscores (_), or backslashes (\).
     * The name cannot be a an A1 cell reference (1 to 3 letters followed by 1 to 6 numbers). In addition, the name
     * cannot be 'r', 'R', 'c', or 'C' or start with a row or column reference in R1C1 cell reference mode
     * ('R' followed by 1 to 6 numbers or 'C' followed by 1 to 6 numbers).
     * @throws [[InvalidOperationException]] The value assigned is the name of another named reference with the same Scope.
     * Names are compared case-insensitively.
     */
    get name(): string;
    set name(a: string);
    /**
     * @hidden
     */
    private _bc;
    /**
     * Gets the scope of the named reference.
     * <p class="body">
     * This can either be the workbook which the named reference belongs to or one of the worksheets
     * in the workbook.
     * </p>
     * <p class="body">
     * The scope determines how formulas need to preface a name in order to use the named reference.
     * </p>
     * <p class="body">
     * If the scope is the workbook, formulas in any cell in the workbook can reference the named reference
     * by specifying just the name or the workbook's file name, an exclamation point, and the name:
     * <list type="bullet">
     * <item>=MyWorkbookName</item>
     * <item>='C:\MyWorkbook.xls'!MyWorkbookName</item>
     * </list>
     * When cells in other workbook's want to reference the named reference, they must use the second format
     * by first specifying the file name when the workbook-scoped named reference exists.
     * </p>
     * <p class="body">
     * If the scope is a worksheet, formulas in cells of the worksheet can reference the named reference
     * by specifying just the name. In addition, they can fully qualify the named reference with the worksheet name
     * and, optionally, the workbook file name:
     * <list type="bullet">
     * <item>=MyWorksheetName</item>
     * <item>=Sheet1!MyWorksheetName</item>
     * <item>='C:\[MyWorkbook.xls]Sheet1'!MyWorksheetName</item>
     * </list>
     * Formulas in cells of other worksheets in the same workbook can use the named reference as well, but they must
     * specify the worksheet name and, optionally, the workbook file name:
     * <list type="bullet">
     * <item>=Sheet2!OtherWorksheetName</item>
     * <item>='C:\[MyWorkbook.xls]Sheet2'!OtherWorksheetName</item>
     * </list>
     * Formulas in cells of other workbooks can also used the named reference, but they must specify the workbook file
     * name, worksheet name, and named reference name.
     * </p>
     * The scope of the named reference.
     */
    get scope(): any;
    /**
     * @hidden
     */
    get _c(): BuiltInName;
    /**
     * @hidden
     */
    protected get__m(): boolean;
    /**
     * @hidden
     */
    get _m(): boolean;
    /**
     * @hidden
     */
    abstract get _n(): boolean;
    /**
     * @hidden
     */
    get _j(): SingleTargetFormula;
    /**
     * @hidden
     */
    set _j(a: SingleTargetFormula);
    /**
     * @hidden
     */
    _bb(a: SingleTargetFormula, b: boolean): void;
    /**
     * @hidden
     */
    get _p(): boolean;
    /**
     * @hidden
     */
    set _p(a: boolean);
    /**
     * @hidden
     */
    get _r(): boolean;
    /**
     * @hidden
     */
    protected get__t(): boolean;
    /**
     * @hidden
     */
    get _t(): boolean;
    /**
     * @hidden
     */
    get _v(): boolean;
    /**
     * @hidden
     */
    set _v(a: boolean);
    /**
     * @hidden
     */
    get _x(): boolean;
    /**
     * @hidden
     */
    set _x(a: boolean);
    /**
     * @hidden
     */
    protected get__y(): boolean;
    /**
     * @hidden
     */
    get _y(): boolean;
    /**
     * @hidden
     */
    get _af(): any;
    /**
     * @hidden
     */
    set _af(a: any);
    /**
     * @hidden
     */
    protected get__g(): NameType;
    /**
     * @hidden
     */
    get _g(): NameType;
    /**
     * @hidden
     */
    protected get__h(): WorkbookReferenceBase;
    /**
     * @hidden
     */
    get _h(): WorkbookReferenceBase;
}
/**
 * @hidden
 */
export declare class NamedReference_FormulaInfo extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: NamedReference, c: CellReferenceMode, d: CultureInfo);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: NamedReference;
    readonly c: NamedReferenceCollection;
    readonly a: CellReferenceMode;
    readonly d: CultureInfo;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Represents a named reference defined in the workbook.
 * <p class="body">
 * Named references allow for names to be used in formulas instead of complex formulas or cell references.
 * For example, instead of using the formula =SUM(E1:E20), a named reference with a name of 'Sales' can be
 * defined to point to the range of E1:E20 (the named reference's formula would be defined like this:
 * =Sheet1!$E$1:$E$20). Then the original formula could be expressed as =SUM(Sales).
 * </p>
 * <p class="body">
 * Each named reference has an associated scope, which can either be the [[workbook]]
 * to which the named reference belongs or one of the [[Worksheet]] instances in the Workbook. The scope
 * determines how the name must be referenced in formulas for different cells. A scope of the workbook means
 * the named reference must be accessed by a formula in any cell of the workbook by specifying only the name.
 * A scope of the worksheet means formulas used in other worksheets must reference the name by first
 * specifying the worksheet scope, such as =SUM( Sheet2!Sales ). If the formula is in the same worksheet as
 * the scope of the named reference, the formula can reference the name with or without the worksheet name.
 * </p>
 * <p class="body">
 * Named references from external workbooks must always be referenced with the scope first. If the named
 * reference's scope is the external workbook, the name is accessed by specifying the workbook file name
 * followed by the name, such as in the following formula: ='C:\ExternalWorkbook.xls'!SalesTax. If the named
 * reference has a scope of a worksheet in the workbook, it is referenced by specifying the file name,
 * worksheet, and name: ='C:\[ExternalWorkbook.xls]Sheet1'!SalesTax.
 * </p>
 * <p class="body">
 * Named references with different scopes can have the same names, but if two named references have the same
 * scope, they must have case-insensitively unique names.
 * </p>
 */
export declare class NamedReference extends NamedReferenceBase implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _bx;
    /**
     * @hidden
     */
    private static readonly _by;
    /**
     * @hidden
     */
    private static readonly _bf;
    private _bm;
    /**
     * @hidden
     */
    _bp: NamedReferenceCollection;
    private _bu;
    constructor(a: number, b: NamedReferenceCollection, c: any);
    constructor(a: number, b: NamedReferenceCollection, c: any, d: boolean);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__a(): ChangeInfo[];
    /**
     * @hidden
     */
    protected get__z(): CultureInfo;
    /**
     * @hidden
     */
    get _z(): CultureInfo;
    /**
     * @hidden
     */
    _a6(a: boolean): void;
    /**
     * Gets the string representation of the named reference.
     * @return The string representation of the named reference.
     */
    toString(): string;
    /**
     * @hidden
     */
    protected get__h(): WorkbookReferenceBase;
    /**
     * @hidden
     */
    private static _bl;
    /**
     * @hidden
     */
    private static _bg;
    /**
     * @hidden
     */
    _bi(a: boolean, b?: Worksheet): WorksheetRegionAddress[];
    /**
     * @hidden
     */
    _bh(a: RefBase, b: Worksheet): WorksheetRegionAddress[];
    /**
     * @hidden
     */
    _bo(a: boolean, b?: RefBase): RefBase;
    /**
     * @hidden
     */
    _b2(a: NamedReferenceCollection): void;
    /**
     * Sets the formula for a named reference.
     * <p class="body">
     * The formula will be parsed using the [[CellReferenceMode]] of the [[workbook]]
     * to which the NamedReference is applied. If the NamedReference has been removed from its collection, the A1 reference mode
     * will be used to parse the formula.
     * </p>
     * @param formula The string containing the formula value.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[ArgumentException]] 'formula' is not a valid formula. The inner exception will contain the [[FormulaParseException]]
     * describing the reason the formula was not valid.
     * @see [[formula]]
     */
    setFormula(formula: string): void;
    /**
     * Sets the formula for a named reference.
     * @param formula The string containing the formula value.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'formula' is not a valid formula. The inner exception will contain the [[FormulaParseException]]
     * describing the reason the formula was not valid.
     * @see [[formula]]
     */
    setFormula(formula: string, cellReferenceMode: CellReferenceMode): void;
    /**
     * Sets the formula for a named reference.
     * @param formula The string containing the formula value.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @param culture The culture used to parse the formula.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentException]] 'formula' is not a valid formula. The inner exception will contain the [[FormulaParseException]]
     * describing the reason the formula was not valid.
     * @see [[formula]]
     */
    setFormula(formula: string, cellReferenceMode: CellReferenceMode, culture: string | CultureInfo): void;
    /**
     * @hidden
     */
    _setFormula1(a: string): void;
    /**
     * @hidden
     */
    _setFormula2(a: string, b: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setFormula3(a: string, b: CellReferenceMode, c: CultureInfo): void;
    private _bz;
    /**
     * @hidden
     */
    private static _b5;
    /**
     * @hidden
     */
    private static _b9;
    /**
     * @hidden
     */
    _b3(): void;
    /**
     * @hidden
     */
    _b4(): void;
    /**
     * @hidden
     */
    private _ca;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * @hidden
     */
    _cb(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    protected get__n(): boolean;
    /**
     * @hidden
     */
    get _n(): boolean;
    /**
     * Gets the formula which defines the named reference.
     * The formula which defines the named reference.
     * @see [[setFormula]]
     * @see [[setFormula]]
     */
    get formula(): string;
    /**
     * Gets the value indicating whether the [[formula]] is a simple formula referring to a single cell, a single region,
     * or multiple regions in the same workbook as the named reference.
     * <p class="body">
     * If the reference is surrounded by parentheses or whitespace or the named reference has some other complex formula this will
     * return false.
     * </p>
     */
    get isSimpleReferenceFormula(): boolean;
    /**
     * Gets the [[WorksheetCell]] referenced by the [[formula]].
     * <p class="body">
     * If named reference is a reference to one or more regions, this will return null.
     * </p>
     * @see [[isSimpleReferenceFormula]]
     */
    get referencedCell(): WorksheetCell;
    /**
     * @hidden
     */
    static _bq(a: CellCalcReference): WorksheetCell;
    /**
     * Gets the [[WorksheetRegion]] referenced by the [[formula]].
     * <p class="body">
     * If the named reference is a reference to a single cell or multiple regions, this will return null.
     * </p>
     * @see [[isSimpleReferenceFormula]]
     */
    get referencedRegion(): WorksheetRegion;
    /**
     * @hidden
     */
    static _bs(a: RegionCalcReferenceBase): WorksheetRegion;
    /**
     * Gets the array of [[WorksheetRegion]] instances referenced by the [[formula]].
     * <p class="body">
     * If the named reference is a reference to a single cell or region, this will return null.
     * </p>
     * @see [[isSimpleReferenceFormula]]
     */
    get referencedRegions(): WorksheetRegion[];
    /**
     * @hidden
     */
    static _bj(a: RegionGroupCalcReference): WorksheetRegion[];
    /**
     * @hidden
     */
    protected get__f(): RefBase;
    /**
     * @hidden
     */
    get _f(): RefBase;
    /**
     * @hidden
     */
    get _bn(): NamedCalcReference;
    /**
     * @hidden
     */
    get _bv(): boolean;
    /**
     * @hidden
     */
    set _bv(a: boolean);
    /**
     * @hidden
     */
    protected get__k(): Workbook;
    /**
     * @hidden
     */
    get _k(): Workbook;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
}
/**
 * @hidden
 */
export declare class NamedReferenceCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: NamedReferenceCollection, c: NamedReference, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly c: number;
    readonly b: NamedReferenceCollection;
    readonly a: NamedReference;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of [[NamedReference]] instances in a workbook.
 * @see [[NamedReference]]
 * @see */
export declare class NamedReferenceCollection extends Base implements ICollection$1<NamedReference> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _s;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    private static readonly _u;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    _n: Workbook;
    private _r;
    static staticInit(): void;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    add(item: NamedReference): void;
    /**
     * Adds a named reference with a scope of the collection's associated [[workbook]] to the collection.
     * <p class="body">
     * The [[CellReferenceMode]] of the owning [[workbook]] will be used to parse the formula.
     * </p>
     * @param name The name to give the named reference.
     * @param formula The formula to give the named reference.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentException]] 'name' is longer than 255 characters.
     * @throws [[ArgumentException]] 'name' is invalid. The name must begin with a letter, underscore (_), or a backslash (\).
     * All other characters in the name must be letters, numbers, periods, underscores (_), or backslashes (\).
     * The name cannot be a an A1 cell reference (1 to 3 letters followed by 1 to 6 numbers). In addition, the name
     * cannot be 'r', 'R', 'c', or 'C' or start with a row or column reference in R1C1 cell reference mode
     * ('R' followed by 1 to 6 numbers or 'C' followed by 1 to 6 numbers).
     * @throws [[InvalidOperationException]] 'name' is used by another named reference which also has a scope of the workbook.
     * Named reference names are compared case-insensitively.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[ArgumentException]] 'formula' is not a valid formula. The inner exception will contain the [[FormulaParseException]]
     * describing the reason the formula was not valid.
     * @return The named reference which was added to the collection.
     * @see [[NamedReferenceBase.scope]]
     */
    add(name: string, formula: string): NamedReference;
    /**
     * Adds a named reference with a scope of the collection's associated [[workbook]] to the collection.
     * @param name The name to give the named reference.
     * @param formula The formula to give the named reference.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentException]] 'name' is longer than 255 characters.
     * @throws [[ArgumentException]] 'name' is invalid. The name must begin with a letter, underscore (_), or a backslash (\).
     * All other characters in the name must be letters, numbers, periods, underscores (_), or backslashes (\).
     * The name cannot be a an A1 cell reference (1 to 3 letters followed by 1 to 6 numbers). In addition, the name
     * cannot be 'r', 'R', 'c', or 'C' or start with a row or column reference in R1C1 cell reference mode
     * ('R' followed by 1 to 6 numbers or 'C' followed by 1 to 6 numbers).
     * @throws [[InvalidOperationException]] 'name' is used by another named reference which also has a scope of the workbook.
     * Named reference names are compared case-insensitively.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[ArgumentException]] 'formula' is not a valid formula. The inner exception will contain the [[FormulaParseException]]
     * describing the reason the formula was not valid.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @return The named reference which was added to the collection.
     * @see [[NamedReferenceBase.scope]]
     */
    add(name: string, formula: string, cellReferenceMode: CellReferenceMode): NamedReference;
    /**
     * Adds a named reference with a scope of a worksheet to the collection.
     * @param name The name to give the named reference.
     * @param formula The formula to give the named reference.
     * @param cellReferenceMode The mode used to interpret cell references in the formula.
     * @param worksheet The scope of the named reference.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentException]] 'name' is longer than 255 characters.
     * @throws [[ArgumentException]] 'name' is invalid. The name must begin with a letter, underscore (_), or a backslash (\).
     * All other characters in the name must be letters, numbers, periods, underscores (_), or backslashes (\).
     * The name cannot be a an A1 cell reference (1 to 3 letters followed by 1 to 6 numbers). In addition, the name
     * cannot be 'r', 'R', 'c', or 'C' or start with a row or column reference in R1C1 cell reference mode
     * ('R' followed by 1 to 6 numbers or 'C' followed by 1 to 6 numbers).
     * @throws [[InvalidOperationException]] 'name' is used by another named reference which also has a scope of
     * the specified 'worksheet'. Named reference names are compared case-insensitively.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[ArgumentException]] 'formula' is not a valid formula. The inner exception will contain the [[FormulaParseException]]
     * describing the reason the formula was not valid.
     * @throws [[InvalidEnumArgumentException]] 'cellReferenceMode' is not defined in the [[CellReferenceMode]] enumeration.
     * @throws [[ArgumentNullException]] 'worksheet' is null.
     * @throws [[ArgumentException]] 'worksheet' does not belong to the workbook owning this collection.
     * @return The named reference which was added to the collection.
     * @see [[NamedReferenceBase.scope]]
     */
    add(name: string, formula: string, cellReferenceMode: CellReferenceMode, worksheet: Worksheet): NamedReference;
    /**
     * Adds a named reference with a scope of a worksheet to the collection.
     * <p class="body">
     * The [[CellReferenceMode]] of the owning [[workbook]] will be used to parse the formula.
     * </p>
     * @param name The name to give the named reference.
     * @param formula The formula to give the named reference.
     * @param worksheet The scope of the named reference.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentException]] 'name' is longer than 255 characters.
     * @throws [[ArgumentException]] 'name' is invalid. The name must begin with a letter, underscore (_), or a backslash (\).
     * All other characters in the name must be letters, numbers, periods, underscores (_), or backslashes (\).
     * The name cannot be a an A1 cell reference (1 to 3 letters followed by 1 to 6 numbers). In addition, the name
     * cannot be 'r', 'R', 'c', or 'C' or start with a row or column reference in R1C1 cell reference mode
     * ('R' followed by 1 to 6 numbers or 'C' followed by 1 to 6 numbers).
     * @throws [[InvalidOperationException]] 'name' is used by another named reference which also has a scope of
     * the specified 'worksheet'. Named reference names are compared case-insensitively.
     * @throws [[ArgumentNullException]] 'formula' is null or empty.
     * @throws [[ArgumentException]] 'formula' is not a valid formula. The inner exception will contain the [[FormulaParseException]]
     * describing the reason the formula was not valid.
     * @throws [[ArgumentNullException]] 'worksheet' is null.
     * @throws [[ArgumentException]] 'worksheet' does not belong to the workbook owning this collection.
     * @return The named reference which was added to the collection.
     * @see [[NamedReferenceBase.scope]]
     */
    add(name: string, formula: string, worksheet: Worksheet): NamedReference;
    /**
     * @hidden
     */
    _add$e(a: NamedReference): void;
    /**
     * @hidden
     */
    copyTo(array: NamedReference[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    remove(item: NamedReference): boolean;
    [Symbol.iterator](): EnumeratorWrapper<NamedReference>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<NamedReference>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    _add1(a: string, b: string): NamedReference;
    /**
     * @hidden
     */
    _add2(a: string, b: string, c: CellReferenceMode): NamedReference;
    /**
     * @hidden
     */
    _add4(a: string, b: string, c: Worksheet): NamedReference;
    /**
     * @hidden
     */
    _add3(a: string, b: string, c: CellReferenceMode, d: Worksheet): NamedReference;
    /**
     * Clears all named references from the collection.
     */
    clear(): void;
    /**
     * Determines whether a named reference is in the collection.
     * @param namedReference The named reference to locate in the collection.
     * @return True if the named reference is found; False otherwise.
     */
    contains(namedReference: NamedReference): boolean;
    /**
     * Finds a named reference in the collection with a scope of the collection's associated [[Workbook]].
     * <p class="body">
     * Named reference names are compared case-insensitively.
     * </p>
     * @param name The name of the named reference to find.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @return The named reference with the specified name or null if the named reference was not found.
     */
    find(name: string): NamedReference;
    /**
     * Finds a named reference in the collection with a scope of the specified worksheet.
     * <p class="body">
     * Named reference names are compared case-insensitively.
     * </p>
     * @param name The name of the named reference to find.
     * @param worksheetScope The worksheet that the named reference found must have a scope of.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentNullException]] 'worksheetScope' is null.
     * @return The named reference with the specified name or null if the named reference was not found.
     */
    find(name: string, worksheetScope: Worksheet): NamedReference;
    /**
     * @hidden
     */
    _find(a: string): NamedReference;
    /**
     * @hidden
     */
    _find1(a: string, b: Worksheet): NamedReference;
    /**
     * Finds all named references in the collection with the specified name.
     * <p class="body">
     * Named reference names are compared case-insensitively.
     * </p>
     * @param name The name of the named references to find.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @return An array of [[NamedReference]] instances with the specified name.
     */
    findAll(name: string): NamedReference[];
    /**
     * Removes the specified named reference from the collection.
     * @param namedReference The named reference to remove fro the collection.
     * @return True if the named reference existed in the collection and was removed; False otherwise.
     */
    remove_1(namedReference: NamedReference): boolean;
    /**
     * Removes the named reference at the specified index in the collection.
     * @param index The zero-based index of the named reference in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _x(a: NamedReference): void;
    /**
     * @hidden
     */
    _y(a: NamedReference, b: boolean): void;
    /**
     * @hidden
     */
    _af(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    private _i;
    /**
     * @hidden
     */
    private _l;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _aa;
    /**
     * @hidden
     */
    private _w;
    /**
     * @hidden
     */
    private _ab;
    /**
     * @hidden
     */
    private static _ad;
    /**
     * @hidden
     */
    private static _ae;
    /**
     * Gets the number of named references in the collection.
     * The number of named references in the collection.
     */
    get count(): number;
    /**
     * Gets the named reference at the specified index.
     * The named reference at the specified index.
     * @param index The zero-based index of the named reference to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    item(a: number): NamedReference;
    /**
     * Gets the workbook associated with this collection.
     * The workbook associated with this collection.
     */
    get workbook(): Workbook;
}
/**
 * @hidden
 */
export declare class NamedReferenceUnconnected extends NamedReferenceBase {
    static $t: Type;
    private _bf;
    private _bh;
    private _bg;
    constructor(a: number, b: string, c: WorkbookFormat, d: NameType, e?: boolean);
    constructor(a: number, b: string, c: any, d: boolean, e: WorkbookFormat, f?: boolean);
    constructor(a: number, ..._rest: any[]);
    protected get__f(): RefBase;
    get _f(): RefBase;
    protected get__n(): boolean;
    get _n(): boolean;
    protected get__z(): CultureInfo;
    get _z(): CultureInfo;
    protected get__l(): WorkbookFormat;
    equals(a: any): boolean;
    getHashCode(): number;
    protected get__t(): boolean;
    _a1(a: GetFormulaStringInfo, b: boolean): string;
    protected get__g(): NameType;
    protected get__k(): Workbook;
    get _k(): Workbook;
    protected get__h(): WorkbookReferenceBase;
}
/**
 * Base class for horizontal and vertical page breaks in a [[Worksheet]].
 * @see [[PrintOptions.clearPageBreaks]]
 * @see [[PrintOptions.insertPageBreak]]
 * @see [[PrintOptions.insertPageBreak]]
 * @see [[PrintOptions.insertPageBreak]]
 * @see [[PrintOptions.horizontalPageBreaks]]
 * @see [[PrintOptions.verticalPageBreaks]]
 * @see [[HorizontalPageBreak]]
 * @see [[VerticalPageBreak]]
 */
export declare abstract class PageBreak extends Base {
    static $t: Type;
    private _c;
    private _j;
    private _f;
    private readonly _n;
    private readonly _p;
    private _a;
    constructor(a: number, b: Nullable$1<number>, c: Nullable$1<number>);
    /**
     * Determines whether this [[PageBreak]] is equal to the specified object.
     * @param obj The object to test.
     * @return True if the object is the same type as this PageBreak and has the same data; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[PageBreak]].
     * @return A hash code for the instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _h(a: PageBreak): number;
    /**
     * Gets the print area in which the page break occurs.
     * A  instance that is the print area where the page break occurs or null if the
     * page break occurs across the entire sheet.
     * @see [[WorksheetRegion]]
     * @see [[PrintOptions.printAreas]]
     */
    get printArea(): WorksheetRegion;
    set printArea(a: WorksheetRegion);
    /**
     * @hidden
     */
    get _d(): boolean;
    /**
     * @hidden
     */
    set _d(a: boolean);
    /**
     * @hidden
     */
    get _k(): number;
    /**
     * @hidden
     */
    set _k(a: number);
    /**
     * @hidden
     */
    get _g(): boolean;
    /**
     * @hidden
     */
    set _g(a: boolean);
    /**
     * @hidden
     */
    get _o(): Nullable$1<number>;
    /**
     * @hidden
     */
    get _l(): number;
    /**
     * @hidden
     */
    get _q(): Nullable$1<number>;
    /**
     * @hidden
     */
    get _m(): number;
}
/**
 * Represents a horizontal page break in a [[Worksheet]].
 * @see [[PrintOptions.horizontalPageBreaks]]
 */
export declare class HorizontalPageBreak extends PageBreak implements IComparable$1<HorizontalPageBreak> {
    static $t: Type;
    constructor(firstRowOnPage: number);
    constructor(firstRowOnPage: number, printArea: WorksheetRegion);
    constructor(firstRowOnPage: number, min: number | null, max: number | null);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    compareTo(other: HorizontalPageBreak): number;
    /**
     * @hidden
     */
    private static _s;
    /**
     * Gets the 0-based index of the first row on the page after this break.
     */
    get firstRowOnPage(): number;
}
/**
 * @hidden
 */
export declare class PageBreakCollection_CollectionChangeContext$1<T extends PageBreak> extends ValueType implements IChangeInfoContext {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: number, b: PageBreakCollection$1<T>, c: T, d: number);
    constructor($t: Type);
    constructor($t: Type, a: number, ..._rest: any[]);
    readonly a: PageBreakCollection$1<T>;
    readonly b: T;
    readonly c: number;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Base class for the collections of horizontal and vertical page breaks on a [[worksheet]].
 * @typedef T The type of page break the collection contains.
 * @see [[PrintOptions.horizontalPageBreaks]]
 * @see [[PrintOptions.verticalPageBreaks]]
 * @see [[HorizontalPageBreakCollection]]
 * @see [[VerticalPageBreakCollection]]
 */
export declare abstract class PageBreakCollection$1<T extends PageBreak> extends Base implements IList$1<T> {
    static $t: Type;
    protected $t: Type;
    /**
     * @hidden
     */
    _e: PrintOptions;
    private _i;
    constructor($t: Type, a: PrintOptions);
    /**
     * @hidden
     */
    insert(index: number, item: T): void;
    /**
     * @hidden
     */
    _insert$i(a: number, b: T): void;
    /**
     * @hidden
     */
    item(index: number, value?: T): T;
    /**
     * Gets the page break at the specified index.
     * @param index The index of the page break to get.
     * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than 0 or greater than of equal to [[count]].
     * @return A [[PageBreak]]-derived instance.
     */
    item(index: number): T;
    /**
     * @hidden
     */
    _item$e(a: number, b?: T): T;
    /**
     * @hidden
     */
    copyTo(array: T[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    [Symbol.iterator](): EnumeratorWrapper<T>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<T>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a page break to the [[worksheet]].
     * @param pageBreak The page break to add to the Worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'pageBreak' is null.
     * @throws [[ArgumentException]] Occurs when 'pageBreak' overlaps with another page break already in the collection.
     * @see [[PrintOptions.insertPageBreak]]
     * @see [[PrintOptions.insertPageBreak]]
     * @see [[PrintOptions.insertPageBreak]]
     */
    add(pageBreak: T): void;
    /**
     * @hidden
     */
    _add$i(a: T): void;
    /**
     * @hidden
     */
    _g(a: T, b: boolean): boolean;
    /**
     * Clears the collection of page breaks.
     * @see [[PrintOptions.clearPageBreaks]]
     */
    clear(): void;
    /**
     * Determines whether the specified page break exists on the [[worksheet]].
     * @param pageBreak The page break to test.
     * @throws [[ArgumentNullException]] Occurs when 'pageBreak' is null.
     * @return True if the page break is on the Worksheet; False otherwise.
     */
    contains(pageBreak: T): boolean;
    /**
     * @hidden
     */
    _contains$i(a: T): boolean;
    /**
     * Gets the 0-based index of the specified page break.
     * @param pageBreak The page break for which the index should be obtained.
     * @throws [[ArgumentNullException]] Occurs when 'pageBreak' is null.
     * @return The 0-based index of the page break or -1 if the page break is no tin the collection.
     */
    indexOf(pageBreak: T): number;
    /**
     * @hidden
     */
    _indexOf$i(a: T): number;
    /**
     * Removes the specified page break from the [[worksheet]].
     * @param pageBreak The page break which should be removed.
     * @throws [[ArgumentNullException]] Occurs when 'pageBreak' is null.
     * @return True if the page break was contained on the Worksheet before removal; False otherwise.
     * @see [[PrintOptions.clearPageBreaks]]
     */
    remove(pageBreak: T): boolean;
    /**
     * @hidden
     */
    _remove$i(a: T): boolean;
    /**
     * Removes the page break at the specified index.
     * @param index The 0-based index of the page break to remove.
     * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than zero or greater than or equal to the number of page breaks in the collection.
     * @see [[PrintOptions.clearPageBreaks]]
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _k(): number;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _o;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private _n;
    /**
     * @hidden
     */
    private _q;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _s;
    /**
     * Gets the number of page breaks in this collection.
     */
    get count(): number;
    /**
     * @hidden
     */
    _item(a: number): T;
    /**
     * @hidden
     */
    abstract get _h(): boolean;
    /**
     * @hidden
     */
    get _f(): Worksheet;
    /**
     * @hidden
     */
    private static readonly _j;
    /**
     * @hidden
     */
    private static readonly _m;
    /**
     * @hidden
     */
    private static readonly _l;
}
/**
 * A collection of horizontal page breaks on a [[Worksheet]].
 * @see [[PrintOptions.horizontalPageBreaks]]
 * @see [[HorizontalPageBreak]]
 */
export declare class HorizontalPageBreakCollection extends PageBreakCollection$1<HorizontalPageBreak> {
    static $t: Type;
    constructor(a: PrintOptions);
    /**
     * @hidden
     */
    protected get__h(): boolean;
    /**
     * @hidden
     */
    get _h(): boolean;
    /**
     * @hidden
     */
    _t(a: CellShiftOperation): void;
}
/**
 * Represents a vertical page break in a [[Worksheet]].
 * @see [[PrintOptions.verticalPageBreaks]]
 */
export declare class VerticalPageBreak extends PageBreak implements IComparable$1<VerticalPageBreak> {
    static $t: Type;
    constructor(firstColumOnPage: number);
    constructor(firstColumOnPage: number, printArea: WorksheetRegion);
    constructor(firstColumOnPage: number, min: number | null, max: number | null);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    compareTo(other: VerticalPageBreak): number;
    /**
     * @hidden
     */
    private static _s;
    /**
     * Gets the 0-based index of the first column on the page after this break.
     */
    get firstColumnOnPage(): number;
}
/**
 * A collection of horizontal page breaks on a [[Worksheet]].
 * @see [[PrintOptions.verticalPageBreaks]]
 * @see [[VerticalPageBreak]]
 */
export declare class VerticalPageBreakCollection extends PageBreakCollection$1<VerticalPageBreak> {
    static $t: Type;
    constructor(a: PrintOptions);
    /**
     * @hidden
     */
    protected get__h(): boolean;
    /**
     * @hidden
     */
    get _h(): boolean;
}
/**
 * @hidden
 */
export declare class PrintAreasCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: PrintAreasCollection, c: WorksheetRegion, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: PrintAreasCollection;
    readonly b: WorksheetRegion;
    readonly c: number;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Gets the collection of print areas in a [[Worksheet]] or a worksheet's print settings in a [[CustomView]].
 * @see [[PrintOptions.printAreas]]
 */
export declare class PrintAreasCollection extends Base implements ICollection$1<WorksheetRegion> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _i;
    /**
     * @hidden
     */
    private static readonly _j;
    /**
     * @hidden
     */
    private static readonly _l;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static _a;
    private _g;
    private _h;
    /**
     * @hidden
     */
    _d: PrintOptions;
    static staticInit(): void;
    constructor(a: PrintOptions);
    /**
     * @hidden
     */
    copyTo(array: WorksheetRegion[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetRegion>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetRegion>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a print area to the collection.
     * @param printArea The print area to add to the collection.
     * @throws [[ArgumentNullException]] Occurs when 'printArea' is null.
     * @throws [[ArgumentException]] Occurs when 'printArea' overlaps with another print area in the collection.
     */
    add(printArea: WorksheetRegion): void;
    /**
     * @hidden
     */
    _o(a: WorksheetRegion, b: boolean): void;
    /**
     * Clears all print areas from the collection.
     * <p class="body">
     * If any page breaks are contained in a print area, they will be removed from their collection.
     * </p>
     * @see [[PrintOptions.horizontalPageBreaks]]
     * @see [[PrintOptions.verticalPageBreaks]]
     */
    clear(): void;
    /**
     * Determines whether the specified print area is in the collection.
     * @param printArea The print area to search for in the collection.
     * @return True if the print area is in the collection; False otherwise.
     */
    contains(printArea: WorksheetRegion): boolean;
    /**
     * Removes the specified print area from the collection.
     * <p class="body">
     * If any page breaks are contained in the removed print area, they will be removed from their collection.
     * </p>
     * @param printArea The print area to remove from the collection.
     * @throws [[ArgumentNullException]] Occurs when 'printArea' is null.
     * @return True if the print area was found and removed; False otherwise.
     * @see [[PrintOptions.horizontalPageBreaks]]
     * @see [[PrintOptions.verticalPageBreaks]]
     */
    remove(printArea: WorksheetRegion): boolean;
    /**
     * Removes the print area at the specified index from the collection.
     * <p class="body">
     * If any page breaks are contained in the removed print area, they will be removed from their collection.
     * </p>
     * @param index The index of the print area to remove from the collection.
     * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than 0 or greater than or equal to the size of the collection.
     * @see [[PrintOptions.horizontalPageBreaks]]
     * @see [[PrintOptions.verticalPageBreaks]]
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _m(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    _n(): void;
    /**
     * @hidden
     */
    _e(a: number, b: Nullable$1<number>, c: Nullable$1<number>, d: boolean): WorksheetRegion;
    /**
     * @hidden
     */
    _t(a: RefBase, b: boolean): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private _q;
    /**
     * @hidden
     */
    private _s;
    /**
     * Gets the number of print areas in the collection.
     */
    get count(): number;
    /**
     * Gets the print area at the specified index.
     * @param index The index of the print area to get.
     * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than 0 or greater than or equal to the size of the collection.
     * @return A [[WorksheetRegion]] instance representing a print area in the [[Worksheet]].
     */
    item(a: number): WorksheetRegion;
}
/**
 * Base class which exposes the various print options available for a sheet which can be saved with both a
 * sheet and its custom view.
 * <p class="body">
 * This class provides a way to control how a sheet is printed.
 * </p>
 * @see [[Worksheet.printOptions]]
 * @see [[CustomView.getPrintOptions]]
 */
export declare abstract class PrintOptionsBase extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _am: number;
    /**
     * @hidden
     */
    static readonly _ao: number;
    /**
     * @hidden
     */
    static readonly _an: number;
    /**
     * @hidden
     */
    static readonly _aj: number;
    /**
     * @hidden
     */
    static readonly _al: number;
    /**
     * @hidden
     */
    static readonly _ak: number;
    /**
     * @hidden
     */
    static readonly _k: PaperSize;
    /**
     * @hidden
     */
    static readonly _a2: number;
    /**
     * @hidden
     */
    static readonly _z: boolean;
    /**
     * @hidden
     */
    static readonly _y: boolean;
    /**
     * @hidden
     */
    static readonly _q: PrintNotes;
    /**
     * @hidden
     */
    static readonly _h: PageNumbering;
    /**
     * @hidden
     */
    static readonly _n: PrintErrors;
    /**
     * @hidden
     */
    static readonly _a1: number;
    /**
     * @hidden
     */
    static readonly _a3: number;
    /**
     * @hidden
     */
    static readonly _a0: number;
    /**
     * @hidden
     */
    static readonly _x: boolean;
    /**
     * @hidden
     */
    static readonly _aa: boolean;
    /**
     * @hidden
     */
    private static readonly _az;
    /**
     * @hidden
     */
    private static readonly _a4;
    /**
     * @hidden
     */
    private static readonly _a5;
    /**
     * @hidden
     */
    private static readonly _a6;
    /**
     * @hidden
     */
    private static readonly _a7;
    /**
     * @hidden
     */
    private static readonly _a8;
    /**
     * @hidden
     */
    private static readonly _a9;
    /**
     * @hidden
     */
    private static readonly _bd;
    /**
     * @hidden
     */
    private static readonly _be;
    /**
     * @hidden
     */
    private static readonly _bf;
    /**
     * @hidden
     */
    private static readonly _bg;
    /**
     * @hidden
     */
    private static readonly _bh;
    /**
     * @hidden
     */
    private static readonly _bi;
    /**
     * @hidden
     */
    private static readonly _bj;
    /**
     * @hidden
     */
    private static readonly _bm;
    /**
     * @hidden
     */
    private static readonly _bn;
    /**
     * @hidden
     */
    private static readonly _bq;
    /**
     * @hidden
     */
    private static readonly _br;
    /**
     * @hidden
     */
    private static readonly _bu;
    /**
     * @hidden
     */
    private static readonly _ba;
    /**
     * @hidden
     */
    private static readonly _a;
    private _t;
    private _at;
    private _ax;
    private _av;
    private _ah;
    private _ar;
    private _ap;
    private _ab;
    private _bv;
    private _bx;
    private _bb;
    private _e;
    private _i;
    private _l;
    private _o;
    private _ad;
    private _r;
    private _bk;
    private _bo;
    private _bs;
    /**
     * @hidden
     */
    readonly _v: boolean;
    constructor(a: Sheet, b: boolean);
    /**
     * Resets the print options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    reset(): void;
    /**
     * @hidden
     */
    _bz(a: PrintOptionsBase): void;
    /**
     * @hidden
     */
    _ag(): boolean;
    /**
     * @hidden
     */
    _b1(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    get _u(): Sheet;
    /**
     * @hidden
     */
    _c: BinaryData;
    private _alignHeadersAndFootersWithMargins;
    /**
     * Gets or sets the value indicating whether to align header and footer margins with page margins.
     * @see [[header]]
     * @see [[footer]]
     * @see [[headerMargin]]
     * @see [[footerMargin]]
     * @see [[leftMargin]]
     * @see [[rightMargin]]
     */
    get alignHeadersAndFootersWithMargins(): boolean;
    set alignHeadersAndFootersWithMargins(a: boolean);
    /**
     * Gets or sets the margin at the bottom of each printed page of the worksheet, specified in inches.
     * The margin at the bottom of each printed page of the worksheet, specified in inches.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
     * @see [[footerMargin]]
     * @see [[headerMargin]]
     * @see [[leftMargin]]
     * @see [[rightMargin]]
     * @see [[topMargin]]
     */
    get bottomMargin(): number;
    set bottomMargin(a: number);
    /**
     * Gets or sets the value indicating whether the printed pages should be printed using draft quality.
     * The value indicating whether the printed pages should be printed using draft quality.
     */
    get draftQuality(): boolean;
    set draftQuality(a: boolean);
    /**
     * Gets or sets the footer for each page of the printed worksheet.
     * <p class="body">
     * The '&' character in the header and footer is a special character. Depending on what is after it,
     * the formatting of the text can be controlled or dynamic text can be inserted. Below is a list of
     * the available commands:
     * <list type="table">
     * 		<listheader>
     * 			<term>Section commands</term>
     * 		</listheader>
     * 		<item>
     * 			<term>&L</term>
     * 			<description>
     * 				The following text will appear in the left section. The formatting of new sections is
     * 				always the default formatting, regardless of the formatting of the previous section.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&C</term>
     * 			<description>
     * 				The following text will appear in the center section. The formatting of new sections is
     * 				always the default formatting, regardless of the formatting of the previous section.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&R</term>
     * 			<description>
     * 				The following text will appear in the right section. The formatting of new sections is
     * 				always the default formatting, regardless of the formatting of the previous section.
     * 			</description>
     * 		</item>
     * </list>
     * <list type="table">
     * 		<listheader>
     * 			<term>Replacement commands</term>
     * 		</listheader>
     * 		<item>
     * 			<term>&&</term>
     * 			<description>Insert the '&' character.</description>
     * 		</item>
     * 		<item>
     * 			<term>&A</term>
     * 			<description>Insert the current worksheet name.</description>
     * 		</item>
     * 		<item>
     * 			<term>&D</term>
     * 			<description>Insert the current date.</description>
     * 		</item>
     * 		<item>
     * 			<term>&F</term>
     * 			<description>Insert the current file name.</description>
     * 		</item>
     * 		<item>
     * 			<term>&G</term>
     * 			<description>Insert an image (<b>Note:</b> This command is currently not supported).</description>
     * 		</item>
     * 		<item>
     * 			<term>&N</term>
     * 			<description>Insert the  number of pages the worksheet will need to print.</description>
     * 		</item>
     * 		<item>
     * 			<term>&P</term>
     * 			<description>Insert the current page number.</description>
     * 		</item>
     * 		<item>
     * 			<term>&T</term>
     * 			<description>Insert the current time.</description>
     * 		</item>
     * 		<item>
     * 			<term>&Z</term>
     * 			<description>Insert the current file path (without the file name).</description>
     * 		</item>
     * </list>
     * <list type="table">
     * 	<listheader>
     * 			<term>Formatting commands</term>
     * 		</listheader>
     * 		<item>
     * 			<term>&B</term>
     * 			<description>Toggle bold.</description>
     * 		</item>
     * 		<item>
     * 			<term>&E</term>
     * 			<description>Toggle double underlining.</description>
     * 		</item>
     * 		<item>
     * 			<term>&I</term>
     * 			<description>Toggle italics.</description>
     * 		</item>
     * 		<item>
     * 			<term>&S</term>
     * 			<description>Toggle strikethrough.</description>
     * 		</item>
     * 		<item>
     * 			<term>&U</term>
     * 			<description>Toggle underlining.</description>
     * 		</item>
     * 		<item>
     * 			<term>&X</term>
     * 			<description>Toggle superscript.</description>
     * 		</item>
     * 		<item>
     * 			<term>&Y</term>
     * 			<description>Toggle subscript.</description>
     * 		</item>
     * 		<item>
     * 			<term>&<FontSize></term>
     * 			<description>
     * 				Sets a new font size for the following text. The size is expressed as a positive integer.
     * 				If a number is to follow this command in the header, it must be separated by a space.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&"<FontName>"</term>
     * 			<description>
     * 				Sets a new font for the following text. If the font name is not recognized, the default
     * 				font will be used.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&"<FontName>,<FontStyle>"</term>
     * 			<description>
     * 				Sets the new font and font style for the following text. The font style is usually "Regular",
     * 				"Bold", "Italic", or "Bold Italic", but	can be other styles depending on the font. The
     * 				available font styles can be seen in the font dialog when a font is selected.
     * 			</description>
     * 		</item>
     * 	</list>
     * </p>
     * <p class="body">
     * The header or footer string could look like this: &L&"Arial,Bold"&D&CPage &P of
     * &N on &A&R&14&F.
     * </p>
     * The footer for each page of the worksheet.
     * @see [[header]]
     * @see [[footerMargin]]
     */
    get footer(): string;
    set footer(a: string);
    /**
     * Gets or sets the footer margin for each printed page of the worksheet, specified in inches.
     * The footer margin for each printed page of the worksheet, specified in inches.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
     * @see [[footer]]
     * @see [[bottomMargin]]
     * @see [[headerMargin]]
     * @see [[leftMargin]]
     * @see [[rightMargin]]
     * @see [[topMargin]]
     */
    get footerMargin(): number;
    set footerMargin(a: number);
    /**
     * Gets or sets the header for each page of the printed worksheet.
     * <p class="body">
     * The '&' character in the header and footer is a special character. Depending on what is after it,
     * the formatting of the text can be controlled or dynamic text can be inserted. Below is a list of
     * the available commands:
     * <list type="table">
     * 		<listheader>
     * 			<term>Section commands</term>
     * 		</listheader>
     * 		<item>
     * 			<term>&L</term>
     * 			<description>
     * 				The following text will appear in the left section. The formatting of new sections is
     * 				always the default formatting, regardless of the formatting of the previous section.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&C</term>
     * 			<description>
     * 				The following text will appear in the center section. The formatting of new sections is
     * 				always the default formatting, regardless of the formatting of the previous section.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&R</term>
     * 			<description>
     * 				The following text will appear in the right section. The formatting of new sections is
     * 				always the default formatting, regardless of the formatting of the previous section.
     * 			</description>
     * 		</item>
     * </list>
     * <list type="table">
     * 		<listheader>
     * 			<term>Replacement commands</term>
     * 		</listheader>
     * 		<item>
     * 			<term>&&</term>
     * 			<description>Insert the '&' character.</description>
     * 		</item>
     * 		<item>
     * 			<term>&A</term>
     * 			<description>Insert the current worksheet name.</description>
     * 		</item>
     * 		<item>
     * 			<term>&D</term>
     * 			<description>Insert the current date.</description>
     * 		</item>
     * 		<item>
     * 			<term>&F</term>
     * 			<description>Insert the current file name.</description>
     * 		</item>
     * 		<item>
     * 			<term>&G</term>
     * 			<description>Insert an image (<b>Note:</b> This command is currently not supported).</description>
     * 		</item>
     * 		<item>
     * 			<term>&N</term>
     * 			<description>Insert the  number of pages the worksheet will need to print.</description>
     * 		</item>
     * 		<item>
     * 			<term>&P</term>
     * 			<description>Insert the current page number.</description>
     * 		</item>
     * 		<item>
     * 			<term>&T</term>
     * 			<description>Insert the current time.</description>
     * 		</item>
     * 		<item>
     * 			<term>&Z</term>
     * 			<description>Insert the current file path (without the file name).</description>
     * 		</item>
     * </list>
     * <list type="table">
     * 	<listheader>
     * 			<term>Formatting commands</term>
     * 		</listheader>
     * 		<item>
     * 			<term>&B</term>
     * 			<description>Toggle bold.</description>
     * 		</item>
     * 		<item>
     * 			<term>&E</term>
     * 			<description>Toggle double underlining.</description>
     * 		</item>
     * 		<item>
     * 			<term>&I</term>
     * 			<description>Toggle italics.</description>
     * 		</item>
     * 		<item>
     * 			<term>&S</term>
     * 			<description>Toggle strikethrough.</description>
     * 		</item>
     * 		<item>
     * 			<term>&U</term>
     * 			<description>Toggle underlining.</description>
     * 		</item>
     * 		<item>
     * 			<term>&X</term>
     * 			<description>Toggle superscript.</description>
     * 		</item>
     * 		<item>
     * 			<term>&Y</term>
     * 			<description>Toggle subscript.</description>
     * 		</item>
     * 		<item>
     * 			<term>&<FontSize></term>
     * 			<description>
     * 				Sets a new font size for the following text. The size is expressed as a positive integer.
     * 				If a number is to follow this command in the header, it must be separated by a space.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&"<FontName>"</term>
     * 			<description>
     * 				Sets a new font for the following text. If the font name is not recognized, the default
     * 				font will be used.
     * 			</description>
     * 		</item>
     * 		<item>
     * 			<term>&"<FontName>,<FontStyle>"</term>
     * 			<description>
     * 				Sets the new font and font style for the following text. The font style is usually "Regular",
     * 				"Bold", "Italic", or "Bold Italic", but	can be other styles depending on the font. The
     * 				available font styles can be seen in the font dialog when a font is selected.
     * 			</description>
     * 		</item>
     * 	</list>
     * </p>
     * <p class="body">
     * The header or footer string could look like this: &L&"Arial,Bold"&D&CPage &P of
     * &N on &A&R&14&F.
     * </p>
     * The header for each page of the worksheet.
     * @see [[footer]]
     * @see [[headerMargin]]
     */
    get header(): string;
    set header(a: string);
    /**
     * Gets or sets the header margin for each printed page of the worksheet, specified in inches.
     * The header margin for each printed page of the worksheet, specified in inches.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
     * @see [[header]]
     * @see [[bottomMargin]]
     * @see [[footerMargin]]
     * @see [[leftMargin]]
     * @see [[rightMargin]]
     * @see [[topMargin]]
     */
    get headerMargin(): number;
    set headerMargin(a: number);
    /**
     * Gets or sets the margin at the left of each printed page of the worksheet, specified in inches.
     * The margin at the left of each printed page of the worksheet, specified in inches.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
     * @see [[bottomMargin]]
     * @see [[footerMargin]]
     * @see [[headerMargin]]
     * @see [[rightMargin]]
     * @see [[topMargin]]
     */
    get leftMargin(): number;
    set leftMargin(a: number);
    /**
     * Gets or sets the number of copies to print.
     * The number of copies to print.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 1 and 65535.
     */
    get numberOfCopies(): number;
    set numberOfCopies(a: number);
    /**
     * Gets or sets the orientation for each page of the printed worksheet.
     * The orientation for each page of the printed worksheet.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[orientation]] enumeration.
     */
    get orientation(): Orientation;
    set orientation(a: Orientation);
    /**
     * Returns the resolved orientation for each page of the printed worksheet.
     */
    get orientationResolved(): Orientation;
    /**
     * Gets or sets the method with which pages are numbered.
     * <p class="body">
     * If this is set to a value of UseStartPageNumber, the first page is numbered using the [[startPageNumber]].
     * </p>
     * The method with which pages are numbered.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[pageNumbering]] enumeration.
     * @see [[startPageNumber]]
     */
    get pageNumbering(): PageNumbering;
    set pageNumbering(a: PageNumbering);
    /**
     * Gets or sets the paper size for each printed page of the worksheet.
     * The paper size for each printed page of the worksheet.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[paperSize]] enumeration.
     */
    get paperSize(): PaperSize;
    set paperSize(a: PaperSize);
    /**
     * Gets or sets the way error values of cells are printed.
     * <p class="body">
     * A cell can have an error value if its [[WorksheetCell.value]] is set directly to
     * an [[ErrorValue]] or if it is set to a [[Formula]] that evaluates to an
     * error.
     * </p>
     * The way error values of cells are printed.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[printErrors]] enumeration.
     * @see [[ErrorValue]]
     * @see [[Formula]]
     */
    get printErrors(): PrintErrors;
    set printErrors(a: PrintErrors);
    /**
     * Gets or sets the value indicating whether the worksheet should be printed in black and white.
     * The value indicating whether the worksheet should be printed in black and white.
     */
    get printInBlackAndWhite(): boolean;
    set printInBlackAndWhite(a: boolean);
    /**
     * Gets or sets the way cell comments are printed.
     * <p class="body">
     * If this is set to a value of PrintAsDisplayed, the comments will only print if they are displayed on the worksheet.
     * If comments are hidden but indicators are shown, neither the indicators nor the comments will print.
     * </p>
     * The way cell notes are printed.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[printNotes]] enumeration.
     * @see [[WorksheetCell.comment]]
     * @see [[WorksheetCellComment]]
     */
    get printNotes(): PrintNotes;
    set printNotes(a: PrintNotes);
    /**
     * Gets or sets the horizontal print resolution in DPI.
     * The horizontal print resolution in DPI.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 65535.
     * @see [[verticalResolution]]
     */
    get resolution(): number;
    set resolution(a: number);
    /**
     * Gets or sets the margin at the right of each printed page of the worksheet, specified in inches.
     * The margin at the right of each printed page of the worksheet, specified in inches.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
     * @see [[bottomMargin]]
     * @see [[footerMargin]]
     * @see [[headerMargin]]
     * @see [[leftMargin]]
     * @see [[topMargin]]
     */
    get rightMargin(): number;
    set rightMargin(a: number);
    private _scaleHeadersAndFootersWithDocument;
    /**
     * Gets or sets the value indicating whether to scale the headers and footers with the document scaling.
     * @see [[header]]
     * @see [[footer]]
     * @see [[PrintOptions.scalingFactor]]
     * @see [[ScalingType]]
     */
    get scaleHeadersAndFootersWithDocument(): boolean;
    set scaleHeadersAndFootersWithDocument(a: boolean);
    /**
     * Gets or sets the page number for the first printed page of the worksheet.
     * <p class="body">
     * For this value to be used, [[pageNumbering]] must be set to a value of UseStartPageNumber.
     * </p>
     * The page number for the first printed page of the worksheet.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of -32765 and 32767.
     * @see [[pageNumbering]]
     */
    get startPageNumber(): number;
    set startPageNumber(a: number);
    /**
     * Gets or sets the margin at the top of each printed page of the worksheet, specified in inches.
     * The margin at the top of each printed page of the worksheet, specified in inches.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid margin range of 0 and 100 inches.
     * @see [[bottomMargin]]
     * @see [[footerMargin]]
     * @see [[headerMargin]]
     * @see [[leftMargin]]
     * @see [[rightMargin]]
     */
    get topMargin(): number;
    set topMargin(a: number);
    /**
     * Gets or sets the vertical print resolution in DPI.
     * The vertical print resolution in DPI.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 65535.
     * @see [[resolution]]
     */
    get verticalResolution(): number;
    set verticalResolution(a: number);
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
}
/**
 * Represents a range of contiguous rows or columns which should be repeated at the top or left or printed pages of the [[Worksheet]].
 * @see [[PrintOptions.columnsToRepeatAtLeft]]
 * @see [[PrintOptions.rowsToRepeatAtTop]]
 */
export declare class RepeatTitleRange extends Base {
    static $t: Type;
    private readonly _b;
    private readonly _e;
    constructor(startIndex: number, endIndex: number);
    /**
     * Determines whether the specified value equals this [[RepeatTitleRange]].
     * @param obj The value to test for equality.
     */
    equals(obj: any): boolean;
    /**
     * Gtes the hash code for the [[RepeatTitleRange]].
     */
    getHashCode(): number;
    /**
     * Gets the string representation of the range.
     * @return The string representation of the range.
     */
    toString(): string;
    /**
     * Gets the index of the last row or column in the range.
     * @see [[RowColumnBase.index]]
     */
    get endIndex(): number;
    /**
     * Gets the index of the first row or column in the range.
     * @see [[RowColumnBase.index]]
     */
    get startIndex(): number;
}
/**
 * Class which exposes the various print options available for a worksheet which can be saved with both a
 * worksheet and a custom view.
 * <p class="body">
 * This class provides a way to control how a worksheet is printed.
 * </p>
 * @see [[Worksheet.printOptions]]
 * @see [[CustomView.getPrintOptions]]
 */
export declare class PrintOptions extends PrintOptionsBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _c1: number;
    /**
     * @hidden
     */
    static readonly _cz: number;
    /**
     * @hidden
     */
    static readonly _c0: number;
    /**
     * @hidden
     */
    static readonly _b7: PageOrder;
    /**
     * @hidden
     */
    private static readonly _cw;
    /**
     * @hidden
     */
    private static readonly _cx;
    /**
     * @hidden
     */
    private static readonly _cy;
    /**
     * @hidden
     */
    private static readonly _c4;
    /**
     * @hidden
     */
    private static readonly _c7;
    /**
     * @hidden
     */
    private static readonly _c9;
    /**
     * @hidden
     */
    private static readonly _da;
    /**
     * @hidden
     */
    private static readonly _db;
    /**
     * @hidden
     */
    private static readonly _dc;
    /**
     * @hidden
     */
    private static readonly _df;
    /**
     * @hidden
     */
    private static readonly _dg;
    /**
     * @hidden
     */
    private static readonly _c8;
    /**
     * @hidden
     */
    private static readonly _b2;
    private _cl;
    private _cn;
    private _c2;
    private _c5;
    private _b8;
    private _dd;
    private _cg;
    private _cs;
    private _cu;
    private _b5;
    private _ci;
    private _cc;
    private _ca;
    private _ce;
    constructor(a: Worksheet, b: boolean);
    /**
     * Clears all page breaks from the [[PrintOptions]].
     * @see [[PageBreakCollection`1.clear]]
     * @see [[PageBreakCollection`1.remove]]
     * @see [[PageBreakCollection`1.removeAt]]
     */
    clearPageBreaks(): void;
    /**
     * Inserts a horizontal and/or vertical page break before the specified cell.
     * <p class="body">
     * If the cell is not contained in one of the print areas in the [[printAreas]] collection, the page breaks added will be as follows:
     * If the cell is at the top-left corner of the [[Worksheet]], an exception will be thrown. If the cell is on the left edge of the
     * Worksheet, a horizontal page break will be inserted above the cell. If the cell is on the top edge of the Worksheet, a vertical page break
     * will be inserted to the left of the cell. If the cell is anywhere else in the Worksheet, a horizontal page break will be inserted above the
     * cell and a vertical page break will be inserted to the left of the cell.
     * </p>
     * <p class="body">
     * If the cell is contained in one of the print areas in the [[printAreas]] collection, the page breaks added will be as follows:
     * If the cell is at the top-left corner of the print area, no page breaks will be inserted. If the cell is on the left edge of the print area,
     * a horizontal page break will be inserted above the cell. If the cell is on the top edge of the print area, a vertical page break will be
     * inserted to the left of the cell. If the cell is anywhere else in the print area, a horizontal page break will be inserted above the cell
     * and a vertical page break will be inserted to the left of the cell.
     * </p>
     * <p class="body">
     * When page breaks are inserted in a print area, they will only extend to the edges of the print area.
     * </p>
     * @param cell The cell at which to insert the page break(s).
     * @throws [[ArgumentNullException]] Occurs when 'cell' is null.
     * @throws [[ArgumentException]] Occurs when 'cell' is at the top-left corner of the [[Worksheet]].
     * @see [[horizontalPageBreaks]]
     * @see [[verticalPageBreaks]]
     * @see [[clearPageBreaks]]
     * @see [[insertPageBreak]]
     * @see [[insertPageBreak]]
     * @see [[printAreas]]
     */
    insertPageBreak(cell: WorksheetCell): void;
    /**
     * Inserts a vertical page break to the left of the specified column.
     * <p class="body">
     * If the column is not contained in one of the print areas in the [[printAreas]] collection, the page breaks added will be as follows:
     * If the column is at the left edge of the [[Worksheet]], an exception will be thrown. If the column is anywhere else in the Worksheet,
     * a vertical page break will be inserted to the left of the column.
     * </p>
     * <p class="body">
     * If the column is contained in one of the print areas in the [[printAreas]] collection, the page breaks added will be as follows:
     * If the column is at the left edge of the print area, no page break will be inserted. If the column is anywhere else in the print area, a
     * vertical page break will be inserted to the left of the column.
     * </p>
     * @param column The column at which to insert the page break.
     * @throws [[ArgumentNullException]] Occurs when 'column' is null.
     * @throws [[ArgumentException]] Occurs when 'column' is at the left edge of the [[Worksheet]].
     * @see [[verticalPageBreaks]]
     * @see [[clearPageBreaks]]
     * @see [[insertPageBreak]]
     * @see [[insertPageBreak]]
     * @see [[printAreas]]
     */
    insertPageBreak(column: WorksheetColumn): void;
    /**
     * Inserts a horizontal page break above the specified row.
     * <p class="body">
     * If the row is not contained in one of the print areas in the [[printAreas]] collection, the page breaks added will be as follows:
     * If the row is at the top edge of the [[Worksheet]], an exception will be thrown. If the row is anywhere else in the Worksheet,
     * a horizontal page break will be inserted above the row.
     * </p>
     * <p class="body">
     * If the row is contained in one of the print areas in the [[printAreas]] collection, the page breaks added will be as follows:
     * If the row is at the top edge of the print area, no page break will be inserted. If the row is anywhere else in the print area, a
     * horizontal page break will be inserted above the row.
     * </p>
     * @param row The row at which to insert the page break.
     * @throws [[ArgumentNullException]] Occurs when 'row' is null.
     * @throws [[ArgumentException]] Occurs when 'row' is at the top edge of the [[Worksheet]].
     * @see [[horizontalPageBreaks]]
     * @see [[clearPageBreaks]]
     * @see [[insertPageBreak]]
     * @see [[insertPageBreak]]
     * @see [[printAreas]]
     */
    insertPageBreak(row: WorksheetRow): void;
    /**
     * @hidden
     */
    _insertPageBreak(a: WorksheetCell): void;
    /**
     * @hidden
     */
    _insertPageBreak1(a: WorksheetColumn): void;
    /**
     * @hidden
     */
    _insertPageBreak2(a: WorksheetRow): void;
    /**
     * Resets the print options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    reset(): void;
    /**
     * @hidden
     */
    _bz(a: PrintOptionsBase): void;
    /**
     * @hidden
     */
    _dq(a: number, b: boolean): void;
    /**
     * @hidden
     */
    _ag(): boolean;
    /**
     * @hidden
     */
    _ds(a: boolean): void;
    /**
     * @hidden
     */
    _dr(a: Workbook, b: string, c: boolean, d: NamedReference, e: boolean): {
        p3?: NamedReference;
        p4: boolean;
    };
    /**
     * @hidden
     */
    _dt(a: Workbook, b: string, c: boolean, d: NamedReference, e: boolean): {
        p3?: NamedReference;
        p4: boolean;
    };
    /**
     * @hidden
     */
    private _dv;
    /**
     * @hidden
     */
    _b1(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    private static _b4;
    /**
     * @hidden
     */
    private static _b3;
    /**
     * @hidden
     */
    private _du;
    /**
     * @hidden
     */
    get _ck(): Worksheet;
    /**
     * Gets or sets the value indicating whether the printed pages should be centered horizontally.
     * The value indicating whether the printed pages should be centered horizontally.
     * @see [[centerVertically]]
     */
    get centerHorizontally(): boolean;
    set centerHorizontally(a: boolean);
    /**
     * Gets or sets the value indicating whether the printed pages should be centered vertically.
     * The value indicating whether the printed pages should be centered vertically.
     * @see [[centerHorizontally]]
     */
    get centerVertically(): boolean;
    set centerVertically(a: boolean);
    /**
     * Gets or sets the range of columns which should be printed on every page.
     * @throws [[ArgumentException]] @see [[RepeatTitleRange.endIndex]]
     * Occurs when the value specified is not null and its  value is greater than or equal
     * to the number of columns in the [[Worksheet]].
     * @see [[rowsToRepeatAtTop]]
     */
    get columnsToRepeatAtLeft(): RepeatTitleRange;
    set columnsToRepeatAtLeft(a: RepeatTitleRange);
    /**
     * @hidden
     */
    _dl(a: RepeatTitleRange, b: boolean): void;
    /**
     * @hidden
     */
    private static _dm;
    /**
     * Gets the page break at the specified index.
     * @param index The index of the page break to get.
     * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than 0 or greater than of equal to [[PageBreakCollection`1.count]].
     * @return A [[PageBreak]]-derived instance.
     */
    horizontalPageBreaks(index: number): HorizontalPageBreak;
    /**
     * Gets the collection of horizontal page breaks in the [[Worksheet]].
     * @see [[HorizontalPageBreak]]
     * @see [[clearPageBreaks]]
     * @see [[insertPageBreak]]
     * @see [[insertPageBreak]]
     * @see [[insertPageBreak]]
     */
    horizontalPageBreaks(): HorizontalPageBreakCollection;
    /**
     * @hidden
     */
    get _horizontalPageBreaks$i(): HorizontalPageBreakCollection;
    /**
     * @hidden
     */
    get _cp(): boolean;
    /**
     * Gets or sets the maximum number of pages allowed in the horizontal direction to print the worksheet.
     * <p class="body">
     * A value of zero indicates no maximum is used in the horizontal direction. As many pages as needed will be used.
     * </p>
     * <p class="note">
     * <B>Note:</B> For MaxPagesHorizontally and [[maxPagesVertically]] to affect the way the worksheet is printed,
     * [[scalingType]] must be set to a value of FitToPages. However, if the the ScalingType is different
     * and these values aren't used, they will still be saved with the worksheet.
     * </p>
     * The maximum number of pages allowed in the horizontal direction to print the worksheet.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 32767.
     * @see [[maxPagesVertically]]
     * @see [[scalingType]]
     */
    get maxPagesHorizontally(): number;
    set maxPagesHorizontally(a: number);
    /**
     * Gets or sets the maximum number of pages allowed in the vertical direction to print the worksheet.
     * <p class="body">
     * A value of zero indicates no maximum is used in the vertical direction. As many pages as needed will be used.
     * </p>
     * <p class="note">
     * <B>Note:</B> For [[maxPagesHorizontally]] and MaxPagesVertically to affect the way the worksheet is printed,
     * [[scalingType]] must be set to a value of FitToPages. However, if the the ScalingType is different
     * and these values aren't used, they will still be saved with the worksheet.
     * </p>
     * The maximum number of pages allowed in the vertical direction to print the worksheet.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is outside the valid range of 0 and 32767.
     * @see [[maxPagesHorizontally]]
     * @see [[scalingType]]
     */
    get maxPagesVertically(): number;
    set maxPagesVertically(a: number);
    /**
     * Gets or sets the order in which to print pages for multiple page worksheets.
     * The order in which to print pages for multiple page worksheets.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[pageOrder]] enumeration.
     */
    get pageOrder(): PageOrder;
    set pageOrder(a: PageOrder);
    /**
     * Gets the print area at the specified index.
     * @param index The index of the print area to get.
     * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than 0 or greater than or equal to the size of the collection.
     * @return A [[WorksheetRegion]] instance representing a print area in the [[Worksheet]].
     */
    printAreas(index: number): WorksheetRegion;
    /**
     * Gets the collection of print areas in the [[Worksheet]].
     */
    printAreas(): PrintAreasCollection;
    /**
     * @hidden
     */
    get _printAreas$i(): PrintAreasCollection;
    /**
     * @hidden
     */
    get _cq(): boolean;
    /**
     * Gets or sets the value which indicates whether to print the worksheet gridlines.
     * The value which indicates whether to print the worksheet gridlines.
     * @see [[DisplayOptions.showGridlines]]
     */
    get printGridlines(): boolean;
    set printGridlines(a: boolean);
    /**
     * Gets or sets the value indicating whether to print row and column headers.
     * <p class="body">
     * The row and column headers show the identifier of the row or column.
     * </p>
     * The value indicating whether to print row and column headers.
     * @see [[DisplayOptions.showRowAndColumnHeaders]]
     */
    get printRowAndColumnHeaders(): boolean;
    set printRowAndColumnHeaders(a: boolean);
    /**
     * Gets or sets the range of rows which should be printed on every page.
     * @throws [[ArgumentException]] @see [[RepeatTitleRange.endIndex]]
     * Occurs when the value specified is not null and its  value is greater than or equal
     * to the number of rows in the [[Worksheet]].
     * @see [[columnsToRepeatAtLeft]]
     */
    get rowsToRepeatAtTop(): RepeatTitleRange;
    set rowsToRepeatAtTop(a: RepeatTitleRange);
    /**
     * @hidden
     */
    _dn(a: RepeatTitleRange, b: boolean): void;
    /**
     * @hidden
     */
    private static _dp;
    /**
     * Gets or sets the scaling factor to use when printing the worksheet.
     * <p class="body">
     * The scaling factor is similar to magnifications in that is it stored as a percentage of the normal scaling.
     * A value of 100 indicates normal scaling whereas a value of 200 indicates the worksheet is scaled to twice its
     * normal size.
     * </p>
     * <p class="note">
     * <B>Note:</B> For ScalingFactor to affect the way the worksheet is printed, [[scalingType]] must be
     * set to a value of UseScalingFactor.
     * </p>
     * The scaling factor to use when printing the worksheet.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of 10 and 400.
     * @see [[scalingType]]
     * @see [[WorksheetDisplayOptions.magnificationInNormalView]]
     * @see [[WorksheetDisplayOptions.magnificationInPageBreakView]]
     * @see [[WorksheetDisplayOptions.magnificationInPageLayoutView]]
     * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
     */
    get scalingFactor(): number;
    set scalingFactor(a: number);
    /**
     * Gets or sets the method for scaling the worksheet when it is printed.
     * <p class="body">
     * If this is set to a value of UseScalingFactor, [[scalingFactor]] is used to uniformly scale
     * the worksheet on the printed pages.
     * </p>
     * <p class="body">
     * If this is set to a value of FitToPages, [[maxPagesHorizontally]] and [[maxPagesVertically]]
     * are used to set the maximum number of pages to fit the printed worksheet into in both directions.
     * </p>
     * The method for scaling the worksheet when it is printed.
     * @throws [[InvalidEnumArgumentException]] The assigned value is not defined in the [[scalingType]] enumeration.
     * @see [[maxPagesHorizontally]]
     * @see [[maxPagesVertically]]
     * @see [[scalingFactor]]
     */
    get scalingType(): ScalingType;
    set scalingType(a: ScalingType);
    /**
     * Gets the page break at the specified index.
     * @param index The index of the page break to get.
     * @throws [[ArgumentOutOfRangeException]] Occurs when 'index' is less than 0 or greater than of equal to [[PageBreakCollection`1.count]].
     * @return A [[PageBreak]]-derived instance.
     */
    verticalPageBreaks(index: number): VerticalPageBreak;
    /**
     * Gets the collection of vertical page breaks in the [[Worksheet]].
     * @see [[VerticalPageBreak]]
     * @see [[clearPageBreaks]]
     * @see [[insertPageBreak]]
     * @see [[insertPageBreak]]
     * @see [[insertPageBreak]]
     */
    verticalPageBreaks(): VerticalPageBreakCollection;
    /**
     * @hidden
     */
    get _verticalPageBreaks$i(): VerticalPageBreakCollection;
    /**
     * @hidden
     */
    get _cr(): boolean;
}
/**
 * Provides information about the types of changes that are disabled when the associated Workbook is protected.
 * @see [[Workbook.hasProtectionPassword]]
 * @see [[Workbook.isProtected]]
 * @see [[Workbook.protection]]
 * @see [[Workbook.protect]]
 * @see [[Workbook.unprotect]]
 */
export declare class WorkbookProtection extends Base {
    static $t: Type;
    private _c;
    private _d;
    private _a;
    /**
     * @hidden
     */
    readonly _b: WorkbookPasswordInfo;
    constructor(a: Workbook);
    /**
     * Returns a boolean indicating if the sheets displayed may be modified when the Workbook is protected.
     */
    get allowEditStructure(): boolean;
    set allowEditStructure(a: boolean);
    /**
     * Returns a boolean indicating if the Workbook windows may be modified when the Workbook is protected.
     */
    get allowEditWindows(): boolean;
    set allowEditWindows(a: boolean);
    /**
     * @hidden
     */
    _h(a: any, b?: boolean, c?: boolean): void;
    /**
     * @hidden
     */
    private _g;
}
/**
 * @hidden
 */
export declare class WorksheetProtectedRangeRegionCollection extends Base implements ICollection$1<WorksheetRegion> {
    static $t: Type;
    private _a;
    private _b;
    constructor(a: WorksheetProtectedRange);
    add(a: WorksheetRegion): void;
    clear(): void;
    contains(a: WorksheetRegion): boolean;
    copyTo(a: WorksheetRegion[], b: number): void;
    get count(): number;
    get isReadOnly(): boolean;
    remove(a: WorksheetRegion): boolean;
    getEnumerator(): IEnumerator$1<WorksheetRegion>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * A collection of [[WorksheetProtectedRange]] instances in a [[Worksheet]]
 */
export declare class WorksheetProtectedRangeCollection extends Base implements ICollection$1<WorksheetProtectedRange> {
    static $t: Type;
    private readonly _d;
    private readonly _a;
    constructor(a: Worksheet);
    /**
     * Gets the number of ranges in the collection.
     */
    get count(): number;
    /**
     * Gets the range at the specified index in the collection.
     * The range at the specified index.
     * @param index The zero-based index of the range to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    item(a: number): WorksheetProtectedRange;
    /**
     * Adds the specified range to the collection.
     * @param item The range to be added
     */
    add(item: WorksheetProtectedRange): void;
    /**
     * Clears all ranges from the collection.
     */
    clear(): void;
    /**
     * Determines whether a range is in the collection.
     * @param range The range to locate in the collection.
     * @return True if the range is found; False otherwise.
     */
    contains(range: WorksheetProtectedRange): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetProtectedRange>;
    /**
     * Gets an enumerator which can iterator all ranges in the collection.
     */
    getEnumerator(): IEnumerator$1<WorksheetProtectedRange>;
    /**
     * Inserts the specified range in the collection.
     * @param index The 0-based index in the collection where the range should be inserted.
     * @param range The range to insert in the collection.
     */
    insert(index: number, range: WorksheetProtectedRange): void;
    /**
     * Removes the specified range from the collection.
     * @param range The range to remove from the collection.
     * @return True if the range was successfully removed from the collection;
     * False if the range did not exist in the collection.
     */
    remove(range: WorksheetProtectedRange): boolean;
    /**
     * Removes the range at the specified index from the collection.
     * @param index The index of the range to remove from the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _b(a: string): WorksheetProtectedRange;
    /**
     * @hidden
     */
    _g(a: number): void;
    /**
     * @hidden
     */
    private _h;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    copyTo(array: WorksheetProtectedRange[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
}
/**
 * Provides information about the types of changes that are disabled when the associated Sheet is protected.
 * @see [[Sheet.hasProtectionPassword]]
 * @see [[Sheet.isProtected]]
 * @see [[Sheet.sheetProtection]]
 * @see@see [[Sheet.unprotect]]
 */
export declare abstract class SheetProtection extends Base implements IChangeInfoContext {
    static $t: Type;
    private _a;
    /**
     * @hidden
     */
    readonly _c: WorkbookPasswordInfo;
    constructor(a: Sheet);
    /**
     * @hidden
     */
    get _sheet(): Sheet;
    /**
     * @hidden
     */
    _d(): void;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
}
/**
 * Provides information about the types of changes that are disabled when the associated Worksheet is protected.
 * <p class="body">When a Worksheet is protected, the contents of unprotected cells may be edited by the end-user. One way to unprotect a
 * cell is to change the [[IWorksheetCellFormat.locked]] property to false. Such cells may be edited by all users. Another way to
 * unprotect cells is using the [[allowedEditRanges]]. This is a collection of [[WorksheetProtectedRange]] instances that
 * define a range of cells that is optionally protected by another password. For any other cells, the Worksheet would need to be unprotected first.
 * A Worksheet may be programatically unprotected using the Worksheet.Unprotect() method.</p>
 * <p class="body">The [[selectionMode]] property is used to control which cells the end user may select when the Worksheet has been
 * protected. This property may be set before or after protecting a Worksheet.</p>
 * <p class="body">Many of the other properties of this class are read-only (e.g. [[allowDeletingColumns]]). The state
 * of these properties are optionally set when the Worksheet is protected (e.g. using the [[Worksheet.protect]]
 * method.</p>
 * @see@see@see [[Worksheet.protection]]
 * @see [[Worksheet.protect]]
 * @see */
export declare class WorksheetProtection extends SheetProtection {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static readonly _e;
    private _j;
    private _h;
    private _l;
    constructor(a: Worksheet);
    /**
     * Returns a boolean indicating if the deletion of columns is allowed in a protected worksheet.
     * @see [[allowDeletingRows]]
     * @see [[allowInsertingColumns]]
     * @see [[allowInsertingRows]]
     */
    get allowDeletingColumns(): boolean;
    set allowDeletingColumns(a: boolean);
    /**
     * Returns a boolean indicating if the deletion of rows is allowed in a protected worksheet.
     * @see [[allowDeletingColumns]]
     * @see [[allowInsertingColumns]]
     * @see [[allowInsertingRows]]
     */
    get allowDeletingRows(): boolean;
    set allowDeletingRows(a: boolean);
    /**
     * Gets the range at the specified index in the collection.
     * The range at the specified index.
     * @param index The zero-based index of the range to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    allowedEditRanges(index: number): WorksheetProtectedRange;
    /**
     * Returns a collection of [[WorksheetProtectedRange]] instances that define which locked ranges of cells may be edited in a protected worksheet.
     * <p class="body">When a Worksheet is protected the only cells that may be edited are those whose [[IWorksheetCellFormat.locked]] property
     * has been set to false. All other cells are not editable by default. One can make additional cells or ranges of cells editable via this collection.
     * The [[WorksheetProtectedRange]] instances specify the range to which it applies and optionally a password that may be used to unlock that range.</p>
     */
    allowedEditRanges(): WorksheetProtectedRangeCollection;
    /**
     * @hidden
     */
    get _allowedEditRanges$i(): WorksheetProtectedRangeCollection;
    /**
     * Returns a boolean indicating if objects such as shapes, comments, charts and controls may be created or changed when the worksheet is protected.
     */
    get allowEditObjects(): boolean;
    set allowEditObjects(a: boolean);
    /**
     * Returns a boolean indicating if existing scenarios are protected when the worksheet is protected.
     */
    get allowEditScenarios(): boolean;
    set allowEditScenarios(a: boolean);
    /**
     * Returns a boolean indicating if the user may use an auto filter created before the worksheet was protected.
     */
    get allowFiltering(): boolean;
    set allowFiltering(a: boolean);
    /**
     * Returns a boolean indicating if the user may change the formatting of cells in a protected worksheet.
     */
    get allowFormattingCells(): boolean;
    set allowFormattingCells(a: boolean);
    /**
     * Returns a boolean indicating if the user may change column information such as its width or visibility in a protected worksheet.
     */
    get allowFormattingColumns(): boolean;
    set allowFormattingColumns(a: boolean);
    /**
     * Returns a boolean indicating if the user may change row information such as its height or visibility in a protected worksheet.
     */
    get allowFormattingRows(): boolean;
    set allowFormattingRows(a: boolean);
    /**
     * Returns a boolean indicating if the user may insert columns in a protected worksheet.
     * @see [[allowDeletingColumns]]
     * @see [[allowDeletingRows]]
     * @see [[allowInsertingRows]]
     */
    get allowInsertingColumns(): boolean;
    set allowInsertingColumns(a: boolean);
    /**
     * Returns a boolean indicating if the user may insert hyperlinks in unlocked cells in a protected worksheet.
     */
    get allowInsertingHyperlinks(): boolean;
    set allowInsertingHyperlinks(a: boolean);
    /**
     * Returns a boolean indicating if the user may insert rows in a protected worksheet.
     * @see [[allowDeletingColumns]]
     * @see [[allowInsertingColumns]]
     * @see [[allowDeletingRows]]
     */
    get allowInsertingRows(): boolean;
    set allowInsertingRows(a: boolean);
    /**
     * Returns a boolean indicating if the sorting is allowed in a protected worksheet.
     */
    get allowSorting(): boolean;
    set allowSorting(a: boolean);
    /**
     * Returns a boolean indicating if the user can change pivot tables in a protected worksheet.
     */
    get allowUsingPivotTables(): boolean;
    set allowUsingPivotTables(a: boolean);
    /**
     * Returns or sets an enumeration used to indicate how cell selection should be affected when the associated Worksheet is protected.
     */
    get selectionMode(): WorksheetProtectedSelectionMode;
    set selectionMode(a: WorksheetProtectedSelectionMode);
    /**
     * @hidden
     */
    get _m(): WorksheetProtectionType;
    /**
     * @hidden
     */
    get _ab(): boolean;
    /**
     * @hidden
     */
    get _ac(): boolean;
    /**
     * @hidden
     */
    _af(): void;
    /**
     * @hidden
     */
    _ag(a: boolean, b: boolean): void;
    /**
     * @hidden
     */
    _ah(a: any, b?: Nullable$1<boolean>, c?: Nullable$1<boolean>, d?: Nullable$1<boolean>, e?: Nullable$1<boolean>, f?: Nullable$1<boolean>, g?: Nullable$1<boolean>, h?: Nullable$1<boolean>, i?: Nullable$1<boolean>, j?: Nullable$1<boolean>, k?: Nullable$1<boolean>, l?: Nullable$1<boolean>, m?: Nullable$1<boolean>, n?: Nullable$1<boolean>): void;
    /**
     * @hidden
     */
    private static _g;
    /**
     * @hidden
     */
    private static _f;
    /**
     * @hidden
     */
    private _aa;
    /**
     * @hidden
     */
    _d(): void;
    /**
     * @hidden
     */
    private _ai;
    /**
     * @hidden
     */
    private _aj;
}
/**
 * @hidden
 */
export declare class RegionLookupTable$1<T extends IRegionAddress> extends Base {
    static $t: Type;
    protected $t: Type;
    private readonly a;
    readonly b: ObjectPool$1<List$1<T>>;
    readonly u: () => HashSet$1<T>;
    readonly v: () => List$1<T>;
    private c;
    private d;
    private n;
    private readonly f;
    private readonly s;
    private readonly t;
    private w;
    private x;
    private e;
    constructor($t: Type, a: Worksheet);
    y(a: WorksheetRegion, b: T): void;
    z(a: WorksheetRegionAddress, b: T): void;
    aa(a: number, b: number, c: number, d: number, e: T): void;
    ab(): void;
    o(a: number, b: number): boolean;
    private p;
    private q;
    ac(a: number, b: number, c: number, d: number): {
        p0: number;
        p1: number;
        p2: number;
        p3: number;
    };
    g(a: number, b: number): RegionLookupTable_Result$1<T>;
    h(a: WorksheetRegionAddress): RegionLookupTable_Result$1<T>;
    private i;
    j(a: number, b: number): RegionLookupTable_Result$1<T>;
    k(a: WorksheetRegionAddress): RegionLookupTable_Result$1<T>;
    l(a: number, b: number, c: number, d: number): RegionLookupTable_Result$1<T>;
    m(a: number, b: number): RegionLookupTable_Result$1<T>;
    ad(a: WorksheetRegion, b: T): void;
    ae(a: WorksheetRegionAddress, b: T): void;
    af(a: number, b: number, c: number, d: number, e: T): void;
    get r(): boolean;
}
/**
 * @hidden
 */
export declare class RegionLookupTable_Result$1<T extends IRegionAddress> extends ValueType implements IDisposable {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: number, b: RegionLookupTable$1<T>, c: List$1<T>);
    constructor($t: Type);
    constructor($t: Type, a: number, ..._rest: any[]);
    private readonly _a;
    readonly _d: List$1<T>;
    dispose(): void;
    get _c(): boolean;
}
/**
 * @hidden
 */
export declare abstract class RowColumnBinaryTreeNode$1<T extends RowColumnBase> extends LoadOnDemandTree_BinaryTreeNode$1<T> {
    static $t: Type;
    protected $t: Type;
    private r;
    private s;
    constructor($t: Type, a: number, b: IBinaryTreeNodeOwner$1<T>, c: LoadOnDemandTree$1<T>);
    o(a: number, b: number, c: number, d: boolean): number;
    abstract p(a: T, b: number): number;
    q(a: number, b: number, c: boolean): number;
    t(a: boolean): void;
}
/**
 * Abstract base class for collections of the main worksheet elements (rows, columns, and cells).
 * <p class="body">
 * Because of the large number of elements on a worksheet, this collection internally creates elements
 * when they are requested. Iterating this collection will only iterate the elements which have already
 * been created.
 * </p>
 * @typedef T The type of item contained in the collection.
 */
export declare abstract class WorksheetItemCollection$1<T> extends Base implements ICollection$1<T>, ILoadOnDemandTreeOwner$1<T> {
    static $t: Type;
    protected $t: Type;
    private _b;
    private _v;
    private readonly _d;
    private _t;
    constructor($t: Type, a: Worksheet, b: number);
    /**
     * @hidden
     */
    add(item: T): void;
    /**
     * @hidden
     */
    _add$i(a: T): void;
    /**
     * @hidden
     */
    clear(): void;
    /**
     * @hidden
     */
    contains(item: T): boolean;
    /**
     * @hidden
     */
    _contains$i(a: T): boolean;
    /**
     * @hidden
     */
    copyTo(array: T[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get count(): number;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    remove(item: T): boolean;
    /**
     * @hidden
     */
    _remove$i(a: T): boolean;
    [Symbol.iterator](): EnumeratorWrapper<T>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<T>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    _createValue$i(index: number): T;
    /**
     * @hidden
     */
    _getItemIndex$i(item: T): number;
    /**
     * @hidden
     */
    _initializeItemIndex$i(item: T, index: number, applyingChangesToTree: boolean): void;
    /**
     * @hidden
     */
    _isItemStillValid$i(item: T): boolean;
    /**
     * @hidden
     */
    abstract _createValue(a: number): T;
    /**
     * @hidden
     */
    abstract _getItemIndex(a: T): number;
    /**
     * @hidden
     */
    abstract _initializeItemIndex(a: T, b: number, c: boolean): void;
    /**
     * @hidden
     */
    abstract _isItemStillValid(a: T): boolean;
    /**
     * @hidden
     */
    abstract _ae(a: number): void;
    /**
     * @hidden
     */
    abstract _af(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    _q(a: number, b: number): number;
    /**
     * @hidden
     */
    _y(): void;
    /**
     * @hidden
     */
    _x(a: CellShiftOperation): void;
    /**
     * @hidden
     */
    _a(): LoadOnDemandTree$1<T>;
    /**
     * @hidden
     */
    private __l;
    _l(): IEnumerable$1<T>;
    /**
     * @hidden
     */
    _p(): IEnumerator$1<T>;
    /**
     * @hidden
     */
    _m(a: number, b: number): IEnumerable$1<T>;
    /**
     * @hidden
     */
    _n(a: number, b: number, c: boolean): IEnumerable$1<T>;
    /**
     * @hidden
     */
    _o(a: number, b: number, c?: boolean): IEnumerable$1<T>;
    /**
     * @hidden
     */
    _g(a: number, b?: boolean): T;
    /**
     * @hidden
     */
    _aa(a: number, b: number): void;
    /**
     * @hidden
     */
    _h(a: number): T;
    /**
     * @hidden
     */
    _ab(): void;
    /**
     * @hidden
     */
    _ad(a: number, b: number): void;
    /**
     * @hidden
     */
    _ac(a: CellShiftResult): void;
    /**
     * @hidden
     */
    _i(a: T, b: number): T;
    /**
     * Gets the maximum number of items allowed in this collection.
     */
    abstract get maxCount(): number;
    /**
     * @hidden
     */
    get _k(): number;
    /**
     * @hidden
     */
    protected get__count(): number;
    /**
     * @hidden
     */
    get _count(): number;
    /**
     * @hidden
     */
    get _c(): LoadOnDemandTree$1<T>;
    /**
     * @hidden
     */
    get _u(): number;
    /**
     * @hidden
     */
    set _u(a: number);
    /**
     * @hidden
     */
    get _e(): Worksheet;
}
/**
 * Base class for row collection and column collection.
 * @typedef T The type of item contained in the collection.
 */
export declare abstract class RowColumnCollectionBase$1<T> extends WorksheetItemCollection$1<T> {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: Worksheet, b: number);
}
/**
 * @hidden
 */
export declare class RowColumnLoadOnDemandTree$1<T extends RowColumnBase> extends LoadOnDemandTree$1<T> {
    static $t: Type;
    protected $t: Type;
    protected _at: Worksheet;
    constructor($t: Type, a: RowColumnCollectionBase$1<T>);
    _au(a: boolean): void;
    _av(a: number, b: boolean): void;
}
/**
 * @hidden
 */
export declare class ShapeFillNoFill extends ShapeFill {
    static $t: Type;
    static readonly _e: ShapeFillNoFill;
    constructor();
    _c<TArg, TResult>($tArg: Type, $tResult: Type, a: IShapeFillVisitor$2<TArg, TResult>, b: TArg): TResult;
    _d(a: WorksheetShape): void;
}
/**
 * Represents a shape fill with a solid color.
 * @see [[WorksheetShape.fill]]
 */
export declare class ShapeFillSolid extends ShapeFill {
    static $t: Type;
    private readonly _e;
    constructor();
    constructor(color: string | Color);
    constructor(colorInfo: WorkbookColorInfo);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _c<TArg, TResult>($tArg: Type, $tResult: Type, a: IShapeFillVisitor$2<TArg, TResult>, b: TArg): TResult;
    /**
     * @hidden
     */
    _d(a: WorksheetShape): void;
    /**
     * Gets or sets the [[WorkbookColorInfo]] describing the color of the fill.
     */
    get colorInfo(): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class ShapeFillImage extends ShapeFill {
    static $t: Type;
    private _e;
    constructor(a: ImageData);
    get _f(): ImageData;
    _c<TArg, TResult>($tArg: Type, $tResult: Type, a: IShapeFillVisitor$2<TArg, TResult>, b: TArg): TResult;
    _d(a: WorksheetShape): void;
}
/**
 * @hidden
 */
export interface IShapeFillVisitor$2<TArg, TResult> {
    _visitNoFill$i(a: ShapeFillNoFill, b: TArg): TResult;
    _visitSolid$i(a: ShapeFillSolid, b: TArg): TResult;
    _visitImage$i(a: ShapeFillImage, b: TArg): TResult;
}
/**
 * @hidden
 */
export declare let IShapeFillVisitor$2_$type: Type;
/**
 * @hidden
 */
export declare class ShapeOutlineNoOutline extends ShapeOutline {
    static $t: Type;
    static readonly _i: ShapeOutlineNoOutline;
    constructor();
    _c<TArg, TResult>($tArg: Type, $tResult: Type, a: IShapeOutlineVisitor$2<TArg, TResult>, b: TArg): TResult;
    _h(a: WorksheetShape): void;
}
/**
 * Represents a shape outline with a solid color.
 * @see [[WorksheetShape.outline]]
 */
export declare class ShapeOutlineSolid extends ShapeOutline {
    static $t: Type;
    private readonly _i;
    constructor();
    constructor(color: string | Color);
    constructor(colorInfo: WorkbookColorInfo);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _c<TArg, TResult>($tArg: Type, $tResult: Type, a: IShapeOutlineVisitor$2<TArg, TResult>, b: TArg): TResult;
    /**
     * @hidden
     */
    _h(a: WorksheetShape): void;
    /**
     * Gets or sets the [[WorkbookColorInfo]] describing the color of the outline.
     */
    get colorInfo(): WorkbookColorInfo;
}
/**
 * @hidden
 */
export interface IShapeOutlineVisitor$2<TArg, TResult> {
    _visitNoOutline$i(a: ShapeOutlineNoOutline, b: TArg): TResult;
    _visitSolid$i(a: ShapeOutlineSolid, b: TArg): TResult;
}
/**
 * @hidden
 */
export declare let IShapeOutlineVisitor$2_$type: Type;
/**
 * @hidden
 */
export declare class SharedStringTable extends GenericCachedCollection$1<StringElement> {
    static $t: Type;
    private _t;
    private _p;
    constructor(a: Workbook);
    private _s;
    protected _l(a: StringElement): void;
    private _u;
    private _v;
    _remove(a: StringElement): boolean;
    _o(a: number, b: number): StringElement;
    _q(a: StringElement): number;
    _r(a: number, b: number): number;
}
/**
 * Represents an index relative to a region
 * @see [[Worksheet.filterSettings]]
 * @see [[Worksheet.sortSettings]]
 */
export declare class RelativeIndex extends Base implements ISortable, IEquatable$1<RelativeIndex>, IComparable$1<RelativeIndex> {
    static $t: Type;
    private readonly _b;
    private _a;
    constructor(index: number);
    /**
     * Returns the relative index (read only)
     */
    get index(): number;
    /**
     * @hidden
     */
    _c(a: WorksheetRegion, b?: WorksheetSortType): void;
    /**
     * @hidden
     */
    equals(other: RelativeIndex): boolean;
    /**
     * Compares this instance of a [[RelativeIndex]] to another.
     * @param obj
     * @return
     */
    compareTo(obj: RelativeIndex): number;
}
/**
 * @hidden
 */
export interface IAreaFormatsOwner$1<TArea> extends IWorksheetCellFormatProxyOwner, IGenericCachedCollectionEx {
    readonly isReadOnly: boolean;
    _onAreaFormatAdded$i(a: TArea, b: WorksheetCellFormatData): void;
    verifyCanBeModified(): void;
}
/**
 * @hidden
 */
export declare let IAreaFormatsOwner$1_$type: Type;
/**
 * Represents a style which can be applied to a [[WorksheetTable]].
 * @see [[WorksheetTable.style]]
 * @see [[Workbook.defaultTableStyle]]
 * @see [[Workbook.customTableStyles]]
 * @see [[Workbook.standardTableStyles]]
 */
export declare class WorksheetTableStyle extends Base implements IAreaFormatsOwner$1<WorksheetTableStyleArea>, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _aa;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    private static readonly _a;
    private _v;
    private _w;
    private _j;
    private _x;
    private readonly _o;
    private _p;
    private _al;
    private _g;
    private _y;
    constructor(name: string);
    constructor(name: string, isCustom: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    _onAreaFormatAdded$i(area: WorksheetTableStyleArea, format: WorksheetCellFormatData): void;
    /**
     * @hidden
     */
    verifyCanBeModified(): void;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    getAdjacentFormatForBorderResolution(sender: WorksheetCellFormatProxy, borderValue: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    onCellFormatValueChanged(sender: WorksheetCellFormatProxy, values: CellFormatValue, options: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    onCellFormatValueChanging(sender: WorksheetCellFormatProxy, values: CellFormatValue): void;
    /**
     * @hidden
     */
    verifyFormatOptions(sender: WorksheetCellFormatProxy, formatOptions: WorksheetCellFormatOptions): void;
    /**
     * Duplicates the style and returns a deep copy.
     * <p class="body">
     * A cloned style must be added to the [[Workbook.customTableStyles]] collection before it can be applied to a
     * [[WorksheetTable]].
     * </p>
     * <p class="body">
     * The only value not cloned from the style is the [[isCustom]] value. Cloning a standard style creates a custom style with
     * the same style settings which can then be changed.
     * </p>
     * @param name The name to give to the cloned style.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @return The clone of the style.
     */
    clone(name: string): WorksheetTableStyle;
    /**
     * @hidden
     */
    _m(a: string, b: boolean): WorksheetTableStyle;
    /**
     * @hidden
     */
    private static readonly _c;
    /**
     * @hidden
     */
    static _q(a: CellFormatValue): boolean;
    /**
     * @hidden
     */
    static _af(a: WorksheetTableStyleArea): number;
    /**
     * @hidden
     */
    _ak(a: WorksheetTableStyleArea): Nullable$1<number>;
    /**
     * @hidden
     */
    _n(): SortedList$2<number, WorksheetTableAreaFormatProxy$1<WorksheetTableStyleArea>>;
    /**
     * @hidden
     */
    _an(a: CustomTableStyleCollection): void;
    /**
     * @hidden
     */
    _ao(): void;
    /**
     * @hidden
     */
    _verifyCanBeModified(): void;
    /**
     * @hidden
     */
    private static _f;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private static _ap;
    /**
     * @hidden
     */
    private static readonly _e;
    /**
     * @hidden
     */
    private static readonly _d;
    /**
     * @hidden
     */
    private static _u;
    /**
     * @hidden
     */
    private static _ar;
    /**
     * Gets or sets the number of columns which will span each alternate column stripe.
     * <p class="body">
     * The stripe sizes must be between 1 and 9, inclusive.
     * </p>
     * <p class="body">
     * The column stripes are assigned from left to right in the table, first assigning the column stripe, then the alternate column
     * stripe, then repeating.
     * </p>
     * <p class="body">
     * The alternate column stripe format is defined in the [[areaFormats]] collection and keyed by the
     * [[WorksheetTableStyleArea]].AlternateColumnStripe value.
     * </p>
     * The number of columns which will span each alternate column stripe.
     * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
     * @see [[columnStripeWidth]]
     */
    get alternateColumnStripeWidth(): number;
    set alternateColumnStripeWidth(a: number);
    /**
     * Gets or sets the number of rows which will span each alternate row stripe.
     * <p class="body">
     * The stripe sizes must be between 1 and 9, inclusive.
     * </p>
     * <p class="body">
     * The row stripes are assigned from top to bottom in the table, first assigning the row stripe, then the alternate row
     * stripe, then repeating.
     * </p>
     * <p class="body">
     * The alternate row stripe format is defined in the [[areaFormats]] collection and keyed by the
     * [[WorksheetTableStyleArea]].AlternateRowStripe value.
     * </p>
     * The number of rows which will span each alternate row stripe.
     * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
     * @see [[rowStripeHeight]]
     */
    get alternateRowStripeHeight(): number;
    set alternateRowStripeHeight(a: number);
    /**
     * Gets the format for the specified area.
     * An [[IWorksheetCellFormat]] instance describing the appearance of the specified area.
     * @param area The area for which to get the format.
     * @throws [[InvalidEnumArgumentException]] 'area' is not defined.
     */
    areaFormats(area: WorksheetTableStyleArea): IWorksheetCellFormat;
    /**
     * Gets the collection of formats used for each area of a [[WorksheetTable]] to which the style is applied.
     * <p class="body">
     * The area formats specified are differential formats. In other words, only the properties that are set to non-default values will be
     * applied to the appropriate cells. An area format can define only a background color or only font information and that format will be
     * applied to the cells while all other formatting properties on the cells will be maintained.
     * </p>
     * @see [[WorksheetTable.areaFormats]]
     * @see [[WorksheetTableColumn.areaFormats]]
     */
    areaFormats(): WorksheetTableAreaFormatsCollection$1<WorksheetTableStyleArea>;
    /**
     * @hidden
     */
    get _areaFormats$i(): WorksheetTableAreaFormatsCollection$1<WorksheetTableStyleArea>;
    /**
     * Gets or sets the number of columns which will span each column stripe.
     * <p class="body">
     * The stripe sizes must be between 1 and 9, inclusive.
     * </p>
     * <p class="body">
     * The column stripes are assigned from left to right in the table, first assigning the column stripe, then the alternate column
     * stripe, then repeating.
     * </p>
     * <p class="body">
     * The column stripe format is defined in the [[areaFormats]] collection and keyed by the
     * [[WorksheetTableStyleArea]].ColumnStripe value.
     * </p>
     * The number of columns which will span each column stripe.
     * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
     * @see [[alternateColumnStripeWidth]]
     */
    get columnStripeWidth(): number;
    set columnStripeWidth(a: number);
    /**
     * Gets the value indicating whether the style is a custom style.
     * True id this is a custom table style; False if this is a read-only, standard table style.
     */
    get isCustom(): boolean;
    /**
     * Gets or sets the name of the style.
     * The name of the style.
     * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
     * @throws [[ArgumentException]] The value assigned is null, empty, or greater than 255 characters in length.
     * @throws [[ArgumentException]] The value assigned matches the name of another custom style in the owning [[Workbook.customTableStyles]] collection.
     * Table names are compared case-insensitively.
     */
    get name(): string;
    set name(a: string);
    /**
     * Gets or sets the number of rows which will span each row stripe.
     * <p class="body">
     * The stripe sizes must be between 1 and 9, inclusive.
     * </p>
     * <p class="body">
     * The row stripes are assigned from top to bottom in the table, first assigning the row stripe, then the alternate row
     * stripe, then repeating.
     * </p>
     * <p class="body">
     * The row stripe format is defined in the [[areaFormats]] collection and keyed by the
     * [[WorksheetTableStyleArea]].RowStripe value.
     * </p>
     * The number of rows which will span each row stripe.
     * @throws [[InvalidOperationException]] The value is set and [[isCustom]] is False, indicating that the style is a read-only, standard table style.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 9.
     * @see [[alternateRowStripeHeight]]
     */
    get rowStripeHeight(): number;
    set rowStripeHeight(a: number);
    /**
     * @hidden
     */
    get _h(): CustomTableStyleCollection;
    /**
     * @hidden
     */
    get _s(): boolean;
    /**
     * @hidden
     */
    set _s(a: boolean);
    /**
     * @hidden
     */
    get _isReadOnly(): boolean;
    /**
     * @hidden
     */
    get _workbook(): Workbook;
}
/**
 * @hidden
 */
export declare class CustomTableStyleCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: CustomTableStyleCollection, c: WorksheetTableStyle, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: CustomTableStyleCollection;
    readonly b: WorksheetTableStyle;
    readonly c: number;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of custom [[WorksheetTableStyle]] instances which can be applied to a [[WorksheetTable]] in the
 * [[workbook]].
 * @see [[Workbook.defaultTableStyle]]
 * @see [[Workbook.customTableStyles]]
 */
export declare class CustomTableStyleCollection extends Base implements ICollection$1<WorksheetTableStyle> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _i;
    /**
     * @hidden
     */
    private static readonly _l;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static _a;
    private _h;
    /**
     * @hidden
     */
    _d: Workbook;
    static staticInit(): void;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    copyTo(array: WorksheetTableStyle[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetTableStyle>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetTableStyle>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a custom [[WorksheetTableStyle]] to the collection.
     * @param style The custom table style to add to the collection.
     * @throws [[ArgumentNullException]] 'style' is null.
     * @throws [[ArgumentException]] 'style' is a standard table style.
     * @throws [[ArgumentException]] 'style' is already in a CustomTableStyleCollection.
     * @throws [[ArgumentException]] 'style' has a name which matches one of the other custom table styles in the collection.
     * Names are compared case-insensitively.
     * @see [[WorksheetTableStyle.isCustom]]
     * @see [[WorksheetTableStyle.name]]
     */
    add(style: WorksheetTableStyle): void;
    /**
     * Clears the collection.
     * <p class="body">
     * If any [[WorksheetTable]] instances in the workbook have their style removed due to this operation, their style
     * will be set to the [[Workbook.defaultTableStyle]].
     * </p>
     */
    clear(): void;
    /**
     * Determines whether the specified [[WorksheetTableStyle]] is contained in the collection.
     * @param style The table style to find in the collection.
     * @return True if the style is in the collection; False otherwise.
     */
    contains(style: WorksheetTableStyle): boolean;
    /**
     * Gets the index of the specified style in the collection.
     * @param style The style to find in the collection.
     * @throws [[ArgumentNullException]] 'style' is null.
     * @return The 0-based index of the specified style in the collection or -1 if the style is not in the collection.
     */
    indexOf(style: WorksheetTableStyle): number;
    /**
     * Removes the specified [[WorksheetTableStyle]] from the collection.
     * <p class="body">
     * If any [[WorksheetTable]] instances in the workbook have their style removed due to this operation, their style
     * will be set to the [[Workbook.defaultTableStyle]].
     * </p>
     * @param style The table style to remove from the collection.
     * @throws [[ArgumentNullException]] 'style' is null.
     * @return True if the style was in the collection and therefore removed; False otherwise.
     */
    remove(style: WorksheetTableStyle): boolean;
    /**
     * Removes the [[WorksheetTableStyle]] at the specified index.
     * <p class="body">
     * If any [[WorksheetTable]] instances in the workbook have their style removed due to this operation, their style
     * will be set to the [[Workbook.defaultTableStyle]].
     * </p>
     * @param index The index of the table style to remove.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    private _n;
    /**
     * @hidden
     */
    _o(a: WorksheetTableStyle, b: string): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _m;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _s;
    /**
     * Gets the number of custom [[WorksheetTableStyle]] instances in the collection.
     */
    get count(): number;
    /**
     * Gets the [[WorksheetTableStyle]] at the specified index.
     * @param index The index at which to get the WorksheetTableStyle.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @return The WorksheetTableStyle instance at the specified index.
     */
    item(index: number): WorksheetTableStyle;
    /**
     * Gets the [[WorksheetTableStyle]] with the specified name.
     * <p class="body">
     * Table style names are compared case-insensitively.
     * </p>
     * @param name The name of the WorksheetTableStyle to find.
     * @return The WorksheetTableStyle instance with the specified name or null if a table style with that name does not exist.
     */
    item(name: string): WorksheetTableStyle;
    /**
     * @hidden
     */
    _item(a: number): WorksheetTableStyle;
    /**
     * @hidden
     */
    _item1(a: string): WorksheetTableStyle;
    /**
     * @hidden
     */
    get _e(): Workbook;
}
/**
 * A collection of standard [[WorksheetTableStyle]] instances which can be applied to a [[WorksheetTable]] in a
 * [[Workbook]].
 * @see [[Workbook.defaultTableStyle]]
 * @see [[Workbook.standardTableStyles]]
 */
export declare class StandardTableStyleCollection extends Base implements IEnumerable$1<WorksheetTableStyle> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _j;
    /**
     * @hidden
     */
    private static _b;
    private _g;
    static staticInit(): void;
    constructor();
    [Symbol.iterator](): EnumeratorWrapper<WorksheetTableStyle>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetTableStyle>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    static _h: (arg1: List$1<WorksheetTableStyle>) => WorkItem;
    /**
     * @hidden
     */
    private _a;
    /**
     * Gets the number of custom [[WorksheetTableStyle]] instances in the collection.
     */
    get count(): number;
    /**
     * Gets the [[WorksheetTableStyle]] at the specified index.
     * @param index The index at which to get the WorksheetTableStyle.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @return The WorksheetTableStyle instance at the specified index.
     */
    item(index: number): WorksheetTableStyle;
    /**
     * Gets the [[WorksheetTableStyle]] with the specified name.
     * <p class="body">
     * Table style names are compared case-insensitively.
     * </p>
     * @param name The name of the WorksheetTableStyle to find.
     * @return The WorksheetTableStyle instance with the specified name or null if a table style with that name does not exist.
     */
    item(name: string): WorksheetTableStyle;
    /**
     * @hidden
     */
    _item(a: number): WorksheetTableStyle;
    /**
     * @hidden
     */
    _item1(a: string): WorksheetTableStyle;
    /**
     * @hidden
     */
    get _d(): WorksheetTableStyle;
    /**
     * @hidden
     */
    static get _c(): StandardTableStyleCollection;
}
/**
 * @hidden
 */
export declare class WorksheetTable_ResizeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetTable_ResizeContext);
    constructor(a: number, b: WorksheetTable, c: WorksheetRegionAddress);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: WorksheetTable;
    readonly c: WorksheetRegionAddress;
    readonly a: WorksheetTableColumn[];
    readonly b: WorksheetTableColumn[];
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class WorksheetTable_ColumnChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetTable, c: number, d: number, e: boolean, f: boolean, g: WorksheetTableColumn[], h: Tuple$3<WorksheetTableColumn, number, SortCondition>[], i: Nullable$1<WorksheetRegionAddress>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly h: number;
    readonly g: number;
    readonly f: boolean;
    readonly e: boolean;
    readonly d: WorksheetTable;
    readonly a: WorksheetTableColumn[];
    readonly b: Tuple$3<WorksheetTableColumn, number, SortCondition>[];
    readonly c: WorksheetRegionAddress;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class WorksheetTable_RowChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetTable, c: number, d: number, e: Nullable$1<WorksheetRegionAddress>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: number;
    readonly c: number;
    readonly b: WorksheetTable;
    readonly a: WorksheetRegionAddress;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Represents a region of cells formatted as a table.
 * <p class="body">
 * Tables assist in managing and analyzing a range of related data. This management can be done separately from the rest of the
 * data in the worksheet.
 * </p>
 * <p class="body">
 * A table can have one or more columns sorted and filtered. There are various sorting and filtering criteria that can be applied
 * to the columns. The types pertaining to filtering can be found in the Infragistics.Documents.Excel.Filtering namespace and a filter
 * can be applied to a column by setting the [[WorksheetTableColumn.filter]] property. The types pertaining to sorting can
 * be found in the Infragistics.Documents.Excel.Sorting namespace and a column can be sorted by setting the
 * [[WorksheetTableColumn.sortCondition]] or by populating the
 * [[SortSettings`1.sortConditions]] collection on the [[sortSettings]].
 * </p>
 * <p class="body">
 * A table can contain calculated columns which dynamically determine their value based on a formula. A
 * [[WorksheetTableColumn]] can be made a calculated column by setting the [[WorksheetTableColumn.columnFormula]].
 * </p>
 * <p class="body">
 * A table can also contain a totals row which display total information about the table. This can be shown by setting
 * [[isTotalsRowVisible]] to True. When the totals row is displayed, each column can display text or a calculated value in the
 * totals row, by setting either the [[WorksheetTableColumn.totalLabel]] or [[WorksheetTableColumn.totalFormula]],
 * respectively.
 * </p>
 * @see [[Worksheet.tables]]
 * @see [[WorksheetRegion.formatAsTable]]
 * @see [[WorksheetRegion.formatAsTable]]
 * @see [[WorksheetCell.associatedTable]]
 * @see [[WorksheetRow.getCellAssociatedTable]]
 */
export declare class WorksheetTable extends NamedReferenceBase implements IAreaFormatsOwner$1<WorksheetTableArea>, IChangeInfoContext, ISortSettingsOwner {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _db;
    /**
     * @hidden
     */
    private static readonly _dc;
    /**
     * @hidden
     */
    private static readonly _dd;
    /**
     * @hidden
     */
    private static readonly _de;
    /**
     * @hidden
     */
    private static readonly _df;
    /**
     * @hidden
     */
    private static readonly _dg;
    /**
     * @hidden
     */
    private static readonly _dh;
    /**
     * @hidden
     */
    private static readonly _dk;
    /**
     * @hidden
     */
    private static readonly _dl;
    /**
     * @hidden
     */
    private static readonly _dm;
    /**
     * @hidden
     */
    private static readonly _dn;
    /**
     * @hidden
     */
    private static readonly _dp;
    /**
     * @hidden
     */
    private static readonly _dq;
    /**
     * @hidden
     */
    private static readonly _di;
    /**
     * @hidden
     */
    private static readonly _da;
    /**
     * @hidden
     */
    private static readonly _dj;
    /**
     * @hidden
     */
    private static _bf;
    private _b2;
    private _b9;
    private _c8;
    private _b1;
    private readonly _dt;
    private _du;
    private _bl;
    private _cb;
    private _c9;
    private _bj;
    /**
     * @hidden
     */
    _bw: WorksheetRegionAddress;
    private _bn;
    static staticInit(): void;
    constructor(a: string, b: number, c: number, d: number, e: number, f: number);
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    _onAreaFormatAdded$i(area: WorksheetTableArea, format: WorksheetCellFormatData): void;
    /**
     * @hidden
     */
    verifyCanBeModified(): void;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    onSortSettingsModified(): void;
    /**
     * @hidden
     */
    get culture(): string | CultureInfo;
    /**
     * @hidden
     */
    get _culture$i(): CultureInfo;
    /**
     * @hidden
     */
    get sortRegion(): WorksheetRegion;
    /**
     * @hidden
     */
    getAdjacentFormatForBorderResolution(sender: WorksheetCellFormatProxy, borderValue: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    onCellFormatValueChanged(sender: WorksheetCellFormatProxy, values: CellFormatValue, options: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    onCellFormatValueChanging(sender: WorksheetCellFormatProxy, values: CellFormatValue): void;
    /**
     * @hidden
     */
    verifyFormatOptions(sender: WorksheetCellFormatProxy, formatOptions: WorksheetCellFormatOptions): void;
    /**
     * @hidden
     */
    protected get__f(): RefBase;
    /**
     * @hidden
     */
    get _f(): RefBase;
    /**
     * @hidden
     */
    protected get__m(): boolean;
    /**
     * @hidden
     */
    protected get__n(): boolean;
    /**
     * @hidden
     */
    get _n(): boolean;
    /**
     * @hidden
     */
    protected get__a(): ChangeInfo[];
    /**
     * @hidden
     */
    protected get__z(): CultureInfo;
    /**
     * @hidden
     */
    get _z(): CultureInfo;
    /**
     * @hidden
     */
    protected get__y(): boolean;
    /**
     * @hidden
     */
    _a6(a: boolean): void;
    /**
     * @hidden
     */
    _a7(a: string): void;
    /**
     * Gets the string representation of the table.
     * @return The string representation of the table.
     */
    toString(): string;
    /**
     * @hidden
     */
    _a1(a: GetFormulaStringInfo, b?: boolean): string;
    /**
     * @hidden
     */
    protected get__k(): Workbook;
    /**
     * @hidden
     */
    get _k(): Workbook;
    /**
     * @hidden
     */
    protected get__h(): WorkbookReferenceBase;
    /**
     * Clears all filters from the columns in the table.
     * <p class="body">
     * If any filters are present and removed when this is called, all hidden rows in the data area of the table will be unhidden.
     * </p>
     * @see [[reapplyFilters]]
     * @see [[WorksheetTableColumn.filter]]
     */
    clearFilters(): void;
    /**
     * Clears all sort conditions from the columns in the table.
     * <p class="note">
     * <b>Note:</b> Just as in Microsoft Excel, clearing the sort conditions will not revert the table back to its original unsorted
     * state. The table will remain in its last sorted order.
     * </p>
     * @see [[sortSettings]]
     * @see [[WorksheetTableColumn.sortCondition]]
     */
    clearSortConditions(): void;
    /**
     * Deletes one or more columns from the table
     * @param tableColumnIndex The deletion start relative to the first column in the table.
     * @param count The number of columns to delete.
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1 or greater than or equal all the columns in the table.
     */
    deleteColumns(tableColumnIndex: number, count?: number): void;
    /**
     * Deletes one or more data rows from the table
     * @param dataRowIndex The deletion start relative to the first row in the [[dataAreaRegion]].
     * @param count The number of rows to delete.
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1 or greater than or equal all the rows (excluding header and total rows) in the table.
     */
    deleteDataRows(dataRowIndex: number, count?: number): void;
    /**
     * Inserts one or more columns into the table
     * @param tableColumnIndex The insertion point relative to the first column in the table.
     * @param count The number of columns to insert
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
     */
    insertColumns(tableColumnIndex: number, count?: number): void;
    /**
     * Inserts one or more data rows into the table
     * @param dataRowIndex The insertion point relative to the first row in the [[dataAreaRegion]].
     * @param count The number of columns to insert
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
     */
    insertDataRows(dataRowIndex: number, count?: number): void;
    /**
     * Re-filters all data cells in the table based on the filters from the columns in the table.
     * <p class="body">
     * Filters are not constantly evaluated as data within the table changes. Filters are applied to the table only when they are
     * added or removed on a column in the table or when the ReapplyFilters method is called.
     * </p>
     * <p class="body">
     * If no columns in the table have filters set, this method will not do anything to the data.
     * </p>
     * <p class="note">
     * <B>Note:</B> When the filters are reevaluated, the rows of any cells which don't meet the filter criteria of their column will
     * be hidden. When a row is filtered out, the entire row is hidden from the worksheet, so any data outside the table but in the
     * same row will also be hidden.
     * </p>
     * @see [[clearFilters]]
     * @see [[WorksheetTableColumn.filter]]
     */
    reapplyFilters(): void;
    /**
     * Re-sorts all data cells in the table based on the sort conditions from the columns in the table.
     * @see [[sortSettings]]
     * @see [[WorksheetTableColumn.sortCondition]]
     */
    reapplySortConditions(): void;
    /**
     * Resizes the table to a new range of data on the worksheet.
     * <p class="body">
     * If the totals row is visible, it will be placed below the last data row automatically. If the totals row is currently inside
     * the new table region, it will be moved out to below the new data rows, which will be shifted up by one row.
     * </p>
     * @param headerAndDataRegion The new region of headers (if currently visible) and data for the table, which must contain at least one data row, and overlap
     * and have the same top as the current table region.
     * @throws [[InvalidOperationException]] Occurs when the [[WorksheetTable]] has previously been removed from the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'headerAndDataRegion' is null.
     * @throws [[ArgumentException]] Occurs when 'headerAndDataRegion' from a different worksheet or has been previously shifted off the table's worksheet.
     * @throws [[ArgumentException]] Occurs when the top of the 'headerAndDataRegion' does is not the same as the top of the table.
     * @throws [[ArgumentException]] Occurs when the 'headerAndDataRegion' does not contain at least one data row for the table.
     * @throws [[ArgumentException]] Occurs when the 'headerAndDataRegion' does not overlap the current table region.
     * @throws [[InvalidOperationException]] Occurs when the there is a merged cell, array formula, data table, or another table in the new region.
     */
    resize(headerAndDataRegion: WorksheetRegion): void;
    /**
     * Resizes the table to a new range of data on the worksheet.
     * <p class="body">
     * If the totals row is visible, it will be placed below the last data row automatically. If the totals row is currently inside
     * the new table region, it will be moved out to below the new data rows, which will be shifted up by one row.
     * </p>
     * @param headerAndDataRegionAddress The address of the new region of headers (if currently visible) and data for the table, which must contain at least one data row,
     * and overlap and have the same top as the current table region.
     * @throws [[InvalidOperationException]] Occurs when the [[WorksheetTable]] has previously been removed from the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'headerAndDataRegionAddress' is null.
     * @throws [[ArgumentException]] Occurs when 'headerAndDataRegionAddress' is not a valid name or a valid cell or region address in the
     * workbook's cell reference mode.
     * @throws [[InvalidOperationException]] Occurs when 'headerAndDataRegionAddress' is a relative R1C1 address. The overload taking an origin cell must
     * be used to resolve relative R1C1 references.
     * @throws [[ArgumentException]] Occurs when the top of the 'headerAndDataRegionAddress' does is not the same as the top of the table.
     * @throws [[ArgumentException]] Occurs when the 'headerAndDataRegionAddress' does not contain at least one data row for the table.
     * @throws [[ArgumentException]] Occurs when the 'headerAndDataRegionAddress' does not overlap the current table region.
     * @throws [[InvalidOperationException]] Occurs when the there is a merged cell, array formula, data table, or another table in the new region.
     */
    resize(headerAndDataRegionAddress: string): void;
    /**
     * Resizes the table to a new range of data on the worksheet.
     * <p class="body">
     * If the totals row is visible, it will be placed below the last data row automatically. If the totals row is currently inside
     * the new table region, it will be moved out to below the new data rows, which will be shifted up by one row.
     * </p>
     * @param headerAndDataRegionAddress The address of the new region of headers (if currently visible) and data for the table, which must contain at least one data row,
     * and overlap and have the same top as the current table region.
     * @param cellReferenceMode The cell reference mode to use to parse the region address.
     * @throws [[InvalidOperationException]] Occurs when the [[WorksheetTable]] has previously been removed from the worksheet.
     * @throws [[ArgumentNullException]] Occurs when 'headerAndDataRegionAddress' is null.
     * @throws [[ArgumentException]] Occurs when 'headerAndDataRegionAddress' is not a valid name or a valid cell or region address in the
     * workbook's cell reference mode.
     * @throws [[InvalidOperationException]] Occurs when 'headerAndDataRegionAddress' is a relative R1C1 address. The overload taking an origin cell must
     * be used to resolve relative R1C1 references.
     * @throws [[ArgumentException]] Occurs when the top of the 'headerAndDataRegionAddress' does is not the same as the top of the table.
     * @throws [[ArgumentException]] Occurs when the 'headerAndDataRegionAddress' does not contain at least one data row for the table.
     * @throws [[ArgumentException]] Occurs when the 'headerAndDataRegionAddress' does not overlap the current table region.
     * @throws [[InvalidOperationException]] Occurs when the there is a merged cell, array formula, data table, or another table in the new region.
     */
    resize(headerAndDataRegionAddress: string, cellReferenceMode: CellReferenceMode): void;
    /**
     * @hidden
     */
    _resize1(a: string): void;
    /**
     * @hidden
     */
    _resize2(a: string, b: CellReferenceMode): void;
    /**
     * @hidden
     */
    _resize(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    private _e2;
    /**
     * @hidden
     */
    private _eu;
    /**
     * @hidden
     */
    _dy(a: number, b: number, c: WorksheetCellFormatProxy): void;
    /**
     * @hidden
     */
    _d2(): void;
    /**
     * @hidden
     */
    static _cd(a: WorksheetTableArea, b: CellFormatValue): boolean;
    /**
     * @hidden
     */
    _ce(a: WorksheetRow, b: number): boolean;
    /**
     * @hidden
     */
    _cf(a: number, b: number): boolean;
    /**
     * @hidden
     */
    _cg(a: number, b: number): boolean;
    /**
     * @hidden
     */
    _ch(a: number, b: number): boolean;
    /**
     * @hidden
     */
    private _d8;
    /**
     * @hidden
     */
    private _d9;
    /**
     * @hidden
     */
    _eb(a: number, b: number): {
        p0: number;
        p1: number;
    };
    /**
     * @hidden
     */
    _ea(a: WorksheetRegionAddress, b: number, c: number): {
        p1: number;
        p2: number;
    };
    /**
     * @hidden
     */
    _ec(): void;
    /**
     * @hidden
     */
    _eg(a: WorksheetTableColumn): void;
    /**
     * @hidden
     */
    _ed(): void;
    /**
     * @hidden
     */
    _ef(a: WorksheetTable, b: boolean): void;
    /**
     * @hidden
     */
    _b4(): WorksheetTableColumn;
    /**
     * @hidden
     */
    _b5(a: number): WorksheetTableColumn;
    /**
     * @hidden
     */
    private _b8;
    /**
     * @hidden
     */
    _b6(a: number): WorksheetTableColumn;
    /**
     * @hidden
     */
    _b7(a: number, b: WorksheetTableColumn): WorksheetTableColumn;
    /**
     * @hidden
     */
    _co(a: number, b: number): boolean;
    /**
     * @hidden
     */
    _cp(a: number, b: number): boolean;
    /**
     * @hidden
     */
    _cv(a: ICellShiftOperationOverride): boolean;
    /**
     * @hidden
     */
    _c0(a: CellShiftOperation, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _em(a: Workbook): void;
    /**
     * @hidden
     */
    _en(a: boolean): void;
    /**
     * @hidden
     */
    _eo(a: Worksheet): void;
    /**
     * @hidden
     */
    private _bo;
    /**
     * @hidden
     */
    static _ev(a: CellShiftResult, b: string): void;
    /**
     * @hidden
     */
    _e3(): void;
    /**
     * @hidden
     */
    _bk(a: CellShiftOperation, b: ICellShiftOperationOverride, c: boolean): ShiftAddressResult;
    /**
     * @hidden
     */
    _e9(): void;
    /**
     * @hidden
     */
    private _dx;
    /**
     * @hidden
     */
    private _dz;
    /**
     * @hidden
     */
    private _d0;
    /**
     * @hidden
     */
    private _d1;
    /**
     * @hidden
     */
    private _d4;
    /**
     * @hidden
     */
    private static _bh;
    /**
     * @hidden
     */
    private static _bi;
    /**
     * @hidden
     */
    private static _bg;
    /**
     * @hidden
     */
    private _cm;
    /**
     * @hidden
     */
    private static _ee;
    /**
     * @hidden
     */
    private _cq;
    /**
     * @hidden
     */
    private _ei;
    /**
     * @hidden
     */
    private _ey;
    /**
     * @hidden
     */
    private _ek;
    /**
     * @hidden
     */
    private _el;
    /**
     * @hidden
     */
    private _ep;
    /**
     * @hidden
     */
    private _eq;
    /**
     * @hidden
     */
    private _er;
    /**
     * @hidden
     */
    private _es;
    /**
     * @hidden
     */
    private _dr;
    /**
     * @hidden
     */
    private _et;
    /**
     * @hidden
     */
    private _e5;
    /**
     * @hidden
     */
    private _c4;
    /**
     * @hidden
     */
    private _fa;
    /**
     * @hidden
     */
    private static _fb;
    /**
     * @hidden
     */
    private static _fc;
    /**
     * @hidden
     */
    private static _fd;
    /**
     * @hidden
     */
    private static _fe;
    /**
     * @hidden
     */
    private static _ff;
    /**
     * @hidden
     */
    private static _fg;
    /**
     * @hidden
     */
    private static _c6;
    /**
     * @hidden
     */
    private _fh;
    private _bv;
    /**
     * @hidden
     */
    private get _bx();
    /**
     * @hidden
     */
    private set _bx(value);
    /**
     * @hidden
     */
    private _e4;
    /**
     * Gets the format for the specified area.
     * An [[IWorksheetCellFormat]] instance describing the appearance of the specified area.
     * @param area The area for which to get the format.
     * @throws [[InvalidEnumArgumentException]] 'area' is not defined.
     */
    areaFormats(area: WorksheetTableArea): IWorksheetCellFormat;
    /**
     * Gets the collection of formats used for each area of the [[WorksheetTable]].
     * <p class="body">
     * The available areas of the table which can have a format set are the whole table, header, data, and totals areas.
     * </p>
     * <p class="body">
     * Applying a format to an area will apply the format to all cells in that area.
     * </p>
     * <p class="body">
     * If any area formats on the tables are set when the table is resized to give it more columns, the area formats of the new columns
     * will be initialized with the area formats from the table.
     * </p>
     * @see [[WorksheetTableColumn.filter]]
     * @see [[WorksheetTableColumn.areaFormats]]
     * @see [[WorksheetTableStyle]]
     * @see [[resize]]
     * @see [[resize]]
     */
    areaFormats(): WorksheetTableAreaFormatsCollection$1<WorksheetTableArea>;
    /**
     * @hidden
     */
    get _areaFormats$i(): WorksheetTableAreaFormatsCollection$1<WorksheetTableArea>;
    /**
     * Gets the [[WorksheetTableColumn]] at the specified index.
     * @param index The 0-based index of the column to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to the number of columns in the collection.
     * @return The WorksheetTableColumn at the specified index.
     */
    columns(index: number): WorksheetTableColumn;
    /**
     * Gets the [[WorksheetTableColumn]] with the specified name or null if it doesn't exist.
     * <p class="body">
     * Column names are compared case-insensitively.
     * </p>
     * @param name The name of the column to get.
     * @return The WorksheetTableColumn with the specified name or null a column with the specified name doesn't exist.
     * @see [[WorksheetTableColumn.name]]
     */
    columns(name: string): WorksheetTableColumn;
    /**
     * Gets the collection of columns in the table.
     * <p class="body">
     * Each column is represented by a [[WorksheetTableColumn]] instance and contains various settings for controlling
     * the contents, formatting, sorting, and filtering of the column.
     * </p>
     * @see [[WorksheetTableColumn]]
     */
    columns(): WorksheetTableColumnCollection;
    /**
     * @hidden
     */
    get _columns$i(): WorksheetTableColumnCollection;
    /**
     * Gets the [[WorksheetRegion]] which represents the region of cells in the data area of the table.
     * <p class="body">
     * The data area of the table can be changed by using one of the Resize overloads.
     * </p>
     * @see [[resize]]
     * @see [[resize]]
     */
    get dataAreaRegion(): WorksheetRegion;
    /**
     * Gets or sets the value which indicates whether the alternate column format should be applied to the appropriate columns of the
     * [[WorksheetTable]].
     * <p class="body">
     * The column formats are defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. These are stored in the
     * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].ColumnStripe and
     * WorksheetTableStyleArea.AlternateColumnStripe values. If there is no area format applied for the AlternateColumnStripe value,
     * this property has no effect on the display of the table.
     * </p>
     * <p class="body">
     * If this value is True and there is an area format for the alternate column stripe, the stripe widths are defined by the
     * [[WorksheetTableStyle.columnStripeWidth]] and [[WorksheetTableStyle.alternateColumnStripeWidth]] values.
     * </p>
     * @see [[style]]
     * @see [[WorksheetTableStyle.areaFormats]]
     * @see [[WorksheetTableStyleArea]]
     * @see [[WorksheetTableStyle.columnStripeWidth]]
     * @see [[WorksheetTableStyle.alternateColumnStripeWidth]]
     */
    get displayBandedColumns(): boolean;
    set displayBandedColumns(a: boolean);
    /**
     * Gets or sets the value which indicates whether the alternate row format should be applied to the appropriate rows of the
     * [[WorksheetTable]].
     * <p class="body">
     * The row formats are defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. These are stored in the
     * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].RowStripe and
     * WorksheetTableStyleArea.AlternateRowStripe values. If there is no area format applied for the AlternateRowStripe value,
     * this property has no effect on the display of the table.
     * </p>
     * <p class="body">
     * If this value is True and there is an area format for the alternate row stripe, the stripe widths are defined by the
     * [[WorksheetTableStyle.rowStripeHeight]] and [[WorksheetTableStyle.alternateRowStripeHeight]] values.
     * </p>
     * @see [[style]]
     * @see [[WorksheetTableStyle.areaFormats]]
     * @see [[WorksheetTableStyleArea]]
     * @see [[WorksheetTableStyle.rowStripeHeight]]
     * @see [[WorksheetTableStyle.alternateRowStripeHeight]]
     */
    get displayBandedRows(): boolean;
    set displayBandedRows(a: boolean);
    /**
     * Gets or sets the value which indicates whether the first column format should be applied to the appropriate column of the
     * [[WorksheetTable]].
     * <p class="body">
     * The first column format is defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. It is stored in the
     * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].FirstColumn
     * value. If there is no area format applied for the FirstColumn value, this property has no effect on the display of the table.
     * </p>
     * <p class="body">
     * If there is only one column in the table and both the first and last column formatting should be applied, the last column format
     * will take precedence.
     * </p>
     * @see [[displayLastColumnFormatting]]
     * @see [[style]]
     * @see [[WorksheetTableStyle.areaFormats]]
     * @see [[WorksheetTableStyleArea]]
     */
    get displayFirstColumnFormatting(): boolean;
    set displayFirstColumnFormatting(a: boolean);
    /**
     * Gets or sets the value which indicates whether the last column format should be applied to the appropriate column of the
     * [[WorksheetTable]].
     * <p class="body">
     * The last column format is defined by the [[WorksheetTableStyle]] applied to the WorksheetTable. It is stored in the
     * [[WorksheetTableStyle.areaFormats]] collection and keyed by the [[WorksheetTableStyleArea]].LastColumn
     * value. If there is no area format applied for the LastColumn value, this property has no effect on the display of the table.
     * </p>
     * <p class="body">
     * If there is only one column in the table and both the first and last column formatting should be applied, the last column format
     * will take precedence.
     * </p>
     * @see [[displayFirstColumnFormatting]]
     * @see [[style]]
     * @see [[WorksheetTableStyle.areaFormats]]
     * @see [[WorksheetTableStyleArea]]
     */
    get displayLastColumnFormatting(): boolean;
    set displayLastColumnFormatting(a: boolean);
    /**
     * Gets the [[WorksheetRegion]] which represents the region of cells in the header row of the table.
     * A WorksheetRegion which represents the region of cells in the header row of the table or null if the header row is not visible.
     * @see [[isHeaderRowVisible]]
     * @see [[resize]]
     * @see [[resize]]
     */
    get headerRowRegion(): WorksheetRegion;
    /**
     * Gets or sets the value indicating whether to allow filtering and show filter buttons in the table headers.
     * <p class="body">
     * If [[isHeaderRowVisible]] is False, this property must be False and setting it to True will cause an error.
     * If [[isHeaderRowVisible]] is set to True, this property will also be set to True automatically.
     * </p>
     * @throws [[InvalidOperationException]] The value assigned is True and [[isHeaderRowVisible]] is False.
     * @see [[isHeaderRowVisible]]
     */
    get isFilterUIVisible(): boolean;
    set isFilterUIVisible(a: boolean);
    /**
     * @hidden
     */
    private _e6;
    /**
     * Gets or sets the value which indicates whether the row containing column headers should be displayed.
     * <p class="body">
     * When the header row is visible, the cell above each column of data will contain the [[WorksheetTableColumn.name]]
     * value. Therefore, all header cells always contain a string value. Additionally, they will all be unique.
     * </p>
     * True if the row containing column headers is visible; False if it is hidden.
     * @see [[WorksheetTableColumn.name]]
     */
    get isHeaderRowVisible(): boolean;
    set isHeaderRowVisible(a: boolean);
    /**
     * @hidden
     */
    private _e7;
    /**
     * Gets or sets the value which indicates whether the row containing column totals should be displayed.
     * <p class="body">
     * When the totals row is visible, the cell below each column of data will contain either a calculated value, a text value, or nothing.
     * To display a calculated value in the cell, set the [[WorksheetTableColumn.totalFormula]]. To display a text label, set the
     * [[WorksheetTableColumn.totalLabel]]. If both are set, the calculated value takes precedence.
     * </p>
     * True if the row containing column totals is visible; False if it is hidden.
     * @throws [[InvalidOperationException]] The value is set to True and the table occupies the last row of the worksheet.
     * @see [[WorksheetTableColumn.totalFormula]]
     * @see [[WorksheetTableColumn.totalLabel]]
     */
    get isTotalsRowVisible(): boolean;
    set isTotalsRowVisible(a: boolean);
    /**
     * @hidden
     */
    private _e8;
    /**
     * @hidden
     */
    get _cz(): boolean;
    /**
     * @hidden
     */
    set _cz(a: boolean);
    /**
     * Gets the settings which determine how the data within the table should be sorted.
     * <p class="note">
     * <B>Note:</B> Sort conditions are not constantly evaluated as data within the table changes. Sort conditions are applied to the table
     * only when they are are added or removed on a column in the table or when the [[reapplySortConditions]] method is called.
     * </p>
     * @see [[reapplySortConditions]]
     * @see [[WorksheetTableColumn.sortCondition]]
     */
    get sortSettings(): SortSettings$1<WorksheetTableColumn>;
    /**
     * Gets or sets the style to use on the [[WorksheetTable]].
     * <p class="body">
     * The [[WorksheetTableStyle]] defines formats to use in various areas of the table. These formats are used as defaults
     * for cells which don't have their formatting properties already set.
     * </p>
     * <p class="body">
     * The area formats specified in the WorksheetTableStyle are differential formats. In other words, only the properties that are set
     * to non-default values will be applied to the appropriate cells. An area format can define only a background color or only font
     * information and that format will be applied to the cells while all other formatting properties on the cells will be maintained.
     * </p>
     * <p class="body">
     * If this value is set to null, the Style will be set to the [[Workbook.defaultTableStyle]].
     * </p>
     * The [[WorksheetTableStyle]] instance which defines the various default table area formats.
     * @throws [[ArgumentException]] The value specified is not in the [[Workbook.customTableStyles]] or [[Workbook.standardTableStyles]]
     * collections.
     * @see [[Workbook.defaultTableStyle]]
     * @see [[Workbook.customTableStyles]]
     * @see [[Workbook.standardTableStyles]]
     */
    get style(): WorksheetTableStyle;
    set style(a: WorksheetTableStyle);
    /**
     * Gets the [[WorksheetRegion]] which represents the region of cells in the totals row of the table.
     * A WorksheetRegion which represents the region of cells in the totals row of the table or null if the totals row is not visible.
     * @see [[isTotalsRowVisible]]
     * @see [[resize]]
     * @see [[resize]]
     */
    get totalsRowRegion(): WorksheetRegion;
    /**
     * Gets the [[WorksheetRegion]] which represents the region of cells in the whole table, including the header and totals rows,
     * if visible.
     * <p class="body">
     * The table region can be changed by using one of the Resize overloads.
     * </p>
     * @see [[resize]]
     * @see [[resize]]
     */
    get wholeTableRegion(): WorksheetRegion;
    /**
     * Gets the [[worksheet]] to which the table belongs.
     * The Worksheet to which the table belongs or null if the table has been removed from the Worksheet.
     * @see [[Worksheet.tables]]
     */
    get worksheet(): Worksheet;
    /**
     * @hidden
     */
    get _bq(): WorksheetRegion;
    /**
     * @hidden
     */
    get _cn(): boolean;
    /**
     * @hidden
     */
    set _cn(a: boolean);
    /**
     * @hidden
     */
    get _bz(): WorksheetRow;
    /**
     * @hidden
     */
    get _dv(): number;
    /**
     * @hidden
     */
    get _cr(): boolean;
    /**
     * @hidden
     */
    set _cr(a: boolean);
    /**
     * @hidden
     */
    get _cu(): boolean;
    /**
     * @hidden
     */
    set _cu(a: boolean);
    /**
     * @hidden
     */
    get _cw(): boolean;
    /**
     * @hidden
     */
    set _cw(a: boolean);
    /**
     * @hidden
     */
    get _cx(): boolean;
    /**
     * @hidden
     */
    set _cx(a: boolean);
    /**
     * @hidden
     */
    _ds: string;
    /**
     * @hidden
     */
    get _dw(): number;
    /**
     * @hidden
     */
    set _dw(a: number);
    /**
     * @hidden
     */
    get _c2(): boolean;
    /**
     * @hidden
     */
    set _c2(a: boolean);
    /**
     * @hidden
     */
    get _bs(): WorksheetRegion;
    /**
     * @hidden
     */
    get _b0(): WorksheetRow;
    /**
     * @hidden
     */
    get _c7(): boolean;
    /**
     * @hidden
     */
    set _c7(a: boolean);
    /**
     * @hidden
     */
    get _by(): WorksheetRegionAddress;
    /**
     * @hidden
     */
    private get _c1();
    /**
     * @hidden
     */
    private set _c1(value);
    /**
     * @hidden
     */
    private get _c3();
    /**
     * @hidden
     */
    private set _c3(value);
    /**
     * @hidden
     */
    private get _c5();
    /**
     * @hidden
     */
    private set _c5(value);
}
/**
 * @hidden
 */
export declare class WorksheetTableResizeOperation extends Base {
    static $t: Type;
    readonly a: WorksheetRegionAddress;
    readonly b: WorksheetRegionAddress;
    readonly c: WorksheetRegionAddress;
    readonly d: WorksheetRegionAddress;
    constructor(a: WorksheetTable, b: WorksheetRegionAddress);
}
/**
 * A collection of formats for areas of a [[WorksheetTable]].
 * @typedef TArea An enumeration defining the various table areas which can contain formats.
 * @see [[WorksheetTable.areaFormats]]
 * @see [[WorksheetTableColumn.areaFormats]]
 * @see [[WorksheetTableStyle.areaFormats]]
 */
export declare class WorksheetTableAreaFormatsCollection$1<TArea> extends Base implements IEnumerable$1<KeyValuePair$2<TArea, IWorksheetCellFormat>> {
    static $t: Type;
    protected $tArea: Type;
    private _h;
    private _a;
    constructor($tArea: Type, a: IAreaFormatsOwner$1<TArea>);
    [Symbol.iterator](): EnumeratorWrapper<KeyValuePair$2<TArea, IWorksheetCellFormat>>;
    /**
     * @hidden
     */
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<KeyValuePair$2<TArea, IWorksheetCellFormat>>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Determines whether the area has a non-default format applied.
     * @param area The area of which to test the format.
     * @throws [[InvalidEnumArgumentException]] 'area' is not defined.
     * @return True if the area has a non-default format applied; False otherwise.
     */
    hasFormat(area: TArea): boolean;
    /**
     * @hidden
     */
    _hasFormat$i(a: TArea): boolean;
    /**
     * @hidden
     */
    _d(a: Workbook, b: TArea): WorksheetTableAreaFormatProxy$1<TArea>;
    /**
     * @hidden
     */
    private _e;
    /**
     * @hidden
     */
    _i(): IEnumerable$1<WorksheetTableAreaFormatProxy$1<TArea>>;
    /**
     * @hidden
     */
    _k(a: Workbook): void;
    /**
     * @hidden
     */
    _l(): void;
    /**
     * @hidden
     */
    _c(a: TArea): WorksheetCellFormatData;
    /**
     * @hidden
     */
    _f(a: TArea): WorksheetTableAreaFormatProxy$1<TArea>;
    /**
     * Gets the number of area formats in the collection.
     */
    get count(): number;
    /**
     * Gets the format for the specified area.
     * An [[IWorksheetCellFormat]] instance describing the appearance of the specified area.
     * @param area The area for which to get the format.
     * @throws [[InvalidEnumArgumentException]] 'area' is not defined.
     */
    item(a: TArea): IWorksheetCellFormat;
}
/**
 * @hidden
 */
export declare class WorksheetTableAreaFormatProxy$1<TArea> extends WorksheetCellFormatProxy {
    static $t: Type;
    protected $tArea: Type;
    private _bs;
    constructor($tArea: Type, a: TArea, b: WorksheetCellFormatData, c: IWorksheetCellFormatProxyOwner);
    protected get__l(): ChangeInfo[];
    protected get _l(): ChangeInfo[];
    protected get__q(): ExcelChangeAction;
    get _q(): ExcelChangeAction;
    protected get__v(): Worksheet;
    get _v(): Worksheet;
    get _bt(): TArea;
}
/**
 * @hidden
 */
export declare class WorksheetTableCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetTableCollection, c: WorksheetTable, d: number, e: boolean);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: number;
    readonly b: WorksheetTableCollection;
    readonly a: WorksheetTable;
    readonly c: boolean;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * The collection of [[WorksheetTable]] instances on a [[Worksheet]].
 * @see [[Worksheet.tables]]
 */
export declare class WorksheetTableCollection extends Base implements IList$1<WorksheetTable> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _o;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static readonly _p;
    /**
     * @hidden
     */
    private static _a;
    private _n;
    private _m;
    /**
     * @hidden
     */
    _d: Worksheet;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    insert(index: number, item: WorksheetTable): void;
    /**
     * @hidden
     */
    item(index: number, value?: WorksheetTable): WorksheetTable;
    /**
     * Gets the [[WorksheetTable]] at the specified index.
     * The WorksheetTable at the specified index.
     * @param index The zero-based index of the WorksheetTable to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    item(index: number): WorksheetTable;
    /**
     * Gets the [[WorksheetTable]] with the specified name.
     * <p class="body">
     * Worksheet names are compared case-insensitively.
     * </p>
     * The WorksheetTable with the specified name.
     * @param name The name of the WorksheetTable to get.
     * @throws [[InvalidOperationException]] A WorksheetTable with the specified name does not exist in the collection.
     * @see [[NamedReferenceBase.name]]
     */
    item(name: string): WorksheetTable;
    /**
     * @hidden
     */
    _item$e(a: number, b?: WorksheetTable): WorksheetTable;
    /**
     * @hidden
     */
    add(item: WorksheetTable): void;
    /**
     * Formats a region as a table and adds an associated [[WorksheetTable]] to the collection.
     * <p class="body">
     * When the table is created, the specified 'tableStyle' will be applied to the
     * value.
     * </p>
     * <p class="body">
     * When the table is created, the column names will be taken from the cells in the header row if 'tableHasHeaders'
     * is True. If it is False, the column names will be generated and the cells for the header row will be inserted into the worksheet.
     * </p>
     * <p class="body">
     * The column names are unique within the owning WorksheetTable. If, when the table is created, there are two or more columns with
     * the same name, the second and subsequent duplicate column names will have a number appended to make them unique. If any cells in
     * the header row have a non-string value, their value will be changed to a string (the current display text of the cell). If any
     * cells in the header row have no value, they will be given a generated column name.
     * </p>
     * <p class="body">
     * If the region partially contains any merged cell regions, they will be removed from the worksheet and the table region will be expanded
     * to include all cells from the merged region.
     * </p>
     * @param region The region to format as a table.
     * @param tableHasHeaders A value which indicates whether the top row of the region contains the headers for the table.
     * @param tableStyle The [[WorksheetTableStyle]] to apply to the table or null to use the [[Workbook.defaultTableStyle]].
     * @see [[WorksheetTable.style]]
     * @throws [[InvalidOperationException]] The owning worksheet has been removed from its workbook.
     * @throws [[ArgumentNullException]] 'region' is null or empty.
     * @throws [[ArgumentException]] 'region' is not a valid region address in the workbook's cell reference mode.
     * @throws [[ArgumentException]] The specified 'tableStyle' does not exist in the [[Workbook.customTableStyles]] or
     * [[Workbook.standardTableStyles]] collections.
     * @throws [[InvalidOperationException]] The region contains one or more cells from another [[WorksheetTable]].
     * @throws [[InvalidOperationException]] The region contains one or more cells which have a multi-cell [[ArrayFormula]] applied.
     * @throws [[InvalidOperationException]] The region contains one or more cells which are part of a [[WorksheetDataTable]].
     * @return The [[WorksheetTable]] created the represent the formatted table for the region.
     * @see [[WorksheetTable]]
     * @see [[Worksheet.tables]]
     * @see [[WorksheetTableColumn.name]]
     * @see [[Workbook.customTableStyles]]
     * @see [[Workbook.standardTableStyles]]
     * @see [[WorksheetTable.style]]
     * @see [[WorksheetTable.isHeaderRowVisible]]
     * @see [[WorksheetRegion.formatAsTable]]
     */
    add(region: string, tableHasHeaders: boolean, tableStyle?: WorksheetTableStyle): WorksheetTable;
    /**
     * @hidden
     */
    _add$e(a: WorksheetTable): void;
    /**
     * @hidden
     */
    copyTo(array: WorksheetTable[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    remove(item: WorksheetTable): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetTable>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetTable>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    _add2(a: string, b: boolean, c?: WorksheetTableStyle): WorksheetTable;
    /**
     * @hidden
     */
    _add1(a: WorksheetRegion, b: boolean, c: WorksheetTableStyle, d?: WorksheetTable, e?: boolean): WorksheetTable;
    /**
     * @hidden
     */
    private _s;
    /**
     * Clears the collection and removes all tables from the worksheet.
     */
    clear(): void;
    /**
     * Determines whether the specified [[WorksheetTable]] is in the collection.
     * @param table The WorksheetTable to find in the collection.
     * @return True if the WorksheetTable is in the collection; False otherwise.
     */
    contains(table: WorksheetTable): boolean;
    /**
     * Determines whether a [[WorksheetTable]] with the specified name is in the collection.
     * <p class="body">
     * Table names are compared case-insensitively.
     * </p>
     * @param name The name of the WorksheetTable to find.
     * @return True if a WorksheetTable with the specified name is in the collection; False otherwise.
     */
    exists(name: string): boolean;
    /**
     * Gets the index of the specified [[WorksheetTable]] in the collection.
     * @param table The WorksheetTable to find in the collection.
     * @return The 0-based index of the specified WorksheetTable in the collection or -1 if the item is not in the collection.
     */
    indexOf(table: WorksheetTable): number;
    /**
     * Removes the [[WorksheetTable]] from the collection.
     * @param table The WorksheetTable to remove from the collection.
     * @param convertToRange True to apply the table style formatting to the cells
     * @return True if the WorksheetTable was found and removed; False otherwise.
     */
    remove_1(table: WorksheetTable, convertToRange?: boolean): boolean;
    /**
     * Removes the [[WorksheetTable]] at the specified index.
     * @param index The 0-based index of the WorksheetTable to remove.
     * @param convertToRange True to apply the table style formatting to the cells
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     */
    removeAt(index: number, convertToRange?: boolean): void;
    /**
     * @hidden
     */
    _g(a: number): WorksheetTable;
    /**
     * @hidden
     */
    _t(a: WorksheetTable): void;
    /**
     * @hidden
     */
    _u(a: number, b: WorksheetTable): void;
    /**
     * @hidden
     */
    _k(a: number, b: number): boolean;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _r;
    /**
     * @hidden
     */
    private _v;
    /**
     * @hidden
     */
    private _x;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _z;
    /**
     * Gets the number of tables in the collection.
     * The number of tables in the collection.
     */
    get count(): number;
    /**
     * @hidden
     */
    _item(a: number): WorksheetTable;
    /**
     * @hidden
     */
    _item1(a: string): WorksheetTable;
}
/**
 * @hidden
 */
export interface IFilterable extends IWorkbookProvider, IWorksheetProvider {
    readonly columnIndex: number;
    readonly filter: Filter;
    getDataAreaRowIndexes(a: number, b: number): {
        p0: number;
        p1: number;
    };
    onFilterModified(): void;
}
/**
 * @hidden
 */
export declare let IFilterable_$type: Type;
/**
 * Abstract base class for all filters which filters cells in a worksheet.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[CustomFilter]]
 * @see [[FixedValuesFilter]]
 * @see [[TopOrBottomFilter]]
 * @see [[DynamicValuesFilter]]
 * @see [[AverageFilter]]
 * @see [[RelativeDateRangeFilter]]
 * @see [[DatePeriodFilter]]
 * @see [[YearToDateFilter]]
 * @see [[FontColorFilter]]
 * @see [[FillFilter]]
 */
export declare abstract class Filter extends Base implements IChangeInfoContext {
    static $t: Type;
    private _a;
    constructor(a: IFilterable);
    /**
     * @hidden
     */
    static _c(a: WorksheetRow, b: number): GetCellTextResult;
    /**
     * @hidden
     */
    abstract _d(a: Filter): boolean;
    /**
     * @hidden
     */
    abstract _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _f(a: Worksheet, b: number, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _i(): void;
    /**
     * @hidden
     */
    _j(a: IFilterable): void;
    /**
     * @hidden
     */
    _g(a: boolean, b: IList$1<string>): {
        ret: boolean;
        p0: boolean;
        p1: IList$1<string>;
    };
    /**
     * @hidden
     */
    get _h(): CultureInfo;
    /**
     * @hidden
     */
    get _b(): IFilterable;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
}
/**
 * Represents a column in a [[WorksheetTable]].
 * <p class="body">
 * Each column contains various settings for controlling the contents, formatting, sorting, and filtering within it.
 * </p>
 */
export declare class WorksheetTableColumn extends Base implements IAreaFormatsOwner$1<WorksheetTableColumnArea>, IChangeInfoContext, IFilterable, ISortable {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _av;
    /**
     * @hidden
     */
    private static readonly _aw;
    /**
     * @hidden
     */
    private static readonly _ax;
    /**
     * @hidden
     */
    private static readonly _az;
    /**
     * @hidden
     */
    private static readonly _a0;
    /**
     * @hidden
     */
    private static readonly _ay;
    /**
     * @hidden
     */
    private static readonly _a;
    private _as;
    private _am;
    private _au;
    private _w;
    private _i;
    private _a8;
    private _a2;
    private _ak;
    private _x;
    private _a3;
    private _ao;
    constructor(a: WorksheetTable, b: number, c: number);
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    _onAreaFormatAdded$i(area: WorksheetTableColumnArea, format: WorksheetCellFormatData): void;
    /**
     * @hidden
     */
    verifyCanBeModified(): void;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get columnIndex(): number;
    /**
     * @hidden
     */
    get worksheet(): Worksheet;
    /**
     * @hidden
     */
    getDataAreaRowIndexes(dataAreaTopRowIndex: number, dataAreaBottomRowIndex: number): {
        p0: number;
        p1: number;
    };
    /**
     * @hidden
     */
    onFilterModified(): void;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    getAdjacentFormatForBorderResolution(sender: WorksheetCellFormatProxy, borderValue: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    onCellFormatValueChanged(sender: WorksheetCellFormatProxy, values: CellFormatValue, options: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    onCellFormatValueChanging(sender: WorksheetCellFormatProxy, values: CellFormatValue): void;
    /**
     * @hidden
     */
    verifyFormatOptions(sender: WorksheetCellFormatProxy, formatOptions: WorksheetCellFormatOptions): void;
    /**
     * Applies an [[AverageFilter]] to the column.
     * @param type The value indicating whether to filter in values below or above the average of the data range.
     * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[AverageFilterType]] enumeration.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[AverageFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyAverageFilter(type: AverageFilterType): AverageFilter;
    /**
     * Applies a [[CustomFilter]] to the column.
     * <p class="note">
     * <b>Note:</b> If the filter condition value is longer than 255 characters in length and the workbook is saved in one of
     * the 2003 formats, the correct rows will be hidden in the saved file, but the filter will be missing from the column.
     * </p>
     * @param condition The condition which must pass for the data to be filtered in.
     * @throws [[ArgumentNullException]] 'condition' is null.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[CustomFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyCustomFilter(condition: CustomFilterCondition): CustomFilter;
    /**
     * Applies a [[CustomFilter]] to the column.
     * <p class="body">
     * If 'condition2' is null, the 'conditionalOperator' value is irrelevant.
     * </p>
     * <p class="note">
     * <b>Note:</b> If one of the filter condition values is longer than 255 characters in length and the workbook is saved in one of
     * the 2003 formats, the correct rows will be hidden in the saved file, but the filter will be missing from the column.
     * </p>
     * @param condition1 The first condition used to filter the data.
     * @param condition2 The second condition used to filter the data.
     * @param conditionalOperator The operator which defines how to logically combine 'condition1' and 'condition2'.
     * @throws [[ArgumentNullException]] 'condition1' is null.
     * @throws [[InvalidEnumArgumentException]] 'conditionalOperator' is not defined in the [[ConditionalOperator]] enumeration.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @see [[CustomFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyCustomFilter(condition1: CustomFilterCondition, condition2: CustomFilterCondition, conditionalOperator: ConditionalOperator): CustomFilter;
    /**
     * @hidden
     */
    _applyCustomFilter(a: CustomFilterCondition): CustomFilter;
    /**
     * @hidden
     */
    _applyCustomFilter1(a: CustomFilterCondition, b: CustomFilterCondition, c: ConditionalOperator): CustomFilter;
    /**
     * Applies an [[DatePeriodFilter]] to the column.
     * <p class="body">
     * If the 'type' is Month, a 'value' of 1 indicates January, 2 indicates February, and so on.
     * If type is Quarter, a value of 1 indicates Quarter 1, and so on.
     * </p>
     * @param type The type of date period to filter in.
     * @param value The 1-based value of the month or quarter to filter in.
     * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[DatePeriodFilterType]] enumeration.
     * @throws [[ArgumentException]] 'type' is Quarter and 'value' is less than 1 or greater than 4 or
     * type is Month and value is less than 1 or greater than 12.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[DatePeriodFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyDatePeriodFilter(type: DatePeriodFilterType, value: number): DatePeriodFilter;
    /**
     * Applies a [[FillFilter]] to the column.
     * @param fill A [[CellFill]] by which the cells should be filtered.
     * @throws [[ArgumentNullException]] 'fill' is null.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[FillFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyFillFilter(fill: CellFill): FillFilter;
    /**
     * @hidden
     */
    _j(a: boolean, ...b: string[]): FixedValuesFilter;
    /**
     * @hidden
     */
    _m(a: boolean, b: IEnumerable$1<string>): FixedValuesFilter;
    /**
     * @hidden
     */
    _n(a: boolean, b: IEnumerable$1<FixedDateGroup>): FixedValuesFilter;
    /**
     * Applies a [[FixedValuesFilter]] to the column.
     * @param includeBlanks The value which indicates whether blank cells should be filtered in.
     * @param calendarType The calendar type used to interpret values in the 'dateGroups' collection.
     * @param dateGroups The collection of fixed date groups which should be filtered in.
     * @throws [[ArgumentNullException]] 'dateGroups' is null.
     * @throws [[InvalidEnumArgumentException]] 'calendarType' is not defined in the [[CalendarType]] enumeration.
     * @throws [[ArgumentNullException]] A FixedDateGroup in the 'dateGroups' collection is null.
     * @throws [[ArgumentException]] Multiple items in 'dateGroups' are equal to each other.
     * @throws [[InvalidOperationException]] 'includeBlanks' is False and 'dateGroups' has no items. At least one value must be allowed.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @see [[FixedValuesFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyFixedValuesFilter(includeBlanks: boolean, calendarType: CalendarType, ...dateGroups: FixedDateGroup[]): FixedValuesFilter;
    /**
     * @hidden
     */
    _applyFixedValuesFilter1(a: boolean, b: CalendarType, ...c: FixedDateGroup[]): FixedValuesFilter;
    /**
     * @hidden
     */
    _l(a: boolean, b: CalendarType, c: IEnumerable$1<FixedDateGroup>): FixedValuesFilter;
    /**
     * Applies a [[FontColorFilter]] to the column.
     * @param fontColorInfo A [[WorkbookColorInfo]] which describes the font color by which the cells should be filtered.
     * @throws [[ArgumentNullException]] 'fontColorInfo' is null.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @see [[FontColorFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyFontColorFilter(fontColorInfo: WorkbookColorInfo): FontColorFilter;
    /**
     * Applies a [[FontColorFilter]] to the column.
     * @param fontColor The font color by which the cells should be filtered.
     * @throws [[ArgumentNullException]] 'fontColor' is empty.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[FontColorFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyFontColorFilter(fontColor: string | Color): FontColorFilter;
    /**
     * @hidden
     */
    _applyFontColorFilter1(a: Color): FontColorFilter;
    /**
     * @hidden
     */
    _applyFontColorFilter(a: WorkbookColorInfo): FontColorFilter;
    /**
     * Applies a [[IconFilter]] to the column.
     * @param iconSet The icon set containing the icon.
     * @throws [[ArgumentException]] If the icon set is not valid.
     * @param iconIndex The zero-based index of the icon in the set or null for 'NoCellIcon'.
     * @throws [[ArgumentOutOfRangeException]] If the index is less than zero or greater than or equal to the number of icons in the icon set..
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @throws [[InvalidEnumArgumentException]] 'iconSet' is not defined in the [[FormatConditionIconSet]] enumeration.
     * @see [[IconFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     * @see [[ConditionalFormatCollection.addIconSetCondition]]
     */
    applyIconFilter(iconSet: FormatConditionIconSet, iconIndex: number | null): IconFilter;
    /**
     * @hidden
     */
    _applyIconFilter$i(a: FormatConditionIconSet, b: Nullable$1<number>): IconFilter;
    /**
     * @hidden
     */
    _r(a: ST_IconSetType, b: Nullable$1<number>): IconFilter;
    /**
     * Applies a [[RelativeDateRangeFilter]] to the column.
     * <p class="body">
     * The RelativeDateRangeFilter allows you to filter in dates which are in the previous, current, or next time period
     * relative to the date when the filter was applied. The time periods available are day, week, month, quarter, year.
     * So when using the previous filter type with a day duration, a 'yesterday' filter is created. Or when using a current
     * filter type with a year duration, a 'this year' filter is created. However, these filters compare the data against
     * the date when the filter was created. So a 'this year' filter created in 1999 will filter in all cells containing
     * dates in 1999, even if the workbook is opened in 2012.
     * </p>
     * @param offset The offset of relative filter. This combined with the 'duration' determines the full range of accepted dates.
     * @param duration The duration of the full range of accepted dates.
     * @throws [[InvalidEnumArgumentException]] 'offset' is not defined in the [[RelativeDateRangeOffset]] enumeration.
     * @throws [[InvalidEnumArgumentException]] 'duration' is not defined in the [[RelativeDateRangeDuration]] enumeration.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[RelativeDateRangeFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyRelativeDateRangeFilter(offset: RelativeDateRangeOffset, duration: RelativeDateRangeDuration): RelativeDateRangeFilter;
    /**
     * Applies a [[TopOrBottomFilter]] to the column which will filter in the top 10 values in the list of sorted values.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[TopOrBottomFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyTopOrBottomFilter(): TopOrBottomFilter;
    /**
     * Applies a [[TopOrBottomFilter]] to the column.
     * @param type The type of the filter.
     * @param value The number or percentage of value of values which should be filtered in.
     * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[TopOrBottomFilterType]] enumeration.
     * @throws [[ArgumentOutOfRangeException]] 'value' is less than 1 or greater than 500.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @see [[TopOrBottomFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyTopOrBottomFilter(type: TopOrBottomFilterType, value: number): TopOrBottomFilter;
    /**
     * @hidden
     */
    _applyTopOrBottomFilter(): TopOrBottomFilter;
    /**
     * @hidden
     */
    _applyTopOrBottomFilter1(a: TopOrBottomFilterType, b: number): TopOrBottomFilter;
    /**
     * Applies a [[YearToDateFilter]] to the column.
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[YearToDateFilter]]
     * @see [[filter]]
     * @see [[clearFilter]]
     */
    applyYearToDateFilter(): YearToDateFilter;
    /**
     * Removes the filter from the column if one is applied.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @see [[applyAverageFilter]]
     * @see [[applyCustomFilter]]
     * @see [[applyCustomFilter]]
     * @see [[applyDatePeriodFilter]]
     * @see [[applyFillFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyFontColorFilter]]
     * @see [[applyFontColorFilter]]
     * @see [[applyRelativeDateRangeFilter]]
     * @see [[applyTopOrBottomFilter]]
     * @see [[applyTopOrBottomFilter]]
     * @see [[applyYearToDateFilter]]
     * @see [[filter]]
     */
    clearFilter(): void;
    /**
     * Sets the formula to use in the data cells in the column.
     * <p class="body">
     * If any relative cell or region references are in the specified formula, it will be assumed that the actual formula is being applied to
     * the first data cell in the column. When the formula is applied to other cells in the column, the relative references will be offset by
     * the appropriate amount.
     * </p>
     * <p class="body">
     * When the column formula is set and the table is resized to give it more rows, the new cells in the column will have the column formula
     * applied to them.
     * </p>
     * <p class="body">
     * If there was a different column formula applied previously and it was applied to any of the cells in the column, setting it to a
     * different formula will overwrite the formulas on those cells, regardless of the value of 'overwriteExistingValues'.
     * </p>
     * @param formula The formula for the data cells of the column or null to remove the current column formula.
     * @param overwriteExistingValues True to overwrite the existing cells values and apply the formula to all data cells in the column.
     * False to only apply the formula to the cells with no value set.
     * @throws [[ArgumentException]] @throws [[InvalidOperationException]] If column was removed from the table.
     * 'formula' is already applied to something else, such as a cell or table column.
     * @see [[columnFormula]]
     */
    setColumnFormula(formula: Formula, overwriteExistingValues: boolean): void;
    /**
     * @hidden
     */
    _setColumnFormula1(a: Formula, b: boolean): void;
    /**
     * @hidden
     */
    private _bu;
    /**
     * @hidden
     */
    private _bw;
    /**
     * @hidden
     */
    _ba(a: number, b: number, c: number): void;
    /**
     * @hidden
     */
    static _ap(a: WorksheetTableColumnArea, b: CellFormatValue): boolean;
    /**
     * @hidden
     */
    _ah(a: WorksheetRegion): WorksheetRegion;
    /**
     * @hidden
     */
    _bd(): void;
    /**
     * @hidden
     */
    _be(a: WorksheetTableColumn, b: boolean): void;
    /**
     * @hidden
     */
    _onFilterModified(): void;
    /**
     * @hidden
     */
    _bg(): void;
    /**
     * @hidden
     */
    _bh(): void;
    /**
     * @hidden
     */
    _bi(): void;
    /**
     * @hidden
     */
    _bj(a: WorksheetTable, b: number, c?: boolean): void;
    /**
     * @hidden
     */
    _bk(a?: boolean): void;
    /**
     * @hidden
     */
    _bl(a: Workbook): void;
    /**
     * @hidden
     */
    _bm(a: WorksheetRegionAddress, b: WorksheetRegion, c: WorksheetRegion): void;
    /**
     * @hidden
     */
    _bn(): void;
    /**
     * @hidden
     */
    _bo(): void;
    /**
     * @hidden
     */
    _bq(): void;
    /**
     * @hidden
     */
    _br(): void;
    /**
     * @hidden
     */
    _bs(): void;
    /**
     * @hidden
     */
    _bt(a: number): void;
    /**
     * @hidden
     */
    _bz(a: Formula): void;
    /**
     * @hidden
     */
    _b4(): void;
    /**
     * @hidden
     */
    _b7(a: WorksheetTableColumnArea): void;
    /**
     * @hidden
     */
    _b6(a: WorksheetTableAreaFormatProxy$1<WorksheetTableColumnArea>, b: CellFormatValue, c: boolean, d: WorksheetRegion, e: WorksheetCell): void;
    /**
     * @hidden
     */
    private _bb;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _aq;
    /**
     * @hidden
     */
    private _a1;
    /**
     * @hidden
     */
    private _bp;
    /**
     * @hidden
     */
    private _by;
    /**
     * @hidden
     */
    private _b5;
    /**
     * @hidden
     */
    private static _b8;
    /**
     * @hidden
     */
    private static _ar;
    /**
     * @hidden
     */
    private _b9;
    /**
     * @hidden
     */
    private _ca;
    /**
     * @hidden
     */
    private _cb;
    /**
     * Gets the format for the specified area.
     * An [[IWorksheetCellFormat]] instance describing the appearance of the specified area.
     * @param area The area for which to get the format.
     * @throws [[InvalidEnumArgumentException]] 'area' is not defined.
     */
    areaFormats(area: WorksheetTableColumnArea): IWorksheetCellFormat;
    /**
     * Gets the collection of formats used for each area of the column.
     * <p class="body">
     * The available areas of the column which can have a format set are the header, data, and totals areas.
     * </p>
     * <p class="body">
     * Applying a format to an area will apply the format to all cells in that area.
     * </p>
     * <p class="body">
     * If any area formats on the columns are set when the table is resized to give it more rows, the new cells in the column will
     * get the new format applied.
     * </p>
     * @see [[filter]]
     * @see [[WorksheetTable.areaFormats]]
     * @see [[WorksheetTableStyle.areaFormats]]
     * @see [[WorksheetTable.resize]]
     * @see [[WorksheetTable.resize]]
     */
    areaFormats(): WorksheetTableAreaFormatsCollection$1<WorksheetTableColumnArea>;
    /**
     * @hidden
     */
    get _areaFormats$i(): WorksheetTableAreaFormatsCollection$1<WorksheetTableColumnArea>;
    /**
     * Gets the formula associated with the data area of the column.
     * <p class="body">
     * When the column formula is set and the table is resized to give it more rows, the new cells in the column will have the column formula
     * applied to them.
     * </p>
     * A [[Formula]] instance representing the formula for the data area of the column or null if no formula is applied.
     * @see [[setColumnFormula]]
     */
    get columnFormula(): Formula;
    /**
     * Gets the [[WorksheetRegion]] which represents the region of cells in the data area of the column.
     */
    get dataAreaRegion(): WorksheetRegion;
    /**
     * Gets the filter applied to the column.
     * <p class="body">
     * Filters are not constantly evaluated as data within the table changes. Filters are applied to the table only when they are
     * added or removed on a column in the table or when the [[WorksheetTable.reapplyFilters]] method is called.
     * </p>
     * <p class="note">
     * <B>Note:</B> When the filters are reevaluated, the rows of any cells which don't meet the filter criteria of their column will
     * be hidden. When a row is filtered out, the entire row is hidden from the worksheet, so any data outside the table but in the
     * same row will also be hidden.
     * </p>
     * A [[filter]]-derived instance if a filter is applied or null if the column is not filtered.
     * @see [[applyAverageFilter]]
     * @see [[applyCustomFilter]]
     * @see [[applyCustomFilter]]
     * @see [[applyDatePeriodFilter]]
     * @see [[applyFontColorFilter]]
     * @see [[applyFontColorFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyFixedValuesFilter]]
     * @see [[applyRelativeDateRangeFilter]]
     * @see [[applyTopOrBottomFilter]]
     * @see [[applyTopOrBottomFilter]]
     * @see [[applyYearToDateFilter]]
     * @see [[clearFilter]]
     * @see [[WorksheetTable.clearFilters]]
     * @see [[WorksheetTable.reapplyFilters]]
     */
    get filter(): Filter;
    set filter(a: Filter);
    /**
     * @hidden
     */
    private _bx;
    /**
     * Gets the [[WorksheetCell]] which represents the header cell for the column.
     * A WorksheetCell which represents the header cell for the column or null if the header row is not visible in the table.
     * @see [[WorksheetTable.isHeaderRowVisible]]
     */
    get headerCell(): WorksheetCell;
    /**
     * Gets the 0-based index of the column in the owning [[WorksheetTable.columns]] collection.
     * The 0-based index of the column in its collection or -1 if the column has been removed from the table.
     * @see [[WorksheetTable.columns]]
     */
    get index(): number;
    /**
     * Gets or sets the name of the column.
     * <p class="body">
     * If the header row is visible in the [[WorksheetTable]], the name of the column will be displayed in the cell of the
     * column in the header row.
     * </p>
     * <p class="body">
     * When the WorksheetTable is created, the column names will be taken from the cells in the header row. If the table does not
     * contain a header row, the column names will be generated.
     * </p>
     * <p class="body">
     * The column names are unique within the owning WorksheetTable. If, when the table is created, there are two or more columns with
     * the same name, the second and subsequent duplicate column names will have a number appended to make them unique. If any cells in
     * the header row have a non-string value, their value will be changed to a string (the current display text of the cell). If any
     * cells in the header row have no value, they will be given a generated column name.
     * </p>
     * <p class="body">
     * If the Name property is set to a null or empty string, a column name will be generated. If the value is set to a column name which
     * already exists in the table, the column with the higher index will have a number appended to its name so all column names can stay
     * unique.
     * </p>
     * The unique name of the column within the owning WorksheetTable.
     * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
     * @see [[WorksheetTable.isHeaderRowVisible]]
     */
    get name(): string;
    set name(a: string);
    /**
     * @hidden
     */
    private _b0;
    /**
     * Gets or sets the sort condition used to sort the column in the table.
     * <p class="body">
     * When a sort condition is set on the column, the SortConditions collection on the [[WorksheetTable.sortSettings]] will be cleared
     * and the new sort condition will be added. To sort by multiple columns, the sort conditions must be added to the SortConditions collection
     * instead of set on the column. However, if a sort condition is cleared with this property, just the sort condition for the column will be
     * removed from the SortConditions collection. All other SortConditions will remain in the collection.
     * </p>
     * <p class="note">
     * <B>Note:</B> Sort conditions are not constantly evaluated as data within the table changes. Sort conditions are applied to the table
     * only when they are are added or removed on a column in the table or when the [[WorksheetTable.reapplySortConditions]] method
     * is called.
     * </p>
     * The [[sortCondition]]-derived instance used to sort the column or null of the column is not sorted.
     * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
     * @see [[WorksheetTable.sortSettings]]
     * @see [[SortSettings`1.sortConditions]]
     * @see [[SortConditionCollection`1]]
     * @see [[WorksheetTable.clearSortConditions]]
     * @see [[WorksheetTable.reapplySortConditions]]
     */
    get sortCondition(): SortCondition;
    set sortCondition(a: SortCondition);
    /**
     * @hidden
     */
    private static _b1;
    /**
     * Gets the [[WorksheetTable]] to which the column belongs.
     * The WorksheetTable to which the column belongs or null if the column has been removed from the table.
     */
    get table(): WorksheetTable;
    /**
     * Gets the [[WorksheetCell]] which represents the total cell for the column.
     * A WorksheetCell which represents the total cell for the column or null if the totals row is not visible in the table.
     * @see [[WorksheetTable.isTotalsRowVisible]]
     */
    get totalCell(): WorksheetCell;
    /**
     * Gets or sets the formula to use in the total cell of the column.
     * <p class="body">
     * The total formula can be set regardless of whether or not the totals row is visible. If the totals row is hidden, the
     * formula will not be applied anywhere. When the totals row is visible, it will be applied to the total cell of the column.
     * </p>
     * <p class="body">
     * Setting the TotalFormula to a non-null value will clear the [[totalLabel]], and vice versa.
     * </p>
     * @throws [[ArgumentException]] The value is already applied to something else, such as a cell or table column.
     * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
     * @see [[totalLabel]]
     * @see [[WorksheetTable.isTotalsRowVisible]]
     */
    get totalFormula(): Formula;
    set totalFormula(a: Formula);
    /**
     * @hidden
     */
    private _b2;
    /**
     * Gets or sets the text label to use in the total cell of the column.
     * <p class="body">
     * The total label can be set regardless of whether or not the totals row is visible. If the totals row is hidden, the
     * label will not be displayed anywhere. When the totals row is visible, it will be set as the value of the total cell of the column.
     * </p>
     * <p class="body">
     * Setting the [[totalFormula]] to a non-null value will clear the TotalLabel, and vice versa.
     * </p>
     * @throws [[InvalidOperationException]] From the setter if column was removed from the table.
     * @see [[totalFormula]]
     * @see [[WorksheetTable.isTotalsRowVisible]]
     */
    get totalLabel(): string;
    set totalLabel(a: string);
    /**
     * @hidden
     */
    private _b3;
    /**
     * Gets the [[WorksheetRegion]] which represents the region of cells in the whole column, including the header and total cells,
     * if visible.
     */
    get wholeColumnRegion(): WorksheetRegion;
    /**
     * @hidden
     */
    get _a9(): number;
    /**
     * @hidden
     */
    get _a5(): string;
    /**
     * @hidden
     */
    get _ai(): WorksheetRegion;
    /**
     * @hidden
     */
    get _a7(): string;
    /**
     * @hidden
     */
    get _aa(): Formula;
    /**
     * @hidden
     */
    get _workbook(): Workbook;
    /**
     * @hidden
     */
    get _worksheet(): Worksheet;
    /**
     * @hidden
     */
    get _at(): number;
}
/**
 * A read-only collection of all [[WorksheetTableColumn]] instances which exist in a [[WorksheetTable]].
 * @see [[WorksheetTable.columns]]
 */
export declare class WorksheetTableColumnCollection extends Base implements IEnumerable$1<WorksheetTableColumn> {
    static $t: Type;
    private _e;
    private _a;
    constructor(a: WorksheetTable);
    [Symbol.iterator](): EnumeratorWrapper<WorksheetTableColumn>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetTableColumn>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Determines whether the specified [[WorksheetTableColumn]] is in the collection.
     * @param column The column to find in the collection.
     * @return True if the specified column is in the collection; False otherwise.
     * @see [[WorksheetTableColumn]]
     */
    contains(column: WorksheetTableColumn): boolean;
    /**
     * Gets the index of the specified [[WorksheetTableColumn]] in the collection.
     * @param column The WorksheetTableColumn to find in the collection.
     * @return The 0-based index of the specified WorksheetTableColumn in the collection or -1 if the item is not in the collection.
     */
    indexOf(column: WorksheetTableColumn): number;
    /**
     * @hidden
     */
    _h(a: number, b: WorksheetTableColumn): void;
    /**
     * @hidden
     */
    _i(a: number): void;
    /**
     * Gets the number of [[WorksheetTableColumn]] instances in the collection.
     * The number of columns in the collection.
     */
    get count(): number;
    /**
     * Gets the [[WorksheetTableColumn]] at the specified index.
     * @param index The 0-based index of the column to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to the number of columns in the collection.
     * @return The WorksheetTableColumn at the specified index.
     */
    item(index: number): WorksheetTableColumn;
    /**
     * Gets the [[WorksheetTableColumn]] with the specified name or null if it doesn't exist.
     * <p class="body">
     * Column names are compared case-insensitively.
     * </p>
     * @param name The name of the column to get.
     * @return The WorksheetTableColumn with the specified name or null a column with the specified name doesn't exist.
     * @see [[WorksheetTableColumn.name]]
     */
    item(name: string): WorksheetTableColumn;
    /**
     * @hidden
     */
    _item(a: number): WorksheetTableColumn;
    /**
     * @hidden
     */
    _item1(a: string): WorksheetTableColumn;
}
/**
 * Class which controls the way unfrozen panes are arranged and used for a worksheet.
 * <p class="note">
 * <B>Note:</B> Frozen and unfrozen panes cannot be used simultaneously, so depending whether the panes are
 * frozen or unfrozen, these settings may not be used or saved.
 * </p>
 * @see [[DisplayOptions.panesAreFrozen]]
 * @see [[FrozenPaneSettings]]
 */
export declare class UnfrozenPaneSettings extends PaneSettingsBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ab;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    private static readonly _al;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static readonly _w;
    private _af;
    private _aj;
    private _z;
    private _ac;
    private _am;
    constructor(a: DisplayOptions);
    /**
     * @hidden
     */
    _g(): PaneSettingsBase;
    /**
     * @hidden
     */
    protected get__h(): boolean;
    /**
     * @hidden
     */
    get _h(): boolean;
    /**
     * @hidden
     */
    protected get__i(): boolean;
    /**
     * @hidden
     */
    get _i(): boolean;
    /**
     * @hidden
     */
    _s(a: PaneSettingsBase): void;
    /**
     * Resets the unfrozen pane settings to their defaults.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    resetCore(): void;
    /**
     * Gets or sets the first visible column in the left pane(s) of the worksheet.
     * <p class="body">
     * This affects the scroll position for the left pane(s) of the worksheet and is used regardless of whether or not the
     * worksheet is split vertically.
     * </p>
     * The zero-based index of the first visible column in the left pane(s).
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid column range (0 to one less than [[Workbook.maxExcelColumnCount]] or
     * [[Workbook.maxExcel2007ColumnCount]], depending on the workbook's
     * [[Workbook.currentFormat]]).
     */
    get firstColumnInLeftPane(): number;
    set firstColumnInLeftPane(a: number);
    /**
     * Gets or sets the first visible row in the top pane(s) of the worksheet.
     * <p class="body">
     * This affects the scroll position for the top pane(s) of the worksheet and is used regardless of whether or not
     * the worksheet is split horizontally.
     * </p>
     * The zero-based index of the first visible row in the top pane(s).
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid row range (0 to one less than [[Workbook.maxExcelRowCount]] or
     * [[Workbook.maxExcel2007RowCount]], depending on the workbook's
     * [[Workbook.currentFormat]]).
     */
    get firstRowInTopPane(): number;
    set firstRowInTopPane(a: number);
    /**
     * Gets or sets the width of the left pane in twips (1/20th of a point).
     * <p class="body">
     * If this value is zero, the left pane occupies the entire visible area of the worksheet.
     * Otherwise, the left pane occupies the specified width and the right pane occupies
     * the remaining area of the worksheet.
     * </p>
     * The width of the left pane, or zero if there is no horizontal pane split.
     * @throws [[ArgumentOutOfRangeException]] Thrown when the width specified is outside the valid width range (0 to 65535).
     */
    get leftPaneWidth(): number;
    set leftPaneWidth(a: number);
    /**
     * Gets or sets the height of the top pane in twips (1/20th of a point).
     * <p class="body">
     * If this value is zero, the top pane occupies the entire visible area of the worksheet.
     * Otherwise, the top pane occupies the specified height and the bottom pane occupies
     * the remaining area of the worksheet.
     * </p>
     * The height of the top pane, or zero if there is no vertical pane split.
     * @throws [[ArgumentOutOfRangeException]] Thrown when the height specified is outside the valid height range (0 to 65535).
     */
    get topPaneHeight(): number;
    set topPaneHeight(a: number);
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    private _an;
    /**
     * @hidden
     */
    _j(): boolean;
    /**
     * @hidden
     */
    _ao(a: number, b: number): void;
}
/**
 * Abstract base class for all shapes that can display text.
 * <p class="body">
 * Primitive shapes, such as polygons, and cell comments can display regular text or text with mixed formatting and are derived from this class.
 * </p>
 * @see [[WorksheetCellComment]]
 * @see [[UnknownShape]]
 */
export declare abstract class WorksheetShapeWithText extends WorksheetShape implements IFormattedTextOwner, IWorkbookFontDefaultsResolver {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _d3: number;
    /**
     * @hidden
     */
    static readonly _d4: number;
    /**
     * @hidden
     */
    static readonly _d7: number;
    /**
     * @hidden
     */
    static readonly _eb: number;
    /**
     * @hidden
     */
    static readonly _d8: number;
    /**
     * @hidden
     */
    private static readonly _dv;
    private _d1;
    private _d5;
    private _d9;
    private _dy;
    private _ec;
    constructor(a: number);
    constructor(a: number, b: boolean);
    constructor(a: number, b: WorksheetShape);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    onFormattingChanged(sender: FormattedText): void;
    /**
     * @hidden
     */
    onUnformattedStringChanged(sender: FormattedText): void;
    /**
     * @hidden
     */
    resolveDefaults(font: WorkbookFontData): void;
    /**
     * @hidden
     */
    _ct(a: WorksheetShapeCollection): void;
    /**
     * @hidden
     */
    _cz(): void;
    /**
     * @hidden
     */
    _c0(a: Sheet): void;
    /**
     * @hidden
     */
    _ee(): void;
    /**
     * @hidden
     */
    private static _dx;
    /**
     * @hidden
     */
    private static _dw;
    /**
     * @hidden
     */
    get _d0(): boolean;
    /**
     * Gets or sets the formatted text of the shape.
     * The formatted text of the shape.
     */
    get text(): FormattedText;
    set text(a: FormattedText);
    /**
     * @hidden
     */
    get _d6(): number;
    /**
     * @hidden
     */
    set _d6(a: number);
    /**
     * @hidden
     */
    get _ed(): number;
    /**
     * @hidden
     */
    set _ed(a: number);
    /**
     * @hidden
     */
    get _ea(): number;
    /**
     * @hidden
     */
    set _ea(a: number);
    /**
     * @hidden
     */
    get _d2(): number;
    /**
     * @hidden
     */
    set _d2(a: number);
}
/**
 * Represents an unsupported shape which has been loaded from a workbook file.
 * <p class="body">
 * This class is used for round-tripping purposes, so unsupported shapes which have been
 * loaded can be saved back out with the workbook.  The class allows the unsupported shapes
 * to be identified in shape collections so they can be removed. This shape will become
 * obsolete in future versions when all shape types are supported.
 * </p>
 */
export declare class UnknownShape extends WorksheetShapeWithText implements IWorksheetImage {
    static $t: Type;
    private _el;
    private _em;
    private _eo;
    private _eh;
    private _ej;
    private _ei;
    constructor(a: number, b: ShapeType, c: number);
    constructor(a: number);
    constructor(a: number, b: WorksheetShape);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    get image(): ExcelImage;
    /**
     * @hidden
     */
    set image(a: ExcelImage);
    /**
     * @hidden
     */
    get preferredFormat(): ImageFormat;
    /**
     * @hidden
     */
    set preferredFormat(a: ImageFormat);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__aq(): boolean;
    /**
     * Throws an exception because all data in an unknown shape is unknown, and clearing that data would leave
     * no data with the shape.
     * @throws [[InvalidOperationException]] This method is called on an [[UnknownShape]] instance.
     */
    clearUnknownData(): void;
    /**
     * @hidden
     */
    _cr(): void;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    _eq(a: Nullable$1<ShapeType>, b: ST_ShapeType): void;
    /**
     * @hidden
     */
    _ef: RoundTripControlData;
    /**
     * @hidden
     */
    _en: any;
    /**
     * @hidden
     */
    get _ek(): boolean;
    /**
     * @hidden
     */
    set _ek(a: boolean);
    /**
     * @hidden
     */
    _eg: ILegacyShapeData;
    /**
     * @hidden
     */
    get _ep(): number;
}
/**
 * @hidden
 */
export interface ILegacyShapeData {
    fmlaMacro: Formula;
}
/**
 * @hidden
 */
export declare let ILegacyShapeData_$type: Type;
/**
 * @hidden
 */
export declare class ColorsInternal extends Base {
    static $t: Type;
    static get a(): Color;
    static get b(): Color;
    static get d(): Color;
    static get c(): Color;
    static get e(): Color;
}
/**
 * @hidden
 */
export declare class SystemColorsInternal extends Base {
    static $t: Type;
    private static a;
    private static get b();
    private static ad;
    private static ae;
    static c(a: Color): boolean;
    static get d(): Color;
    static get e(): Color;
    static get f(): Color;
    static get g(): Color;
    static get h(): Color;
    static get i(): Color;
    static get j(): Color;
    static get k(): Color;
    static get r(): Color;
    static get s(): Color;
    static get l(): Color;
    static get m(): Color;
    static get n(): Color;
    static get o(): Color;
    static get p(): Color;
    static get q(): Color;
    static get v(): Color;
    static get w(): Color;
    static get z(): Color;
    static get aa(): Color;
    static get x(): Color;
    static get y(): Color;
    static get t(): Color;
    static get u(): Color;
    static get ab(): Color;
    static get ac(): Color;
    static get af(): Color;
    static get ag(): Color;
    static get ah(): Color;
    static get ai(): Color;
    static get aj(): Color;
    static get ak(): Color;
    static get al(): Color;
    static get am(): Color;
    static get an(): Color;
    static get ao(): Color;
    static get ap(): Color;
    static get aq(): Color;
    static get ar(): Color;
    static get as(): Color;
    static get at(): Color;
    static get au(): Color;
    static get av(): Color;
    static get aw(): Color;
    static get ax(): Color;
    static get ay(): Color;
    static get az(): Color;
    static get a0(): Color;
    static get a3(): Color;
    static get a4(): Color;
    static get a1(): Color;
    static get a2(): Color;
    static get a5(): Color;
    static get a6(): Color;
    static get a7(): Color;
    static get a8(): Color;
    static get a9(): Color;
    static get ba(): Color;
    static get bb(): Color;
    static get bc(): Color;
    static get bd(): Color;
    static get be(): Color;
    static get bf(): Color;
    static get bg(): Color;
}
/**
 * @hidden
 */
export declare class SystemColorsInternal_ColorResolver extends Base {
    static $t: Type;
    private a;
    c(a: any): void;
    get b(): Color[];
}
/**
 * @hidden
 */
export declare class ActiveCellChangedInfo extends Base {
    static $t: Type;
    private readonly a;
    constructor(a: Workbook);
    e(): void;
    b: Worksheet;
    d: number;
    c: number;
}
/**
 * Represents the color palette used when the saved file is opened in Microsoft Excel 2003 and earlier versions.
 * @see [[Workbook.palette]]
 */
export declare class WorkbookColorPalette extends Base implements ICollection$1<Color> {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _h: number;
    /**
     * @hidden
     */
    static readonly _o: number;
    /**
     * @hidden
     */
    static readonly _v: number;
    /**
     * @hidden
     */
    static readonly _w: number;
    /**
     * @hidden
     */
    static readonly _z: number;
    /**
     * @hidden
     */
    static readonly _x: number;
    /**
     * @hidden
     */
    static readonly _y: number;
    /**
     * @hidden
     */
    static readonly _i: number;
    /**
     * @hidden
     */
    static readonly _l: number;
    /**
     * @hidden
     */
    static readonly _k: number;
    /**
     * @hidden
     */
    static readonly _j: number;
    /**
     * @hidden
     */
    static readonly _q: number;
    /**
     * @hidden
     */
    static readonly _t: number;
    /**
     * @hidden
     */
    static readonly _u: number;
    /**
     * @hidden
     */
    static readonly _r: number;
    /**
     * @hidden
     */
    static readonly _s: number;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _am;
    /**
     * @hidden
     */
    private static readonly _al;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    private static readonly _ak;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static _b;
    private _d;
    private _a;
    private readonly _c;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    add(item: string | Color): void;
    /**
     * @hidden
     */
    _add$i(a: Color): void;
    /**
     * @hidden
     */
    clear(): void;
    /**
     * @hidden
     */
    copyTo(array: Color[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    remove(item: string | Color): boolean;
    /**
     * @hidden
     */
    _remove$i(a: Color): boolean;
    [Symbol.iterator](): EnumeratorWrapper<Color>;
    /**
     * @hidden
     */
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<Color>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Determines whether the specified color is in the color palette.
     * @param color The color to find in the palette.
     * @return Determines whether an equivalent color is in the palette.
     */
    contains(color: string | Color): boolean;
    /**
     * @hidden
     */
    _contains$i(a: Color): boolean;
    /**
     * Gets the index of the closest color in the color palette, which will be seen when the file is opened in Microsoft Excel 2003
     * and older versions.
     * @param color The color to match in the palette.
     * @return A 0-based index into the collection of the closest color available in the palette.
     */
    getIndexOfNearestColor(color: string | Color): number;
    /**
     * @hidden
     */
    _getIndexOfNearestColor$i(a: Color): number;
    /**
     * Resets the palette back to the default colors for Microsoft Excel.
     * @see [[isCustom]]
     */
    reset(): void;
    /**
     * @hidden
     */
    _m(a: WorkbookColorInfo, b: ColorableItem): number;
    /**
     * @hidden
     */
    private _n;
    /**
     * @hidden
     */
    _af(a: number): Color;
    /**
     * @hidden
     */
    _g(a: number): boolean;
    /**
     * @hidden
     */
    private _ag;
    /**
     * @hidden
     */
    static _e(a: Color, b: Color): boolean;
    /**
     * @hidden
     */
    private static _ah;
    /**
     * @hidden
     */
    private _ab;
    /**
     * Gets the number of colors in the palette, which is always 56.
     */
    get count(): number;
    /**
     * Gets or sets a color in the palette.
     * <p class="body">
     * When a color is set in the palette, [[isCustom]] will return True. The palette can than be reset with the
     * [[reset]] method.
     * </p>
     * <p class="body">
     * Colors added to the palette must be opaque.
     * </p>
     * @param index The index of the color to get or set in the palette.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than 55.
     * @throws [[ArgumentException]] The value assigned is an empty color, a system color, or is not opaque.
     * @see [[isCustom]]
     * @see [[reset]]
     */
    item(index: number, value?: string | Color): string;
    /**
     * @hidden
     */
    _item$i(a: number, b?: Color): Color;
    /**
     * Gets the value which indicates whether the palette has been cusotmized.
     * @see [[reset]]
     */
    get isCustom(): boolean;
}
/**
 * @hidden
 */
export declare class UltimateFontDefaultsResolver extends Base implements IWorkbookFontDefaultsResolver {
    static $t: Type;
    static readonly a: UltimateFontDefaultsResolver;
    constructor();
    resolveDefaults(a: WorkbookFontData): void;
}
/**
 * @hidden
 */
export declare class WorkbookFontDataResolved extends Base implements IWorkbookFont {
    static $t: Type;
    private _a;
    constructor(a: WorksheetCellFormatProxy);
    equals(a: any): boolean;
    getHashCode(): number;
    setFontFormatting(a: IWorkbookFont): void;
    get bold(): boolean | null;
    set bold(a: boolean | null);
    get _bold$i(): Nullable$1<boolean>;
    set _bold$i(a: Nullable$1<boolean>);
    get colorInfo(): WorkbookColorInfo;
    set colorInfo(a: WorkbookColorInfo);
    get height(): number;
    set height(a: number);
    get italic(): boolean | null;
    set italic(a: boolean | null);
    get _italic$i(): Nullable$1<boolean>;
    set _italic$i(a: Nullable$1<boolean>);
    get name(): string;
    set name(a: string);
    get strikeout(): boolean | null;
    set strikeout(a: boolean | null);
    get _strikeout$i(): Nullable$1<boolean>;
    set _strikeout$i(a: Nullable$1<boolean>);
    get superscriptSubscriptStyle(): FontSuperscriptSubscriptStyle;
    set superscriptSubscriptStyle(a: FontSuperscriptSubscriptStyle);
    get underlineStyle(): FontUnderlineStyle;
    set underlineStyle(a: FontUnderlineStyle);
    _d(a: WorksheetCellFormatProxy): void;
    private _e;
}
/**
 * @hidden
 */
export declare class WorkbookFontOwnerAccessor extends Base implements IWorkbookFont {
    static $t: Type;
    private _a;
    constructor(a: WorksheetCellFormatProxy);
    setFontFormatting(a: IWorkbookFont): void;
    _setFontFormatting1(a: IWorkbookFont, b: boolean, c: CellFormatValueChangedOptions): void;
    private _e;
    get bold(): boolean | null;
    set bold(a: boolean | null);
    get _bold$i(): Nullable$1<boolean>;
    set _bold$i(a: Nullable$1<boolean>);
    _b(a: Nullable$1<boolean>, b: boolean, c: CellFormatValueChangedOptions): void;
    get colorInfo(): WorkbookColorInfo;
    set colorInfo(a: WorkbookColorInfo);
    _c(a: WorkbookColorInfo, b: boolean, c: CellFormatValueChangedOptions): void;
    get height(): number;
    set height(a: number);
    _f(a: number, b: boolean, c: CellFormatValueChangedOptions): void;
    get italic(): boolean | null;
    set italic(a: boolean | null);
    get _italic$i(): Nullable$1<boolean>;
    set _italic$i(a: Nullable$1<boolean>);
    _g(a: Nullable$1<boolean>, b: boolean, c: CellFormatValueChangedOptions): void;
    get name(): string;
    set name(a: string);
    _h(a: string, b: boolean, c: CellFormatValueChangedOptions): void;
    get strikeout(): boolean | null;
    set strikeout(a: boolean | null);
    get _strikeout$i(): Nullable$1<boolean>;
    set _strikeout$i(a: Nullable$1<boolean>);
    _i(a: Nullable$1<boolean>, b: boolean, c: CellFormatValueChangedOptions): void;
    get superscriptSubscriptStyle(): FontSuperscriptSubscriptStyle;
    set superscriptSubscriptStyle(a: FontSuperscriptSubscriptStyle);
    _j(a: FontSuperscriptSubscriptStyle, b: boolean, c: CellFormatValueChangedOptions): void;
    get underlineStyle(): FontUnderlineStyle;
    set underlineStyle(a: FontUnderlineStyle);
    _k(a: FontUnderlineStyle, b: boolean, c: CellFormatValueChangedOptions): void;
}
/**
 * @hidden
 */
export declare class WorkbookFontProxy extends GenericCacheElementProxy$1<WorkbookFontData> implements IWorkbookFont {
    static $t: Type;
    private _m;
    private _q;
    private _n;
    constructor(a: number, b: WorkbookFontData, c: Workbook, d: WorksheetCellFormatData);
    constructor(a: number, b: WorkbookFontData, c: GenericCachedCollectionEx$1<WorkbookFontData>);
    constructor(a: number, ..._rest: any[]);
    g(a: GenericCachedCollection$1<WorkbookFontData>): void;
    static _l(a: IWorkbookFont, b: IWorkbookFont): CellFormatValue;
    _s(a: (arg1: WorkbookFontProxy_PropertyIds) => void): void;
    setFontFormatting(a: IWorkbookFont): void;
    _t(a: IWorkbookFont, b: boolean): void;
    static _o(a: IWorkbookFont, b: IWorkbookFont, c: CellFormatValue): boolean;
    private _u;
    _p(): boolean;
    get bold(): boolean | null;
    set bold(a: boolean | null);
    get _bold$i(): Nullable$1<boolean>;
    set _bold$i(a: Nullable$1<boolean>);
    get colorInfo(): WorkbookColorInfo;
    set colorInfo(a: WorkbookColorInfo);
    get height(): number;
    set height(a: number);
    get italic(): boolean | null;
    set italic(a: boolean | null);
    get _italic$i(): Nullable$1<boolean>;
    set _italic$i(a: Nullable$1<boolean>);
    get name(): string;
    set name(a: string);
    get strikeout(): boolean | null;
    set strikeout(a: boolean | null);
    get _strikeout$i(): Nullable$1<boolean>;
    set _strikeout$i(a: Nullable$1<boolean>);
    get superscriptSubscriptStyle(): FontSuperscriptSubscriptStyle;
    set superscriptSubscriptStyle(a: FontSuperscriptSubscriptStyle);
    get underlineStyle(): FontUnderlineStyle;
    set underlineStyle(a: FontUnderlineStyle);
    get _r(): Nullable$1<number>;
    set _r(a: Nullable$1<number>);
}
/**
 * @hidden
 */
export declare class WorkbookFormatCollection extends Base {
    static $t: Type;
    private static h;
    private static k;
    private i;
    private j;
    private s;
    private o;
    private p;
    private l;
    private b;
    private aa;
    private ab;
    private ag;
    private f;
    private n;
    private readonly g;
    private v;
    private y;
    constructor(a: Workbook);
    q(a: string): number;
    am(a: number, b: string): void;
    an(a: number, b: string, c: boolean): void;
    private ao;
    ap(a: number, b: string): void;
    private aq;
    private z;
    private static d;
    static aj(a: number): number;
    private _m;
    m(): IEnumerable$1<number>;
    ad(a: number): string;
    static af(a: CultureInfo): string;
    static ae(a: CultureInfo): string;
    a(a: number): ValueFormatter;
    c(a: number): boolean;
    private static ar;
    private static as;
    e(a: number): boolean;
    static ak(a: number): number;
    private at;
    private au;
    get r(): number;
    item(a: number): string;
    private al;
}
/**
 * @hidden
 */
export declare class WorkbookLoadCache extends Base implements IDisposable, IPackageFactory {
    static $t: Type;
    private readonly _a;
    private _b;
    constructor(a: WorkbookLoadOptions);
    open(stream: string | Uint8Array, packageMode: FileMode): WorkItem$1<IPackage>;
    _open$i(a: Stream, b: FileMode): WorkItem$1<IPackage>;
    dispose(): void;
}
/**
 * Contains the options related to saving a workbook to a file or stream.
 * @see [[Workbook.save]]
 */
export declare class WorkbookSaveOptions extends WorkbookOptionsBase {
    static $t: Type;
    private _f;
    constructor();
    /**
     * @hidden
     */
    get _g(): WorkbookSaveFilter;
    /**
     * @hidden
     */
    set _g(a: WorkbookSaveFilter);
    /**
     * @hidden
     */
    _i: boolean;
    private _type;
    /**
     * Gets or sets the format in which to save the workbook: "base64", "string", "uint8array", "arraybuffer", "blob"
     */
    get type(): string;
    set type(a: string);
    /**
     * @hidden
     */
    static _h(a: WorkbookSaveOptions): WorkbookSaveFilter;
}
/**
 * @hidden
 */
export declare abstract class WorkbookSaveFilter extends Base {
    static $t: Type;
    abstract d(a: Worksheet): number;
    abstract e(a: Worksheet): number;
    a(a: Worksheet): IEnumerable$1<WorksheetMergedCellsRegion>;
    abstract b(a: Worksheet, b: boolean): IEnumerable$1<WorksheetRow>;
    abstract c(a: Workbook): IList$1<Sheet>;
}
/**
 * @hidden
 */
export declare class DefaultWorkbookSaveFilter extends WorkbookSaveFilter {
    static $t: Type;
    static readonly f: WorkbookSaveFilter;
    constructor();
    d(a: Worksheet): number;
    e(a: Worksheet): number;
    b(a: Worksheet, b: boolean): IEnumerable$1<WorksheetRow>;
    c(a: Workbook): IList$1<Sheet>;
}
/**
 * @hidden
 */
export declare class WorkbookStyle_StyleChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorkbookStyle);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly a;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Represents a complex format which can be applied to a cell's format.
 * <p class="body">
 * When a style is applied to a cell by setting its CellFormat.Style property, the cell's format will pick up subsequent
 * changes to the format properties set by the style when it was applied. This will continue to happen until those format
 * properties are set to other values on the cell format.
 * </p>
 * @see [[IWorksheetCellFormat.style]]
 * @see [[Workbook.styles]]
 */
export declare abstract class WorkbookStyle extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _s: number;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    private static readonly _t;
    /**
     * @hidden
     */
    private static _a;
    private _j;
    private _q;
    private _h;
    private _f;
    static staticInit(): void;
    constructor(a: Workbook, b: IWorksheetCellFormat);
    /**
     * Resets the style to its original state.
     * <p class="body">
     * If this is a user defined style, the format of the style will be reset so that it provides no formatting properties.
     * If this is a built in style, this format will revert back to its preset state if it has previously been changed.
     * </p>
     */
    abstract reset(): void;
    /**
     * @hidden
     */
    _v(): void;
    /**
     * @hidden
     */
    _w(a: WorksheetCellFormatOptions): void;
    /**
     * @hidden
     */
    _x(): void;
    /**
     * @hidden
     */
    _y(): void;
    /**
     * @hidden
     */
    _z(): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * Gets the value indicating whether the style is a built in style in Microsoft Excel.
     */
    abstract get isBuiltIn(): boolean;
    /**
     * Gets or sets the name of the workbook style.
     * <p class="body">
     * The style names must be case-insensitively unique and the names for built in styles cannot be changed.
     * </p>
     * The name of the workbook style.
     * @throws [[InvalidOperationException]] The value is assigned and the style is a built.
     * @throws [[ArgumentException]] The value assigned is null or empty.
     * @throws [[ArgumentException]] The value assigned is longer than 255 characters.
     * @throws [[ArgumentException]] The value assigned matches the name of another style in the collection.
     * @see [[isBuiltIn]]
     */
    abstract get name(): string;
    abstract set name(a: string);
    /**
     * Gets the cell format which applies to the workbook style.
     * The cell format which applies to the workbook style.
     */
    get styleFormat(): IWorksheetCellFormat;
    /**
     * @hidden
     */
    abstract get _e(): StyleCategory;
    /**
     * @hidden
     */
    protected get__k(): boolean;
    /**
     * @hidden
     */
    get _k(): boolean;
    /**
     * @hidden
     */
    get _m(): boolean;
    /**
     * @hidden
     */
    set _m(a: boolean);
    /**
     * @hidden
     */
    abstract get _n(): boolean;
    /**
     * @hidden
     */
    protected get__o(): boolean;
    /**
     * @hidden
     */
    get _o(): boolean;
    /**
     * @hidden
     */
    protected get__p(): boolean;
    /**
     * @hidden
     */
    get _p(): boolean;
    /**
     * @hidden
     */
    get _i(): WorksheetCellFormatData;
    /**
     * @hidden
     */
    get _g(): Workbook;
}
/**
 * @hidden
 */
export declare class WorkbookBuiltInStyle extends WorkbookStyle implements IComparable$1<WorkbookBuiltInStyle> {
    static $t: Type;
    private _af;
    private _ae;
    private readonly _aj;
    private readonly _ab;
    constructor(a: Workbook, b: IWorksheetCellFormat, c: BuiltInStyleType, d: number);
    compareTo(a: WorkbookBuiltInStyle): number;
    protected get__e(): StyleCategory;
    get _e(): StyleCategory;
    protected get__k(): boolean;
    protected get_isBuiltIn(): boolean;
    get isBuiltIn(): boolean;
    protected get__n(): boolean;
    get _n(): boolean;
    protected get_name(): string;
    protected set_name(a: string): void;
    get name(): string;
    set name(a: string);
    _w(a: WorksheetCellFormatOptions): void;
    reset(): void;
    protected get__o(): boolean;
    protected get__p(): boolean;
    _ad(a: Workbook): WorkbookBuiltInStyle;
    get _ag(): boolean;
    get _ah(): boolean;
    set _ah(a: boolean);
    get _ak(): number;
    get _ac(): BuiltInStyleType;
    get _ai(): boolean;
}
/**
 * @hidden
 */
export declare class WorkbookUserDefinedStyle extends WorkbookStyle {
    static $t: Type;
    private _ab;
    constructor(a: Workbook, b: IWorksheetCellFormat, c: string);
    protected get__e(): StyleCategory;
    get _e(): StyleCategory;
    protected get_isBuiltIn(): boolean;
    get isBuiltIn(): boolean;
    protected get__n(): boolean;
    get _n(): boolean;
    protected get_name(): string;
    protected set_name(a: string): void;
    get name(): string;
    set name(a: string);
    reset(): void;
    protected get__o(): boolean;
    protected get__p(): boolean;
}
/**
 * @hidden
 */
export declare class ExcelCalcEngine extends Base {
    static $t: Type;
    private readonly p;
    private readonly t;
    private e;
    private f;
    private readonly a;
    private r;
    private readonly s;
    private c;
    private j;
    private k;
    private readonly q;
    private g;
    private h;
    private readonly i;
    constructor(a: Workbook);
    w(a: IExcelCalcReference, b: RefBase): void;
    x(a: SingleTargetFormula): void;
    aa(): void;
    ab(a?: boolean): void;
    ac(a: RefBase, b: boolean): void;
    ad(): void;
    static u(a: IExcelCalcReference): any;
    static b(a: IExcelCalcReference): IExcelCalcReference;
    n(a: RefBase): boolean;
    al(a: WorksheetDataTable): void;
    am(a: WorksheetDataTable): void;
    an(a: NamedCalcReferenceBase, b: ReferenceActionCode): void;
    ao(a: WorksheetTable): void;
    ap(a: WorksheetTable): void;
    aq(a: CellCalcReference): void;
    ar(a: CellCalcReference, b: boolean): void;
    at(a: boolean): void;
    au(a: IExcelCalcReference, b: RefBase): void;
    av(a: SingleTargetFormula): void;
    ay(): void;
    private y;
    private z;
    private ae;
    private af;
    private ag;
    private ah;
    private ai;
    private aj;
    private v;
    private ak;
    private as;
    private o;
    aw(a: RefBase): {
        p0?: RefBase;
    };
    private ax;
    get d(): UltraCalcFunctionFactory;
    get l(): boolean;
    get m(): boolean;
}
/**
 * @hidden
 */
export declare abstract class RefBase extends Base implements IExcelCalcReference {
    static $t: Type;
    static readonly _a: RefBase[];
    private _ap;
    private _p;
    private _h;
    private _i;
    private _an;
    _e: CalculationContext;
    constructor();
    get formula(): IExcelCalcFormula;
    get references(): IExcelCalcReferenceCollection;
    equals(a: any): boolean;
    abstract _z(a: IExcelCalcReference): boolean;
    abstract getHashCode(): number;
    toString(): string;
    _au(a: RefBase): void;
    abstract containsReference(a: IExcelCalcReference): boolean;
    createReference(a: string): IExcelCalcReference;
    _v(): WorksheetRegion;
    _am(): IList$1<WorksheetRegion>;
    _al(): IEnumerable$1<RefBase>;
    _ae(a: Worksheet, b: WorksheetRegionAddress): boolean;
    abstract isSubsetReference(a: IExcelCalcReference): boolean;
    _aw(a: RefBase): void;
    _ax(): void;
    _m(a: CalculationContext, b: boolean, c: ExcelCalcErrorValue): {
        ret: RefBase;
        p0?: CalculationContext;
        p2: ExcelCalcErrorValue;
    };
    _a0(a: SingleTargetFormula, b: boolean, c?: boolean, d?: boolean): void;
    _o(): RefBase;
    _b(a: boolean): ExcelCalcValue;
    _n(a: CellCalcReference, b: ExcelCalcErrorValue): {
        ret: RefBase;
        p1: ExcelCalcErrorValue;
    };
    _az(a: SingleTargetFormula): void;
    protected _a1(a: ExcelCalcValue): void;
    private _aa;
    private _av;
    private _ay;
    get absoluteName(): string;
    protected get__formula(): SingleTargetFormula;
    get _formula(): SingleTargetFormula;
    get _aq(): number;
    set _aq(a: number);
    get _d(): NodeState;
    set _d(a: NodeState);
    protected get__x(): boolean;
    get _x(): boolean;
    abstract get _ao(): number;
    protected get_context(): any;
    get context(): any;
    abstract get elementName(): string;
    get _ab(): boolean;
    set _ab(a: boolean);
    get _ac(): boolean;
    get _ad(): boolean;
    set _ad(a: boolean);
    get _af(): boolean;
    set _af(a: boolean);
    protected get_isEnumerable(): boolean;
    get isEnumerable(): boolean;
    get _ag(): boolean;
    set _ag(a: boolean);
    get _ah(): boolean;
    set _ah(a: boolean);
    protected get__aj(): boolean;
    get _aj(): boolean;
    get _ai(): boolean;
    set _ai(a: boolean);
    get _j(): RefBase;
    set _j(a: RefBase);
    get normalizedAbsoluteName(): string;
    protected get__f(): IExcelCalcReferenceCollectionEx;
    get _f(): IExcelCalcReferenceCollectionEx;
    get _k(): RefBase;
    set _k(a: RefBase);
    protected get__references(): IExcelCalcReferenceCollectionEx;
    get _references(): IExcelCalcReferenceCollectionEx;
    protected get__l(): RefBase;
    get _l(): RefBase;
    abstract get _w(): WorksheetRow;
    protected get__as(): number;
    get _as(): number;
    protected get__r(): Sheet;
    get _r(): Sheet;
    protected get__ak(): boolean;
    protected get _ak(): boolean;
    protected get_value(): ExcelCalcValue;
    protected set_value(a: ExcelCalcValue): void;
    get value(): ExcelCalcValue;
    set value(a: ExcelCalcValue);
    abstract get _c(): ExcelCalcValue;
    protected get__t(): Workbook;
    get _t(): Workbook;
    protected get__u(): Worksheet;
    get _u(): Worksheet;
    protected get__q(): WorksheetReference;
    get _q(): WorksheetReference;
}
/**
 * @hidden
 */
export declare abstract class RegionCalcReferenceBase extends RefBase implements IRegionAddress {
    static $t: Type;
    static readonly _a8: List$1<RegionCalcReferenceBase>;
    private _a2;
    constructor();
    protected get__x(): boolean;
    protected get__ao(): number;
    get _ao(): number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    _am(): IList$1<WorksheetRegion>;
    _ae(a: Worksheet, b: WorksheetRegionAddress): boolean;
    protected get_isEnumerable(): boolean;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__references(): IExcelCalcReferenceCollectionEx;
    _n(a: CellCalcReference, b: ExcelCalcErrorValue): {
        ret: RefBase;
        p1: ExcelCalcErrorValue;
    };
    protected get__w(): WorksheetRow;
    get _w(): WorksheetRow;
    abstract get _a3(): WorksheetRegion;
    abstract _a4(a: number, b: number): boolean;
    abstract _a5(a: number, b: number): boolean;
    abstract _a7(a: number, b: number): boolean;
    abstract _a6(a: number, b: number): boolean;
    containsColumns(a: number, b: number): boolean;
    intersectsWithColumns(a: number, b: number): boolean;
    containsRows(a: number, b: number): boolean;
    intersectsWithRows(a: number, b: number): boolean;
}
/**
 * @hidden
 */
export declare abstract class CellCalcReferenceBase extends RefBase {
    static $t: Type;
    private _a9;
    protected _a8: number;
    private _a2;
    protected _a3: WorksheetRow;
    constructor(a: WorksheetRow, b: number);
    protected get__x(): boolean;
    protected get__ao(): number;
    get _ao(): number;
    protected get_context(): any;
    protected get_elementName(): string;
    get elementName(): string;
    protected get__formula(): SingleTargetFormula;
    _am(): IList$1<WorksheetRegion>;
    _ae(a: Worksheet, b: WorksheetRegionAddress): boolean;
    protected get__f(): IExcelCalcReferenceCollectionEx;
    protected get__w(): WorksheetRow;
    get _w(): WorksheetRow;
    _az(a: SingleTargetFormula): void;
    protected _a1(a: ExcelCalcValue): void;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
    protected get__t(): Workbook;
    _ba(a: number, b: number): {
        p0: number;
        p1: number;
    };
    protected _bb(a: WorksheetRow, b: number): void;
    get _a4(): boolean;
    get _a5(): boolean;
    get _a6(): boolean;
    get _a7(): boolean;
}
/**
 * @hidden
 */
export declare class CellCalcReference extends CellCalcReferenceBase {
    static $t: Type;
    private static _bc;
    constructor(a: WorksheetRow, b: number);
    containsReference(a: IExcelCalcReference): boolean;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    _bf(): void;
    _bg(): void;
    static _bd(a: WorksheetRow, b: number): CellCalcReference;
    _be(): boolean;
}
/**
 * @hidden
 */
export declare class DependencyGraph extends Base {
    static $t: Type;
    readonly b: CalculationNetworkLinkedList;
    private readonly e;
    c: DependencyGraph_EvaluationEnumerator;
    private j;
    private readonly s;
    private readonly r;
    private k;
    private readonly z;
    private readonly t;
    private static readonly f;
    private i;
    constructor(a: ExcelCalcEngine);
    ad(a: RefBase, b: RefBase): void;
    ae(a: SingleTargetFormula): void;
    af(a: RefBase): void;
    am(): void;
    ao(a: RefBase): void;
    aq(): void;
    n(a: boolean): boolean;
    y(): IEnumerator$1<RefBase>;
    q(a: RefBase): boolean;
    at(a: CellCalcReference): void;
    av(a: RefBase, b: RefBase): void;
    aw(a: SingleTargetFormula): void;
    a2(): void;
    private a3;
    ag(a: IEnumerable$1<RefBase>, b: RefBase, c: boolean, d: number): void;
    private static ah;
    private l;
    private m;
    private ai;
    private aj;
    private static readonly h;
    private static readonly aa;
    private ak;
    private readonly ab;
    private al;
    private an;
    private ap;
    private static ar;
    private static as;
    private u;
    private v;
    private w;
    private g;
    private d;
    private x;
    private o;
    private au;
    private ax;
    private static readonly a;
    private ay;
    private az;
    private static a0;
    private a1;
    get p(): boolean;
}
/**
 * @hidden
 */
export declare class CalculationNetworkLinkedList extends Base implements IEnumerable$1<RefBase> {
    static $t: Type;
    private _a;
    private _b;
    constructor();
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<RefBase>;
    getEnumeratorObject(): IEnumerator;
    _e(a: RefBase, b: RefBase): void;
    _f(a: RefBase, b: RefBase): void;
    _g(a: RefBase): void;
    _h(a: RefBase): void;
    _i(a: RefBase): void;
    _j(): void;
    get _c(): RefBase;
    get _d(): RefBase;
}
/**
 * @hidden
 */
export declare class DependencyGraph_StronglyConnectedComponent extends Base {
    static $t: Type;
    private readonly e;
    constructor(a: IEnumerable$1<RefBase>);
    c(a: RefBase): boolean;
    f(a: DependencyGraph): void;
    b(a: RefBase): RefBase;
    a(a: RefBase): RefBase;
    d(): boolean;
}
/**
 * @hidden
 */
export declare class DependencyGraph_SuccessorsResolvedEnumerable extends Base implements IEnumerable$1<RefBase>, IEnumerator$1<RefBase> {
    static $t: Type;
    private _b;
    private readonly _c;
    private _e;
    private readonly _a;
    private _d;
    constructor(a: IEnumerable$1<RefBase>, b: RegionLookupTable_Result$1<RegionCalcReferenceBase>);
    getEnumerator(): IEnumerator$1<RefBase>;
    getEnumeratorObject(): IEnumerator;
    get current(): RefBase;
    dispose(): void;
    get currentObject(): any;
    moveNext(): boolean;
    reset(): void;
}
/**
 * Represents a data table for a range of cells.
 * <p class="body">
 * Data tables are a way to show the results of one or more formulas by trying many different values in the variables
 * of the formulas at the same time, and showing the different results in a table.  An excellent example of a data table
 * application would be for a multiplication table.  A multiplication table shows results for the formula =X*Y.  However,
 * it shows many different results for the formula, where each result is determined by using different values for X and Y.
 * These results are displayed in a table, where each cell in the table shows the formula's result for specific values of
 * X and Y, which are labeled in the row and column headers, respectively.  Therefore, each cell in a row will use the
 * same X value, and each cell in a column will use the same Y value.
 * </p>
 * <p class="body">
 * The multiplication table is known as a two-variable data table. Two-variable data tables are characterized by having a
 * single formula and values in the row and column headers of the table.  The formula is entered into the top-left cell of
 * the data table and usually references at least two cells outside the data table, known as the column-input and row-input
 * cells.  When the formula is evaluated for a specific cell in the data table, the reference to the column-input cell in the
 * formula is replaced with the value in the cell's row header (this may seem backwards, but the values in the row headers
 * run down the left column of the data table, which is why they are used for the column-input cell), and the reference to
 * the row-input cell is replaced with the value in the cell's column header.
 * </p>
 * <p class="body">
 * Another type of data table is the one-variable data table.  A one-variable data table can be a column-oriented or
 * a row-oriented data table.  A column-oriented data table has data in the cells of the left column and formulas in the
 * cells of the top row (anything in the top-left cell of the data table is ignored in this type of data table).  Usually,
 * the formulas in the top row all reference the same cell outside the data table, known as the column-input cell.  When a
 * cell in the table is evaluated, the formula in its column header is used, with the reference to the column-input cell
 * replaced by the value in cell's row header.
 * </p>
 * <p class="body">
 * A row-oriented one-variable data table is formed like a column-oriented data table, except the values run along the top
 * row, the formulas run down the left column, and the cell referenced by all formulas is known as the row-input cell.
 * </p>
 */
export declare class WorksheetDataTable extends Base implements IRegionBlockingValue {
    static $t: Type;
    private _c;
    private _i;
    private _k;
    private _t;
    private _r;
    private _q;
    private _u;
    private _s;
    constructor(a: Worksheet, b: WorksheetRegion, c: WorksheetCell, d: WorksheetCell);
    /**
     * @hidden
     */
    removeFromRegion(): void;
    /**
     * @hidden
     */
    throwBlockingException(): void;
    /**
     * @hidden
     */
    throwExceptionWhenMergedCellsInRegion(): void;
    /**
     * @hidden
     */
    throwExceptionWhenTableInRegion(): void;
    /**
     * @hidden
     */
    get blockedRegion(): WorksheetRegion;
    /**
     * @hidden
     */
    _a(): RefBase;
    /**
     * @hidden
     */
    _v(): string;
    /**
     * @hidden
     */
    _b(): RefBase;
    /**
     * @hidden
     */
    _n(a: WorksheetRow, b: number, c: boolean): {
        ret: boolean;
        p2: boolean;
    };
    /**
     * @hidden
     */
    _o(a: CellShiftOperation): boolean;
    /**
     * @hidden
     */
    _p(a: CellShiftOperation, b: Nullable$1<WorksheetRegionAddress>): boolean;
    /**
     * @hidden
     */
    _y(a: Worksheet, b: WorksheetRegionAddress, c: Nullable$1<WorksheetCellAddress>, d: Nullable$1<WorksheetCellAddress>): void;
    /**
     * @hidden
     */
    _z(): void;
    /**
     * @hidden
     */
    static _ae(a: Worksheet, b: WorksheetRegion, c: string, d: WorksheetCell, e: string, f: WorksheetCell, g: string): void;
    /**
     * @hidden
     */
    private _w;
    /**
     * @hidden
     */
    private _x;
    /**
     * @hidden
     */
    private _aa;
    /**
     * @hidden
     */
    private static _ad;
    /**
     * Gets or sets the region of cells in the data table.
     * <p class="body">
     * Any interior cells (cells not in the left-most column or top row) in this region will have their values removed
     * when this is set. If any interior cells have array formulas with a region that crosses outside the data
     * table, an error will occur. However, if the array formula's region is confined to cells in the
     * interior of the data table, the array formula will have [[ArrayFormula.clearCellRange]]
     * called on it, which will remove it from all its cells. Similarly, if an existing data table's interior cells
     * contain some of the interior cells in this region as well as some external cells, an error will occur.
     * However, if all interior cells of the existing data table are contained in the interior cells of the new
     * region specified here, the existing data table will be removed from the worksheet.
     * </p>
     * <p class="body">
     * After the cells in the table have been specified, the interior cells' values cannot be modified.
     * </p>
     * <p class="note">
     * <B>Note:</B> The [[rowInputCell]] and [[columnInputCell]] cannot be with the region.
     * </p>
     * The region of cells in the data table.
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
     * @throws [[ArgumentException]] The value assigned is a region from a worksheet other than the data table's worksheet.
     * @throws [[InvalidOperationException]] The region specified contains the RowInputCell or the ColumnInputCell.
     * @throws [[InvalidOperationException]] One or more of the interior cells of the value assigned (all cells except the left-most column and top row) is an
     * interior cell of another data table or is a cell in an array formula, and the entire range of that other
     * entity extends outside the interior cells of the value assigned.
     * @throws [[ArgumentException]] The assigned value is only one row tall or one column wide. The cells in the table must be at least two rows by two columns.
     * @throws [[InvalidOperationException]] The assigned value contains merged regions which are not confined to the left-most column or top row. No merged regions
     * can exist in the interior cells of the data table and no merged regions can exist in the left-most column or top row
     * and extend outside the data table region.
     * @see [[ArrayFormula]]
     * @see [[columnInputCell]]
     * @see [[rowInputCell]]
     */
    get cellsInTable(): WorksheetRegion;
    set cellsInTable(a: WorksheetRegion);
    /**
     * @hidden
     */
    get _j(): WorksheetRegionAddress;
    /**
     * Gets or sets the cell used as the column-input cell in the data table.
     * <p class="body">
     * This represents the cell reference in all formulas of the data table to replace with row header values.
     * If this and the [[rowInputCell]] are non-null, the data table is a two-variable data table.
     * Otherwise, if only one is non-null, this is a one-variable data table.
     * </p>
     * <p class="note">
     * <B>Note:</B> The RowInputCell and ColumnInputCell cannot be within the [[cellsInTable]] region.
     * </p>
     * The cell used as the column-input cell in the data table.
     * @throws [[ArgumentException]] The assigned value does not belong to the same worksheet as the data table.
     * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
     * @throws [[InvalidOperationException]] The value assigned is within the CellsInTable region.
     * @throws [[InvalidOperationException]] The assigned value is null and RowInputCell is null. At least one input cell must be non-null.
     * @throws [[InvalidOperationException]] The assigned value is the same as RowInputCell. The input cells cannot be the same cell.
     * @see [[cellsInTable]]
     * @see [[rowInputCell]]
     */
    get columnInputCell(): WorksheetCell;
    set columnInputCell(a: WorksheetCell);
    /**
     * @hidden
     */
    private _ab;
    /**
     * @hidden
     */
    get _l(): boolean;
    /**
     * @hidden
     */
    get _m(): boolean;
    /**
     * @hidden
     */
    get _h(): WorksheetRegion;
    /**
     * Gets or sets the cell used as the row-input cell in the data table.
     * <p class="body">
     * This represents the cell reference in all formulas of the data table to replace with column header values.
     * If this and the [[columnInputCell]] are non-null, the data table is a two-variable data table.
     * Otherwise, if only one is non-null, this is a one-variable data table.
     * </p>
     * <p class="note">
     * <B>Note:</B> The RowInputCell and ColumnInputCell cannot be within the [[cellsInTable]] region.
     * </p>
     * The cell used as the row-input cell in the data table.
     * @throws [[ArgumentException]] The assigned value does not belong to the same worksheet as the data table.
     * @throws [[InvalidOperationException]] The value is assigned after the data table has been removed from the worksheet.
     * @throws [[InvalidOperationException]] The value assigned is within the CellsInTable region.
     * @throws [[InvalidOperationException]] The assigned value is null and ColumnInputCell is null. At least one input cell must be non-null.
     * @throws [[InvalidOperationException]] The assigned value is the same as ColumnInputCell. The input cells cannot be the same cell.
     * @see [[cellsInTable]]
     * @see [[columnInputCell]]
     */
    get rowInputCell(): WorksheetCell;
    set rowInputCell(a: WorksheetCell);
    /**
     * @hidden
     */
    private _ac;
    /**
     * Gets the worksheet on which this data table resides.
     */
    get worksheet(): Worksheet;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionFactory extends Base implements IEnumerable {
    static $t: Type;
    private static _d;
    static get _e(): UltraCalcFunctionFactory;
    private _h;
    private _a;
    static _f: (arg1: UltraCalcFunctionFactory) => void;
    constructor();
    _item(a: string): ExcelCalcFunction;
    _g(a: ExcelCalcFunction): boolean;
    private _i;
    private _j;
    _b(a: UltraCalcOperatorFunction): ExcelCalcFunction;
    private _getEnumeratorObject;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare class UltraCalcErrorException extends UltraCalcException {
    static $t: Type;
    private _c;
    constructor(a: ExcelCalcErrorValue);
    get _value(): ExcelCalcErrorValue;
    toString(): string;
}
/**
 * Provides methods and properties used to define and manage a calculation error value.
 */
export declare class ExcelCalcErrorValue extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    static get _e(): ExcelCalcErrorValue;
    /**
     * @hidden
     */
    static get _f(): ExcelCalcErrorValue;
    /**
     * @hidden
     */
    private _l;
    private _b;
    private _i;
    private _g;
    constructor(code: ExcelCalcErrorCode);
    constructor(code: ExcelCalcErrorCode, message: string);
    constructor(code: ExcelCalcErrorCode, message: string, value: any);
    constructor(..._rest: any[]);
    /**
     * Gets the error code for this class instance
     */
    get code(): ExcelCalcErrorCode;
    /**
     * Gets error message for this class instance. Note that when setting this property the
     * message is assumed to be localized.
     */
    get message(): string;
    /**
     * Gets the error object for this class instance
     */
    get errorValue(): any;
    /**
     * Return a string message that denotes reason for error
     * @return String containing error message
     */
    toString(): string;
    /**
     * @hidden
     */
    _m(): void;
}
/**
 * @hidden
 */
export declare class ExcelCalcValue_ArrayProxyGroup extends Base {
    static $t: Type;
    private readonly a;
    constructor(a: ArrayProxy[]);
    get b(): ArrayProxy[];
    get d(): number;
    item(a: number, b?: ArrayProxy): ArrayProxy;
}
/**
 * @hidden
 */
export declare class CalculationContext extends ValueType {
    static $t: Type;
    constructor(a: number, b: ExcelCalcNumberStack, c: TokenClass);
    constructor();
    constructor(a: number, ..._rest: any[]);
    c: TokenClass;
    a: ExcelCalcNumberStack;
    d: boolean;
    static b(a: CalculationContext): {
        ret: IExcelCalcReference;
        p0?: CalculationContext;
    };
}
/**
 * Provides methods that manage a composite data type representing a value.
 * <p class="body">
 * An instance of this class may contain one of several base data types including doubles, singles, integers, booleans, strings, and error values.
 * <p></p>
 * The class implements the IConvertible interface providing methods to perform conversions between the basic data types.
 * <p></p>
 * Additionally the class provides methods to perform basic arithmetic operations and comparisons between [[ExcelCalcValue]] objects.
 * </p>
 */
export declare class ExcelCalcValue extends Base implements IConvertible, IComparable {
    static $t: Type;
    /**
     * @hidden
     */
    private _bu;
    /**
     * @hidden
     */
    private _k;
    /**
     * @hidden
     */
    private _l;
    /**
     * @hidden
     */
    _n: CalculationContext;
    /**
     * @hidden
     */
    private _br;
    /**
     * @hidden
     */
    private _bk;
    /**
     * Returns whether this class instance contains an array value.
     * @return True if this instance class contains an array, else false.
     * @see [[toArrayProxy]]
     */
    get isArray(): boolean;
    /**
     * Returns whether this class instance contains a group of array values.
     * @return True if this instance class contains an array group, else false.
     * @see [[toArrayProxyGroup]]
     */
    get isArrayGroup(): boolean;
    /**
     * @hidden
     */
    get _s(): boolean;
    private _x;
    /**
     * @hidden
     */
    get _y(): boolean;
    /**
     * @hidden
     */
    set _y(a: boolean);
    /**
     * Convert this class instance's value to an [[ArrayProxy]] data type.
     * @return An array equivalent to the value of this instance.
     * @see [[ArrayProxy]]
     */
    toArrayProxy(): ArrayProxy;
    /**
     * @hidden
     */
    _d(a: boolean, b?: boolean): ArrayProxy;
    /**
     * @hidden
     */
    _e(): ArrayProxy;
    /**
     * Convert this class instance's value to an array group data type.
     * @return An array group equivalent to the value of this instance.
     * @see [[ArrayProxy]]
     */
    toArrayProxyGroup(): ArrayProxy[];
    /**
     * @hidden
     */
    _b(a: boolean): ArrayProxy[];
    /**
     * @hidden
     */
    get _o(): Workbook;
    /**
     * @hidden
     */
    toUInt64(provider: IFormatProvider): number;
    /**
     * @hidden
     */
    toSByte(provider: IFormatProvider): number;
    /**
     * @hidden
     */
    toUInt16(provider: IFormatProvider): number;
    /**
     * @hidden
     */
    toUInt32(provider: IFormatProvider): number;
    /**
     * @hidden
     */
    private static readonly _ax;
    /**
     * @hidden
     */
    private static readonly _aw;
    /**
     * @hidden
     */
    private static readonly _av;
    /**
     * @hidden
     */
    static readonly _g: ExcelCalcValue;
    private _bl;
    constructor(value: any);
    constructor();
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _bt(a: any): void;
    /**
     * Convert this class instance's value to an int
     * @return A signed 32-bit integer value containing the equivalent value of this instance
     */
    toInt(): number;
    /**
     * Convert this class instance's value to an int
     * <p class="body">
     * If there is no meaningful conversion to an integer this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A signed 32-bit integer value containing the equivalent value of this instance
     */
    toInt(provider: IFormatProvider): number;
    /**
     * @hidden
     */
    _toInt(): number;
    /**
     * @hidden
     */
    _toInt1(a: IFormatProvider): number;
    /**
     * @hidden
     */
    private _bs;
    /**
     * Convert this instance's value to a [[IExcelCalcReference]].
     * <p class="body">
     * The instance value's underlying data type must be reference to return a reference, else an error reference is returned.
     * <p></p>
     * If there is no meaningful conversion to a reference, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @return If this instance contains a object that implements the [[IExcelCalcReference]] interface, this method returns the object instance, else an error reference is returned.
     */
    toReference(): IExcelCalcReference;
    /**
     * @hidden
     */
    _j(a: boolean): IExcelCalcReference;
    /**
     * @hidden
     */
    private _m;
    /**
     * @hidden
     */
    private static _h;
    /**
     * Convert this instance's value to an [[ExcelCalcErrorValue]]
     * <p class="body">
     * This method returns an [[ExcelCalcErrorValue]] whose error code is set this instance's error code.
     * <p></p>
     * If there this instance does not contain an error, a [[ExcelCalcErrorValue]] containing a default value is returned
     * </p>
     * @return A [[ExcelCalcErrorValue]] containing the equivalent error code to the value of this instance
     */
    toErrorValue(): ExcelCalcErrorValue;
    /**
     * Returns a string representation of this instance's value.
     * @return String representation of instance's value
     */
    toString(): string;
    /**
     * Returns whether this class instance contains a [[IExcelCalcReference]] value
     * @return True if this instance class contains a reference, else false
     */
    get isReference(): boolean;
    /**
     * Returns whether this class instance contains an error value
     * @return True if this class instance contains an error, else false
     */
    get isError(): boolean;
    /**
     * @hidden
     */
    static _aa(a: any): boolean;
    /**
     * Returns whether this class instance contains a null value
     * @return True if this instance class contains a null value, else false
     */
    get isNull(): boolean;
    /**
     * @hidden
     */
    static _ac(a: any): boolean;
    /**
     * Returns whether this class instance contains a DBNull value
     * @return True if this instance class contains a null value, else false
     */
    get isDBNull(): boolean;
    /**
     * Returns whether this class instance contains a string value
     * @return True if this instance class contains a string, else false
     */
    get isString(): boolean;
    /**
     * @hidden
     */
    static _ag(a: any): boolean;
    /**
     * Returns whether this class instance contains a boolean value
     * @return True if this instance class contains a boolean, else false
     */
    get isBoolean(): boolean;
    /**
     * @hidden
     */
    static _u(a: any): boolean;
    /**
     * Returns whether this class instance contains a DateTime value
     * @return True if this instance class contains a DateTime, else false
     */
    get isDateTime(): boolean;
    /**
     * Return the underlying value
     */
    get value(): any;
    /**
     * Indicates if the value of the specified [[ExcelCalcValue]] is equivalent to the [[value]]
     * @param x First [[ExcelCalcValue]] to compare
     * @param y Second [[ExcelCalcValue]] to compare
     * @return True if the values are the same; otherwise false is returned.
     */
    static areValuesEqual(x: ExcelCalcValue, y: ExcelCalcValue): boolean;
    /**
     * @hidden
     */
    compareToObject(value: any): number;
    /**
     * Compares current instance with the passed in [[ExcelCalcValue]] instance. Returns
     * -1, 1 or 0 depending on whether the current instance is less than, greater than
     * or equal to the passed in instance respectively.
     * @param value The object that this instance should be compared against.
     * @return -1, 1 or 0 depending on whether the current instance is less than, greater than
     * or equal to the passed in instance respectively.
     */
    compareTo(value: ExcelCalcValue): number;
    /**
     * Compares x and y [[ExcelCalcValue]] instances and returns -1 if x is less than y,
     * 1 if x is greater than y and 0 if x and y are equal.
     * @param x The first value to compare.
     * @param y The value to compare with the first value.
     * @return -1, 1 or 0 depending on whether the current instance is less than, greater than
     * or equal to the passed in instance respectively.
     */
    static compareTo(x: ExcelCalcValue, y: ExcelCalcValue): number;
    /**
     * @hidden
     */
    static _compareTo1(a: ExcelCalcValue, b: ExcelCalcValue): number;
    /**
     * @hidden
     */
    static _a4(a: ExcelCalcValue, b: any, c: ExcelCalcValue, d: any): number;
    /**
     * Indicates if the specified [[ExcelCalcValue]] has the save [[value]] as this instance.
     * @param value [[ExcelCalcValue]] to compare against.
     * @return True if the [[value]] of both instances are equal; otherwise false.
     */
    isSameValue(value: ExcelCalcValue): boolean;
    /**
     * @hidden
     */
    _ah(a: IFormatProvider): boolean;
    /**
     * Gets the resolved value of the reference. This method will walk down the reference chain recursively to get the resolved value of the reference that is not just another reference.
     * @return
     */
    getResolvedValue(): any;
    /**
     * Gets the resolved value of the reference. This method will walk down the reference chain recursively to get the resolved value of the reference that is not just another reference.
     * @param willUseValueInCalculations True if the value returned will actually be used in calculations; False if the value is being requested to inspect some aspect of it, such as its type.
     */
    getResolvedValue(willUseValueInCalculations: boolean): any;
    /**
     * @hidden
     */
    _getResolvedValue(): any;
    /**
     * Convert this class instance's value to a double data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A double-precision floating-point equivalent to the value of this instance
     */
    toDouble(provider: IFormatProvider): number;
    /**
     * Convert this class instance's value to a double data type
     * @see [[toDouble]]
     */
    toDouble(): number;
    /**
     * @hidden
     */
    _toDouble3(): number;
    /**
     * @hidden
     */
    _toDouble(a: IFormatProvider): number;
    /**
     * @hidden
     */
    _toDouble1(a: number): {
        ret: boolean;
        p0: number;
    };
    /**
     * @hidden
     */
    private _toDouble2;
    /**
     * @hidden
     */
    _ao(a: any, b: number, c: IFormatProvider, d: BaseError): {
        ret: boolean;
        p1: number;
        p3: BaseError;
    };
    /**
     * Convert this class instance's value to a DateTime data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A <b>DateTime</b> equivalent to the value of this instance
     */
    toDateTime(provider: IFormatProvider): Date;
    /**
     * Convert this class instance's value to a DateTime data type
     * @see [[toDateTime]]
     */
    toDateTime(): Date;
    /**
     * @hidden
     */
    _toDateTime1(): Date;
    /**
     * @hidden
     */
    _toDateTime(a: IFormatProvider): Date;
    /**
     * @hidden
     */
    _aj(a: IFormatProvider, b: Date, c?: boolean, d?: boolean): {
        ret: boolean;
        p1: Date;
    };
    /**
     * Convert this class instance's value to a float data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A single-precision floating-point equivalent to the value of this instance
     */
    toSingle(provider: IFormatProvider): number;
    /**
     * Convert this class instance's value to a float data type
     * @see [[toSingle]]
     */
    toSingle(): number;
    /**
     * @hidden
     */
    _toSingle1(): number;
    /**
     * @hidden
     */
    _toSingle(a: IFormatProvider): number;
    /**
     * Convert this class instance's value to a boolean data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A boolean floating-point equivalent to the value of this instance
     */
    toBoolean(provider: IFormatProvider): boolean;
    /**
     * Convert this class instance's value to a boolean data type
     * @see [[toBoolean]]
     * @return A boolean floating-point equivalent to the value of this instance
     */
    toBoolean(): boolean;
    /**
     * @hidden
     */
    _toBoolean1(): boolean;
    /**
     * @hidden
     */
    _toBoolean(a: IFormatProvider): boolean;
    /**
     * Convert this class instance's value to a int data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A 32-bit signed integer floating-point equivalent to the value of this instance
     */
    toInt32(provider: IFormatProvider): number;
    /**
     * Convert this class instance's value to a int data type
     * @see [[toInt32]]
     * @return A 32-bit signed integer floating-point equivalent to the value of this instance
     */
    toInt32(): number;
    /**
     * @hidden
     */
    _toInt321(): number;
    /**
     * @hidden
     */
    _toInt32(a: IFormatProvider): number;
    /**
     * Convert this class instance's value to a short data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A 16-bit signed integer floating-point equivalent to the value of this instance
     */
    toInt16(provider: IFormatProvider): number;
    /**
     * Convert this class instance's value to a short data type
     * @see [[toInt16]]
     */
    toInt16(): number;
    /**
     * @hidden
     */
    _toInt161(): number;
    /**
     * @hidden
     */
    _toInt16(a: IFormatProvider): number;
    /**
     * Convert this class instance's value to a string instance data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A string instance equivalent to the value of this instance
     */
    toString1(provider: IFormatProvider): string;
    /**
     * @hidden
     */
    _bp(a: any, b: IFormatProvider): string;
    /**
     * Convert this class instance's value to a byte data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A 8-bit unsigned integer equivalent to the value of this instance
     */
    toByte(provider: IFormatProvider): number;
    /**
     * Convert this class instance's value to a byte data type
     * @see [[toByte]]
     */
    toByte(): number;
    /**
     * @hidden
     */
    _toByte1(): number;
    /**
     * @hidden
     */
    _toByte(a: IFormatProvider): number;
    /**
     * Convert this class instance's value to a char type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A Unicode character equivalent to the value of this instance
     */
    toChar(provider: IFormatProvider): string;
    /**
     * Convert this class instance's value to a char data type
     * @see [[toChar]]
     * @return A Unicode character equivalent to the value of this instance
     */
    toChar(): string;
    /**
     * @hidden
     */
    _toChar1(): string;
    /**
     * @hidden
     */
    _toChar(a: IFormatProvider): string;
    /**
     * Convert this class instance's value to a long data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A 64-bit signed integer equivalent to the value of this instance
     */
    toInt64(provider: IFormatProvider): number;
    /**
     * Convert this class instance's value to a long data type
     * @see [[toInt64]]
     */
    toInt64(): number;
    /**
     * @hidden
     */
    _toInt641(): number;
    /**
     * @hidden
     */
    _toInt64(a: IFormatProvider): number;
    /**
     * Convert this class instance's value to a decimal data type
     * <p class="body">
     * If there is no meaningful conversion, this method will throw an <b>InvalidCastException</b>
     * </p>
     * @param provider An <b>IFormatProvider</b> interface implementation that supplies culture-specific formatting information
     * @return A <b>Decimal</b> equivalent to the value of this instance
     */
    toDecimal(provider: IFormatProvider): number;
    /**
     * Convert this class instance's value to a decimal data type
     * @see [[toDecimal]]
     * @return A <b>Decimal</b> equivalent to the value of this instance
     * @see [[toDecimal]]
     */
    toDecimal(): number;
    /**
     * @hidden
     */
    _toDecimal2(): number;
    /**
     * @hidden
     */
    _toDecimal1(a: number): {
        ret: boolean;
        p0: number;
    };
    /**
     * @hidden
     */
    _toDecimal(a: IFormatProvider): number;
    /**
     * @hidden
     */
    private _al;
    /**
     * Converts a DateTime to Excel's numerical representation of a date.
     * <p class="body">
     * When using the 1900 date system in Excel, dates before 3/1/1900 must be corrected, because Excel
     * incorrectly assumes 1900 is a leap year. This overload assumes the 1900 date system is being used
     * as so it corrects the date values.
     * </p>
     * @param dateValue The DateTime value to convert to the Microsoft Excel date format.
     */
    static dateTimeToExcelDate(workbook: Workbook, dateValue: Date): number;
    /**
     * Converts a DateTime to Excel's numerical representation of a date.
     * @param dateValue The DateTime value to convert to the Microsoft Excel date format.
     * @param shouldCorrect1900Dates When using the 1900 date system in Excel, dates before 3/1/1900 must be corrected, because Excel
     * incorrectly assumes 1900 is a leap year. Pass False to disable this correction.
     */
    static dateTimeToExcelDate(workbook: Workbook, dateValue: Date, shouldCorrect1900Dates: boolean): number;
    /**
     * @hidden
     */
    static _dateTimeToExcelDate(a: Workbook, b: Date): Nullable$1<number>;
    /**
     * @hidden
     */
    static _dateTimeToExcelDate1(a: Workbook, b: Date, c: boolean): Nullable$1<number>;
    /**
     * @hidden
     */
    static _bb(a: Date, b: boolean, c: boolean): Nullable$1<number>;
    /**
     * Converts Excel's numerical representation of a date to a DateTime.
     * <p class="body">
     * When using the 1900 date system in Excel, dates before 3/1/1900 must be corrected, because Excel
     * incorrectly assumes 1900 is a leap year. This overload assumes the 1900 date system is being used
     * as so it corrects the date values.
     * </p>
     * @param excelDate The Microsoft Excel date format which should be converted to a DateTime.
     */
    static excelDateToDateTime(workbook: Workbook, excelDate: number): Date;
    /**
     * Converts Excel's numerical representation of a date to a DateTime.
     * @param excelDate The Microsoft Excel date format which should be converted to a DateTime.
     * @param shouldCorrect1900Dates When using the 1900 date system in Excel, dates before 3/1/1900 must be corrected, because Excel
     * incorrectly assumes 1900 is a leap year. Pass False to disable this correction.
     */
    static excelDateToDateTime(workbook: Workbook, excelDate: number, shouldCorrect1900Dates: boolean): Date;
    /**
     * @hidden
     */
    static _excelDateToDateTime(a: Workbook, b: number): Nullable$1<Date>;
    /**
     * @hidden
     */
    static _excelDateToDateTime1(a: Workbook, b: number, c: boolean): Nullable$1<Date>;
    /**
     * @hidden
     */
    static _be(a: Workbook, b: number, c: boolean, d: boolean): Nullable$1<Date>;
    /**
     * @hidden
     */
    static _bq(a: number, b?: boolean): number;
    /**
     * @hidden
     */
    static _ay(a: number, b?: boolean): number;
    /**
     * @hidden
     */
    _getResolvedValue3(a: boolean): any;
    /**
     * @hidden
     */
    _bj(a: boolean, b: boolean): any;
    /**
     * @hidden
     */
    private _bg;
    /**
     * @hidden
     */
    private _bh;
    /**
     * @hidden
     */
    static readonly _aq: boolean;
    /**
     * @hidden
     */
    static readonly _ap: boolean;
    /**
     * @hidden
     */
    get _a0(): CultureInfo;
}
/**
 * Represents a two-dimensional array of [[ExcelCalcValue]] instances used in calculations.
 */
export declare abstract class ArrayProxy extends Base implements IEnumerable$1<ExcelCalcValue> {
    static $t: Type;
    private _f;
    [Symbol.iterator](): EnumeratorWrapper<ExcelCalcValue>;
    /**
     * @hidden
     */
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<ExcelCalcValue>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Gets the number of elements in the specified dimension of the array.
     * @param dimension The zero-based index of the dimension.
     * @return The number of elements in the specified dimension.
     */
    abstract getLength(dimension: number): number;
    /**
     * @hidden
     */
    abstract _d(a: ArrayValueContext): ExcelCalcValue;
    /**
     * @hidden
     */
    abstract _a(): ExcelCalcValue[][];
    /**
     * @hidden
     */
    abstract _b(a: number, b: number, c: number, d: number): ArrayProxy;
    /**
     * @hidden
     */
    private __j;
    _j(a: number, b: number): IEnumerable$1<KeyValuePair$2<number, ExcelCalcValue>>;
    /**
     * @hidden
     */
    abstract _k(a: number, b: number): IEnumerable$1<KeyValuePair$2<number, ExcelCalcValue>>;
    /**
     * @hidden
     */
    _n(a: boolean, b: (arg1: ExcelCalcValue, arg2: ArrayValueContext) => void): void;
    /**
     * @hidden
     */
    _o(): void;
    /**
     * @hidden
     */
    _m(a: ExcelCalcValue): void;
    /**
     * Gets the [[ExcelCalcValue]] at the specified index.
     * @param x The index for the first dimension of the array. This is the relative column index for arrays representing cell regions on a worksheet.
     * @param y The index for the second dimension of the array. This is the relative row index for arrays representing cell regions on a worksheet.
     * @return An [[ExcelCalcValue]] representing the specified value in the array.
     */
    item(a: number, b: number): ExcelCalcValue;
    /**
     * @hidden
     */
    _c(a: ArrayValueContext): ExcelCalcValue;
    /**
     * @hidden
     */
    abstract get _h(): boolean;
    /**
     * @hidden
     */
    protected get__i(): boolean;
    /**
     * @hidden
     */
    get _i(): boolean;
    /**
     * @hidden
     */
    get _g(): ExcelCalcValue;
    /**
     * @hidden
     */
    set _g(a: ExcelCalcValue);
}
/**
 * @hidden
 */
export declare class CLRArrayProxy extends ArrayProxy {
    static $t: Type;
    private _p;
    constructor(a: number, b: ExcelCalcValue);
    constructor(a: number, b: ExcelCalcValue[][]);
    constructor(a: number, ..._rest: any[]);
    protected get__h(): boolean;
    get _h(): boolean;
    private __k;
    _k(a: number, b: number): IEnumerable$1<KeyValuePair$2<number, ExcelCalcValue>>;
    getLength(a: number): number;
    _d(a: ArrayValueContext): ExcelCalcValue;
    _a(): ExcelCalcValue[][];
    _b(a: number, b: number, c: number, d: number): ArrayProxy;
}
/**
 * Base class for formula functions.
 */
export declare abstract class ExcelCalcFunction extends Base {
    static $t: Type;
    constructor();
    /**
     * @hidden
     */
    _ae(): void;
    /**
     * @hidden
     */
    get _o(): boolean;
    /**
     * Function name used to reference the function in a formula
     */
    abstract get name(): string;
    /**
     * Minimum number of arguments required for the function
     */
    abstract get minArgs(): number;
    /**
     * Maximum number of arguments required for the function
     */
    abstract get maxArgs(): number;
    /**
     * @hidden
     */
    private _z;
    /**
     * Evaluates the function against the arguments on the number stack.
     * @param numberStack Formula number stack containing function arguments.
     * @param argumentCount Denotes the number of function arguments pushed onto the number stack.
     */
    performEvaluation(numberStack: ExcelCalcNumberStack, argumentCount: number): void;
    /**
     * @hidden
     */
    _aj(a: ExcelCalcNumberStack, b: number): void;
    /**
     * Evaluates the function against the arguments on the number stack.
     * @param numberStack Formula number stack containing function arguments.
     * @param argumentCount Denotes the number of function arguments pushed onto the number stack.
     * @return An [[ExcelCalcValue]] that represents the result of the function evaluation.
     */
    protected abstract evaluate(numberStack: ExcelCalcNumberStack, argumentCount: number): ExcelCalcValue;
    /**
     * @hidden
     */
    static _t(a: ExcelCalcNumberStack, b: number, c: List$1<number>, d: boolean, e: boolean): boolean;
    /**
     * @hidden
     */
    private static _w;
    /**
     * A helper method for extracting the [[ExcelCalcValue]] instances from the stack.
     * @param numberStack Number stack whose values should be popped.
     * @param argumentCount Number of items to pop/evaluate from the number stack
     * @param skipEmptyValues True to ignore values whose IsNull returns true; otherwise false to include empty items in the list.
     * @return An array of [[ExcelCalcValue]] instances removed from the number stack.
     */
    getArguments(numberStack: ExcelCalcNumberStack, argumentCount: number, skipEmptyValues: boolean): ExcelCalcValue[];
    /**
     * A helper method for extracting the [[ExcelCalcValue]] instances from the stack.
     * @param numberStack Number stack whose values should be popped.
     * @param argumentCount Number of items to pop/evaluate from the number stack
     * @param skipEmptyValues True to ignore values whose IsNull returns true; otherwise false to include empty items in the list.
     * @param skipHiddenCells True to ignore values from hidden cells.
     * @return An array of UltraCalcValue instances removed from the number stack.
     */
    getArguments(numberStack: ExcelCalcNumberStack, argumentCount: number, skipEmptyValues: boolean, skipHiddenCells: boolean): ExcelCalcValue[];
    /**
     * @hidden
     */
    protected _getArguments(a: ExcelCalcNumberStack, b: number, c: boolean): ExcelCalcValue[];
    /**
     * @hidden
     */
    protected _getArguments1(a: ExcelCalcNumberStack, b: number, c: boolean, d: boolean): ExcelCalcValue[];
    /**
     * @hidden
     */
    _ad(a: List$1<ExcelCalcValue>, b: ExcelCalcNumberStack, c: number, d: boolean): void;
    /**
     * @hidden
     */
    static _ac(a: List$1<ExcelCalcValue>, b: ExcelCalcValue, c: boolean, d: boolean, e?: boolean): void;
    /**
     * @hidden
     */
    private static _ab;
    /**
     * @hidden
     */
    static _p(a: IExcelCalcReference): boolean;
    /**
     * @hidden
     */
    static _q(a: IExcelCalcReference, b: boolean, c: boolean): boolean;
    /**
     * @hidden
     */
    static _u(a: IExcelCalcReference): boolean;
    /**
     * Determines whether the parameter at the specified index will accept an enumerable reference.
     * @param parameterIndex In 0-based index of the parameter.
     * @return True if the parameter at the specified index can accept enumerable references; False otherwise or if the parameter is out of range for this function.
     */
    canParameterBeEnumerable(parameterIndex: number): boolean;
    /**
     * @hidden
     */
    static _c(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    /**
     * @hidden
     */
    static _d(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    /**
     * @hidden
     */
    static _f(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    /**
     * @hidden
     */
    static _g(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    /**
     * @hidden
     */
    private _af;
    /**
     * @hidden
     */
    private _ag;
    /**
     * @hidden
     */
    private _ah;
    /**
     * @hidden
     */
    protected get__k(): TokenClass;
    /**
     * @hidden
     */
    get _k(): TokenClass;
    /**
     * Determines whether the function accepts an intermediate result array created by evaluating a nested function
     * on a per-element basis of an array or region parameter when a single value is expected.
     * <p class="body">
     * An intermediate result array will be generated when multiple values are specified where a single value is expected.
     * For example, the following formula will generate the value 15: =SUM(10/{1,2}). This is because "10/{1,2}" will
     * result in an intermediate result array of {10/1,10/2}, or {10,5}. Then each element is summed up to result in the
     * value 15. However, the SUM function does not allow intermediate result arrays for region references. So a function
     * such as =SUM(10/D6:E7) will result in a #VALUE! error. Unlike the SUM function, the LOOKUP function allows intermediate
     * result arrays from region references. So a formula like LOOKUP(10,D6:E7*2) will return a correct result if the value 10
     * can be found in the following intermediate result array when using the normal LOOKUP function logic: {D6*2,E6*2; D7*2,E7*2}.
     * Therefore, SUM would return True from this method only when 'isCreatedFromRegionReference' is False
     * and LOOKUP would return True from this method always (for a 'parameterIndex' value of 1 in this example).
     * </p>
     * <p class="note">
     * <b>Note:</b> if this function is being called in an array formula, the restrictions are relaxed in the following way:
     * if the function supports intermediate result arrays created from constant array, it will also support intermediate
     * result arrays created from region references, so the 'isCreatedFromRegionReference' value will always
     * be passed in as False.
     * </p>
     * @param parameterIndex The 0-based index of parameter in which the intermediate array will be passed.
     * @param isCreatedFromRegionReference True if the value which will generate the intermediate result array is a region reference; False if it is a constant array.
     * @return True to allow intermediate result arrays for the specified parameter; False otherwise.
     */
    doesParameterAllowIntermediateResultArray(parameterIndex: number, isCreatedFromRegionReference: boolean): boolean;
    private _h;
    /**
     * @hidden
     */
    _i(): Function;
    /**
     * @hidden
     */
    _j(a: number): TokenClass;
    /**
     * @hidden
     */
    static _l(a: ExcelCalcNumberStack): Workbook;
    /**
     * @hidden
     */
    protected get__r(): boolean;
    /**
     * @hidden
     */
    get _r(): boolean;
    /**
     * @hidden
     */
    protected get__s(): boolean;
    /**
     * @hidden
     */
    get _s(): boolean;
    /**
     * @hidden
     */
    _v(a: number): boolean;
}
/**
 * @hidden
 */
export declare abstract class BuiltInFunctionBase extends ExcelCalcFunction {
    static $t: Type;
    constructor();
}
/**
 * @hidden
 */
export declare abstract class UltraCalcBinaryOperatorBase extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    protected abstract _ak(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionPlus extends UltraCalcBinaryOperatorBase {
    static $t: Type;
    protected _ak(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
}
/**
 * @hidden
 */
export declare class Function extends Base implements IComparable$1<Function> {
    static $t: Type;
    private _amt;
    private _vg;
    private _rm;
    private _xn;
    private _ra;
    private _rc;
    private _abi;
    private _abg;
    private _a;
    private _q2;
    private _c;
    private _q5;
    private _rh;
    private _rg;
    private _asz;
    private readonly _amv;
    private readonly _amx;
    readonly _q8: boolean;
    constructor(a: string, b: number, c: number, d: number, e: boolean, f: boolean, g: number, h: number, i: number[], j: TokenClass, ...k: TokenClass[]);
    compareTo(a: Function): number;
    _q1(a: number): TokenClass;
    _rj(a: WorkbookFormat): number;
    get _wi(): number;
    get _q4(): boolean;
    get _q6(): boolean;
    get _q7(): boolean;
    get _q9(): boolean;
    get _rb(): boolean;
    get _rd(): boolean;
    get _b(): number[];
    get _re(): boolean;
    get _rn(): number;
    get _amu(): string;
    get _rf(): boolean;
    get _ri(): boolean;
    get _q3(): TokenClass;
    get _abh(): number;
    get _abj(): number;
    get _as0(): string;
    static _ro: Dictionary$2<number, Function[]>;
    private static _atf;
    private static _rp;
    static _gy(a: string, b: string): Function;
    private static _rq;
    static _gz(a: number): Function;
    static _g0(a: string): Function;
    static _g2(a: string, b: number, c: number): Function;
    private static _g1;
    static _g4(a: string): Function;
    static get _cb(): Function;
    static get _hk(): Function;
    static get _iv(): Function;
    static get _ir(): Function;
    static get _on(): Function;
    static get _ai(): Function;
    static get _j3(): Function;
    static get _jv(): Function;
    static get _nc(): Function;
    static get _bv(): Function;
    static get _kl(): Function;
    static get _k5(): Function;
    static get _od(): Function;
    static get _d1(): Function;
    static get _fi(): Function;
    static get _nz(): Function;
    static get _b7(): Function;
    static get _o4(): Function;
    static get _ae(): Function;
    static get _lx(): Function;
    static get _oa(): Function;
    static get _ew(): Function;
    static get _ji(): Function;
    static get _jk(): Function;
    static get _d(): Function;
    static get _ij(): Function;
    static get _ny(): Function;
    static get _m7(): Function;
    static get _jq(): Function;
    static get _id(): Function;
    static get _mx(): Function;
    static get _j1(): Function;
    static get _jd(): Function;
    static get _p4(): Function;
    static get _pu(): Function;
    static get _e6(): Function;
    static get _w(): Function;
    static get _lj(): Function;
    static get _k1(): Function;
    static get _kb(): Function;
    static get _de(): Function;
    static get _d7(): Function;
    static get _c8(): Function;
    static get _dz(): Function;
    static get _dy(): Function;
    static get _d5(): Function;
    static get _p5(): Function;
    static get _d9(): Function;
    static get _pb(): Function;
    static get _jg(): Function;
    static get _pr(): Function;
    static get _jl(): Function;
    static get _g7(): Function;
    static get _mb(): Function;
    static get _f3(): Function;
    static get _k4(): Function;
    static get _ly(): Function;
    static get _mn(): Function;
    static get _j8(): Function;
    static get _io(): Function;
    static get _mh(): Function;
    static get _ju(): Function;
    static get _c4(): Function;
    static get _pm(): Function;
    static get _c9(): Function;
    static get _kf(): Function;
    static get _qu(): Function;
    static get _qg(): Function;
    static get _hf(): Function;
    static get _j6(): Function;
    static get _np(): Function;
    static get _k3(): Function;
    static get _z(): Function;
    static get _nd(): Function;
    static get _bw(): Function;
    static get _lg(): Function;
    static get _nl(): Function;
    static get _pq(): Function;
    static get _px(): Function;
    static get _af(): Function;
    static get _ac(): Function;
    static get _h(): Function;
    static get _bs(): Function;
    static get _he(): Function;
    static get _qd(): Function;
    static get _i3(): Function;
    static get _jj(): Function;
    static get _bi(): Function;
    static get _jr(): Function;
    static get _p2(): Function;
    static get _ma(): Function;
    static get _jb(): Function;
    static get _m4(): Function;
    static get _et(): Function;
    static get _ps(): Function;
    static get _mv(): Function;
    static get _ol(): Function;
    static get _bu(): Function;
    static get _fd(): Function;
    static get _bh(): Function;
    static get _iq(): Function;
    static get _i4(): Function;
    static get _ix(): Function;
    static get _ip(): Function;
    static get _ox(): Function;
    static get _kk(): Function;
    static get _c7(): Function;
    static get _pn(): Function;
    static get _n4(): Function;
    static get _ow(): Function;
    static get _dg(): Function;
    static get _ie(): Function;
    static get _bt(): Function;
    static get _jy(): Function;
    static get _j7(): Function;
    static get _j9(): Function;
    static get _im(): Function;
    static get _l3(): Function;
    static get _cc(): Function;
    static get _l9(): Function;
    static get _e4(): Function;
    static get _gx(): Function;
    static get _d4(): Function;
    static get _iw(): Function;
    static get _oh(): Function;
    static get _p9(): Function;
    static get _d6(): Function;
    static get _ea(): Function;
    static get _pv(): Function;
    static get _iu(): Function;
    static get _df(): Function;
    static get _p3(): Function;
    static get _fe(): Function;
    static get _nm(): Function;
    static get _mw(): Function;
    static get _jc(): Function;
    static get _m5(): Function;
    static get _j2(): Function;
    static get _je(): Function;
    static get _nb(): Function;
    static get _na(): Function;
    static get _ab(): Function;
    static get _dd(): Function;
    static get _mk(): Function;
    static get _r(): Function;
    static get _db(): Function;
    static get _pp(): Function;
    static get _qb(): Function;
    static get _j0(): Function;
    static get _oq(): Function;
    static get _n1(): Function;
    static get _b8(): Function;
    static get _o5(): Function;
    static get _ad(): Function;
    static get _i(): Function;
    static get _ag(): Function;
    static get _du(): Function;
    static get _ig(): Function;
    static get _dc(): Function;
    static get _f0(): Function;
    static get _eq(): Function;
    static get _ah(): Function;
    static get _au(): Function;
    static get _gc(): Function;
    static get _av(): Function;
    static get _a2(): Function;
    static get _bk(): Function;
    static get _bl(): Function;
    static get _bx(): Function;
    static get _b2(): Function;
    static get _cq(): Function;
    static get _es(): Function;
    static get _ey(): Function;
    static get _e8(): Function;
    static get _ff(): Function;
    static get _fg(): Function;
    static get _fh(): Function;
    static get _fj(): Function;
    static get _ga(): Function;
    static get _gb(): Function;
    static get _be(): Function;
    static get _hj(): Function;
    static get _jp(): Function;
    static get _jm(): Function;
    static get _ko(): Function;
    static get _kx(): Function;
    static get _kz(): Function;
    static get _ky(): Function;
    static get _ka(): Function;
    static get _oc(): Function;
    static get _lb(): Function;
    static get _lt(): Function;
    static get _lz(): Function;
    static get _o9(): Function;
    static get _qi(): Function;
    static get _ou(): Function;
    static get _os(): Function;
    static get _ot(): Function;
    static get _br(): Function;
    static get _b6(): Function;
    static get _cm(): Function;
    static get _fp(): Function;
    static get _f2(): Function;
    static get _ik(): Function;
    static get _lm(): Function;
    static get _nf(): Function;
    static get _ok(): Function;
    static get _n5(): Function;
    static get _pw(): Function;
    static get _l8(): Function;
    static get _dt(): Function;
    static get _gg(): Function;
    static get _g9(): Function;
    static get _or(): Function;
    static get _i6(): Function;
    static get _n2(): Function;
    static get _q0(): Function;
    static get _i8(): Function;
    static get _n6(): Function;
    static get _mc(): Function;
    static get _ln(): Function;
    static get _lq(): Function;
    static get _kc(): Function;
    static get _pt(): Function;
    static get _po(): Function;
    static get _b1(): Function;
    static get _l2(): Function;
    static get _mg(): Function;
    static get _dl(): Function;
    static get _om(): Function;
    static get _oo(): Function;
    static get _ce(): Function;
    static get _cd(): Function;
    static get _i2(): Function;
    static get _c5(): Function;
    static get _c6(): Function;
    static get _k6(): Function;
    static get _m6(): Function;
    static get _g3(): Function;
    static get _hg(): Function;
    static get _lw(): Function;
    static get _aj(): Function;
    static get _jw(): Function;
    static get _j4(): Function;
    static get _oi(): Function;
    static get _qa(): Function;
    static get _og(): Function;
    static get _p8(): Function;
    static get _q(): Function;
    static get _f(): Function;
    static get _g(): Function;
    static get _t(): Function;
    static get _u(): Function;
    static get _ak(): Function;
    static get _al(): Function;
    static get _am(): Function;
    static get _ao(): Function;
    static get _ap(): Function;
    static get _aq(): Function;
    static get _ar(): Function;
    static get _aw(): Function;
    static get _ax(): Function;
    static get _ay(): Function;
    static get _bz(): Function;
    static get _b5(): Function;
    static get _cg(): Function;
    static get _ch(): Function;
    static get _ci(): Function;
    static get _cj(): Function;
    static get _ck(): Function;
    static get _cl(): Function;
    static get _ct(): Function;
    static get _cu(): Function;
    static get _cv(): Function;
    static get _cw(): Function;
    static get _cx(): Function;
    static get _cy(): Function;
    static get _cz(): Function;
    static get _c0(): Function;
    static get _c1(): Function;
    static get _dh(): Function;
    static get _di(): Function;
    static get _dj(): Function;
    static get _dr(): Function;
    static get _dx(): Function;
    static get _d2(): Function;
    static get _d3(): Function;
    static get _d8(): Function;
    static get _ed(): Function;
    static get _ee(): Function;
    static get _ek(): Function;
    static get _el(): Function;
    static get _en(): Function;
    static get _e5(): Function;
    static get _f4(): Function;
    static get _gf(): Function;
    static get _gh(): Function;
    static get _hb(): Function;
    static get _hc(): Function;
    static get _hd(): Function;
    static get _hi(): Function;
    static get _hl(): Function;
    static get _ho(): Function;
    static get _hp(): Function;
    static get _hq(): Function;
    static get _hr(): Function;
    static get _hs(): Function;
    static get _hx(): Function;
    static get _hy(): Function;
    static get _hz(): Function;
    static get _h0(): Function;
    static get _h1(): Function;
    static get _h2(): Function;
    static get _h3(): Function;
    static get _h4(): Function;
    static get _h7(): Function;
    static get _h9(): Function;
    static get _ia(): Function;
    static get _ib(): Function;
    static get _il(): Function;
    static get _is(): Function;
    static get _iz(): Function;
    static get _ja(): Function;
    static get _jz(): Function;
    static get _kh(): Function;
    static get _ki(): Function;
    static get _kp(): Function;
    static get _ks(): Function;
    static get _k0(): Function;
    static get _k8(): Function;
    static get _k9(): Function;
    static get _la(): Function;
    static get _lc(): Function;
    static get _ld(): Function;
    static get _le(): Function;
    static get _lf(): Function;
    static get _l5(): Function;
    static get _l6(): Function;
    static get _l7(): Function;
    static get _mf(): Function;
    static get _mj(): Function;
    static get _mo(): Function;
    static get _ng(): Function;
    static get _ns(): Function;
    static get _ob(): Function;
    static get _op(): Function;
    static get _o6(): Function;
    static get _o7(): Function;
    static get _o8(): Function;
    static get _qh(): Function;
    static get _qn(): Function;
    static get _qp(): Function;
    static get _qs(): Function;
    static get _qv(): Function;
    static get _qw(): Function;
    static get _qx(): Function;
    static get _qy(): Function;
    static get _j(): Function;
    static get _k(): Function;
    static get _y(): Function;
    static get _s(): Function;
    static get _an(): Function;
    static get _as(): Function;
    static get _at(): Function;
    static get _az(): Function;
    static get _a0(): Function;
    static get _a1(): Function;
    static get _a3(): Function;
    static get _a4(): Function;
    static get _a5(): Function;
    static get _a6(): Function;
    static get _a7(): Function;
    static get _bf(): Function;
    static get _bg(): Function;
    static get _bm(): Function;
    static get _bn(): Function;
    static get _bo(): Function;
    static get _bp(): Function;
    static get _bq(): Function;
    static get _by(): Function;
    static get _b3(): Function;
    static get _b4(): Function;
    static get _b9(): Function;
    static get _ca(): Function;
    static get _cn(): Function;
    static get _co(): Function;
    static get _cr(): Function;
    static get _cs(): Function;
    static get _da(): Function;
    static get _dk(): Function;
    static get _em(): Function;
    static get _eo(): Function;
    static get _ex(): Function;
    static get _ez(): Function;
    static get _e0(): Function;
    static get _e1(): Function;
    static get _e2(): Function;
    static get _e3(): Function;
    static get _fc(): Function;
    static get _fk(): Function;
    static get _fl(): Function;
    static get _fw(): Function;
    static get _f7(): Function;
    static get _f8(): Function;
    static get _f9(): Function;
    static get _gd(): Function;
    static get _ge(): Function;
    static get _hh(): Function;
    static get _hm(): Function;
    static get _ht(): Function;
    static get _hu(): Function;
    static get _hv(): Function;
    static get _hw(): Function;
    static get _h5(): Function;
    static get _h6(): Function;
    static get _h8(): Function;
    static get _ic(): Function;
    static get _it(): Function;
    static get _i1(): Function;
    static get _jn(): Function;
    static get _jo(): Function;
    static get _kd(): Function;
    static get _ke(): Function;
    static get _kj(): Function;
    static get _kn(): Function;
    static get _kt(): Function;
    static get _ku(): Function;
    static get _kv(): Function;
    static get _kw(): Function;
    static get _k7(): Function;
    static get _ll(): Function;
    static get _lo(): Function;
    static get _lp(): Function;
    static get _lr(): Function;
    static get _ls(): Function;
    static get _lu(): Function;
    static get _lv(): Function;
    static get _l0(): Function;
    static get _md(): Function;
    static get _me(): Function;
    static get _ml(): Function;
    static get _mm(): Function;
    static get _ne(): Function;
    static get _nn(): Function;
    static get _no(): Function;
    static get _nv(): Function;
    static get _nw(): Function;
    static get _n3(): Function;
    static get _oe(): Function;
    static get _of(): Function;
    static get _oy(): Function;
    static get _oz(): Function;
    static get _o0(): Function;
    static get _o1(): Function;
    static get _o2(): Function;
    static get _o3(): Function;
    static get _py(): Function;
    static get _pz(): Function;
    static get _p6(): Function;
    static get _p7(): Function;
    static get _qf(): Function;
    static get _qj(): Function;
    static get _qt(): Function;
    static get _qz(): Function;
    static get _ec(): Function;
    static get _iy(): Function;
    static get _kq(): Function;
    static get _qo(): Function;
    static get _fq(): Function;
    static get _fr(): Function;
    static get _fs(): Function;
    static get _fu(): Function;
    static get _ft(): Function;
    static get _cf(): Function;
    static get _b0(): Function;
    static get _hn(): Function;
    static get _jx(): Function;
    static get _j5(): Function;
    static get _ov(): Function;
    static get _pd(): Function;
    static get _i5(): Function;
    static get _m8(): Function;
    static get _m9(): Function;
    static get _pf(): Function;
    static get _pg(): Function;
    static get _ph(): Function;
    static get _pi(): Function;
    static get _pj(): Function;
    static get _pk(): Function;
    static get _pl(): Function;
    static get _e(): Function;
    static get _l(): Function;
    static get _bb(): Function;
    static get _bc(): Function;
    static get _er(): Function;
    static get _gm(): Function;
    static get _ii(): Function;
    static get _i9(): Function;
    static get _nk(): Function;
    static get _nq(): Function;
    static get _pe(): Function;
    static get _qc(): Function;
    static get _m(): Function;
    static get _n(): Function;
    static get _o(): Function;
    static get _p(): Function;
    static get _x(): Function;
    static get _aa(): Function;
    static get _a8(): Function;
    static get _bd(): Function;
    static get _bj(): Function;
    static get _cp(): Function;
    static get _c2(): Function;
    static get _c3(): Function;
    static get _dm(): Function;
    static get _dn(): Function;
    static get _dp(): Function;
    static get _dq(): Function;
    static get _ds(): Function;
    static get _dv(): Function;
    static get _dw(): Function;
    static get _d0(): Function;
    static get _eb(): Function;
    static get _ef(): Function;
    static get _eg(): Function;
    static get _eh(): Function;
    static get _ei(): Function;
    static get _ej(): Function;
    static get _ep(): Function;
    static get _eu(): Function;
    static get _ev(): Function;
    static get _e7(): Function;
    static get _fa(): Function;
    static get _fm(): Function;
    static get _fn(): Function;
    static get _fo(): Function;
    static get _fv(): Function;
    static get _fx(): Function;
    static get _fy(): Function;
    static get _fz(): Function;
    static get _f1(): Function;
    static get _f5(): Function;
    static get _f6(): Function;
    static get _gi(): Function;
    static get _gj(): Function;
    static get _gk(): Function;
    static get _gl(): Function;
    static get _gn(): Function;
    static get _go(): Function;
    static get _gp(): Function;
    static get _gq(): Function;
    static get _gr(): Function;
    static get _gs(): Function;
    static get _gt(): Function;
    static get _gu(): Function;
    static get _gv(): Function;
    static get _gw(): Function;
    static get _g5(): Function;
    static get _g6(): Function;
    static get _g8(): Function;
    static get _ha(): Function;
    static get _ih(): Function;
    static get _jh(): Function;
    static get _kg(): Function;
    static get _km(): Function;
    static get _kr(): Function;
    static get _k2(): Function;
    static get _lh(): Function;
    static get _li(): Function;
    static get _lk(): Function;
    static get _l1(): Function;
    static get _l4(): Function;
    static get _mq(): Function;
    static get _mr(): Function;
    static get _ms(): Function;
    static get _mt(): Function;
    static get _mu(): Function;
    static get _my(): Function;
    static get _mz(): Function;
    static get _m0(): Function;
    static get _m1(): Function;
    static get _m2(): Function;
    static get _m3(): Function;
    static get _nh(): Function;
    static get _ni(): Function;
    static get _nt(): Function;
    static get _nu(): Function;
    static get _nx(): Function;
    static get _n9(): Function;
    static get _oj(): Function;
    static get _pa(): Function;
    static get _pc(): Function;
    static get _p1(): Function;
    static get _qe(): Function;
    static get _qk(): Function;
    static get _ql(): Function;
    static get _qm(): Function;
    static get _v(): Function;
    static get _n0(): Function;
    static get _qr(): Function;
    static get _fb(): Function;
    static get _n7(): Function;
    static get _e9(): Function;
    static get _mi(): Function;
    static get _nr(): Function;
    static get _n8(): Function;
    static get _p0(): Function;
    static get _qq(): Function;
    static get _jf(): Function;
    static get _i7(): Function;
    static get _a9(): Function;
    static get _ba(): Function;
    static get _i0(): Function;
    static get _js(): Function;
    static get _jt(): Function;
    static get _mp(): Function;
    static get _nj(): Function;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionMinus extends UltraCalcBinaryOperatorBase {
    static $t: Type;
    protected _ak(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionMultiply extends UltraCalcBinaryOperatorBase {
    static $t: Type;
    protected _ak(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionDivide extends UltraCalcBinaryOperatorBase {
    static $t: Type;
    protected _ak(a: ExcelCalcValue, b: ExcelCalcValue): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionEqual extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionNE extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionGE extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionGT extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__k(): TokenClass;
    protected get__r(): boolean;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionLE extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionLT extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionConcat extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionExpon extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionPercent extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionUnaryMinus extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionUnaryPlus extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    doesParameterAllowIntermediateResultArray(a: number, b: boolean): boolean;
    _j(a: number): TokenClass;
    protected get__r(): boolean;
    protected get__k(): TokenClass;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionXLIntersect extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    _j(a: number): TokenClass;
    protected get__k(): TokenClass;
    _v(a: number): boolean;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionXLRange extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    _j(a: number): TokenClass;
    protected get__k(): TokenClass;
    _v(a: number): boolean;
}
/**
 * @hidden
 */
export declare class UltraCalcFunctionXLUnion extends BuiltInFunctionBase {
    static $t: Type;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    _j(a: number): TokenClass;
    protected get__k(): TokenClass;
    _v(a: number): boolean;
}
/**
 * @hidden
 */
export declare class WorksheetCellFormatCollection extends GenericCachedCollectionEx$1<WorksheetCellFormatData> {
    static $t: Type;
    constructor(a: WorksheetCellFormatData, b: Workbook);
    _q(a: WorksheetCellFormatData): void;
    get workbook(): Workbook;
}
/**
 * @hidden
 */
export declare class ValueFormatter_ValueFormatterContext extends Base {
    static $t: Type;
    j: number;
    o: any;
    a: ValueFormatter_GetTextWidthHelper;
    b: ValueFormatter_SectionType;
    f: boolean;
    g: boolean;
    c: ValueFormatterFlags;
    d: ValueFormatterOptions;
    private v;
    private ae;
    private ac;
    private y;
    private aa;
    private af;
    private ah;
    private ak;
    readonly r: StringBuilder;
    readonly s: StringBuilder;
    n: Nullable$1<boolean>;
    q: string;
    i: number;
    p: string;
    l: number;
    k: number;
    h: string;
    e: boolean;
    t(a: string, b?: string): void;
    w(): void;
    ad(): void;
    u(): void;
    ab(): void;
    x(): void;
    aj(a: ValueFormatter_FormatSection, b: string, c: number): void;
    z(a: ValueFormatter_FormatSection): void;
    ag(): void;
    ai(a: string): void;
    get m(): number;
}
/**
 * @hidden
 */
export declare class ValueFormatter extends Base {
    static $t: Type;
    i: Workbook;
    constructor(a: number, b: Workbook, c: string, d: CultureInfo);
    constructor(a: number, b: string, c: CultureInfo, d?: CultureInfo);
    constructor(a: number, ..._rest: any[]);
    h(a: number, b: string, c: any, d: number, e: TextMetricsProviderBase, f: WorksheetCellFormatData, g: boolean, h?: ValueFormatterOptions): GetCellTextResult;
    private static ag;
    ah(): string;
    ab(a: number): number;
    c(a: number): IValueFormatterSectionInfo;
    f(a: number): ValueFormatter_SectionType;
    e(a: number): ValueFormatter_SectionType;
    j(): boolean;
    k(a: number): boolean;
    l(a: number): boolean;
    m(a: number): boolean;
    n(a: number): boolean;
    private ai;
    private aj;
    private static d;
    a: ValueFormatter_FormatSection[];
    static y: CultureInfo;
    z: CultureInfo;
    private static g;
    private static aa;
    private b;
    private static p;
    private static q;
    private static r;
    private s;
    private t;
    static x(a: number, b?: number): number;
    private static u;
    v(a: number, b: string, c: string): {
        ret: boolean;
        p2: string;
    };
    private ak;
    get o(): boolean;
}
/**
 * @hidden
 */
export declare class ValueFormatter_FormatSection extends Base {
    static $t: Type;
    cp(a: ValueFormatter_ValueFormatterContext, b: number, c: string, d: number): {
        p3?: number;
    };
    private ct;
    private static ar;
    private static readonly a6;
    private static readonly a9;
    private static readonly a8;
    private static a;
    private bk;
    private bl;
    private bm;
    private bn;
    private bo;
    private ba;
    private bb;
    private ca;
    private a7;
    private h;
    private bf;
    private ao;
    private bq;
    private a3;
    private bh;
    private o;
    private p;
    private f;
    private b6;
    private b4;
    private b8;
    private q;
    private r;
    private bv;
    private t;
    private y;
    private ab;
    private ad;
    private af;
    private al;
    private aa;
    private b9;
    private aj;
    private am;
    private as;
    private a5;
    private bz;
    private b2;
    private j;
    private e;
    private a1;
    private m;
    constructor(a: ValueFormatter, b: number, c: CultureInfo);
    cn(a: string, b?: ValueFormatter_LiteralType): void;
    co(a: string, b?: ValueFormatter_LiteralType): void;
    private cq;
    cr(a: ValueFormatter_WellKnownPartType): void;
    cs(a: ValueFormatter_WellKnownPartType, b: number): void;
    cb(a: string): string;
    be(a: number): Calendar;
    private static b;
    cc(a: Date, b: ValueFormatter_FormatValueState, c: number): string;
    cd(a: Date, b: ValueFormatter_FormatValueState, c: string, d?: boolean): string;
    ce(a: Date, b: ValueFormatter_FormatValueState, c: number): string;
    cf(a: Date, b: ValueFormatter_FormatValueState, c: string, d?: boolean): string;
    cg(a: number, b?: boolean, c?: boolean): string;
    ch(a: number): string;
    private static readonly d;
    ci(a: number, b: number, c?: boolean): string;
    cj(a: Date, b: number): string;
    ck(a: Calendar, b: Date, c: number): string;
    cu(a: ValueFormatter_ValueFormatterContext): void;
    cv(a: ValueFormatter_ValueFormatterContext, b: number): {
        p1: number;
    };
    get s(): boolean;
    cl(): string;
    l(): ValueFormatter_WellKnownPart;
    static c(a: number): string[];
    cm(a: ValueFormatter_FormatValueState): string;
    get ae(): boolean;
    get ag(): boolean;
    ai(a: ValueFormatter_WellKnownPartType[]): boolean;
    bu(a: ValueFormatter_WellKnownPartType[], b?: number): number;
    get an(): boolean;
    cw(a: string, b: number, c: string): {
        p0?: string;
    };
    cx(a: string, b: number, c: string, d: string): {
        p0?: string;
    };
    au(a: number): boolean;
    cy(): void;
    av(a: string): boolean;
    aw(a: ValueFormatter_CompareOperator, b: number): boolean;
    ax(a: ValueFormatter_CompareOperator, b: number, c: boolean): boolean;
    ay(a: number): boolean;
    az(a: number, b?: boolean): boolean;
    cz(a: ValueFormatter_SectionType): void;
    a0(a: ValueFormatter_FormatValueState): boolean;
    c0(): void;
    private c1;
    get bd(): Calendar;
    get bc(): Calendar;
    get bg(): CultureInfo;
    get bi(): CultureInfo;
    get bj(): CultureInfo;
    get n(): ValueFormatterFlags;
    get g(): ValueFormatter;
    get br(): number;
    get b7(): Nullable$1<number>;
    set b7(a: Nullable$1<number>);
    get b5(): Nullable$1<number>;
    set b5(a: Nullable$1<number>);
    get bs(): number;
    get bt(): number;
    get bw(): number;
    get u(): boolean;
    get v(): boolean;
    get w(): boolean;
    get z(): boolean;
    get x(): boolean;
    get ac(): boolean;
    get ah(): boolean;
    get a2(): boolean;
    get ak(): boolean;
    get ap(): boolean;
    get aq(): boolean;
    get at(): boolean;
    get i(): ValueFormatter_Part;
    get by(): number;
    get b0(): number;
    get b1(): number;
    get k(): ValueFormatter_SectionType;
    get a4(): boolean;
}
/**
 * @hidden
 */
export declare abstract class ValueFormatter_Part extends Base {
    static $t: Type;
    abstract b(a: ValueFormatter_FormatSection, b: string): string;
    abstract a(a: ValueFormatter_FormatSection, b: ValueFormatter_FormatValueState): string;
}
/**
 * @hidden
 */
export declare class ValueFormatter_WellKnownPart extends ValueFormatter_Part {
    static $t: Type;
    private j;
    private c;
    constructor(a: ValueFormatter_WellKnownPartType, b: number);
    b(a: ValueFormatter_FormatSection, b: string): string;
    a(a: ValueFormatter_FormatSection, b: ValueFormatter_FormatValueState): string;
    o(): void;
    private l;
    private m;
    private n;
    static e(a: ValueFormatter_WellKnownPartType): boolean;
    static f(a: ValueFormatter_WellKnownPartType): boolean;
    static g(a: ValueFormatter_WellKnownPartType): boolean;
    static h(a: ValueFormatter_WellKnownPartType): boolean;
    static i(a: ValueFormatter_WellKnownPartType): boolean;
    get d(): ValueFormatter_WellKnownPartType;
}
/**
 * @hidden
 */
export declare class ValueFormatter_LiteralFormatPart extends ValueFormatter_Part {
    static $t: Type;
    private e;
    private c;
    constructor(a: string, b: ValueFormatter_LiteralType);
    b(a: ValueFormatter_FormatSection, b: string): string;
    a(a: ValueFormatter_FormatSection, b: ValueFormatter_FormatValueState): string;
    private f;
    get g(): string;
    get d(): ValueFormatter_LiteralType;
}
/**
 * A collection of worksheets in a workbook.
 * @see [[Worksheet]]
 * @see */
export declare class WorksheetCollection extends Base implements IList$1<Worksheet> {
    static $t: Type;
    private readonly _j;
    private _f;
    private readonly _a;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    add(item: Worksheet): void;
    /**
     * Creates a new [[Worksheet]] and adds it to the collection.
     * <p class="body">
     * If the workbook originally had no worksheets, the newly added worksheet will become the selected worksheet of
     * the workbook.  This can be changed after more worksheets are added by setting the [[WindowOptions.selectedWorksheet]]
     * of the Workbook.
     * </p>
     * @param name The name to give the new Worksheet.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentException]] 'name' contains the invalid characters: ':', '\', '/', '?', '*', '[', or ']'.
     * @throws [[ArgumentException]] 'name' exceeds 31 characters in length.
     * @throws [[ArgumentException]] 'name' is being used as the name of another worksheet (worksheet names are case-insensitively compared).
     * @return The Worksheet created with the specified name.
     */
    add(name: string): Worksheet;
    /**
     * @hidden
     */
    _add$e(a: Worksheet): void;
    /**
     * @hidden
     */
    copyTo(array: Worksheet[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    remove(item: Worksheet): boolean;
    [Symbol.iterator](): EnumeratorWrapper<Worksheet>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<Worksheet>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    insert(index: number, item: Worksheet): void;
    /**
     * @hidden
     */
    item(index: number, value?: Worksheet): Worksheet;
    /**
     * Gets the worksheet at the specified index.
     * The worksheet at the specified index.
     * @param index The zero-based index of the worksheet to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    item(index: number): Worksheet;
    /**
     * Gets the worksheet with the specified name.
     * <p class="body">
     * Worksheet names are compared case-insensitively.
     * </p>
     * The worksheet with the specified name.
     * @param name The name of the worksheet to get.
     * @throws [[InvalidOperationException]] A worksheet with the specified name does not exist in the collection.
     * @see [[Sheet.name]]
     */
    item(name: string): Worksheet;
    /**
     * @hidden
     */
    _item$e(a: number, b?: Worksheet): Worksheet;
    /**
     * @hidden
     */
    _add1(a: string): Worksheet;
    /**
     * @hidden
     */
    _add2(a: string, b: number): Worksheet;
    /**
     * Clears all worksheets from the collection.
     * <p class="body">
     * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
     * with a worksheet for a scope, they will be removed from the [[Workbook]].
     * </p>
     */
    clear(): void;
    /**
     * Determines whether a worksheet is in the collection.
     * @param worksheet The worksheet to locate in the collection.
     * @return True if the worksheet is found; False otherwise.
     */
    contains(worksheet: Worksheet): boolean;
    /**
     * @hidden
     */
    _n(): void;
    /**
     * Determines whether a worksheet with the specified name exists in the collection.
     * @param name The name of the worksheet to search for. The name is compared case-insensitively.
     * @return True if a worksheet with the specified name is found; False otherwise.
     */
    exists(name: string): boolean;
    /**
     * Gets the index of the specified worksheet in the collection.
     * @param worksheet The worksheet of which to get the index.
     * @return The index of the specified worksheet in the collection.
     * @see [[Worksheet.index]]
     */
    indexOf(worksheet: Worksheet): number;
    /**
     * @hidden
     */
    _o(a: number, b: number): void;
    /**
     * Removes the specified worksheet from the collection.
     * <p class="body">
     * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
     * with the worksheet to remove as their scope, they will be removed from the [[Workbook]].
     * </p>
     * @param worksheet The worksheet to remove from the collection.
     * @return True if the worksheet was successfully removed from the collection;
     * False if the worksheet did not exist in the collection.
     */
    remove_1(worksheet: Worksheet): boolean;
    /**
     * Removes the worksheet at the specified index from the collection.
     * <p class="body">
     * If there are any [[NamedReference]] instances in the [[Workbook.namedReferences]] collection
     * with the worksheet to remove as their scope, they will be removed from the [[Workbook]].
     * </p>
     * @param index The index of the worksheet to remove from the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * Gets the number of worksheets in the collection.
     * The number of worksheets in the collection.
     */
    get count(): number;
    /**
     * @hidden
     */
    _item(a: number): Worksheet;
    /**
     * @hidden
     */
    _item1(a: string): Worksheet;
    /**
     * @hidden
     */
    private get _k();
}
/**
 * @hidden
 */
export declare class WorksheetRowCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetRowCollection, c: number, d: number, e: WorksheetRow[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly e: number;
    readonly d: number;
    readonly b: WorksheetRowCollection;
    readonly a: WorksheetRow[];
    readonly c: Dictionary$2<WorksheetCellAddress, SingleTargetFormula>;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of rows in a worksheet.
 * <p class="body">
 * Rows in this collection are lazily created (they are only created and added to the collection when they are accessed).
 * If this collection is enumerated, it only enumerates the rows which were already accessed.
 * </p>
 * @see [[WorksheetRow]]
 * @see [[Worksheet.rows]]
 */
export declare class WorksheetRowCollection extends RowColumnCollectionBase$1<WorksheetRow> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _am;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    private static _ag;
    private _al;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    _a(): LoadOnDemandTree$1<WorksheetRow>;
    /**
     * @hidden
     */
    _createValue(a: number): WorksheetRow;
    /**
     * @hidden
     */
    _getItemIndex(a: WorksheetRow): number;
    /**
     * @hidden
     */
    _initializeItemIndex(a: WorksheetRow, b: number, c: boolean): void;
    /**
     * @hidden
     */
    _isItemStillValid(a: WorksheetRow): boolean;
    /**
     * Gets the maximum number of items allowed in this collection.
     */
    protected get_maxCount(): number;
    /**
     * Gets the maximum number of items allowed in this collection.
     */
    get maxCount(): number;
    /**
     * @hidden
     */
    _ab(): void;
    /**
     * @hidden
     */
    _ae(a: number): void;
    /**
     * @hidden
     */
    _af(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    private static _ai;
    /**
     * @hidden
     */
    private static _ah;
    /**
     * @hidden
     */
    _aq(a: number, b: number, c: number, d: number, e?: boolean): {
        p2: number;
        p3: number;
    };
    /**
     * @hidden
     */
    _aj(a: number): WorksheetRow;
    /**
     * @hidden
     */
    _ar(a: number, b: number, c: number, d: number, e?: boolean): {
        p0?: number;
        p1?: number;
        p2: number;
        p3: number;
    };
    /**
     * @hidden
     */
    _ap(a: number, b: number, c: boolean): Nullable$1<number>;
    /**
     * @hidden
     */
    _as(a: HiddenRowCollection): void;
    /**
     * Inserts one or more rows into the collection
     * <para class="note"><b>Note:</b> An equal number of rows will be removed (i.e. bumped) off the end of the collection.</para>
     * @param index the insertion point
     * @param count The number of rows to insert
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
     */
    insert(index: number, count?: number): void;
    /**
     * @hidden
     */
    private _au;
    /**
     * @hidden
     */
    _av(): void;
    /**
     * @hidden
     */
    private _aw;
    /**
     * @hidden
     */
    remove(item: WorksheetRow): boolean;
    /**
     * Removes one or more rows from the collection
     * @param index the index of the first row to remove point
     * @param count The number of rows to remove
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it the range intersects with a protected region.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
     */
    remove(index: number, count?: number): void;
    /**
     * @hidden
     */
    _remove1(a: number, b?: number): void;
    /**
     * @hidden
     */
    private _ay;
    /**
     * @hidden
     */
    _az(a: boolean): void;
    /**
     * @hidden
     */
    _a0(a: number, b: boolean): void;
    /**
     * @hidden
     */
    private static _a1;
    /**
     * @hidden
     */
    private static _a2;
    /**
     * @hidden
     */
    private _a3;
    /**
     * Gets the row at the specified index.
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all rows. It will only iterate the rows which have already
     * been used.  To create and iterate all rows in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum row count, and pass in each index to the collection's indexer.
     * </p>
     * The row at the specified index.
     * @param index The zero-based index of the row to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
     * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelRowCount]]
     * or [[Workbook.maxExcel2007RowCount]], depending on the [[Workbook.currentFormat]].
     */
    item(a: number): WorksheetRow;
}
/**
 * @hidden
 */
export declare abstract class WorksheetElementResizeContext extends Base {
    static $t: Type;
    static b(a: RowColumnBase): WorksheetElementResizeContext;
    static j(a: List$1<IndexRange>, b: number, c: number): List$1<WorksheetElementResizeState>;
    static c(a: Worksheet, b: number, c: number, d: boolean, e?: List$1<IndexRange>): WorksheetElementResizeContext;
    static d(a: Worksheet, b: List$1<WorksheetElementResizeState>, c: boolean, d: number): WorksheetElementResizeContext;
    static e(a: Worksheet, b: number, c: number, d: Nullable$1<boolean>, e: boolean, f?: List$1<IndexRange>): WorksheetElementResizeContext;
    static k(a: Worksheet, b: number, c: number, d: boolean): List$1<IndexRange>;
    static n(a: Worksheet, b: number, c: number, d: Nullable$1<boolean>, e: boolean): List$1<IndexRange>;
    static l(a: Worksheet, b: number, c: number): List$1<WorksheetElementResizeState>;
    static m(a: Worksheet, b: number, c: number, d?: (arg1: WorksheetRow) => boolean): List$1<WorksheetElementResizeState>;
    static o(a: Worksheet, b: List$1<WorksheetElementResizeState>, c: boolean): {
        ret: List$1<WorksheetElementResizeState>;
        p2: boolean;
    };
    static p(a: Worksheet, b: List$1<WorksheetElementResizeState>, c: boolean): {
        ret: List$1<WorksheetElementResizeState>;
        p2: boolean;
    };
    z(a: Worksheet, b: boolean): void;
    y(): void;
    q(a: number): number;
    f(a: number): boolean;
    s(a: number, b?: boolean): number;
    t(a: number, b: number, c?: boolean): number;
    abstract g(a: number): boolean;
    abstract u(a: number, b: boolean): number;
    abstract v(a: number, b: number): number;
    aa(): void;
    ab(): void;
    abstract get i(): List$1<IndexRange>;
    abstract get r(): number;
    h: boolean;
    abstract get w(): number;
    a: Worksheet;
    x: number;
}
/**
 * @hidden
 */
export declare class WorksheetShapeCollection_ChartShiftInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: WorksheetChart, c: Tuple$2<IChartObject, any>[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: WorksheetChart;
    readonly a: Tuple$2<IChartObject, any>[];
}
/**
 * @hidden
 */
export declare class WorksheetShapeCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetShapeCollection, c: WorksheetShape, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: WorksheetShapeCollection;
    readonly a: WorksheetShape;
    readonly c: number;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export interface IMultiChartContext {
    charts(): IEnumerable$1<WorksheetChart>;
}
/**
 * @hidden
 */
export declare let IMultiChartContext_$type: Type;
/**
 * @hidden
 */
export declare class WorksheetShapeCollection_ChartShiftContext extends ValueType implements IChangeInfoContext, IMultiChartContext {
    static $t: Type;
    constructor(a: number, b: WorksheetShapeCollection, c: WorksheetShapeCollection_ChartShiftInfo[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: WorksheetShapeCollection;
    readonly a: WorksheetShapeCollection_ChartShiftInfo[];
    c(): void;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
    private _charts;
    charts(): IEnumerable$1<WorksheetChart>;
}
/**
 * A collection of [[WorksheetShape]] instances in a [[Worksheet]]
 * or [[WorksheetShapeGroup]].
 * @see@see */
export declare class WorksheetShapeCollection extends Base implements ICollection$1<WorksheetShape> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    private static readonly _ab;
    /**
     * @hidden
     */
    private static readonly _aa;
    /**
     * @hidden
     */
    static readonly _x: number;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    static _a: ChangeInfo[];
    /**
     * @hidden
     */
    static _t: List$1<Tuple$2<IChartObject, any>>;
    /**
     * @hidden
     */
    static _s: List$1<WorksheetShapeCollection_ChartShiftInfo>;
    /**
     * @hidden
     */
    _e: IWorksheetShapeOwner;
    private _u;
    static staticInit(): void;
    constructor(a: IWorksheetShapeOwner);
    /**
     * @hidden
     */
    copyTo(array: WorksheetShape[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    remove(item: WorksheetShape): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetShape>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetShape>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a predefined shape to the collection with the specified bounds.
     * @param shapeType The type of shape to add to the collection.
     * @param sheet The [[sheet]] to which the 'boundsInTwips' relate.
     * @param boundsInTwips The bounds of the shape on the 'sheet' in twips (1/20th of a point).
     * @throws [[ArgumentNullException]] 'sheet' is null.
     * @throws [[InvalidEnumArgumentException]] 'shapeType' is not defined in the [[PredefinedShapeType]] enumeration.
     * @return A [[WorksheetShape]]-derived instance representing the predefined shape.
     */
    add(shapeType: PredefinedShapeType, sheet: Sheet, boundsInTwips: IgRect): WorksheetShape;
    /**
     * Adds a predefined shape to the collection with the specified anchors.
     * @param shapeType The type of shape to add to the collection.
     * @param topLeftCornerCell The cell where the top-left corner of the shape resides.
     * @param topLeftCornerPosition The position in the 'topLeftCornerCell' of the shape's top-left corner,
     * expressed in percentages.
     * @param bottomRightCornerCell The cell where the bottom-right corner of the shape resides.
     * @param bottomRightCornerPosition the position in the 'bottomRightCornerCell' of the shape's bottom-right
     * corner, expressed in percentages.
     * @throws [[InvalidEnumArgumentException]] 'shapeType' is not defined in the [[PredefinedShapeType]] enumeration.
     * @throws [[InvalidOperationException]] 'topLeftCornerCell' or 'bottomRightCornerCell' is null.
     * @throws [[InvalidOperationException]] 'topLeftCornerCell' and 'bottomRightCornerCell' belong to different worksheets or a worksheet other
     * than the worksheet to which this collection belongs.
     * @return A [[WorksheetShape]]-derived instance representing the predefined shape.
     */
    add(shapeType: PredefinedShapeType, topLeftCornerCell: WorksheetCell, topLeftCornerPosition: IgPoint, bottomRightCornerCell: WorksheetCell, bottomRightCornerPosition: IgPoint): WorksheetShape;
    /**
     * Adds a predefined shape to the collection with the specified bounds.
     * @param shapeType The type of shape to add to the collection.
     * @param boundsInTwips The bounds of the shape on the [[Worksheet]] in twips (1/20th of a point).
     * @throws [[InvalidOperationException]] This shapes collection belongs to a [[WorksheetShapeGroup]] which isn't placed on a Worksheet yet. In this case,
     * call [[add]] instead and specify the Worksheet where the group will be added.
     * @throws [[InvalidEnumArgumentException]] 'shapeType' is not defined in the [[PredefinedShapeType]] enumeration.
     * @return A [[WorksheetShape]]-derived instance representing the predefined shape.
     */
    add(shapeType: PredefinedShapeType, boundsInTwips: IgRect): WorksheetShape;
    /**
     * Adds a shape to the collection.
     * @param shape The shape to add to the collection.
     * @throws [[ArgumentNullException]] 'shape' is null.
     * @throws [[InvalidOperationException]] 'shape' has already been added to a worksheet or group.
     * @throws [[InvalidOperationException]] 'shape' does not have the [[WorksheetShape.topLeftCornerCell]]
     * or [[WorksheetShape.bottomRightCornerCell]] set.
     * @throws [[InvalidOperationException]] Adding 'shape' to this collection will place it on a different worksheet then either its
     * TopLeftCornerCell or BottomRightCornerCell or 'shape' is a [[WorksheetShapeGroup]]
     * and adding it to this collection will create a similar situation for one of its descendant shapes.
     * @throws [[InvalidOperationException]] 'shape' is a WorksheetShapeGroup and this is the group's collection of shapes.
     */
    add(shape: WorksheetShape): void;
    /**
     * @hidden
     */
    _add2(a: PredefinedShapeType, b: Rect): WorksheetShape;
    /**
     * @hidden
     */
    _add(a: PredefinedShapeType, b: Sheet, c: Rect): WorksheetShape;
    /**
     * @hidden
     */
    _add1(a: PredefinedShapeType, b: WorksheetCell, c: Point, d: WorksheetCell, e: Point): WorksheetShape;
    /**
     * @hidden
     */
    _add3(a: WorksheetShape): void;
    /**
     * @hidden
     */
    _add4(a: WorksheetShape, b: boolean, c?: (arg1: WorksheetChart) => void): void;
    /**
     * @hidden
     */
    private _ai;
    /**
     * Adds a chart to the collection with the specified bounds.
     * @param chartType The type of chart to add to the collection.
     * @param sheet The [[sheet]] to which the 'boundsInTwips' relate.
     * @param boundsInTwips The bounds of the shape on the 'sheet' in twips (1/20th of a point).
     * @param chartInitializer An optional callback for initializing the chart before it is added to the collection.
     * @throws [[ArgumentNullException]] if sheet is null.
     * @throws [[InvalidEnumArgumentException]] 'chartType' is not defined in the [[ChartType]] enumeration.
     * @throws [[InvalidOperationException]] if a chart is being added to the Shapes collection of another Chart is null.
     * @throws [[InvalidOperationException]] if a <see cref="Workbook.CurrentFormat">Workbook.CurrentFormat</see> doesn't support Chart mofications, e.g. 'Excel97To2003' or 'Excel97To2003Template'.
     * @return A [[WorksheetChart]]-instance.
     */
    addChart(chartType: ChartType, sheet: Sheet, boundsInTwips: IgRect, chartInitializer?: (arg1: WorksheetChart) => void): WorksheetChart;
    /**
     * Adds a chart to the collection with the specified bounds.
     * @param chartType The type of chart to add to the collection.
     * @param topLeftCornerCell The cell where the top-left corner of the shape resides.
     * @param topLeftCornerPosition The position in the 'topLeftCornerCell' of the shape's top-left corner,
     * expressed in percentages.
     * @param bottomRightCornerCell The cell where the bottom-right corner of the shape resides.
     * @param bottomRightCornerPosition the position in the 'bottomRightCornerCell' of the shape's bottom-right
     * corner, expressed in percentages.
     * @param chartInitializer An optional callback for initializing the chart before it is added to the collection.
     * @throws [[InvalidEnumArgumentException]] 'chartType' is not defined in the [[ChartType]] enumeration.
     * @throws [[InvalidOperationException]] 'topLeftCornerCell' or 'bottomRightCornerCell' is null.
     * @throws [[InvalidOperationException]] 'topLeftCornerCell' and 'bottomRightCornerCell' belong to different worksheets or a worksheet other
     * than the worksheet to which this collection belongs.
     * @throws [[InvalidOperationException]] if a chart is being added to the Shapes collection of another Chart is null.
     * @throws [[InvalidOperationException]] if a <see cref="Workbook.CurrentFormat">Workbook.CurrentFormat</see> doesn't support Chart mofications, e.g. 'Excel97To2003' or 'Excel97To2003Template'.
     * @return A [[WorksheetChart]]-instance.
     */
    addChart(chartType: ChartType, topLeftCornerCell: WorksheetCell, topLeftCornerPosition: IgPoint, bottomRightCornerCell: WorksheetCell, bottomRightCornerPosition: IgPoint, chartInitializer?: (arg1: WorksheetChart) => void): WorksheetChart;
    /**
     * Adds a chart to the collection with the specified bounds.
     * @param chartType The type of chart to add to the collection.
     * @param boundsInTwips The bounds of the shape on the worksheet in twips (1/20th of a point).
     * @param chartInitializer An optional callback for initializing the chart before it is added to the collection.
     * @throws [[ArgumentNullException]] if worksheet is null.
     * @throws [[InvalidEnumArgumentException]] 'chartType' is not defined in the [[ChartType]] enumeration.
     * @throws [[InvalidOperationException]] if a chart is being added to the Shapes collection of another Chart is null.
     * @throws [[InvalidOperationException]] if a <see cref="Workbook.CurrentFormat">Workbook.CurrentFormat</see> doesn't support Chart mofications, e.g. 'Excel97To2003' or 'Excel97To2003Template'.
     * @return A [[WorksheetChart]]-instance.
     */
    addChart(chartType: ChartType, boundsInTwips: IgRect, chartInitializer?: (arg1: WorksheetChart) => void): WorksheetChart;
    /**
     * @hidden
     */
    _addChart2(a: ChartType, b: Rect, c?: (arg1: WorksheetChart) => void): WorksheetChart;
    /**
     * @hidden
     */
    _addChart(a: ChartType, b: Sheet, c: Rect, d?: (arg1: WorksheetChart) => void): WorksheetChart;
    /**
     * @hidden
     */
    _addChart1(a: ChartType, b: WorksheetCell, c: Point, d: WorksheetCell, e: Point, f?: (arg1: WorksheetChart) => void): WorksheetChart;
    /**
     * Clears all shapes from the collection.
     */
    clear(): void;
    /**
     * Determines whether a shape is in the collection.
     * @param shape The shape to locate in the collection.
     * @return True if the shape is found; False otherwise.
     */
    contains(shape: WorksheetShape): boolean;
    /**
     * Removes the specified shape from the collection.
     * @param shape The shape to remove from the collection.
     * @return True if the shape was successfully removed from the collection;
     * False if the shape did not exist in the collection.
     */
    remove_1(shape: WorksheetShape): boolean;
    /**
     * Removes the shape at the specified index from the collection.
     * @param index The index of the shape to remove from the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _ag(): void;
    /**
     * @hidden
     */
    _al(a: CellShiftOperation, b: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _ao(): void;
    /**
     * @hidden
     */
    _ah(a: (arg1: WorksheetShape) => void): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _aj;
    /**
     * @hidden
     */
    private _ak;
    /**
     * @hidden
     */
    private _ac;
    /**
     * @hidden
     */
    private _am;
    /**
     * @hidden
     */
    private static _ap;
    /**
     * @hidden
     */
    private static _aq;
    /**
     * Gets the number of shapes in the collection.
     * The number of shapes in the collection.
     */
    get count(): number;
    /**
     * Gets the shape at the specified index in the collection.
     * The shape at the specified index.
     * @param index The zero-based index of the shape to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    item(a: number): WorksheetShape;
    /**
     * @hidden
     */
    get _p(): boolean;
    /**
     * @hidden
     */
    get _q(): boolean;
    /**
     * @hidden
     */
    get _f(): IWorksheetShapeOwner;
    /**
     * @hidden
     */
    get _g(): Sheet;
}
/**
 * @hidden
 */
export declare class WorksheetCellAddress extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, c: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    static readonly b: WorksheetCellAddress;
    private readonly l;
    private readonly n;
    equals(a: any): boolean;
    getHashCode(): number;
    toString(): string;
    a(): WorksheetCellAddress;
    p(a: boolean, b: boolean, c: WorkbookFormat, d: CellReferenceMode): string;
    c(a: number): WorksheetCellAddress;
    d(a: number): WorksheetCellAddress;
    get m(): number;
    get e(): boolean;
    get o(): number;
    static f(a: WorksheetCellAddress, b: WorksheetCellAddress): boolean;
    static g(a: Nullable$1<WorksheetCellAddress>, b: Nullable$1<WorksheetCellAddress>): boolean;
    static h(a: WorksheetCellAddress, b: WorksheetCellAddress): boolean;
    static i(a: Nullable$1<WorksheetCellAddress>, b: Nullable$1<WorksheetCellAddress>): boolean;
}
/**
 * Represents a comment for a cell.
 * <p class="body">
 * Comments cannot be added to a worksheet's or a shape group's shapes collection. Instead, they must be set directly on the cell
 * with the cell's [[WorksheetCell.comment]] property.
 * </p>
 * <p class="body">
 * It is not required that the anchors of this shape be initialized before setting it as the comment of a cell. If the
 * [[WorksheetShape.topLeftCornerCell]] and [[WorksheetShape.bottomRightCornerCell]] anchors are both null when
 * the comment is applied to a cell, default anchor cells will be used based on the cell.
 * </p>
 */
export declare class WorksheetCellComment extends WorksheetShape implements IFormattedStringOwner, IWorkbookFontDefaultsResolver {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _d6: number;
    /**
     * @hidden
     */
    static readonly _d5: number;
    /**
     * @hidden
     */
    static readonly _d8: number;
    /**
     * @hidden
     */
    static readonly _d7: number;
    /**
     * @hidden
     */
    private static readonly _dv;
    private _d9;
    private _d1;
    private _d0;
    private _eb;
    private _d3;
    private _dy;
    constructor();
    constructor(shapeWithText: WorksheetShapeWithText);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    private _ed;
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__aq(): boolean;
    /**
     * @hidden
     */
    protected get__as(): boolean;
    /**
     * @hidden
     */
    protected get__a8(): boolean;
    /**
     * @hidden
     */
    _cz(): void;
    /**
     * @hidden
     */
    _c0(a: Sheet): void;
    /**
     * @hidden
     */
    _c3(): void;
    /**
     * @hidden
     */
    _c4(a: WorksheetCell, b: WorksheetCellAddress, c: WorksheetCellAddress): void;
    /**
     * @hidden
     */
    _r(a: CellShiftOperation, b: boolean, c: WorksheetRegionAddress): {
        ret: ShiftAddressResult;
        p2?: WorksheetRegionAddress;
    };
    /**
     * @hidden
     */
    _dc(): void;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    _dh(a: ShapePositioningMode): void;
    /**
     * Gets the worksheet on which the shape resides.
     * The worksheet on which the shape resides.
     */
    protected get_sheet(): Sheet;
    /**
     * @hidden
     */
    get allowDefaultValues(): boolean;
    /**
     * @hidden
     */
    getDefaultFont(): IWorkbookFont;
    /**
     * @hidden
     */
    getFontDefaultsResolver(): IWorkbookFontDefaultsResolver;
    /**
     * @hidden
     */
    onUnformattedStringChanged(sender: FormattedString): void;
    /**
     * @hidden
     */
    onFormattingChanged(): void;
    /**
     * @hidden
     */
    resolveDefaults(font: WorkbookFontData): void;
    /**
     * @hidden
     */
    _ee(): void;
    /**
     * @hidden
     */
    private static _dx;
    /**
     * @hidden
     */
    private static _dw;
    /**
     * Gets or sets the author of the comment.
     * <p class="body">
     * This information is not displayed in the Microsoft Excel UI and is for informational purposes only.
     * </p>
     * The author of the comment.
     */
    get author(): string;
    set author(a: string);
    /**
     * Gets the cell to which the comment is applied.
     * The cell to which the comment is applied.
     * @see [[WorksheetCell.comment]]
     */
    get cell(): WorksheetCell;
    set cell(a: WorksheetCell);
    /**
     * @hidden
     */
    get _d4(): WorksheetCellAddress;
    /**
     * @hidden
     */
    get _ec(): number;
    /**
     * @hidden
     */
    set _ec(a: number);
    /**
     * Gets or sets the formatted text of the comment.
     * <p class="body">
     * Getting the value of this property will always return a non-null value. If null is set on the property, it will subsequently
     * return an empty formatted string.
     * </p>
     * The formatted text of the comment.
     */
    get text(): FormattedString;
    set text(a: FormattedString);
}
/**
 * @hidden
 */
export declare class WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange extends WorksheetElementResizeContext {
    static $t: Type;
    static ac: WorksheetElementResizeContext_SingleElementResizeOrVisibilityChange;
    private ae;
    private ad;
    private af;
    constructor();
    y(): void;
    ag(a: RowColumnBase): void;
    g(a: number): boolean;
    u(a: number, b?: boolean): number;
    v(a: number, b: number): number;
    protected get_i(): List$1<IndexRange>;
    get i(): List$1<IndexRange>;
    protected get_r(): number;
    get r(): number;
    protected get_w(): number;
    get w(): number;
}
/**
 * @hidden
 */
export declare class WorksheetColumnBlock extends Base {
    static $t: Type;
    private a;
    private o;
    private e;
    private p;
    private l;
    private s;
    private f;
    constructor(a: number, b: number, c: number, d: WorksheetCellFormatData);
    constructor(a: number, b: number, c: number, d: WorksheetColumnBlock);
    constructor(a: number, ..._rest: any[]);
    equals(a: any): boolean;
    getHashCode(): number;
    toString(): string;
    c(a: Workbook): WorksheetColumnBlock;
    d(a: Workbook, b: number, c: number): WorksheetColumnBlock;
    g(a: number): boolean;
    n(a: Worksheet, b: WorksheetColumnWidthUnit, c?: boolean): number;
    x(a: FormatLimitErrors, b: WorkbookFormat): void;
    get b(): WorksheetCellFormatData;
    set b(a: WorksheetCellFormatData);
    get t(): number;
    get q(): number;
    set q(a: number);
    get i(): boolean;
    set i(a: boolean);
    get j(): boolean;
    set j(a: boolean);
    get k(): boolean;
    get r(): number;
    set r(a: number);
    get m(): number;
    set m(a: number);
    get v(): number;
    set v(a: number);
}
/**
 * @hidden
 */
export declare class WorksheetCellFormatBlock extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, c: WorksheetCellFormatData[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: number;
    readonly a: WorksheetCellFormatData[];
}
/**
 * @hidden
 */
export declare class CellSizeMeasurementContext extends Base {
    static $t: Type;
    private readonly b;
    private readonly d;
    private readonly c;
    private readonly a;
    constructor(a: Workbook, b: TextMetricsProviderBase);
    e(a: WorksheetCellFormatData, b: string, c: number, d: number): number;
    k(a: WorksheetCellFormatData): number;
    l(a: WorksheetCellFormatData, b: string, c: number): number;
    private static j;
    private f;
    private m;
    private g;
    private h;
    private static i;
}
/**
 * @hidden
 */
export declare class CellDataContext extends Base {
    static $t: Type;
    private c;
    private i;
    private k;
    private q;
    private m;
    private g;
    private e;
    constructor(a: number, b: WorksheetCellBlock, c: WorksheetCellFormatData, d: boolean, e: WorksheetCellBlock_DataType, f: WorksheetCellBlock_CellValue);
    get d(): WorksheetCellBlock;
    get j(): WorksheetCellFormatData;
    set j(a: WorksheetCellFormatData);
    get l(): boolean;
    get r(): number;
    get n(): boolean;
    get o(): boolean;
    get h(): WorksheetCellBlock_DataType;
    get f(): WorksheetCellBlock_CellValue;
    get p(): boolean;
    s(a: WorksheetRow): any;
    t(a: WorksheetRow): any;
    private static a;
    u(): void;
    static b(a: number, b: WorksheetCellBlock, c: WorksheetCellFormatData, d: boolean, e: WorksheetCellBlock_DataType, f: WorksheetCellBlock_CellValue): CellDataContext;
}
/**
 * @hidden
 */
export declare abstract class WorksheetCellBlock extends Base {
    static $t: Type;
    private readonly v;
    constructor(a: number);
    protected abstract h(a: WorksheetCellBlock): {
        ret: boolean;
        p0: WorksheetCellBlock;
    };
    abstract al(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue, d: boolean): {
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
        p3: boolean;
    };
    protected abstract e(a: number): WorksheetCellBlock_CellValue;
    protected abstract f(a: number): WorksheetCellBlock_DataType;
    protected abstract am(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): {
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
    };
    abstract r(a: number): boolean;
    protected abstract an(a: number, b: WorksheetCellBlock_CellValue, c: boolean): void;
    protected abstract aq(a: number, b: WorksheetCellBlock_DataType): void;
    abstract ar(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): void;
    abstract at(a: number, b: boolean): void;
    private static o;
    static q(a: string): boolean;
    static u(a: any): boolean;
    static ax(a: any): void;
    static az(a: IRegionBlockingValue, b: WorksheetRegion, c: WorksheetRegion): void;
    static a0(a: any): void;
    aj(a: WorksheetRow, b: number): void;
    i(a: WorksheetRow, b: number): boolean;
    j(a: number): boolean;
    k(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): {
        ret: boolean;
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
    };
    m(a: number): boolean;
    n(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): {
        ret: boolean;
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
    };
    l(a: WorksheetCellBlock_DataType, b: WorksheetCellBlock_CellValue): boolean;
    y(a: WorksheetRow, b: number, c?: boolean): any;
    b(a: WorksheetRow, b: number, c: GetCellTextParameters): GetCellTextResult;
    static a(a: Worksheet, b: WorksheetRow, c: number, d: GetCellTextParameters, e: any): GetCellTextResult;
    z(a: WorksheetRow, b: number): any;
    c(a: WorksheetRow, b: number): StringElement;
    ai(a: WorksheetRow, b: number, c: WorksheetCellBlock_DataType, d: WorksheetCellBlock_CellValue): StringBuilder;
    ac(a: WorksheetRow, b: number, c: WorksheetCellBlock_DataType, d: WorksheetCellBlock_CellValue): {
        ret: any;
        p2: WorksheetCellBlock_DataType;
        p3: WorksheetCellBlock_CellValue;
    };
    aa(a: WorksheetRow, b: number, c?: WorkbookSaveManager): any;
    ab(a: WorksheetRow, b: number, c: WorkbookSaveManager, d: WorksheetCellBlock_DataType, e: WorksheetCellBlock_CellValue): any;
    private ad;
    static ah(a: any): string;
    private g;
    p(a: WorksheetRow, b: number): boolean;
    static s(a: any): boolean;
    as(a: WorksheetRow, b: number, c: boolean, d: WorksheetCellBlock, e?: boolean): {
        p3: WorksheetCellBlock;
    };
    ao(a: WorksheetRow, b: number, c: any, d: WorksheetCellBlock, e?: boolean, f?: boolean): {
        p3: WorksheetCellBlock;
    };
    ap(a: WorksheetRow, b: number, c: any, d: any, e: WorksheetCellBlock_DataType, f: WorksheetCellBlock_CellValue, g: WorksheetCellBlock, h?: boolean): {
        p6: WorksheetCellBlock;
    };
    av(a: number, b: StringElement): void;
    private aw;
    ay(a: WorksheetRow, b: number, c: any, d: any, e: boolean): void;
    private ak;
    private x;
    private d;
    private af;
    private ae;
    private ag;
    private au;
    private static t;
    get w(): number;
}
/**
 * Represents a merged region of cells, or cells which share a value and format and appear as one cell when
 * viewed in Microsoft Excel.
 * <p class="body">
 * Merged cell regions cannot overlap (a cell can only belong to one merged cell region). In addition,
 * [[ArrayFormula]] and [[WorksheetDataTable]] instances cannot be applied to merged cell
 * regions.
 * </p>
 */
export declare class WorksheetMergedCellsRegion extends WorksheetRegion implements ICellFormatOwner, IWorksheetCellFormatProxyOwner {
    static $t: Type;
    private _au;
    private _ay;
    /**
     * @hidden
     */
    static _aw: WorksheetMergedCellsRegion;
    constructor(a: Worksheet, b: number, c: number, d: number, e: number);
    /**
     * @hidden
     */
    get cellFormatInternal(): WorksheetCellFormatProxy;
    /**
     * @hidden
     */
    get hasCellFormat(): boolean;
    /**
     * @hidden
     */
    getAdjacentFormatForBorderResolution(sender: WorksheetCellFormatProxy, borderValue: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    onCellFormatValueChanged(sender: WorksheetCellFormatProxy, values: CellFormatValue, options: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    onCellFormatValueChanging(sender: WorksheetCellFormatProxy, values: CellFormatValue): void;
    /**
     * @hidden
     */
    verifyFormatOptions(sender: WorksheetCellFormatProxy, formatOptions: WorksheetCellFormatOptions): void;
    /**
     * @hidden
     */
    _aj(a: Formula, b: WorksheetRow, c: number, d?: ApplyFormulaFlags): {
        p1?: WorksheetRow;
        p2?: number;
    };
    /**
     * @hidden
     */
    _d(a: CellShiftOperation, b: boolean): ShiftAddressResult;
    /**
     * @hidden
     */
    _al(a: WorksheetRegionAddress): void;
    /**
     * @hidden
     */
    private static _a3;
    /**
     * @hidden
     */
    private static _a4;
    /**
     * @hidden
     */
    _a1(a: Nullable$1<CellFormatValue>, b: boolean): Dictionary$2<CellFormatValue, any>;
    /**
     * @hidden
     */
    static _a0(a: Worksheet, b: WorksheetRegionAddress, c: Nullable$1<CellFormatValue>, d: boolean): Dictionary$2<CellFormatValue, any>;
    /**
     * Gets the resolved cell formatting for this merged cell region.
     * <p class="body">
     * If any cell format properties are the default values on the merged cell region, the values from the owning row's cell format will be used.
     * If those are default, then the values from the owning column's cell format will be used. Otherwise, the workbook default values
     * will be used.
     * </p>
     * @return A format object describing the actual formatting that will be used when displayed this cell in Microsoft Excel.
     * @see [[cellFormat]]
     * @see [[RowColumnBase.cellFormat]]
     */
    getResolvedCellFormat(): IWorksheetCellFormat;
    /**
     * @hidden
     */
    _a5(a: boolean): void;
    /**
     * @hidden
     */
    private _a6;
    /**
     * @hidden
     */
    _a7(a: WorksheetRow, b: number, c: CellFormatValue): void;
    /**
     * @hidden
     */
    _a8(): void;
    /**
     * @hidden
     */
    _a9(): void;
    /**
     * @hidden
     */
    private static _ba;
    /**
     * @hidden
     */
    private static _bb;
    /**
     * Gets the cell formatting for the merged cell region.
     * The cell formatting for the merged cell region.
     */
    get cellFormat(): IWorksheetCellFormat;
    /**
     * @hidden
     */
    get _hasCellFormat(): boolean;
    /**
     * @hidden
     */
    get _cellFormatInternal(): WorksheetCellFormatProxy;
    /**
     * Gets or sets the comment for the merged cells region.
     * <p class="body">
     * The comment of the merged region can also be accessed from the top-left cell of the merged region of cells.
     * </p>
     * The comment for the merged cells region.
     */
    get comment(): WorksheetCellComment;
    set comment(a: WorksheetCellComment);
    /**
     * Gets the formula which has been applied to the merged region.
     * The formula which has been applied to the merged region or null if no formula has been applied.
     */
    get formula(): Formula;
    /**
     * @hidden
     */
    get _az(): boolean;
    /**
     * Gets or sets the value of the merged cell region.
     * <p class="body">The types supported for the value are:
     * <BR/>
     * <ul>
     * <li class="taskitem"><span class="taskitemtext">System.Byte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.SByte</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt16</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt64</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.UInt32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Int32</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Single</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Double</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Boolean</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Char</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Enum</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Decimal</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DateTime</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.String</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.Text.StringBuilder</span></li>
     * <li class="taskitem"><span class="taskitemtext">System.DBNull</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[ErrorValue]]</span></li>
     * <li class="taskitem"><span class="taskitemtext">[[FormattedString]]</span></li>
     * </ul>
     * </p>
     * The value of the merged cell region.
     * @throws [[NotSupportedException]] The assigned value's type is not supported and can't be exported to Excel.
     * @throws [[InvalidOperationException]] The value assigned is a [[formula]]. Instead, [[Formula.applyTo]]
     * should be called on the Formula, passing in the cell.
     * @throws [[InvalidOperationException]] The value assigned is a [[WorksheetDataTable]]. Instead, the [[WorksheetDataTable.cellsInTable]]
     * should be set to a region containing the cell.
     * @throws [[InvalidOperationException]] The value assigned is a FormattedString which is the value another cell or merged cell region.
     * @throws [[InvalidOperationException]] The value is assigned and this cell is part of an [[ArrayFormula]] or WorksheetDataTable.
     * @see [[WorksheetCell.value]]
     * @see [[WorksheetCell.isCellTypeSupported]]
     */
    get value(): any;
    set value(a: any);
}
/**
 * Class which exposes the display options which can only be controlled through the worksheet.
 * @see [[Worksheet.displayOptions]]
 * @see [[CustomViewDisplayOptions]]
 */
export declare class WorksheetDisplayOptions extends DisplayOptions {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _b7;
    /**
     * @hidden
     */
    private static readonly _ca;
    /**
     * @hidden
     */
    private static readonly _cd;
    /**
     * @hidden
     */
    private static readonly _cf;
    /**
     * @hidden
     */
    private static readonly _cg;
    /**
     * @hidden
     */
    private static readonly _ce;
    /**
     * @hidden
     */
    private static readonly _bt;
    private _b5;
    private _b8;
    private _cb;
    private _by;
    private _b0;
    private _bx;
    private _b2;
    constructor(a: Worksheet, b: boolean);
    /**
     * @hidden
     */
    _e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    _n(a: DisplayOptionsBase): void;
    /**
     * @hidden
     */
    protected get__j(): boolean;
    /**
     * @hidden
     */
    get _j(): boolean;
    /**
     * Resets the display options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank worksheet.
     * </p>
     */
    protected resetCore(): void;
    /**
     * @hidden
     */
    _bq(a: WorksheetView): void;
    /**
     * @hidden
     */
    private static _bv;
    /**
     * @hidden
     */
    private static _bu;
    /**
     * @hidden
     */
    private _b4;
    /**
     * @hidden
     */
    private _ch;
    /**
     * Gets or sets the magnification level of the worksheet when it is displayed in normal view.
     * <p class="body">
     * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
     * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
     * </p>
     * The magnification level of the worksheet when it is displayed in normal view.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
     * @see [[magnificationInPageBreakView]]
     * @see [[magnificationInPageLayoutView]]
     * @see [[DisplayOptions.view]]
     * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
     */
    get magnificationInNormalView(): number;
    set magnificationInNormalView(a: number);
    /**
     * Gets or sets the magnification level of the worksheet when it is displayed in the page break preview.
     * <p class="body">
     * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
     * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
     * </p>
     * The magnification level of the worksheet when it is displayed in the page break preview.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
     * @see [[magnificationInNormalView]]
     * @see [[magnificationInPageLayoutView]]
     * @see [[DisplayOptions.view]]
     * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
     */
    get magnificationInPageBreakView(): number;
    set magnificationInPageBreakView(a: number);
    /**
     * Gets or sets the magnification level of the worksheet when it is displayed in page layout view.
     * <p class="body">
     * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
     * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
     * </p>
     * The magnification level of the worksheet when it is displayed in page layout view.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a worksheet. The level must be between 10 and 400.
     * @see [[magnificationInNormalView]]
     * @see [[magnificationInPageBreakView]]
     * @see [[DisplayOptions.view]]
     * @see [[CustomViewDisplayOptions.magnificationInCurrentView]]
     */
    get magnificationInPageLayoutView(): number;
    set magnificationInPageLayoutView(a: number);
    /**
     * Gets or sets the value indicating whether the columns are ordered right to left.
     * <p class="body">
     * If the columns are ordered right to left, other aspects of the worksheet display differently. The vertical scrollbar
     * will display on the left side of the worksheet and the worksheet tab bar, usually displayed on the left side of the
     * worksheet, will display on the right side.
     * </p>
     * The value indicating whether the columns are ordered right to left.
     */
    get orderColumnsRightToLeft(): boolean;
    set orderColumnsRightToLeft(a: boolean);
    /**
     * Gets or sets the value which indicates whether to show whitespace between worksheet pages in page layout view.
     * <p class="note">
     * <B>Note:</B> For this value to affect the display of the worksheet, the [[DisplayOptions.view]] must
     * be set to PageLayout. However, if a different view is used, this is still saved with the workbook.
     * </p>
     * <p class="note">
     * <b>Note:</b> The [[WorksheetView]] value of PageLayout is only supported in Excel 2007.
     * If a worksheet with that View is viewed in earlier versions of Microsoft Excel, the view will default to Normal view.
     * </p>
     * The value which indicates whether to show white page between worksheet pages in page layout view.
     * @see [[DisplayOptions.view]]
     */
    get showWhitespaceInPageLayoutView(): boolean;
    set showWhitespaceInPageLayoutView(a: boolean);
    /**
     * Gets or sets the [[WorkbookColorInfo]] to use for the associated worksheet's tab in the tab bar of Microsoft Excel.
     * <p class="body">
     * If the tab bar is not visible, this color will not be seen.
     * </p>
     * The WorkbookColorInfo to use for the associated worksheet's tab in the tab bar of Microsoft Excel.
     * @see [[WindowOptions.tabBarVisible]]
     */
    get tabColorInfo(): WorkbookColorInfo;
    set tabColorInfo(a: WorkbookColorInfo);
    /**
     * @hidden
     */
    get _b3(): number;
    /**
     * @hidden
     */
    set _b3(a: number);
}
/**
 * @hidden
 */
export declare class GetCellTextParameters extends Base {
    static $t: Type;
    constructor(a: number);
    readonly e: number;
    b: PreventTextFormattingTypes;
    c: TextFormatMode;
    g: Nullable$1<boolean>;
    d: () => TextMetricsProviderBase;
    a: ValueFormatterOptions;
    h: number;
    f: number;
}
/**
 * @hidden
 */
export declare class WorksheetCellBlock_CellValue extends ValueType {
    static $t: Type;
    constructor();
    private d;
    private e;
    get b(): number;
    set b(a: number);
    get i(): number;
    set i(a: number);
    get a(): WorksheetCellBlock_DataTypeEncoded;
    set a(a: WorksheetCellBlock_DataTypeEncoded);
    get g(): number;
    set g(a: number);
    get f(): number;
    set f(a: number);
    get c(): number;
    set c(a: number);
    get h(): number;
    set h(a: number);
    j(a: StringElement): void;
}
/**
 * @hidden
 */
export declare abstract class WorkbookSerializationManager extends Base implements IDisposable {
    static $t: Type;
    private readonly _c;
    private readonly _k;
    private readonly _d;
    private readonly _a;
    private readonly _e;
    private readonly _f;
    constructor(a: Workbook, b: string);
    dispose(): void;
    protected disposeCore(a: boolean): void;
    get _g(): List$1<WorksheetCellFormatData>;
    get _l(): string;
    get _h(): List$1<WorkbookFontData>;
    get _b(): Workbook;
    get _i(): List$1<WorkbookReferenceBase>;
    get _j(): List$1<WorksheetReference>;
}
/**
 * @hidden
 */
export interface IColorFilterVisitor$2<TArg, TResult> {
    _visitFillFilter$i(a: FillFilter, b: TArg): TResult;
    _visitFontColorFilter$i(a: FontColorFilter, b: TArg): TResult;
}
/**
 * @hidden
 */
export declare let IColorFilterVisitor$2_$type: Type;
/**
 * @hidden
 */
export declare abstract class WorkbookSaveManager extends WorkbookSerializationManager implements IColorFilterVisitor$2<boolean, WorksheetCellFormatData> {
    static $t: Type;
    private readonly _aw;
    private readonly _ak;
    private readonly _al;
    private _ba;
    private readonly _am;
    private readonly _an;
    private readonly _ap;
    private readonly _aq;
    private readonly _a2;
    private readonly _ar;
    private _bb;
    private _ac;
    private _ad;
    private readonly _ao;
    private readonly _a0;
    private readonly _x;
    private readonly _ab;
    private readonly _t;
    readonly _as: Dictionary$2<Formula, string>;
    constructor(a: Workbook, b: string, c: WorkbookSaveOptions);
    _visitFillFilter$i(a: FillFilter, b: boolean): WorksheetCellFormatData;
    _visitFontColorFilter$i(a: FontColorFilter, b: boolean): WorksheetCellFormatData;
    abstract _a8(a: WorksheetCellFormatData): number;
    abstract _a9(a: WorkbookStyle): number;
    abstract _bm(): void;
    protected abstract _p(): WorkItem;
    _bc(a: WorksheetCellFormatData): number;
    _bf(a: WorkbookFontProxy, b: IWorkbookFontDefaultsResolver): void;
    _y(a: IColorFilter): WorksheetCellFormatData;
    _ae(a: WorksheetColumnBlock): boolean;
    _bh<T>($t: Type, a: WorksheetTableAreaFormatsCollection$1<T>, b: T, c: WorkbookStyle, d: WorksheetCellFormatData): {
        p2: WorkbookStyle;
        p3: WorksheetCellFormatData;
    };
    _bi<T>($t: Type, a: WorksheetTableAreaFormatsCollection$1<T>, b: T, c: WorkbookStyle, d: WorksheetCellFormatData, e: WorksheetCellFormatData, ...f: CellFormatValue[]): {
        p2: WorkbookStyle;
        p3: WorksheetCellFormatData;
        p4: WorksheetCellFormatData;
    };
    _a4(a: WorksheetTableColumn): Nullable$1<number>;
    _ax(a: Worksheet): IEnumerable$1<WorksheetMergedCellsRegion>;
    _z(a: WorksheetShape): WorksheetShape;
    _ay(a: Worksheet, b?: boolean): IEnumerable$1<WorksheetRow>;
    _w(a: Worksheet): WorksheetSerializationCache;
    _s(a: Sheet): SheetSerializationCache;
    _u(a: WorksheetRow): WorksheetRowSerializationCache;
    _a5(a: WorksheetRow, b: CellDataContext, c?: boolean): any;
    private static _a6;
    private __az;
    _az(): IEnumerable$1<StringElement>;
    _aa(a: WorksheetTableStyle): SortedList$2<WorksheetTableStyleArea, number>;
    _af(a: Worksheet): boolean;
    _o(): WorkItem;
    static _b7(a: WorksheetHyperlink, b: string, c: string, d: string): {
        p1: string;
        p2: string;
        p3: string;
    };
    protected _bq(a: IWorksheetImage): void;
    protected _b6(a: WorksheetShape): {
        p0?: WorksheetShape;
    };
    protected _bn(a: Worksheet): void;
    protected _bo(a: Worksheet): void;
    private _bg;
    private static _at;
    _bl(a: FormattedText, b: IWorkbookFontDefaultsResolver): void;
    private _bp;
    private _br;
    private _bs;
    _bt(): void;
    private _bu;
    private _bj;
    private _bv;
    private _bw;
    private _bx;
    private _bz;
    private _by;
    private _bk;
    private _b0;
    private _b1;
    private _ah;
    private _v;
    private _b2;
    private _b3;
    private _b4;
    private _b5;
    protected abstract get _ai(): boolean;
    get _bd(): number;
    get _au(): Dictionary$2<StringBuilder, number>;
    get _av(): Dictionary$2<WorkbookStyle, number>;
    get _a3(): number;
    get _be(): number;
    get _a1(): IList$1<Sheet>;
    protected get _aj(): boolean;
    protected get__r(): CellContext;
    protected set__r(a: CellContext): void;
    get _r(): CellContext;
    set _r(a: CellContext);
    protected get__q(): CellDataContext;
    protected set__q(a: CellDataContext): void;
    get _q(): CellDataContext;
    set _q(a: CellDataContext);
    get _ag(): boolean;
}
/**
 * A collection of cells in a row.
 * <p class="body">
 * Cells in this collection are lazily created (they are only created and added to the collection when they are accessed).
 * If this collection is enumerated, it only enumerates the cells which were already accessed.
 * </p>
 * @see [[WorksheetCell]]
 * @see [[WorksheetRow.cells]]
 */
export declare class WorksheetCellCollection extends RowColumnCollectionBase$1<WorksheetCell> {
    static $t: Type;
    private _ai;
    private _ah;
    constructor(a: WorksheetRow);
    /**
     * @hidden
     */
    protected get__count(): number;
    /**
     * @hidden
     */
    _a(): LoadOnDemandTree$1<WorksheetCell>;
    /**
     * @hidden
     */
    _createValue(a: number): WorksheetCell;
    /**
     * @hidden
     */
    private __p;
    _p(): IEnumerator$1<WorksheetCell>;
    /**
     * @hidden
     */
    private __n;
    _n(a: number, b: number, c: boolean): IEnumerable$1<WorksheetCell>;
    /**
     * @hidden
     */
    _getItemIndex(a: WorksheetCell): number;
    /**
     * @hidden
     */
    _initializeItemIndex(a: WorksheetCell, b: number, c: boolean): void;
    /**
     * @hidden
     */
    _isItemStillValid(a: WorksheetCell): boolean;
    /**
     * Gets the maximum number of items allowed in this collection.
     */
    protected get_maxCount(): number;
    /**
     * Gets the maximum number of items allowed in this collection.
     */
    get maxCount(): number;
    /**
     * @hidden
     */
    _ab(): void;
    /**
     * @hidden
     */
    _ae(a: number): void;
    /**
     * @hidden
     */
    _af(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    _aj(): void;
    /**
     * Gets the cell at the specified column index in the owning row.
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all cells. It will only iterate the cells which have already
     * been used.  To create and iterate all cells in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum column count, and pass in each index to the collection's indexer.
     * </p>
     * The cell at the specified column index in the owning row.
     * @param index The zero-based column index of the cell to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
     * @throws [[InvalidOperationException]] If the row was removed from the worksheet.
     * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelColumnCount]]
     * or [[Workbook.maxExcel2007ColumnCount]], depending on the [[Workbook.currentFormat]].
     */
    item(a: number): WorksheetCell;
    /**
     * @hidden
     */
    _h(a: number): WorksheetCell;
}
/**
 * @hidden
 */
export declare class DependencyGraph_StronglyConnectedComponentSorter extends Base implements IComparer$1<RefBase> {
    static $t: Type;
    static readonly _a: DependencyGraph_StronglyConnectedComponentSorter;
    constructor();
    compare(a: RefBase, b: RefBase): number;
}
/**
 * @hidden
 */
export declare abstract class NamedCalcReferenceBase extends RefBase {
    static $t: Type;
    protected get__ao(): number;
    get _ao(): number;
    protected get__aj(): boolean;
    protected get__w(): WorksheetRow;
    get _w(): WorksheetRow;
}
/**
 * @hidden
 */
export declare class NamedCalcReference extends NamedCalcReferenceBase {
    static $t: Type;
    private _a4;
    private _a2;
    constructor(a: NamedReference);
    protected get__formula(): SingleTargetFormula;
    protected get__x(): boolean;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__f(): IExcelCalcReferenceCollectionEx;
    _az(a: SingleTargetFormula): void;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
    protected get__t(): Workbook;
    get _a3(): NamedReference;
}
/**
 * @hidden
 */
export declare class ExcelReferenceError extends RefBase {
    static $t: Type;
    static readonly _a2: ExcelReferenceError;
    constructor();
    _au(a: RefBase): void;
    protected get__ao(): number;
    get _ao(): number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__w(): WorksheetRow;
    get _w(): WorksheetRow;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
}
/**
 * @hidden
 */
export declare class WorksheetDataTableCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetDataTableCollection, c: WorksheetDataTable, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: WorksheetDataTableCollection;
    readonly a: WorksheetDataTable;
    readonly d: number;
    readonly c: WorksheetRegionAddress;
    readonly e: Nullable$1<WorksheetCellAddress>;
    readonly f: Nullable$1<WorksheetCellAddress>;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of [[WorksheetDataTable]] instances on a worksheet.
 */
export declare class WorksheetDataTableCollection extends Base implements ICollection$1<WorksheetDataTable> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _i;
    /**
     * @hidden
     */
    private static readonly _l;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static _a;
    private _h;
    /**
     * @hidden
     */
    _d: Worksheet;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    add(item: WorksheetDataTable): void;
    /**
     * Creates a new data table and adds it to the collection.
     * <p class="body">
     * The input cells specified must be different cell references and at least one must be non-null.
     * See the [[WorksheetDataTable]] overview for more information on data tables.
     * </p>
     * @param cellsInTable The region of cells in the data table.
     * @param columnInputCell The cell used as the column-input cell in the data table.
     * @param rowInputCell The cell used as the row-input cell in the data table.
     * @throws [[ArgumentNullException]] 'cellsInTable' is null.
     * @throws [[ArgumentException]] 'cellsInTable' is a region which does not belongs to the worksheet which owns this collection.
     * @throws [[ArgumentException]] 'columnInputCell' is not null but does not belong to the worksheet which owns this collection.
     * @throws [[ArgumentException]] 'rowInputCell' is not null but does not belong to the worksheet which owns this collection.
     * @throws [[InvalidOperationException]] Both 'columnInputCell' and 'rowInputCell' are null.
     * @throws [[InvalidOperationException]] 'columnInputCell' and 'rowInputCell' are the same cell.
     * @throws [[InvalidOperationException]] 'columnInputCell' or 'rowInputCell' are contained in the
     * 'cellsInTable' region.
     * @throws [[InvalidOperationException]] One or more of the interior cells of the 'cellsInTable' region (all cells except the left-most column
     * and top row) is an interior cell of another data table or is a cell in an array formula, and the entire
     * range of that other entity extends outside the interior cells of 'cellsInTable'.
     * @return The newly created data table.
     */
    add(cellsInTable: WorksheetRegion, columnInputCell: WorksheetCell, rowInputCell: WorksheetCell): WorksheetDataTable;
    /**
     * @hidden
     */
    _add$e(a: WorksheetDataTable): void;
    /**
     * @hidden
     */
    contains(item: WorksheetDataTable): boolean;
    /**
     * @hidden
     */
    copyTo(array: WorksheetDataTable[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    remove(item: WorksheetDataTable): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetDataTable>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetDataTable>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    _add1(a: WorksheetRegion, b: WorksheetCell, c: WorksheetCell): WorksheetDataTable;
    /**
     * Clears all data tables from the collection.
     * <p class="body">
     * Once a data table is removed from the collection, it can no longer be used.
     * </p>
     */
    clear(): void;
    /**
     * Removes the specified data table from the collection.
     * <p class="body">
     * Once a data table is removed from the collection, it can no longer be used.
     * </p>
     * @param dataTable The data table to remove from the collection.
     * @return True if the dataTable was successfully removed; False if the dataTable was not in the collection.
     */
    remove_1(dataTable: WorksheetDataTable): boolean;
    /**
     * Removes the data table at the specified index from the collection.
     * <p class="body">
     * Once a data table is removed from the collection, it can no longer be used.
     * </p>
     * @param index The zero-based index of the data table to remove from the collection.
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _o;
    /**
     * @hidden
     */
    private _m;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _s;
    /**
     * Gets the number of data tables in the collection.
     * The number of data tables in the collection.
     */
    get count(): number;
    /**
     * Gets the data table at the specified index in the collection.
     * The data table at the specified index.
     * @param index The zero-based index of the data table to get.
     */
    item(a: number): WorksheetDataTable;
}
/**
 * @hidden
 */
export declare class WorksheetColumnCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetColumnCollection_CollectionChangeContextData);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: WorksheetColumnCollection_CollectionChangeContextData;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of columns in a worksheet.
 * <p class="body">
 * Columns in this collection are lazily created (they are only created and added to the collection when they are accessed).
 * Therefore, if this collection is enumerated, it only enumerates the columns which were already accessed.
 * </p>
 * @see [[WorksheetColumn]]
 * @see [[Worksheet.columns]]
 */
export declare class WorksheetColumnCollection extends RowColumnCollectionBase$1<WorksheetColumn> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    private static _ag;
    private _ak;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    _createValue(a: number): WorksheetColumn;
    /**
     * @hidden
     */
    _p(): IEnumerator$1<WorksheetColumn>;
    /**
     * @hidden
     */
    _getItemIndex(a: WorksheetColumn): number;
    /**
     * @hidden
     */
    _n(a: number, b: number, c: boolean): IEnumerable$1<WorksheetColumn>;
    /**
     * @hidden
     */
    _initializeItemIndex(a: WorksheetColumn, b: number, c: boolean): void;
    /**
     * @hidden
     */
    _isItemStillValid(a: WorksheetColumn): boolean;
    /**
     * Gets the maximum number of items allowed in this collection.
     */
    protected get_maxCount(): number;
    /**
     * Gets the maximum number of items allowed in this collection.
     */
    get maxCount(): number;
    /**
     * @hidden
     */
    _ab(): void;
    /**
     * @hidden
     */
    _ae(a: number): void;
    /**
     * @hidden
     */
    _af(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    private static _ai;
    /**
     * @hidden
     */
    private static _ah;
    /**
     * @hidden
     */
    private _al;
    /**
     * @hidden
     */
    _aq(a: number, b: number, c: number, d: number, e?: boolean): {
        p2: number;
        p3: number;
    };
    /**
     * @hidden
     */
    _ar(a: number, b: number, c: number, d: number, e?: boolean): {
        p0?: number;
        p1?: number;
        p2: number;
        p3: number;
    };
    /**
     * @hidden
     */
    _as(a: HiddenColumnCollection): void;
    /**
     * Inserts one or more columns into the collection
     * <para class="note"><b>Note:</b> An equal number of columns will be removed (i.e. bumped) off the end of the collection.</para>
     * @param index the insertion point
     * @param count The number of columns to insert
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it would cause data to be shifted off the worksheet.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
     */
    insert(index: number, count?: number): void;
    /**
     * @hidden
     */
    private _am;
    /**
     * @hidden
     */
    _au(a: WorksheetColumn[], b: WorksheetColumnBlock[]): void;
    /**
     * @hidden
     */
    remove(item: WorksheetColumn): boolean;
    /**
     * Removes one or more columns from the collection
     * @param index the index of the first column to remove point
     * @param count The number of columns to remove
     * @throws [[InvalidOperationException]] If the operation is not allowed, e.g. if it the range intersects with a protected region.
     * @throws [[IndexOutOfRangeException]] If index is negative.
     * @throws [[ArgumentOutOfRangeException]] If count is less than 1.
     */
    remove(index: number, count?: number): void;
    /**
     * @hidden
     */
    _remove1(a: number, b?: number): void;
    /**
     * @hidden
     */
    private _aw;
    /**
     * @hidden
     */
    private _ax;
    /**
     * @hidden
     */
    private static _ay;
    /**
     * @hidden
     */
    private _az;
    /**
     * @hidden
     */
    private static _a0;
    /**
     * @hidden
     */
    private _a1;
    /**
     * Gets the column at the specified index.
     * <p class="note">
     * <b>Note:</b> Iterating the collection will not create all columns. It will only iterate the columns which have already
     * been used.  To create and iterate all columns in the worksheet use a For loop, iterating from 0 to one less than
     * the maximum column count, and pass in each index to the collection's indexer.
     * </p>
     * The column at the specified index.
     * @param index The zero-based index of the column to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero.
     * @throws [[InvalidOperationException]] 'index' is greater than or equal to [[Workbook.maxExcelColumnCount]]
     * or [[Workbook.maxExcel2007ColumnCount]], depending on the [[Workbook.currentFormat]].
     */
    item(a: number): WorksheetColumn;
}
/**
 * @hidden
 */
export declare class WorksheetRegion_HorizontalSorter extends Base implements IComparer$1<WorksheetRegion> {
    static $t: Type;
    static readonly _a: WorksheetRegion_HorizontalSorter;
    constructor();
    compare(a: WorksheetRegion, b: WorksheetRegion): number;
}
/**
 * @hidden
 */
export declare class DependencyGraph_EvaluationEnumerator extends Base implements IEnumerator$1<RefBase> {
    static $t: Type;
    private _b;
    private readonly _a;
    private _d;
    private _c;
    constructor(a: DependencyGraph);
    dispose(): void;
    get current(): RefBase;
    get currentObject(): any;
    moveNext(): boolean;
    reset(): void;
    _e(a: HashSet$1<RefBase>): void;
}
/**
 * Stack of [[ExcelCalcValue]] instances used to evaluate formulas.
 * <p class="body">
 * The number stack is used for evaluating formulas.  When formulas are compiled, the formula tokens are
 * placed in a collection in post-fix, or Reverse Polish Notation (RPN) format.  RPN format arranges the formula token list so each
 * sub-expressions's terms are placed before their operator, and sub-expressions are ordered to enforce correct operator precedence.
 * This format allows the formula evaluate method to loop through the formula token collection front to back pushing an operator's terms onto
 * the number stack until an operator is reached.  Each time an operator is reached, it's subexpression is computed and resulting value pushed
 * onto the number stack.  Once the end of the end of the formula collection is reached, the formulas calculated value is at the top of the
 * number stack.
 * </p>
 */
export declare class ExcelCalcNumberStack extends Base {
    static $t: Type;
    constructor(formulaOwner: IExcelCalcReference, formula: SingleTargetFormula);
    constructor();
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _e(a: ExcelCalcValue): ExcelCalcValue;
    /**
     * @hidden
     */
    _f(a: ExcelCalcValue): ExcelCalcValue;
    /**
     * @hidden
     */
    _g(a: ExcelCalcValue): ExcelCalcValue;
    private readonly _o;
    private _a;
    private _y;
    private _z;
    /**
     * @hidden
     */
    private _b;
    /**
     * @hidden
     */
    get _p(): SingleTargetFormula;
    private readonly _m;
    /**
     * @hidden
     */
    get _n(): TokenClass;
    private readonly _j;
    /**
     * @hidden
     */
    get _k(): IExcelCalcReference;
    /**
     * @hidden
     */
    _d(a: number): ExcelCalcValue;
    private _t;
    /**
     * @hidden
     */
    get _u(): boolean;
    /**
     * @hidden
     */
    set _u(a: boolean);
    /**
     * Gets the [[WorksheetCell]] instance whose formula is currently being solved.
     */
    get owningCell(): WorksheetCell;
    /**
     * @hidden
     */
    _ab(): void;
    /**
     * @hidden
     */
    _ac(a: ExcelCalcFunction, b: number): void;
    private _q;
    /**
     * @hidden
     */
    get _r(): Workbook;
    private _v;
    /**
     * @hidden
     */
    private static _l;
    /**
     * @hidden
     */
    static _c(a: any): ExcelCalcValue;
    /**
     * @hidden
     */
    static _ad(a: ExcelCalcValue): void;
    /**
     * Push a value onto number stack.
     * @param value Value to push onto the number stack
     */
    push(value: ExcelCalcValue): void;
    /**
     * Pop value off top of the number stack.
     * @return [[ExcelCalcValue]] that was at the top of the number stack.
     */
    pop(): ExcelCalcValue;
    /**
     * Return value off top of the number stack.
     * @return [[ExcelCalcValue]] that is at the top of the number stack.
     */
    peek(): ExcelCalcValue;
    /**
     * Remove all values from number stack.
     */
    clear(): void;
    /**
     * Clear elements off top of number stack until it contains given number of elements
     * @param elements Denotes the desired stack level
     */
    reset(elements: number): void;
    /**
     * Return the number of values on number stack
     * @return Number of stack values
     */
    count(): number;
    /**
     * @hidden
     */
    get _w(): CultureInfo;
}
/**
 * @hidden
 */
export declare class FormulaContext extends Base {
    static $t: Type;
    private readonly a;
    private readonly n;
    private readonly g;
    private readonly c;
    private readonly k;
    private readonly e;
    private readonly i;
    constructor(a: number, b: Workbook);
    constructor(a: number, b: Workbook, c: Formula);
    constructor(a: number, b: Formula, c: CellReferenceMode, d: CultureInfo);
    constructor(a: number, b: Workbook, c: Worksheet, d: WorksheetRow, e: number, f: Formula);
    constructor(a: number, b: Sheet, c: number, d: number, e: WorkbookFormat, f: Formula, g?: CultureInfo, h?: CellReferenceMode);
    constructor(a: number, b: Workbook, c: Worksheet, d: WorksheetRow, e: number, f: Formula, g: CultureInfo, h: CellReferenceMode, i: WorkbookFormat);
    constructor(a: number, ..._rest: any[]);
    get b(): CellReferenceMode;
    get o(): CultureInfo;
    get h(): WorkbookFormat;
    get d(): Formula;
    get l(): WorksheetCellAddress;
    get m(): WorksheetRow;
    get f(): Workbook;
    get j(): Worksheet;
}
/**
 * @hidden
 */
export declare class TempCellCalcReference extends RefBase {
    static $t: Type;
    private _a3;
    private _a9;
    private _a2;
    private _a4;
    private _a5;
    private static _ba;
    constructor(a: boolean, b: Sheet, c: WorksheetCellAddress);
    protected get__x(): boolean;
    protected get__ao(): number;
    get _ao(): number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    protected get__formula(): SingleTargetFormula;
    getHashCode(): number;
    _am(): IList$1<WorksheetRegion>;
    _ae(a: Worksheet, b: WorksheetRegionAddress): boolean;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__f(): IExcelCalcReferenceCollectionEx;
    protected get__w(): WorksheetRow;
    get _w(): WorksheetRow;
    _az(a: SingleTargetFormula): void;
    protected get__ak(): boolean;
    protected _a1(a: ExcelCalcValue): void;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
    protected get__t(): Workbook;
    protected get__u(): Worksheet;
    get _a6(): boolean;
    get _a7(): boolean;
    _a8: boolean;
    protected get__as(): number;
    protected get__r(): Sheet;
}
/**
 * @hidden
 */
export declare class CalcUtilities extends Base {
    static $t: Type;
    static i(a: WorksheetRegion, b: IExcelCalcReference): boolean;
    static c(a: any): ExcelCalcValue;
    static b(a: number): ExcelCalcErrorCode;
    static h(a: IExcelCalcReference): TokenClass;
    static e(a: string, b: WorksheetRow, c: number, d: Worksheet, e: Workbook): IExcelCalcReference;
    static f(a: string, b: WorksheetRow, c: number, d: Worksheet, e: Workbook, f: CellReferenceMode): IExcelCalcReference;
    static a(a: WorksheetRegion): ExcelCalcValue[][];
    static l(a: IExcelCalcReference): IList$1<WorksheetRegion>;
    static g(a: CellCalcReference, b: WorksheetRegion, c: ExcelCalcErrorValue): {
        ret: CellCalcReference;
        p2: ExcelCalcErrorValue;
    };
    static m(a: any, b: boolean): any;
    static j(a: WorksheetRegion, b: IExcelCalcReference): boolean;
    static d(a: ArrayProxy, b: CellCalcReference): ExcelCalcValue;
    static k(a: CellCalcReference, b: number, c: number, d: number, e: number): {
        ret: boolean;
        p3: number;
        p4: number;
    };
}
/**
 * @hidden
 */
export declare class DataValidationCalcReference extends CellCalcReferenceBase {
    static $t: Type;
    constructor(a: WorksheetRow, b: number, c: boolean);
    containsReference(a: IExcelCalcReference): boolean;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__f(): IExcelCalcReferenceCollectionEx;
    protected get__ak(): boolean;
    protected get__c(): ExcelCalcValue;
    _bc: boolean;
}
/**
 * @hidden
 */
export declare class FormulaEvaluator extends FormulaTokenVisitor {
    static $t: Type;
    private static a4;
    private a2;
    private a0;
    private a3;
    private a7;
    private bd;
    private az;
    private readonly a6;
    constructor();
    g(): void;
    p(a: AttrChooseToken): void;
    q(a: AttrIfToken): void;
    r(a: AttrSkipToken): void;
    v(a: BinaryOperatorToken): void;
    x(a: CellReferenceToken): void;
    aa(a: FunctionOperator): void;
    ab(a: IFunctionToken): void;
    ac(a: FunctionVOperator): void;
    aj(a: NameToken): void;
    am(a: OperandToken): void;
    ay(a: UnaryOperatorToken): void;
    private a8;
    private be;
    private bf;
    static a5(a: FormulaContext, b: IExcelCalcReference, c: ExcelCalcNumberStack): FormulaEvaluator;
    private a9;
    private bh;
    private bb;
    private bc;
    private a1;
    private ba;
    private bg;
    private bi;
    private bj;
}
/**
 * @hidden
 */
export declare abstract class FormulaTokenEvaluator$1<TStackItem> extends FormulaTokenVisitor$1<boolean> {
    static $t: Type;
    protected $tStackItem: Type;
    protected readonly bf: Stack$1<TStackItem>;
    constructor($tStackItem: Type);
    a1(): void;
    r(a: BinaryOperatorToken): boolean;
    t(a: CellReferenceToken): boolean;
    w(a: FunctionOperator): boolean;
    x(a: IFunctionToken): boolean;
    y(a: FunctionVOperator): boolean;
    ai(a: OperandToken): boolean;
    aj(a: ParenToken): boolean;
    al(a: Ref3DToken): boolean;
    am(a: ReferenceToken): boolean;
    aq(a: RefToken): boolean;
    au(a: UnaryOperatorToken): boolean;
    protected a4(a: IFunctionToken, b: string): TStackItem;
    a2(): EvaluationResult$1<TStackItem>;
    a3(a: boolean): EvaluationResult$1<TStackItem>;
    protected abstract a5(a: BinaryOperatorToken, b: TStackItem, c: TStackItem): TStackItem;
    protected abstract a6(a: IFunctionToken, b: TStackItem, c: TStackItem[]): TStackItem;
    protected abstract a7(a: OperandToken): TStackItem;
    protected abstract a8(a: ParenToken, b: TStackItem): TStackItem;
    protected abstract a9(a: UnaryOperatorToken, b: TStackItem): TStackItem;
    private ba;
    private bb;
    private bc;
    private bd;
    private be;
    get bg(): Stack$1<TStackItem>;
}
/**
 * @hidden
 */
export declare class FormulaEvaluator_ShouldSplitParameterHelper extends FormulaTokenEvaluator$1<number> {
    static $t: Type;
    private bl;
    private bk;
    private bi;
    private bh;
    private bn;
    private bm;
    constructor();
    a1(): void;
    bj(a: FormulaContext, b: number, c: number, d: boolean): boolean;
    protected a5(a: BinaryOperatorToken, b: number, c: number): number;
    protected a6(a: IFunctionToken, b: number, c: number[]): number;
    protected a7(a: OperandToken): number;
    protected a8(a: ParenToken, b: number): number;
    protected a9(a: UnaryOperatorToken, b: number): number;
    private bo;
}
/**
 * @hidden
 */
export declare abstract class SpecialFormulaToken extends FormulaToken {
    static $t: Type;
    constructor(a: TokenClass);
    protected get_n(): boolean;
    get n(): boolean;
}
/**
 * @hidden
 */
export declare class TokenReferenceResolver extends FormulaTokenEvaluator$1<FormulaToken> {
    static $t: Type;
    private static bi;
    private bl;
    private bh;
    private bm;
    constructor();
    protected a5(a: BinaryOperatorToken, b: FormulaToken, c: FormulaToken): FormulaToken;
    protected a6(a: IFunctionToken, b: FormulaToken, c: FormulaToken[]): FormulaToken;
    protected a7(a: OperandToken): FormulaToken;
    protected a8(a: ParenToken, b: FormulaToken): FormulaToken;
    protected a9(a: UnaryOperatorToken, b: FormulaToken): FormulaToken;
    protected get_a(): FormulaToken[];
    a1(): void;
    l(a: AttrChooseToken): boolean;
    m(a: AttrIfToken): boolean;
    n(a: AttrSkipToken): boolean;
    static bj(a: FormulaContext): TokenReferenceResolver;
    static bk(a: FormulaContext, b: FormulaToken[]): TokenReferenceResolver;
}
/**
 * @hidden
 */
export declare class TokenReferenceResolver_SkipTokenInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: AttrSkipToken, c: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: AttrSkipToken;
    readonly b: number;
}
/**
 * @hidden
 */
export declare class RefBase_DynamicReference extends RefBase {
    static $t: Type;
    private readonly _a2;
    constructor(a: RefBase);
    protected get__formula(): SingleTargetFormula;
    protected get__x(): boolean;
    protected get__ao(): number;
    get _ao(): number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    _v(): WorksheetRegion;
    _am(): IList$1<WorksheetRegion>;
    protected get_isEnumerable(): boolean;
    protected get__aj(): boolean;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__references(): IExcelCalcReferenceCollectionEx;
    protected get__l(): RefBase;
    _m(a: CalculationContext, b: boolean, c: ExcelCalcErrorValue): {
        ret: RefBase;
        p0?: CalculationContext;
        p2: ExcelCalcErrorValue;
    };
    _n(a: CellCalcReference, b: ExcelCalcErrorValue): {
        ret: RefBase;
        p1: ExcelCalcErrorValue;
    };
    protected get__w(): WorksheetRow;
    get _w(): WorksheetRow;
    protected get__as(): number;
    _az(a: SingleTargetFormula): void;
    _o(): RefBase;
    protected get_value(): ExcelCalcValue;
    protected set_value(a: ExcelCalcValue): void;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
    protected get__q(): WorksheetReference;
    protected get__t(): Workbook;
}
/**
 * @hidden
 */
export declare class NamedCalcReferenceUnconnected extends NamedCalcReferenceBase {
    static $t: Type;
    private _a2;
    constructor(a: NamedReferenceUnconnected);
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
}
/**
 * @hidden
 */
export declare class EmptyReferencesCollection extends Base implements IExcelCalcReferenceCollectionEx {
    static $t: Type;
    static readonly _a: EmptyReferencesCollection;
    constructor();
    getEnumeratorObject(): IEnumerator;
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<IExcelCalcReference>;
}
/**
 * @hidden
 */
export declare class DependencyGraph_FinishTimeSorter extends Base implements IComparer$1<RefBase> {
    static $t: Type;
    static readonly _a: DependencyGraph_FinishTimeSorter;
    constructor();
    compare(a: RefBase, b: RefBase): number;
}
/**
 * @hidden
 */
export declare class ArrayValueContext extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, c: number);
    constructor(a: number, b: WorksheetRow, c: number, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: WorksheetRow;
    readonly b: number;
    readonly c: number;
}
/**
 * @hidden
 */
export declare class ConditionalFormatCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: ConditionalFormatCollection, c: ConditionBase, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: number;
    readonly b: ConditionalFormatCollection;
    readonly c: ConditionBase;
    readonly a: WorksheetRegionAddress[];
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class ConditionalFormatCollection_PriorityChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: ConditionalFormatCollection, c: ConditionBase, d: number, e: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: number;
    readonly c: number;
    readonly b: ConditionBase;
    readonly a: ConditionalFormatCollection;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class ConditionalFormatCollection_ShiftChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: ConditionalFormatCollection, c: List$1<Tuple$2<ConditionBase, WorksheetRegionAddress[]>>, d: List$1<Tuple$3<ConditionBase, number, WorksheetRegionAddress[]>>, e: List$1<Tuple$3<ISupportFormulaShifts, any, string>>, f: List$1<ConditionBase>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly e: ConditionalFormatCollection;
    readonly c: Tuple$2<ConditionBase, WorksheetRegionAddress[]>[];
    readonly d: Tuple$3<ISupportFormulaShifts, any, string>[];
    readonly b: Tuple$3<ConditionBase, number, WorksheetRegionAddress[]>[];
    readonly a: ConditionBase[];
    f(): void;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Collection class for objects which derive from [[ConditionBase]].
 * <p class="body">
 * To enable a conditional format on a <see cref="WorksheetRegion">region</see>
 * of worksheet <see cref="WorksheetCell">cells</see>, add a [[ConditionBase]]-derived
 * instance to this collection.
 * </p>
 * <p class="body">
 * This collection exposes an Add method for each type of conditional format available.
 * </p>
 * <p class="body">
 * For example, to add a conditional format which is based on a value and a logical
 * operator, use the [[addOperatorCondition]]
 * method.
 * </p>
 * <p class="body">
 * The conditional formatting classes which derive from [[ConditionalFormatBase]]
 * expose a <see cref="ConditionalFormatBase.CellFormat">CellFormat</see> property, which
 * in turn exposes properties which control the visual attributes of cells which meet the
 * criteria defined by the condition. This format is applied to cells with a value which
 * passes the condition.
 * </p>
 * @see [[ConditionBase]]
 * @see [[addAverageCondition]]
 * @see [[addBlanksCondition]]
 * @see [[addColorScaleCondition]]
 * @see [[addDataBarCondition]]
 * @see [[addDateTimeCondition]]
 * @see [[addDuplicateCondition]]
 * @see [[addErrorsCondition]]
 * @see [[addFormulaCondition]]
 * @see [[addIconSetCondition]]
 * @see [[addNoBlanksCondition]]
 * @see [[addNoErrorsCondition]]
 * @see [[addOperatorCondition]]
 * @see [[addRankCondition]]
 * @see [[addTextCondition]]
 * @see [[addUniqueCondition]]
 */
export declare class ConditionalFormatCollection extends Base implements IEnumerable$1<ConditionBase> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ak;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    static readonly _aq: number;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    static _a: ChangeInfo[];
    private _aa;
    /**
     * @hidden
     */
    _y: Worksheet;
    /**
     * @hidden
     */
    readonly _aj: List$1<ConditionBase>;
    /**
     * @hidden
     */
    static _ag: List$1<Tuple$2<ConditionBase, WorksheetRegionAddress[]>>;
    /**
     * @hidden
     */
    static _ah: List$1<Tuple$3<ISupportFormulaShifts, any, string>>;
    /**
     * @hidden
     */
    static _af: List$1<Tuple$3<ConditionBase, number, WorksheetRegionAddress[]>>;
    /**
     * @hidden
     */
    static _ai: List$1<WorksheetRegionAddress>;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * Returns the total number of items in the collection.
     */
    get count(): number;
    /**
     * Indexer
     * @param index The zer-based index of an item
     * @return The item at the specified index
     * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
     */
    item(a: number): ConditionBase;
    /**
     * @hidden
     */
    get _x(): Workbook;
    /**
     * @hidden
     */
    get _z(): Worksheet;
    /**
     * @hidden
     */
    _as(a: ConditionBase, b?: boolean): void;
    /**
     * @hidden
     */
    private _at;
    /**
     * Adds a new [[OperatorConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param conditionOperator A [[FormatConditionOperator]] value which defines the initial value of the [[OperatorConditionalFormat.operator]] property. This parameter is optional and defaults to <i>Equal</i>.
     * @return The resulting [[OperatorConditionalFormat]] instance.
     * @see [[OperatorConditionalFormat]]
     */
    addOperatorCondition(regionAddress: string, conditionOperator?: FormatConditionOperator): OperatorConditionalFormat;
    /**
     * Adds a new [[FormulaConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param formula The formula which is used to determine whether a cell value meets the condition criteria.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     * @return The resulting [[FormulaConditionalFormat]] instance.
     * @see [[FormulaConditionalFormat]]
     * @see [[FormulaConditionalFormat.formula]]
     * @see [[FormulaConditionalFormat.setFormula]]
     */
    addFormulaCondition(regionAddress: string, formula: string, cellReferenceMode?: CellReferenceMode): FormulaConditionalFormat;
    /**
     * @hidden
     */
    _addFormulaCondition$i(a: string, b: string, c?: Nullable$1<CellReferenceMode>): FormulaConditionalFormat;
    /**
     * Adds a new [[RankConditionalFormat]] instance to this collection.
     * <p class="body">
     * A <i>RankConditionalFormat</i> can be used, for example, to format the "top ten" values in a given cell range.
     * </p>
     * <p class="body">
     * To change the number of top or bottom values, use the [[RankConditionalFormat.rank]] property.
     * </p>
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param topBottom A [[FormatConditionTopBottom]] value which determines whether the top or bottom of the ranking is evaluated. This parameter is optional and defaults to <i>Top</i>.
     * @param rank The numeric, percentage, or percentile ranking. This parameter is optional and defaults to <i>10</i>.
     * @return The resulting [[RankConditionalFormat]] instance.
     * @see [[RankConditionalFormat]]
     */
    addRankCondition(regionAddress: string, topBottom?: FormatConditionTopBottom, rank?: number): RankConditionalFormat;
    /**
     * Adds a new [[AverageConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param aboveBelow A [[FormatConditionAboveBelow]] value which defines the initial value of the [[AverageConditionalFormat.aboveBelow]] property. This parameter is optional and defaults to <i>AboveAverage</i>.
     * @return The resulting [[AverageConditionalFormat]].
     * @see [[AverageConditionalFormat]]
     */
    addAverageCondition(regionAddress: string, aboveBelow?: FormatConditionAboveBelow): AverageConditionalFormat;
    /**
     * Adds a new [[UniqueConditionalFormat]] instance to this collection,
     * configured as a unique value condition.
     * <p class="body">
     * Use this method to add a condition which evaluates to true only for cell values which
     * are unique across the associated range.
     * </p>
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @return The resulting [[UniqueConditionalFormat]] instance.
     * @see [[UniqueConditionalFormat]]
     * @see [[addDuplicateCondition]]
     */
    addUniqueCondition(regionAddress: string): UniqueConditionalFormat;
    /**
     * Adds a new [[DuplicateConditionalFormat]] instance to this collection,
     * configured as a duplicate value condition.
     * <p class="body">
     * Use this method to add a condition which evaluates to true only for cell values which
     * are non-unique across the associated range.
     * </p>
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @return The resulting [[DuplicateConditionalFormat]] instance.
     * @see [[DuplicateConditionalFormat]]
     * @see [[addUniqueCondition]]
     */
    addDuplicateCondition(regionAddress: string): DuplicateConditionalFormat;
    /**
     * Adds a new [[DateTimeConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param dateOperator A [[FormatConditionTimePeriod]] which defines the time period against which cell date values are evaluated. This parameter is optional and defaults to <i>Today</i>.
     * @return The resulting [[DateTimeConditionalFormat]] instance.
     * @see [[DateTimeConditionalFormat]]
     */
    addDateTimeCondition(regionAddress: string, dateOperator?: FormatConditionTimePeriod): DateTimeConditionalFormat;
    /**
     * Adds a new [[TextOperatorConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param text A string which determines the string against which cell text values are evaluated. This parameter is optional and defaults to <i>null</i>.
     * @param textOperator A [[FormatConditionTextOperator]] value which determines the manner in which cell values are compared to the 'text' value. This parameter is optional and defaults to <i>BeginsWith</i>.
     * @return The resulting [[TextOperatorConditionalFormat]] instance.
     * @see [[TextOperatorConditionalFormat]]
     */
    addTextCondition(regionAddress: string, text?: string, textOperator?: FormatConditionTextOperator): TextOperatorConditionalFormat;
    /**
     * Adds a new [[BlanksConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @return The resulting [[BlanksConditionalFormat]] instance.
     * @see [[BlanksConditionalFormat]]
     * @see [[addNoBlanksCondition]]
     */
    addBlanksCondition(regionAddress: string): BlanksConditionalFormat;
    /**
     * Adds a new [[NoBlanksConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @return The resulting [[NoBlanksConditionalFormat]] instance.
     * @see [[NoBlanksConditionalFormat]]
     * @see [[addBlanksCondition]]
     */
    addNoBlanksCondition(regionAddress: string): NoBlanksConditionalFormat;
    /**
     * Adds a new [[ErrorsConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @return The resulting [[ErrorsConditionalFormat]] instance.
     * @see [[ErrorsConditionalFormat]]
     * @see [[addNoErrorsCondition]]
     */
    addErrorsCondition(regionAddress: string): ErrorsConditionalFormat;
    /**
     * Adds a new [[NoErrorsConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @return The resulting [[NoErrorsConditionalFormat]] instance.
     * @see [[ErrorsConditionalFormat]]
     * @see [[addErrorsCondition]]
     */
    addNoErrorsCondition(regionAddress: string): NoErrorsConditionalFormat;
    /**
     * Adds a new [[ColorScaleConditionalFormat]] instance to this collection.
     * <p class="body">
     * Note that when <i>TwoColor</i> is specified as the value of the 'colorScaleType'
     * parameter, the [[ColorScaleConditionalFormat.midpointThreshold]] property is not applicable;
     * attempting to set properties on the object returned from that property causes an exception to be thrown.
     * </p>
     * <p class="body">
     * The [[ColorScaleConditionalFormat.minimumThreshold]] and [[ColorScaleConditionalFormat.maximumThreshold]]
     * properties can be used to customize the coloring and threshold boundaries for the minimum and maximum points of the associated
     * range.
     * </p>
     * <p class="body">
     * For a 3-color scale, the [[ColorScaleConditionalFormat.midpointThreshold]] can also
     * be used to customize the midpoint threshold boundary.
     * </p>
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param colorScaleType A [[ColorScaleType]] value which determines whether to add a 2-color or 3-color scale.
     * @return The resulting [[ColorScaleConditionalFormat]] instance.
     * @see [[ColorScaleConditionalFormat]]
     * @see [[ColorScaleCriterion]]
     */
    addColorScaleCondition(regionAddress: string, colorScaleType: ColorScaleType): ColorScaleConditionalFormat;
    /**
     * Adds a new [[IconSetConditionalFormat]] instance to this collection.
     * <p class="body">
     * Each constant in the [[FormatConditionIconSet]] enumeration contains either
     * 3, 4, or 5 in its name. This number identifies the number of thresholds supported by
     * the condition.
     * </p>
     * <p class="body">
     * A three-threshold condition supports thresholds of 33%, 67%, and 100%.
     * </p>
     * <p class="body">
     * A four-threshold condition supports thresholds of 25%, 50%, 75%, and 100%.
     * </p>
     * <p class="body">
     * A five-threshold condition supports thresholds of 20%, 40%, 60%, 80%, and 100%.
     * </p>
     * <p class="body">
     * A [[ColorScaleCriterion]] object for each threshold, is returned
     * from the [[IconSetConditionalFormat.iconCriteria]]
     * collection.
     * </p>
     * <p class="body">
     * These objects provide the ability to customize the values for the corresponding
     * threshold. For example, the icon that is displayed for a given index can be
     * overridden using the [[IconCriterion.icon]] property.
     * </p>
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @param iconSet A [[FormatConditionIconSet]] value which identifies the icon set to use. This parameter is optional and defaults to <i>IconSet3TrafficLights1</i>.
     * @return The resulting [[IconSetConditionalFormat]] instance.
     * @see [[IconSetConditionalFormat]]
     * @see [[IconSetConditionalFormat.iconCriteria]]
     * @see [[IconCriterion]]
     */
    addIconSetCondition(regionAddress: string, iconSet?: FormatConditionIconSet): IconSetConditionalFormat;
    /**
     * Adds a new [[DataBarConditionalFormat]] instance to this collection.
     * @param regionAddress A string identifying the <see cref="WorksheetRegion">region</see> to which this conditional format applies.
     * @return The resulting [[DataBarConditionalFormat]] instance.
     */
    addDataBarCondition(regionAddress: string): DataBarConditionalFormat;
    /**
     * Removes all items from the collection.
     */
    clear(): void;
    /**
     * Returns true if the collection contains the condition
     * @param condition The condition
     */
    contains(condition: ConditionBase): boolean;
    /**
     * @hidden
     */
    private static _e;
    /**
     * @hidden
     */
    private static _f;
    /**
     * @hidden
     */
    private static _g;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _ar;
    /**
     * @hidden
     */
    private _a3;
    [Symbol.iterator](): EnumeratorWrapper<ConditionBase>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<ConditionBase>;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
    /**
     * @hidden
     */
    _av(a: List$1<ConditionBase>, b: number, c: number): void;
    /**
     * @hidden
     */
    _ac(a: number, b: number): boolean;
    /**
     * Gets the index of the item in the collection
     * @param condition
     * @return The index or -1 if the item is not in the collection
     */
    indexOf(condition: ConditionBase): number;
    /**
     * @hidden
     */
    _ax(a: number, b: ConditionBase): void;
    /**
     * @hidden
     */
    _ay(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _az(a: WorksheetRow, b: number): void;
    /**
     * @hidden
     */
    _a0(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    _ad(a: List$1<ConditionBase>, b: number, c: number, d: boolean): boolean;
    /**
     * @hidden
     */
    _a1(a: WorksheetMergedCellsRegion): void;
    /**
     * @hidden
     */
    _a2(a: CellShiftOperation, b: ICellShiftOperationOverride): void;
    /**
     * Removes an item from the collection
     * @param condition
     * @return true is the item was removed or false if the item wasn't in the collection
     */
    remove(condition: ConditionBase): boolean;
    /**
     * Removes an item from the collection at a specifoed index
     * @param index The zero based index in the collection
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _a5(a: number, b: ConditionBase): void;
    /**
     * @hidden
     */
    _a6(a?: boolean): void;
    /**
     * @hidden
     */
    _a7(): void;
    /**
     * @hidden
     */
    private static _a8;
    /**
     * @hidden
     */
    private static _ba;
    /**
     * @hidden
     */
    private static _a9;
    /**
     * @hidden
     */
    private _c;
    /**
     * @hidden
     */
    private _d;
    /**
     * @hidden
     */
    _aw(a: IList$1<ConditionBase>): void;
}
/**
 * @hidden
 */
export declare class FormulaStringGenerator extends FormulaTokenEvaluator$1<string> {
    static $t: Type;
    private static bi;
    private bq;
    private bm;
    private bh;
    private bo;
    private bp;
    constructor();
    protected a4(a: IFunctionToken, b: string): string;
    a2(): EvaluationResult$1<string>;
    protected a5(a: BinaryOperatorToken, b: string, c: string): string;
    protected a6(a: IFunctionToken, b: string, c: string[]): string;
    protected a7(a: OperandToken): string;
    protected a8(a: ParenToken, b: string): string;
    protected a9(a: UnaryOperatorToken, b: string): string;
    a1(): void;
    o(a: AttrSpaceToken): boolean;
    v(a: ExpToken): boolean;
    at(a: TblToken): boolean;
    protected bs(a: FormulaToken): string;
    private bt;
    static bj(a: FormulaContext): FormulaStringGenerator;
    static bk(a: FormulaContext, b: string[]): FormulaStringGenerator;
    static bl(a: FormulaContext, b: boolean): FormulaStringGenerator;
    protected static bu(a: FormulaStringGenerator, b: FormulaContext, c: boolean): void;
    private bv;
    protected get_bn(): boolean;
    protected get bn(): boolean;
}
/**
 * @hidden
 */
export declare abstract class AttrTokenBase extends SpecialFormulaToken {
    static $t: Type;
    constructor();
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    static o(a: IBiffRecordStream, b: number[], c: number): {
        ret: AttrTokenBase;
        p1?: number[];
        p2?: number;
    };
    abstract get p(): AttrTokenBase_AttrType;
    protected get_q(): boolean;
    get q(): boolean;
}
/**
 * @hidden
 */
export declare class AttrSpaceToken extends AttrTokenBase {
    static $t: Type;
    private static w;
    private u;
    private s;
    constructor(a: number);
    constructor(a: number, b: number, c: WhitespaceType);
    constructor(a: number, ..._rest: any[]);
    static r(a: number, b: WhitespaceType): AttrSpaceToken;
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_p(): AttrTokenBase_AttrType;
    get p(): AttrTokenBase_AttrType;
    get v(): number;
    set v(a: number);
    get t(): WhitespaceType;
    set t(a: WhitespaceType);
}
/**
 * @hidden
 */
export declare class FormulaParser extends Base {
    static $t: Type;
    static b(a: string, b: CultureInfo): ErrorValue;
    static d(a: string, b: CellReferenceMode, c: FormulaType, d: WorkbookFormat, e: CultureInfo, f: List$1<WorkbookReferenceBase>, g: FormulaParseException): {
        ret: Formula;
        p6: FormulaParseException;
    };
    static e(a: string, b: CellReferenceMode, c: FormulaType, d: WorkbookFormat, e: CultureInfo, f: List$1<WorkbookReferenceBase>, g: number, h: number, i: FormulaParseException): {
        ret: Formula;
        p8: FormulaParseException;
    };
    static f(a: string, b: FormulaType, c: FormulaContext, d: List$1<WorkbookReferenceBase>, e: FormulaParseException): {
        ret: Formula;
        p4: FormulaParseException;
    };
    private static m;
    private cx;
    cz: string;
    private readonly cb;
    readonly cc: List$1<FormulaParser_FormulaTokenInfo>;
    private bz;
    i: FormulaType;
    b4: string;
    private r;
    cs: number;
    private af;
    private g;
    private cj;
    private readonly p;
    private ca;
    private readonly d0;
    private readonly cg;
    private readonly ce;
    private readonly cf;
    private readonly cd;
    private readonly d1;
    private x;
    private readonly b6;
    j: FormulaContext;
    private ch;
    private ci;
    constructor();
    private ef;
    private c;
    private av;
    private a5;
    private be;
    private ag;
    private ah;
    private ai;
    private ct;
    private cu;
    private aj;
    private ak;
    private al;
    static am(a: string, b: number, c: WorkbookFormat, d: CultureInfo, e: number, f: boolean, g: number): {
        ret: boolean;
        p4?: number;
        p5?: boolean;
        p6: number;
    };
    private static an;
    private ao;
    static ap(a: string, b: number, c: WorkbookFormat, d: number, e: boolean, f: number): {
        ret: boolean;
        p3?: number;
        p4?: boolean;
        p5: number;
    };
    private aq;
    private cv;
    private eg;
    private at;
    private au;
    private c6;
    private c7;
    private c8;
    private c9;
    private aw;
    private ax;
    private s;
    private da;
    private ay;
    private az;
    private a0;
    private a1;
    private db;
    static dc(a: string, b: boolean, c: number): {
        ret: string;
        p2?: number;
    };
    private static b7;
    private static b8;
    private static b9;
    static ac(a: string, b: boolean): boolean;
    private eh;
    private a2;
    private ar;
    private dd;
    private as;
    private static z;
    static ei(a: string, b: string, c: string, d?: string): {
        p1: string;
        p2: string;
    };
    private a3;
    private a4;
    private cr;
    private a6;
    private a7;
    private a8;
    static a9(a: string, b: number, c: WorkbookFormat, d: number, e: boolean, f: number): {
        ret: boolean;
        p3?: number;
        p4?: boolean;
        p5: number;
    };
    private static ba;
    private bb;
    static bc(a: string, b: number, c: WorkbookFormat, d: number, e: boolean, f: number): {
        ret: boolean;
        p3?: number;
        p4?: boolean;
        p5: number;
    };
    private bd;
    private cw;
    private bf;
    private bg;
    private bh;
    private bi;
    private de;
    private bj;
    private df;
    private t;
    private static u;
    private static ae;
    private bk;
    private bl;
    private bm;
    static bu(a: string, b: boolean): {
        ret: boolean;
        p1: boolean;
    };
    private d2;
    private d3;
    private d4;
    private d5;
    private d6;
    private ed;
    private d7;
    private d9;
    d8(a: FormulaToken, b: number, c: number, d: FormulaParser_TextSpan, e: WhitespaceType): void;
    private ee;
    private ea;
    private eb;
    private ec;
    private q;
    private static k;
    static l(a: Workbook, b: Worksheet, c: WorksheetRow, d: number, e: CultureInfo, f: CellReferenceMode, g: FormulaType): FormulaContext;
    private v;
    private a;
    private static w;
    static c0(a: StructuredTableReferenceKeywordType): string;
    static bw(a: string): string;
    static bx(a: CultureInfo): string;
    static by(a: string): string;
    private y;
    static aa(a: string): boolean;
    static ab(a: string, b: WorkbookFormat, c: CultureInfo): boolean;
    private ad;
    ej(a: FormulaParser_PositionInfo): void;
    o(): FormulaParser_PositionInfo;
    static bo(a: string): boolean;
    bp(a: string): boolean;
    bq(a: string): boolean;
    private br;
    bs(a: string): boolean;
    private bt;
    private static get n();
    private get ck();
    private get cn();
    get h(): FormulaParseException;
    set h(a: FormulaParseException);
    private get bn();
    private dj;
    private dn;
    private dl;
    private dq;
    private ds;
    private du;
    private dw;
    private dy;
    private get dk();
    private get dp();
    private get dm();
    private get dr();
    private get dt();
    private get dv();
    private get dx();
    private get dz();
}
/**
 * Represents the aggregated conditioal format for a specific cell. It is returned via the <see cref="Worksheet.GetCellConditionalFormat(int, int)">Worksheet.GetCellConditionalFormat</see> and the <see cref="WorksheetRow.GetCellConditionalFormat">WorksheetRow.GetCellConditionalFormat</see> methods.
 */
export declare class CellConditionalFormat extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static _a: CellConditionalFormat;
    private _g;
    private _b;
    private _d;
    private _i;
    constructor(a: number);
    constructor(a: number, b: WorksheetCellFormatData, c: CellDataBarInfo, d: CellIconInfo);
    constructor(a: number, ..._rest: any[]);
    /**
     * Returns a cell format that represents the aggregated format for all conditional formats that apply to the cell (read-only).
     */
    get cellFormat(): IWorksheetCellFormat;
    /**
     * @hidden
     */
    get _h(): WorksheetCellFormatData;
    /**
     * Returns a data bar info if applicable, otherwise null (read-only).
     */
    get dataBarInfo(): CellDataBarInfo;
    /**
     * Returns an icon info if applicable, otherwise null (read-only).
     */
    get iconInfo(): CellIconInfo;
    /**
     * Returns whether this cell has conditional formatting applied (read-only)
     */
    get hasConditionFormatting(): boolean;
}
/**
 * Exposes the information necessary for drawing a data bar for a specific cell.
 * @see [[CellConditionalFormat]]
 */
export declare class CellDataBarInfo extends Base {
    static $t: Type;
    private _o;
    private _p;
    private _q;
    private _k;
    private _l;
    private _a;
    private _c;
    private _e;
    private _g;
    private _f;
    constructor(a: number, b: number, c: number, d: boolean, e: boolean, f: DataBarDirection, g: DataBarFillType, h: WorkbookColorInfo, i: WorkbookColorInfo, j: WorkbookColorInfo);
    /**
     * The color to use to draw the axis line or null if no axis line is to be drawn (read-only).
     * @see [[axisPosition]]
     */
    get axisColor(): WorkbookColorInfo;
    /**
     * Specifies the position, as a percentage of the cell width, where the axis ahould be rendered (read-only)
     * a percentage from 0 to 100
     * <para class="note"><b>Note:</b> if [[axisColor]] returns null then this property can be ignored.</para>
     * @see [[axisColor]]
     */
    get axisPosition(): number;
    /**
     * The color to use to draw the border around the data bar or null if no border is to be drawn (read-only).
     */
    get barBorder(): WorkbookColorInfo;
    /**
     * The color to use to draw the data bar (read-only).
     * @see [[barFillType]]
     * @see [[barPositionFrom]]
     * @see [[barPositionTo]]
     */
    get barColor(): WorkbookColorInfo;
    /**
     * Specifies whether the data bar should be filled with a sold color or a gradient (read-only).
     * @see [[barColor]]
     */
    get barFillType(): DataBarFillType;
    /**
     * Species the position, as a percentage of the cell width, where the data bar should begin (read-only).
     * @see [[barPositionTo]]
     * @see [[direction]]
     */
    get barPositionFrom(): number;
    /**
     * Species the position, as a percentage of the cell width, where the data bar should end (read-only).
     * @see [[barPositionFrom]]
     * @see [[direction]]
     */
    get barPositionTo(): number;
    /**
     * Specifies the direction of the bata bar (read-only).
     * @see [[barPositionFrom]]
     * @see [[barPositionTo]]
     */
    get direction(): DataBarDirection;
    /**
     * Returns true if the cell value is negative (read-only).
     */
    get isNegative(): boolean;
    /**
     * Returns whether the cell value is to be shown along with the data bar (read-only).
     */
    get showValue(): boolean;
}
/**
 * @hidden
 */
export declare class ConditionMatchResult extends Base {
    static $t: Type;
    static readonly e: ConditionMatchResult;
    static readonly f: ConditionMatchResult;
    readonly i: boolean;
    private g;
    private a;
    private c;
    constructor(a: number, b: WorkbookColorInfo);
    constructor(a: number, b: CellDataBarInfo);
    constructor(a: number, b: CellIconInfo);
    constructor(a: number, b: boolean);
    constructor(a: number, ..._rest: any[]);
    get h(): WorkbookColorInfo;
    get b(): CellDataBarInfo;
    get d(): CellIconInfo;
}
/**
 * Abstract base class for classes which control
 * the visual attributes of a [[WorksheetCell]],
 * based on whether the cell's value meets a logical condition.
 */
export declare abstract class ConditionalFormatBase extends ConditionBase implements IWorksheetCellFormatProxyOwner {
    static $t: Type;
    private _bt;
    private _bv;
    private _by;
    constructor();
    constructor(regions: IList$1<WorksheetRegion>, conditionType: FormatConditionType);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _bb(): void;
    /**
     * @hidden
     */
    _bf(): void;
    /**
     * Returns an [[IWorksheetCellFormat]] interface implementation
     * which represents the format for cells which meet the criteria associated
     * with this condition.
     * <p class="body">
     * The IWorksheetCellFormat implementation defines the visual attributes which
     * are applied to cells whose value meets the associated condition.
     * </p>
     */
    get cellFormat(): IWorksheetCellFormat;
    /**
     * @hidden
     */
    get _bz(): number;
    /**
     * @hidden
     */
    set _bz(a: number);
    /**
     * @hidden
     */
    get _bw(): WorksheetCellFormatData;
    /**
     * @hidden
     */
    set _bw(a: WorksheetCellFormatData);
    /**
     * @hidden
     */
    get _bx(): boolean;
    /**
     * @hidden
     */
    _a5(): void;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    getAdjacentFormatForBorderResolution(sender: WorksheetCellFormatProxy, borderValue: CellFormatValue): WorksheetCellFormatData;
    /**
     * @hidden
     */
    onCellFormatValueChanged(sender: WorksheetCellFormatProxy, values: CellFormatValue, options: CellFormatValueChangedOptions): void;
    /**
     * @hidden
     */
    onCellFormatValueChanging(sender: WorksheetCellFormatProxy, values: CellFormatValue): void;
    /**
     * @hidden
     */
    verifyFormatOptions(sender: WorksheetCellFormatProxy, formatOptions: WorksheetCellFormatOptions): void;
}
/**
 * @hidden
 */
export declare class WorksheetMergedRegionOwnedCellFormatProxy extends WorksheetCellFormatProxy {
    static $t: Type;
    private static readonly _br;
    constructor(a: GenericCachedCollectionEx$1<WorksheetCellFormatData>, b: IWorksheetCellFormatProxyOwner);
    protected get__l(): ChangeInfo[];
    protected get _l(): ChangeInfo[];
    protected get__q(): ExcelChangeAction;
    get _q(): ExcelChangeAction;
    protected get__v(): Worksheet;
    get _v(): Worksheet;
}
/**
 * @hidden
 */
export declare class ValueFormatter_GetTextWidthHelper extends Base {
    static $t: Type;
    private readonly b;
    private readonly a;
    private c;
    constructor(a: TextMetricsProviderBase, b: WorksheetCellFormatData);
    f(a: string): number;
    e(a: string): number;
    get d(): boolean;
}
/**
 * @hidden
 */
export declare class ValueFormatter_FormatValueState extends Base {
    static $t: Type;
    private g;
    private m;
    private b;
    private aa;
    private o;
    private q;
    private s;
    private ac;
    private u;
    private d;
    private ae;
    private w;
    private ag;
    private i;
    private ai;
    private k;
    private y;
    private ak;
    private a;
    readonly f: boolean;
    constructor(a: ValueFormatter_FormatSection, b: number, c: boolean);
    am(): void;
    ao(): void;
    an(): void;
    ap(): void;
    aq(): void;
    private static ar;
    as(): void;
    private at;
    get h(): number;
    get n(): number;
    set n(a: number);
    get c(): ValueFormatter_NumberSection;
    get ab(): Nullable$1<Date>;
    get p(): number;
    set p(a: number);
    get r(): number;
    set r(a: number);
    get t(): number;
    get ad(): string;
    get v(): number;
    get e(): boolean;
    set e(a: boolean);
    get af(): string;
    get x(): number;
    get ah(): string;
    get l(): number;
    get j(): number;
    get aj(): string;
    get z(): number;
    get al(): string;
}
/**
 * @hidden
 */
export declare class WorksheetRowCollection_RowsLoadOnDemandTree extends RowColumnLoadOnDemandTree$1<WorksheetRow> {
    static $t: Type;
    private _ay;
    constructor(a: WorksheetRowCollection);
    _f(a: number, b: IBinaryTreeNodeOwner$1<WorksheetRow>): LoadOnDemandTree_BinaryTreeNode$1<WorksheetRow>;
    _k(a: LoadOnDemandTree_ChangeHistoryItem$1<WorksheetRow>, b: number, c: number): LoadOnDemandTree_ChangeAdjustmentPoint$1<WorksheetRow>;
    protected _l(a: number, b: number): LoadOnDemandTree_ChangeHistoryItem$1<WorksheetRow>;
    protected _m(a: number, b: number): LoadOnDemandTree_ChangeHistoryItem$1<WorksheetRow>;
    get _a1(): number;
    private _a3;
    _a2(a: number, b: number, c: number, d: boolean): number;
    _a6(a: number, b: number, c: number, d: number, e: boolean): {
        p2: number;
        p3: number;
    };
    _a4(a: number, b: number, c: number, d: number, e: number, f: number, g: boolean): {
        p2: number;
        p3: number;
    };
    private _a5;
    private static _az;
    protected _a8(a: number, b: number, c: number, d: number, e: number, f: number, g: number, h: boolean): {
        p0?: number;
        p1?: number;
        p2: number;
        p3: number;
    };
    private _a9;
    _a7(a: number, b: number, c: number, d: number, e: boolean): {
        p0?: number;
        p1?: number;
        p2: number;
        p3: number;
    };
    private static _a0;
    _ba(): void;
    private _aw;
    private _ax;
}
/**
 * @hidden
 */
export declare class WorksheetRowCollection_RowBinaryTreeNode extends RowColumnBinaryTreeNode$1<WorksheetRow> {
    static $t: Type;
    constructor(a: number, b: IBinaryTreeNodeOwner$1<WorksheetRow>, c: LoadOnDemandTree$1<WorksheetRow>);
    p(a: WorksheetRow, b: number): number;
}
/**
 * @hidden
 */
export declare class WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeAdjustmentPoint extends LoadOnDemandTree_ChangeAdjustmentPoint$1<WorksheetRow> {
    static $t: Type;
    private ac;
    private ad;
    private w;
    private x;
    private v;
    constructor(a: WorksheetRowCollection_RowsLoadOnDemandTree, b: LoadOnDemandTree_ChangeHistoryItem$1<WorksheetRow>, c: number, d: number);
    protected t(): void;
    ae(a: number, b: number, c: boolean): number;
    y(a: number, b: number, c: number, d: boolean): {
        ret: number;
        p0?: number;
    };
    z(a: number, b: number, c: number, d: boolean): number;
    aa(a: number, b: number, c: boolean): number;
    private af;
    private ab;
    private ag;
}
/**
 * @hidden
 */
export declare class WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemAdd extends LoadOnDemandTree_ChangeHistoryItemAdd$1<WorksheetRow> {
    static $t: Type;
    private k;
    private l;
    constructor(a: number, b: number);
    d(a: number, b: number, c: number, d: boolean): number;
    e(a: number, b: number, c: boolean): number;
    private m;
    n(): void;
}
/**
 * @hidden
 */
export declare class WorksheetPaneSelection extends Base {
    static $t: Type;
    private e;
    constructor();
    b: WorksheetCellAddress;
    f: number;
    a: PaneLocation;
    get d(): IList$1<WorksheetRegionAddress>;
    static c(a?: PaneLocation): WorksheetPaneSelection;
    g(a: WorksheetPaneSelection): void;
}
/**
 * Represents the window options which are saved with the workbook.
 * <p class="body">
 * The properties explicitly defined on this class and not inherited from the base class,
 * [[WindowOptions]], are options that can be saved with a workbook, but
 * not with a custom view.
 * </p>
 * @see [[Workbook.windowOptions]]
 * @see [[CustomViewWindowOptions]]
 */
export declare class WorkbookWindowOptions extends WindowOptions {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _al;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _aq;
    /**
     * @hidden
     */
    private static readonly _ag;
    private _at;
    private _am;
    private _aj;
    private _ar;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    protected get__o(): boolean;
    /**
     * @hidden
     */
    get _o(): boolean;
    /**
     * @hidden
     */
    _d(a: Sheet): DisplayOptionsBase;
    /**
     * Resets the window options to their default settings.
     * <p class="body">
     * The defaults used for each setting are the same defaults with which Microsoft Excel creates a blank workbook.
     * </p>
     */
    reset(): void;
    /**
     * @hidden
     */
    _ad(): void;
    /**
     * @hidden
     */
    private static _ai;
    /**
     * @hidden
     */
    private static _ah;
    /**
     * Gets or sets the bounds of the workbook's MDI child window in twips (1/20th of a point).
     * <p class="note">
     * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
     * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
     * a newly created CustomView will not be initialized with the setting from this property.
     * </p>
     * The bounds of the workbook's MDI child window in twips (1/20th of a point).
     * @throws [[ArgumentException]] The width or height of the value assigned are less than zero.
     */
    get boundsInTwips(): IgRect;
    set boundsInTwips(a: IgRect);
    /**
     * @hidden
     */
    get _boundsInTwips$i(): Rect;
    /**
     * @hidden
     */
    set _boundsInTwips$i(a: Rect);
    /**
     * Gets or sets the index of the first visible tab in the worksheet tab bar.
     * <p class="body">
     * If the worksheet tab bar is not visible, this value will not be used, but it is still saved with the workbook.
     * </p>
     * <p class="note">
     * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
     * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
     * a newly created CustomView will not be initialized with the setting from this property.
     * </p>
     * The index of the first visible tab in the worksheet tab bar.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is less than zero.
     * @see [[WindowOptions.tabBarVisible]]
     * @see [[WindowOptions.tabBarWidth]]
     */
    get firstVisibleTabIndex(): number;
    set firstVisibleTabIndex(a: number);
    /**
     * Gets or sets the value indicating whether the workbook's MDI child window is minimized in Microsoft Excel.
     * <p class="note">
     * <b>Note:</b> This setting cannot be saved with a [[CustomView]] in the Excel file. It can only be saved
     * with a [[Workbook]]. Therefore, there is no corresponding property in [[CustomViewWindowOptions]] and
     * a newly created CustomView will not be initialized with the setting from this property.
     * </p>
     * The value indicating whether the workbook's MDI child window is minimized in Microsoft Excel.
     * @see [[CustomViewWindowOptions.maximized]]
     */
    get minimized(): boolean;
    set minimized(a: boolean);
    /**
     * @hidden
     */
    get _as(): number;
    /**
     * @hidden
     */
    set _as(a: number);
}
/**
 * @hidden
 */
export declare class WorksheetSelection extends Base {
    static $t: Type;
    private c;
    constructor();
    get b(): IList$1<WorksheetPaneSelection>;
    a(a: PaneLocation): WorksheetPaneSelection;
    d(a: PaneLocation): number;
    e(a: WorksheetSelection): void;
}
/**
 * A collection of workbook styles, or complex formats which can be easily applied to cells in Microsoft Excel.
 * @see [[WorkbookStyle]]
 */
export declare class WorkbookStyleCollection extends Base implements ICollection$1<WorkbookStyle> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    private static _w;
    /**
     * @hidden
     */
    private static _p;
    private _a;
    private _q;
    private _b;
    private _y;
    private _r;
    private _s;
    private _c;
    private _v;
    static staticInit(): void;
    constructor(a: Workbook);
    /**
     * @hidden
     */
    add(item: WorkbookStyle): void;
    /**
     * @hidden
     */
    copyTo(array: WorkbookStyle[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorkbookStyle>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorkbookStyle>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds new user defined style to the workbook.
     * @param styleFormat A cell format of the style.
     * @param name The name which will identify the style in Microsoft Excel.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentNullException]] 'name' is longer than 255 characters.
     * @throws [[ArgumentException]] A style already exists with the a name of 'name'. Names are compared case-insensitively.
     * @return The added user defined style as a [[WorkbookStyle]] instance.
     */
    addUserDefinedStyle(styleFormat: IWorksheetCellFormat, name: string): WorkbookStyle;
    /**
     * Adds new user defined style to the workbook.
     * @param name The name which will identify the style in Microsoft Excel.
     * @throws [[ArgumentNullException]] 'name' is null or empty.
     * @throws [[ArgumentNullException]] 'name' is longer than 255 characters.
     * @throws [[ArgumentException]] A style already exists with the a name of 'name'. Names are compared case-insensitively.
     * @return The added user defined style as a [[WorkbookStyle]] instance.
     */
    addUserDefinedStyle(name: string): WorkbookStyle;
    /**
     * @hidden
     */
    _addUserDefinedStyle1(a: string): WorkbookStyle;
    /**
     * @hidden
     */
    _addUserDefinedStyle(a: IWorksheetCellFormat, b: string): WorkbookStyle;
    /**
     * Clears all styles, other than the Normal style, from the collection.
     * @see [[normalStyle]]
     */
    clear(): void;
    /**
     * Determines whether a style is in the collection.
     * @param style The style to locate in the collection.
     * @return True if the style is found; False otherwise.
     */
    contains(style: WorkbookStyle): boolean;
    /**
     * Removes the specified style from the collection.
     * @param style The style to remove from the collection.
     * @throws [[InvalidOperationException]] 'style' is the Normal style.
     * @return True if the style was successfully removed; False if the style was not
     * in the collection.
     * @see [[normalStyle]]
     */
    remove(style: WorkbookStyle): boolean;
    /**
     * Removes the style at the specified index from the collection.
     * @param index The zero-based index of the style in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     * @throws [[InvalidOperationException]] The style to remove at 'index' is the Normal style.
     * @see [[normalStyle]]
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    private _ae;
    /**
     * Resets the collection to its original state by clearing all styles and adding in preset built in styles.
     */
    reset(): void;
    /**
     * @hidden
     */
    private _ag;
    /**
     * @hidden
     */
    _add(a: WorkbookStyle): WorkbookStyle;
    /**
     * @hidden
     */
    _e(a: WorkbookBuiltInStyle): WorkbookStyle;
    /**
     * @hidden
     */
    _f(a: IWorksheetCellFormat, b: string): WorkbookStyle;
    /**
     * @hidden
     */
    _o(a: BuiltInStyleType): boolean;
    /**
     * @hidden
     */
    _i(a: BuiltInStyleType): WorkbookStyle;
    /**
     * @hidden
     */
    _j(a: BuiltInStyleType, b: number): WorkbookStyle;
    /**
     * @hidden
     */
    private __u;
    _u(): IEnumerable$1<WorkbookBuiltInStyle>;
    /**
     * @hidden
     */
    _ac(a: WorkbookUserDefinedStyle, b: string): void;
    /**
     * @hidden
     */
    _ah(a: string, b: string): void;
    /**
     * @hidden
     */
    private _aa;
    /**
     * @hidden
     */
    static _n: (arg1: List$1<WorkbookBuiltInStyle>) => void;
    /**
     * @hidden
     */
    static _ab(): void;
    /**
     * Gets the number of styles in the collection.
     * The number of styles in the collection.
     */
    get count(): number;
    /**
     * Gets the style at the specified index.
     * The style at the specified index.
     * @param index The zero-based index of the style to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    item(index: number): WorkbookStyle;
    /**
     * Gets the style with the specified name.
     * <p class="body">
     * Style names are compared case-insensitively.
     * </p>
     * The style with the specified name or null if no style with that name exists.
     * @param name The name of the style to get.
     * @throws [[ArgumentNullException]] 'name' is null.
     */
    item(name: string): WorkbookStyle;
    /**
     * @hidden
     */
    _item(a: number): WorkbookStyle;
    /**
     * @hidden
     */
    _item1(a: string): WorkbookStyle;
    /**
     * Gets the default style for the workbook.
     * <p class="body">
     * The normal style is the parent style for all cell and differential formats in the workbook, unless another parent style is specified.
     * </p>
     * @see [[IWorksheetCellFormat.style]]
     */
    get normalStyle(): WorkbookStyle;
    /**
     * @hidden
     */
    static get _x(): List$1<WorkbookBuiltInStyle>;
    /**
     * @hidden
     */
    static get _t(): Dictionary$2<string, BuiltInStyleInfo>;
}
/**
 * @hidden
 */
export declare class Worksheet_ShiftRegionHelper extends Base {
    static $t: Type;
    private a;
    constructor(a: CellShiftOperation);
    b(a: WorksheetRegion, b: boolean): {
        p1: boolean;
    };
}
/**
 * @hidden
 */
export declare class Worksheet_InsertRemoveOperationWrapper extends Base implements ICellShiftOperationOverride {
    static $t: Type;
    readonly a: ChangeInfo;
    readonly b: Worksheet_CellInsertDeleteChangeContext;
    private e;
    readonly c: boolean;
    readonly d: boolean;
    constructor(a: ChangeInfo, b: Worksheet_CellInsertDeleteChangeContext, c: boolean, d: boolean);
    get f(): any;
    get count(): number;
    get index(): number;
    get shiftsColumns(): boolean;
    get shiftsRows(): boolean;
    get isRemoveOperation(): boolean;
    get isUndoOperation(): boolean;
    get performsShift(): boolean;
    get worksheet(): Worksheet;
    onBeforeShift(a: CellShiftOperation): void;
    performShift(a: CellShiftOperation): boolean;
}
/**
 * @hidden
 */
export declare class WorksheetCellShiftResult extends ValueType {
    static $t: Type;
    constructor(a: number, b: CellShiftResult, c: List$1<WorksheetTable>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: CellShiftResult;
    readonly b: List$1<WorksheetTable>;
}
/**
 * @hidden
 */
export declare class WorksheetDummyCellFormatProxy extends WorksheetCellFormatProxy {
    static $t: Type;
    constructor(a: WorksheetCellFormatData);
    protected get__l(): ChangeInfo[];
    protected get _l(): ChangeInfo[];
    protected get__q(): ExcelChangeAction;
    get _q(): ExcelChangeAction;
    protected get__v(): Worksheet;
    get _v(): Worksheet;
}
/**
 * @hidden
 */
export declare class WorksheetCellBlockFull extends WorksheetCellBlock {
    static $t: Type;
    private bx;
    private by;
    private bz;
    private b0;
    private b1;
    private a1;
    private a2;
    private a3;
    private a4;
    private a5;
    private a6;
    private a7;
    private a8;
    private a9;
    private ba;
    private bb;
    private bc;
    private bd;
    private be;
    private bf;
    private bg;
    private bh;
    private bi;
    private bj;
    private bk;
    private bl;
    private bm;
    private bn;
    private bo;
    private bp;
    private bq;
    private br;
    private bs;
    private bt;
    private bu;
    private bv;
    private bw;
    constructor(a: number);
    protected h(a: WorksheetCellBlock): {
        ret: boolean;
        p0: WorksheetCellBlock;
    };
    al(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue, d: boolean): {
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
        p3: boolean;
    };
    protected e(a: number): WorksheetCellBlock_CellValue;
    protected f(a: number): WorksheetCellBlock_DataType;
    protected am(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): {
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
    };
    r(a: number): boolean;
    protected an(a: number, b: WorksheetCellBlock_CellValue, c: boolean): void;
    protected aq(a: number, b: WorksheetCellBlock_DataType): void;
    ar(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): void;
    at(a: number, b: boolean): void;
}
/**
 * @hidden
 */
export declare class WorksheetCellBlockHalf extends WorksheetCellBlock {
    static $t: Type;
    private bq;
    private br;
    private bs;
    private bt;
    private bu;
    private bv;
    private bj;
    private bk;
    private bw;
    private by;
    private bx;
    private a2;
    private a3;
    private a4;
    private a5;
    private a6;
    private a7;
    private a8;
    private a9;
    private ba;
    private bb;
    private bc;
    private bd;
    private be;
    private bf;
    private bg;
    private bh;
    constructor(a: number);
    protected h(a: WorksheetCellBlock): {
        ret: boolean;
        p0: WorksheetCellBlock;
    };
    al(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue, d: boolean): {
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
        p3: boolean;
    };
    protected e(a: number): WorksheetCellBlock_CellValue;
    private a1;
    protected f(a: number): WorksheetCellBlock_DataType;
    private bi;
    protected am(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): {
        p1: WorksheetCellBlock_DataType;
        p2: WorksheetCellBlock_CellValue;
    };
    r(a: number): boolean;
    private bl;
    protected an(a: number, b: WorksheetCellBlock_CellValue, c: boolean): void;
    private b1;
    protected aq(a: number, b: WorksheetCellBlock_DataType): void;
    private b3;
    ar(a: number, b: WorksheetCellBlock_DataType, c: WorksheetCellBlock_CellValue): void;
    at(a: number, b: boolean): void;
    private bz;
    private b0;
    private bm;
    private bp;
    private b2;
}
/**
 * @hidden
 */
export declare class WorksheetCellLocation extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetRow, c: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly e: WorksheetRow;
    readonly f: number;
    static readonly a: ChangeInfo$2<WorksheetCellLocation, WorksheetCellComment>;
    static readonly c: ChangeInfo$2<WorksheetCellLocation, any>;
    static h(a: WorksheetCellLocation): any;
    static d(a: WorksheetCellLocation): WorksheetCellComment;
    static j(a: WorksheetCellLocation, b: any): void;
    private static k;
    static i(a: WorksheetCellLocation, b: WorksheetCellComment): void;
    private static b;
    private static g;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class WorksheetCellFormatDataResolved extends Base implements IWorksheetCellFormat {
    static $t: Type;
    private _a;
    private _b;
    constructor(a: WorksheetCellFormatProxy);
    equals(a: any): boolean;
    getHashCode(): number;
    _f(a: CellFormatValue, b: any): {
        ret: boolean;
        p1: any;
    };
    _m(a: WorksheetCellFormatProxy): void;
    setFormatting(a: IWorksheetCellFormat): void;
    private _n;
    get alignment(): HorizontalCellAlignment;
    set alignment(a: HorizontalCellAlignment);
    get bottomBorderColorInfo(): WorkbookColorInfo;
    set bottomBorderColorInfo(a: WorkbookColorInfo);
    get bottomBorderStyle(): CellBorderLineStyle;
    set bottomBorderStyle(a: CellBorderLineStyle);
    get _g(): number;
    get _h(): number;
    get _i(): number;
    get _k(): number;
    get _j(): number;
    get _c(): boolean;
    get _d(): boolean;
    get diagonalBorderColorInfo(): WorkbookColorInfo;
    set diagonalBorderColorInfo(a: WorkbookColorInfo);
    get diagonalBorders(): DiagonalBorders;
    set diagonalBorders(a: DiagonalBorders);
    get diagonalBorderStyle(): CellBorderLineStyle;
    set diagonalBorderStyle(a: CellBorderLineStyle);
    get fill(): CellFill;
    set fill(a: CellFill);
    get font(): IWorkbookFont;
    get formatOptions(): WorksheetCellFormatOptions;
    set formatOptions(a: WorksheetCellFormatOptions);
    get formatString(): string;
    set formatString(a: string);
    get indent(): number;
    set indent(a: number);
    get leftBorderColorInfo(): WorkbookColorInfo;
    set leftBorderColorInfo(a: WorkbookColorInfo);
    get leftBorderStyle(): CellBorderLineStyle;
    set leftBorderStyle(a: CellBorderLineStyle);
    get locked(): boolean | null;
    set locked(a: boolean | null);
    get _locked$i(): Nullable$1<boolean>;
    set _locked$i(a: Nullable$1<boolean>);
    get rightBorderColorInfo(): WorkbookColorInfo;
    set rightBorderColorInfo(a: WorkbookColorInfo);
    get rightBorderStyle(): CellBorderLineStyle;
    set rightBorderStyle(a: CellBorderLineStyle);
    get rotation(): number;
    set rotation(a: number);
    get shrinkToFit(): boolean | null;
    set shrinkToFit(a: boolean | null);
    get _shrinkToFit$i(): Nullable$1<boolean>;
    set _shrinkToFit$i(a: Nullable$1<boolean>);
    get style(): WorkbookStyle;
    set style(a: WorkbookStyle);
    get topBorderColorInfo(): WorkbookColorInfo;
    set topBorderColorInfo(a: WorkbookColorInfo);
    get topBorderStyle(): CellBorderLineStyle;
    set topBorderStyle(a: CellBorderLineStyle);
    get verticalAlignment(): VerticalCellAlignment;
    set verticalAlignment(a: VerticalCellAlignment);
    get wrapText(): boolean | null;
    set wrapText(a: boolean | null);
    get _wrapText$i(): Nullable$1<boolean>;
    set _wrapText$i(a: Nullable$1<boolean>);
}
/**
 * @hidden
 */
export declare class WorksheetMergedCellFormatDataResolved extends WorksheetCellFormatDataResolved {
    static $t: Type;
    private _o;
    constructor(a: WorksheetMergedCellsRegion);
    _f(a: CellFormatValue, b: any): {
        ret: boolean;
        p1: any;
    };
}
/**
 * @hidden
 */
export declare class WorksheetCellOwnedFormatProxy extends WorksheetCellFormatProxy {
    static $t: Type;
    private static readonly _br;
    private _bs;
    private _bw;
    private _bu;
    constructor(a: WorksheetCellFormatData, b: WorksheetCellFormatCollection, c: WorksheetRow, d: number, e: WorksheetCellFormatData[]);
    g(a: GenericCachedCollection$1<WorksheetCellFormatData>): void;
    b(a: boolean): GenericCachedCollection$1<WorksheetCellFormatData>;
    protected get__l(): ChangeInfo[];
    protected get _l(): ChangeInfo[];
    protected get__q(): ExcelChangeAction;
    get _q(): ExcelChangeAction;
    _ai(): Nullable$1<WorksheetCellAddress>;
    _at(a: Nullable$1<WorksheetCellAddress>): void;
    protected get__v(): Worksheet;
    get _v(): Worksheet;
    protected get_d(): WorksheetCellFormatData;
    private _bx;
    private _by;
    get _bv(): number;
    get _bt(): WorksheetCellFormatData;
    set _bt(a: WorksheetCellFormatData);
}
/**
 * @hidden
 */
export declare class FontXInfo extends Base {
    static $t: Type;
    private readonly c;
    private readonly a;
    private readonly d;
    constructor(a: number, b: WorkbookLoadManager);
    e(a: WorkbookSaveManager): number;
    get b(): WorkbookFontData;
}
/**
 * @hidden
 */
export declare class WorksheetColumnOwnedFormatProxy extends WorksheetCellFormatProxy {
    static $t: Type;
    private static readonly _br;
    constructor(a: GenericCachedCollectionEx$1<WorksheetCellFormatData>, b: WorksheetColumn);
    g(a: GenericCachedCollection$1<WorksheetCellFormatData>): void;
    b(a: boolean): GenericCachedCollection$1<WorksheetCellFormatData>;
    protected get__l(): ChangeInfo[];
    protected get _l(): ChangeInfo[];
    protected get__q(): ExcelChangeAction;
    get _q(): ExcelChangeAction;
    protected get_d(): WorksheetCellFormatData;
    protected get__v(): Worksheet;
    get _v(): Worksheet;
    private _bs;
}
/**
 * @hidden
 */
export declare class WorksheetColumnCollection_InsertRemoveOperationWrapper extends Base implements ICellShiftOperationOverride {
    static $t: Type;
    readonly c: ChangeInfo;
    readonly d: WorksheetColumnCollection_CollectionChangeContext;
    readonly a: WorksheetColumnBlock[];
    private h;
    private readonly g;
    readonly b: WorksheetColumn[];
    readonly e: boolean;
    readonly f: boolean;
    constructor(a: ChangeInfo, b: WorksheetColumnCollection_CollectionChangeContext, c: number, d: boolean, e: boolean, f: WorksheetColumn[], g: WorksheetColumnBlock[]);
    i(): void;
    j(): void;
    k(): void;
    get count(): number;
    get index(): number;
    get shiftsColumns(): boolean;
    get shiftsRows(): boolean;
    get isRemoveOperation(): boolean;
    get isUndoOperation(): boolean;
    get performsShift(): boolean;
    get worksheet(): Worksheet;
    onBeforeShift(a: CellShiftOperation): void;
    performShift(a: CellShiftOperation): boolean;
}
/**
 * @hidden
 */
export declare class WorksheetColumnCollection_CollectionChangeContextData extends Base {
    static $t: Type;
    readonly f: boolean;
    readonly h: number;
    readonly g: number;
    readonly e: WorksheetColumnCollection;
    readonly b: WorksheetColumn[];
    readonly a: WorksheetColumnBlock[];
    private c;
    constructor(a: WorksheetColumnCollection, b: boolean, c: number, d: number, e: WorksheetColumn[], f: WorksheetColumnBlock[]);
    i(a: WorksheetTable[]): void;
    get d(): WorksheetTable[];
}
/**
 * @hidden
 */
export declare class WorksheetElementResizeContext_MultiElementResizeChange extends WorksheetElementResizeContext {
    static $t: Type;
    private readonly ac;
    private readonly ad;
    constructor(a: Worksheet, b: List$1<WorksheetElementResizeState>, c: boolean, d: number);
    g(a: number): boolean;
    u(a: number, b?: boolean): number;
    v(a: number, b: number): number;
    protected get_i(): List$1<IndexRange>;
    get i(): List$1<IndexRange>;
    protected get_r(): number;
    get r(): number;
    protected get_w(): number;
    get w(): number;
}
/**
 * @hidden
 */
export declare class WorksheetElementResizeContext_MultiElementVisibilityChange extends WorksheetElementResizeContext {
    static $t: Type;
    private readonly ac;
    private readonly ad;
    private readonly ae;
    constructor(a: Worksheet, b: boolean, c: number, d: number, e: List$1<IndexRange>);
    g(a: number): boolean;
    u(a: number, b?: boolean): number;
    v(a: number, b: number): number;
    protected get_i(): List$1<IndexRange>;
    get i(): List$1<IndexRange>;
    protected get_r(): number;
    get r(): number;
    protected get_w(): number;
    get w(): number;
}
/**
 * Represents a hyperlink for a cell or region.
 * @see [[Worksheet.hyperlinks]]
 * @see [[WorksheetCell.getHyperlink]]
 * @see [[WorksheetRow.getCellHyperlink]]
 */
export declare class WorksheetHyperlink extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _ab;
    /**
     * @hidden
     */
    private static readonly _aa;
    /**
     * @hidden
     */
    private static readonly _x;
    /**
     * @hidden
     */
    private static readonly _y;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    private static readonly _a;
    private _aj;
    private _r;
    private _q;
    private readonly _p;
    private _ak;
    private _h;
    private _k;
    private _n;
    private _ah;
    private _al;
    private _f;
    constructor(sourceAddress: string, target: any, displayText?: string, toolTip?: string);
    constructor(sourceCell: WorksheetCell, target: any, displayText?: string, toolTip?: string);
    constructor(sourceRegion: WorksheetRegion, target: any, displayText?: string, toolTip?: string);
    constructor(sourceCell: WorksheetCell, target: string, displayText: string, isSealed: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * Gets the string representation of the hyperlink.
     * @return The string representation of the hyperlink.
     */
    toString(): string;
    /**
     * @hidden
     */
    private _au;
    /**
     * @hidden
     */
    static _at(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    _s(): boolean;
    /**
     * @hidden
     */
    private _an;
    /**
     * @hidden
     */
    private _ao;
    /**
     * @hidden
     */
    _av(): void;
    /**
     * @hidden
     */
    _a3(a: Worksheet, b?: boolean, c?: boolean): void;
    /**
     * @hidden
     */
    private _aw;
    /**
     * @hidden
     */
    _ax(a: Worksheet, b: WorksheetRegionAddress): void;
    /**
     * @hidden
     */
    _az(a: WorksheetRegionAddress): void;
    /**
     * @hidden
     */
    _a4(): void;
    /**
     * @hidden
     */
    private _a5;
    /**
     * @hidden
     */
    private _a6;
    /**
     * @hidden
     */
    private _a7;
    /**
     * @hidden
     */
    private _a8;
    /**
     * @hidden
     */
    private _a9;
    /**
     * Gets or sets the text to display in the cell when the hyperlink is added to a worksheet, or null to use the target text.
     * <p class="note">
     * <b>Note: the display text will only get applied if the target cell has no value or a string value.</b>
     * </p>
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentException]] Occurs when the specified value is longer than 2084 characters.
     */
    get displayText(): string;
    set displayText(a: string);
    /**
     * @hidden
     */
    private _ay;
    /**
     * Gets the value indicating whether the hyperlink is sealed and cannot be modified.
     */
    get isSealed(): boolean;
    /**
     * Gets or sets the address of the cell or region on which the hyperlink resides.
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
     * @throws [[ArgumentException]] Occurs when the value assigned cannot be parsed as a cell or region address in the owning workbook's current
     * cell reference mode.
     * @see [[sourceCell]]
     * @see [[sourceRegion]]
     */
    get sourceAddress(): string;
    set sourceAddress(a: string);
    /**
     * @hidden
     */
    private _a0;
    /**
     * Gets or sets the cell on which the hyperlink resides.
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
     * @throws [[ArgumentException]] Occurs when the value assigned is not on the same worksheet as the hyperlink.
     * @see [[sourceAddress]]
     * @see [[sourceRegion]]
     */
    get sourceCell(): WorksheetCell;
    set sourceCell(a: WorksheetCell);
    /**
     * @hidden
     */
    private _a1;
    /**
     * Gets or sets the region on which the hyperlink resides.
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentNullException]] Occurs when the value assigned is null.
     * @throws [[ArgumentException]] Occurs when the value assigned is not on the same worksheet as the hyperlink.
     * @see [[sourceCell]]
     * @see [[sourceRegion]]
     */
    get sourceRegion(): WorksheetRegion;
    set sourceRegion(a: WorksheetRegion);
    /**
     * @hidden
     */
    private _a2;
    /**
     * Gets or sets the target of the hyperlink, which can be a string, [[WorksheetCell]], [[WorksheetRegion]], or
     * [[NamedReference]] instance. For bookmarks in an external document, separate the sub-address with a #,
     * such as "File.xlsx#Sheet1!C3". For email addresses, use a target string with the format "mailto:joe@company.com" or
     * "mailto:joe@company.com?subject=Email%20Subject".
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentException]] Occurs when the value assigned is not a string, WorksheetCell, WorksheetRegion, or NamedReference instance.
     * @throws [[ArgumentException]] Occurs when the specified value is a string longer than 256 characters.
     * @throws [[ArgumentException]] Occurs when the value assigned is a cell or region which is not from the same workbook as the owning workbook of the hyperlink.
     * @see [[targetAddress]]
     * @see [[targetCell]]
     * @see [[targetRegion]]
     * @see [[targetNamedReference]]
     */
    get target(): any;
    set target(a: any);
    /**
     * Gets or sets the target address of the hyperlink. For bookmarks in an external document, separate the sub-address with a #,
     * such as "File.xlsx#Sheet1!C3". For email addresses, use a target string with the format "mailto:joe@company.com" or
     * "mailto:joe@company.com?subject=Email%20Subject".
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentException]] Occurs when the specified value is longer than 256 characters.
     * @see [[target]]
     * @see [[targetCell]]
     * @see [[targetRegion]]
     * @see [[targetNamedReference]]
     */
    get targetAddress(): string;
    set targetAddress(a: string);
    /**
     * Gets or sets the target cell of the hyperlink.
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentException]] Occurs when the value assigned is a cell which is not from the same workbook as the owning workbook of the hyperlink.
     * @see [[target]]
     * @see [[targetAddress]]
     * @see [[targetRegion]]
     * @see [[targetNamedReference]]
     */
    get targetCell(): WorksheetCell;
    set targetCell(a: WorksheetCell);
    /**
     * Gets or sets the target named reference of the hyperlink.
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentException]] Occurs when the value assigned is a named reference which is not from the same workbook as the owning workbook of the hyperlink.
     * @see [[target]]
     * @see [[targetAddress]]
     * @see [[targetCell]]
     * @see [[targetRegion]]
     */
    get targetNamedReference(): NamedReference;
    set targetNamedReference(a: NamedReference);
    /**
     * Gets or sets the target region of the hyperlink.
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentException]] Occurs when the value assigned is a region which is not from the same workbook as the owning workbook of the hyperlink.
     * @see [[target]]
     * @see [[targetAddress]]
     * @see [[targetCell]]
     * @see [[targetNamedReference]]
     */
    get targetRegion(): WorksheetRegion;
    set targetRegion(a: WorksheetRegion);
    /**
     * Gets or sets the text to use in a tool tip when hovering over the source cell or region, or null to use the default tool tip.
     * @throws [[InvalidOperationException]] Occurs when [[isSealed]] is True.
     * @throws [[ArgumentException]] Occurs when the specified value is longer than 256 characters.
     */
    get toolTip(): string;
    set toolTip(a: string);
    /**
     * Gets the worksheet to which the hyperlink belongs.
     */
    get worksheet(): Worksheet;
    /**
     * @hidden
     */
    _t: boolean;
    /**
     * @hidden
     */
    get _o(): WorksheetRegionAddress;
    /**
     * @hidden
     */
    private _v;
    /**
     * @hidden
     */
    private get _c();
}
/**
 * @hidden
 */
export declare class WorksheetHyperlinkCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetHyperlinkCollection, c: WorksheetHyperlink, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly c: number;
    readonly b: WorksheetHyperlinkCollection;
    readonly a: WorksheetHyperlink;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class WorksheetHyperlinkCollection_ShiftChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetHyperlinkCollection, c: List$1<Tuple$3<WorksheetHyperlink, number, WorksheetRegionAddress>>, d: List$1<Tuple$2<WorksheetHyperlink, WorksheetRegionAddress>>, e: List$1<WorksheetHyperlink>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: WorksheetHyperlinkCollection;
    readonly b: Tuple$3<WorksheetHyperlink, number, WorksheetRegionAddress>[];
    readonly c: Tuple$2<WorksheetHyperlink, WorksheetRegionAddress>[];
    readonly a: WorksheetHyperlink[];
    e(): void;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of [[WorksheetHyperlink]] instances in a [[Worksheet]].
 * @see [[Worksheet.hyperlinks]]
 */
export declare class WorksheetHyperlinkCollection extends Base implements ICollection$1<WorksheetHyperlink> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _h;
    /**
     * @hidden
     */
    private static readonly _j;
    /**
     * @hidden
     */
    static readonly _k: number;
    /**
     * @hidden
     */
    private static readonly _i;
    /**
     * @hidden
     */
    static _a: ChangeInfo[];
    /**
     * @hidden
     */
    readonly _g: List$1<WorksheetHyperlink>;
    /**
     * @hidden
     */
    readonly _e: Worksheet;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    copyTo(array: WorksheetHyperlink[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds the specified hyperlink to the collection.
     * @param hyperlink The hyperlink to add to the collection.
     * @throws [[ArgumentNullException]] Occurs when the 'hyperlink' is null.
     * @throws [[ArgumentException]] Occurs when the 'hyperlink' already belongs to a [[Worksheet.hyperlinks]] collection.
     * @throws [[ArgumentException]] Occurs when the 'hyperlink' has a source cell or region from a different worksheet than the owner
     * of the collection.
     * @throws [[ArgumentException]] Occurs when the 'hyperlink' was created with a string address which cannot be parsed in the cell
     * reference mode of the owning workbook.
     */
    add(hyperlink: WorksheetHyperlink): void;
    /**
     * Clears all hyperlinks from the collection.
     */
    clear(): void;
    /**
     * Determines whether a hyperlink is in the collection.
     * @param hyperlink The hyperlink to locate in the collection.
     * @return True if the hyperlink is found; False otherwise.
     */
    contains(hyperlink: WorksheetHyperlink): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetHyperlink>;
    /**
     * Gets an enumerator which can iterator all hyperlinks in the collection.
     */
    getEnumerator(): IEnumerator$1<WorksheetHyperlink>;
    /**
     * Inserts the specified hyperlink in the collection.
     * @param index The 0-based index in the collection where the hyperlink should be inserted.
     * @param hyperlink The hyperlink to insert in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than [[count]].
     * @throws [[ArgumentNullException]] Occurs when the 'hyperlink' is null.
     * @throws [[ArgumentException]] Occurs when the 'hyperlink' already belongs to a [[Worksheet.hyperlinks]] collection.
     * @throws [[ArgumentException]] Occurs when the 'hyperlink' has a source cell or region from a different worksheet than the owner
     * of the collection.
     * @throws [[ArgumentException]] Occurs when the 'hyperlink' was created with a string address which cannot be parsed in the cell
     * reference mode of the owning workbook.
     */
    insert(index: number, hyperlink: WorksheetHyperlink): void;
    /**
     * @hidden
     */
    _n(a: number, b: WorksheetHyperlink, c: boolean): void;
    /**
     * Removes the specified hyperlink from the collection.
     * @param hyperlink The hyperlink to remove from the collection.
     * @return True if the hyperlink was successfully removed from the collection;
     * False if the hyperlink did not exist in the collection.
     */
    remove(hyperlink: WorksheetHyperlink): boolean;
    /**
     * Removes the hyperlink at the specified index from the collection.
     * @param index The index of the hyperlink to remove from the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _o(): void;
    /**
     * @hidden
     */
    _q(a: CellShiftOperation, b: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _s(a: number, b?: boolean): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _l;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private static _t;
    /**
     * @hidden
     */
    private static _u;
    /**
     * Gets the number of hyperlinks on the [[Worksheet]].
     */
    get count(): number;
    /**
     * Gets the hyperlink at the specified index in the collection.
     * The hyperlink at the specified index.
     * @param index The zero-based index of the hyperlink to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or equal to [[count]].
     */
    item(a: number): WorksheetHyperlink;
}
/**
 * Represents any image on the worksheet except the background image.
 * @see [[Worksheet.imageBackground]]
 */
export declare class WorksheetImage extends WorksheetShape implements IWorksheetImage {
    static $t: Type;
    private _dv;
    private _dx;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(image: string);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    get image(): ExcelImage;
    /**
     * @hidden
     */
    set image(a: ExcelImage);
    /**
     * @hidden
     */
    get preferredFormat(): ImageFormat;
    /**
     * @hidden
     */
    set preferredFormat(a: ImageFormat);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__a4(): boolean;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _image(): ExcelImage;
    /**
     * @hidden
     */
    set _image(a: ExcelImage);
}
/**
 * @hidden
 */
export declare class WorksheetMergedCellsRegionCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetMergedCellsRegionCollection, c: WorksheetMergedCellsRegion, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: WorksheetMergedCellsRegionCollection;
    readonly a: WorksheetMergedCellsRegion;
    readonly c: number;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class WorksheetMergedCellsRegionCollection_ShiftChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetMergedCellsRegionCollection, c: List$1<Tuple$2<WorksheetMergedCellsRegion, WorksheetRegionAddress>>, d: List$1<Tuple$3<WorksheetMergedCellsRegion, number, WorksheetRegionAddress>>, e: List$1<WorksheetMergedCellsRegion>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: WorksheetMergedCellsRegionCollection;
    readonly c: Tuple$2<WorksheetMergedCellsRegion, WorksheetRegionAddress>[];
    readonly b: Tuple$3<WorksheetMergedCellsRegion, number, WorksheetRegionAddress>[];
    readonly a: WorksheetMergedCellsRegion[];
    e(): void;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of [[WorksheetMergedCellsRegion]] instances in a [[Worksheet]].
 * @see [[WorksheetMergedCellsRegion]]
 * @see [[Worksheet.mergedCellsRegions]]
 */
export declare class WorksheetMergedCellsRegionCollection extends Base implements ICollection$1<WorksheetMergedCellsRegion> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static readonly _n;
    /**
     * @hidden
     */
    static readonly _o: number;
    /**
     * @hidden
     */
    private static readonly _m;
    /**
     * @hidden
     */
    static _a: ChangeInfo[];
    /**
     * @hidden
     */
    _j: List$1<WorksheetMergedCellsRegion>;
    /**
     * @hidden
     */
    _e: Worksheet;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * @hidden
     */
    add(item: WorksheetMergedCellsRegion): void;
    /**
     * Creates new merged cell region and adds it to the collection.
     * <p class="body">
     * The new merged cell region will take its value from the first cell containing a value, starting at the top-left and going across
     * then down in the region. The value of all other cells will be lost. Similarly, the new region will initialize its cell format
     * from the first cell containing a non-default cell format.
     * </p>
     * @param firstRow The index of the first row of the merged cell region.
     * @param firstColumn The index of the first column of the merged cell region.
     * @param lastRow The index of the last row of the merged cell region.
     * @param lastColumn The index of the last row column of the merged cell region.
     * @throws [[InvalidOperationException]] 'firstRow' is greater than 'lastRow' or
     * 'firstColumn' is greater than 'lastColumn'.
     * @throws [[ArgumentOutOfRangeException]] Any row or column indices specified are outside the valid row or column ranges.
     * @throws [[InvalidOperationException]] The new merged cell region overlaps with an existing merged cell region.
     * @return The newly created [[WorksheetMergedCellsRegion]].
     */
    add(firstRow: number, firstColumn: number, lastRow: number, lastColumn: number): WorksheetMergedCellsRegion;
    /**
     * @hidden
     */
    _add$e(a: WorksheetMergedCellsRegion): void;
    /**
     * @hidden
     */
    contains(item: WorksheetMergedCellsRegion): boolean;
    /**
     * @hidden
     */
    copyTo(array: WorksheetMergedCellsRegion[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    remove(item: WorksheetMergedCellsRegion): boolean;
    [Symbol.iterator](): EnumeratorWrapper<WorksheetMergedCellsRegion>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<WorksheetMergedCellsRegion>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * @hidden
     */
    _add1(a: number, b: number, c: number, d: number): WorksheetMergedCellsRegion;
    /**
     * Clears all merged cell regions from the collection.
     * <p class="body">
     * When a merged cell region is removed, the top-left cell in the region will retain the region's value.
     * All other cells in the region will have a null value. In addition, all cells in the merged region will
     * have the region's cell format when it is removed.
     * </p>
     */
    clear(): void;
    /**
     * @hidden
     */
    _r(a: number, b: WorksheetMergedCellsRegion, c: boolean, d?: boolean): void;
    /**
     * Checks if any part of specified region is already a part of a merged cell region.
     * @param firstRow The index of the first row of the merged cell region.
     * @param firstColumn The index of the first column of the merged cell region.
     * @param lastRow The index of the last row of the merged cell region.
     * @param lastColumn The index of the last row column of the merged cell region.
     * @return True if any part of specified region is a part of merged cell region; False otherwise.
     */
    isOverlappingWithMergedRegion(firstRow: number, firstColumn: number, lastRow: number, lastColumn: number): boolean;
    /**
     * Removes the specified merged cell region from the collection.
     * <p class="body">
     * When a merged cell region is removed, the top-left cell in the region will retain the region's value.
     * All other cells in the region will have a null value. In addition, all cells in the merged region will
     * have the region's cell format when it is removed.
     * </p>
     * @param region The merged cell region to remove from the collection.
     * @return True if the merged cell region was successfully removed; False if the merged cell region was not
     * in the collection.
     */
    remove_1(region: WorksheetMergedCellsRegion): boolean;
    /**
     * Removes the merged cell region at the specified index from the collection.
     * <p class="body">
     * When a merged cell region is removed, the top-left cell in the region will retain the region's value.
     * All other cells in the region will have a null value. In addition, all cells in the merged region will
     * have the region's cell format when it is removed.
     * </p>
     * @param index The zero-based index of the merged cell region in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _s(a: CellShiftOperation, b: ICellShiftOperationOverride, c: List$1<WorksheetMergedCellsRegion>): void;
    /**
     * @hidden
     */
    _x(a: FormatLimitErrors, b: WorkbookFormat): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private _t;
    /**
     * @hidden
     */
    private static _v;
    /**
     * @hidden
     */
    private static _w;
    /**
     * @hidden
     */
    private _y;
    /**
     * Gets the number of merged cell regions in the collection.
     * The number of merged cell regions in the collection.
     */
    get count(): number;
    /**
     * Gets the merged cell region at the specified index.
     * The merged cell region at the specified index.
     * @param index The zero-based index of the merged cell region to get.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than zero or 'index' is greater than or
     * equal to [[count]].
     */
    item(a: number): WorksheetMergedCellsRegion;
}
/**
 * @hidden
 */
export declare class WorksheetRegion_HorizontalAddressSorter extends Base implements IComparer$1<WorksheetRegionAddress> {
    static $t: Type;
    static readonly _a: WorksheetRegion_HorizontalAddressSorter;
    constructor();
    static _b(a: WorksheetRegionAddress, b: WorksheetRegionAddress): number;
    static _c(a: WorksheetRegionAddress, b: WorksheetRegionAddress): number;
    compare(a: WorksheetRegionAddress, b: WorksheetRegionAddress): number;
}
/**
 * @hidden
 */
export declare class WorksheetRegion_VerticalSorter extends Base implements IComparer$1<WorksheetRegion> {
    static $t: Type;
    static readonly _a: WorksheetRegion_VerticalSorter;
    constructor();
    compare(a: WorksheetRegion, b: WorksheetRegion): number;
}
/**
 * @hidden
 */
export declare class WorksheetRegion_VerticalAddressSorter extends Base implements IComparer$1<WorksheetRegionAddress> {
    static $t: Type;
    static readonly _a: WorksheetRegion_VerticalAddressSorter;
    constructor();
    static _b(a: WorksheetRegionAddress, b: WorksheetRegionAddress): number;
    static _c(a: WorksheetRegionAddress, b: WorksheetRegionAddress): number;
    compare(a: WorksheetRegionAddress, b: WorksheetRegionAddress): number;
}
/**
 * @hidden
 */
export declare class RegionShiftComparer$1<T extends WorksheetRegion> extends Base implements IComparer$1<T> {
    static $t: Type;
    protected $t: Type;
    private _a;
    private _b;
    constructor($t: Type, a: CellShiftOperation);
    compare(a: T, b: T): number;
}
/**
 * @hidden
 */
export declare class CellFormatContext extends Base {
    static $t: Type;
    private a;
    private b;
    private d;
    constructor(a: number, b: WorksheetCellFormatData, c: WorksheetCellFormatData[]);
    c(a: WorksheetRow): WorksheetCellFormatProxy;
    get e(): number;
}
/**
 * @hidden
 */
export declare class WorksheetRowOwnedCellFormatProxy extends WorksheetCellFormatProxy {
    static $t: Type;
    private static readonly _br;
    constructor(a: GenericCachedCollectionEx$1<WorksheetCellFormatData>, b: IWorksheetCellFormatProxyOwner);
    protected get__l(): ChangeInfo[];
    protected get _l(): ChangeInfo[];
    protected get__q(): ExcelChangeAction;
    get _q(): ExcelChangeAction;
    protected get__v(): Worksheet;
    get _v(): Worksheet;
}
/**
 * @hidden
 */
export declare class WorksheetRowCollection_RowsLoadOnDemandTree_RowChangeHistoryItemRemove extends LoadOnDemandTree_ChangeHistoryItemRemove$1<WorksheetRow> {
    static $t: Type;
    constructor(a: number, b: number);
    d(a: number, b: number, c: number, d: boolean): number;
    e(a: number, b: number, c: boolean): number;
}
/**
 * @hidden
 */
export declare class WorksheetRowCollection_InsertRemoveOperationWrapper extends Base implements ICellShiftOperationOverride {
    static $t: Type;
    readonly a: ChangeInfo;
    readonly c: WorksheetRowCollection_CollectionChangeContext;
    private f;
    readonly d: boolean;
    readonly e: boolean;
    readonly b: WorksheetRow;
    constructor(a: ChangeInfo, b: WorksheetRowCollection_CollectionChangeContext, c: boolean, d: boolean, e: WorksheetRow);
    get g(): any;
    h(): void;
    get count(): number;
    get index(): number;
    get shiftsColumns(): boolean;
    get shiftsRows(): boolean;
    get isRemoveOperation(): boolean;
    get isUndoOperation(): boolean;
    get performsShift(): boolean;
    get worksheet(): Worksheet;
    onBeforeShift(a: CellShiftOperation): void;
    performShift(a: CellShiftOperation): boolean;
}
/**
 * @hidden
 */
export interface IWorksheetShapeVisitor$2<TArg, TResult> {
    _visitDiamondShape$i(a: DiamondShape, b: TArg): TResult;
    _visitEllipseShape$i(a: EllipseShape, b: TArg): TResult;
    _visitHeartShape$i(a: HeartShape, b: TArg): TResult;
    _visitIrregularSeal1Shape$i(a: IrregularSeal1Shape, b: TArg): TResult;
    _visitIrregularSeal2Shape$i(a: IrregularSeal2Shape, b: TArg): TResult;
    _visitLightningBoltShape$i(a: LightningBoltShape, b: TArg): TResult;
    _visitLineShape$i(a: LineShape, b: TArg): TResult;
    _visitPentagonShape$i(a: PentagonShape, b: TArg): TResult;
    _visitRectangleShape$i(a: RectangleShape, b: TArg): TResult;
    _visitRightTriangleShape$i(a: RightTriangleShape, b: TArg): TResult;
    _visitStraightConnector1Shape$i(a: StraightConnector1Shape, b: TArg): TResult;
    _visitUnknownShape$i(a: UnknownShape, b: TArg): TResult;
    _visitWorksheetCellComment$i(a: WorksheetCellComment, b: TArg): TResult;
    _visitWorksheetChart$i(a: WorksheetChart, b: TArg): TResult;
    _visitWorksheetImage$i(a: WorksheetImage, b: TArg): TResult;
    _visitWorksheetShapeGroup$i(a: WorksheetShapeGroupBase, b: TArg): TResult;
}
/**
 * @hidden
 */
export declare let IWorksheetShapeVisitor$2_$type: Type;
/**
 * @hidden
 */
export declare class WorksheetShapeVisitor$2<TArg, TResult> extends Base implements IWorksheetShapeVisitor$2<TArg, TResult> {
    static $t: Type;
    protected $tArg: Type;
    protected $tResult: Type;
    constructor($tArg: Type, $tResult: Type);
    visitDiamondShape(value: DiamondShape, argument: TArg): TResult;
    _visitDiamondShape$i(a: DiamondShape, b: TArg): TResult;
    visitEllipseShape(value: EllipseShape, argument: TArg): TResult;
    _visitEllipseShape$i(a: EllipseShape, b: TArg): TResult;
    visitHeartShape(value: HeartShape, argument: TArg): TResult;
    _visitHeartShape$i(a: HeartShape, b: TArg): TResult;
    visitIrregularSeal1Shape(value: IrregularSeal1Shape, argument: TArg): TResult;
    _visitIrregularSeal1Shape$i(a: IrregularSeal1Shape, b: TArg): TResult;
    visitIrregularSeal2Shape(value: IrregularSeal2Shape, argument: TArg): TResult;
    _visitIrregularSeal2Shape$i(a: IrregularSeal2Shape, b: TArg): TResult;
    visitLightningBoltShape(value: LightningBoltShape, argument: TArg): TResult;
    _visitLightningBoltShape$i(a: LightningBoltShape, b: TArg): TResult;
    visitLineShape(value: LineShape, argument: TArg): TResult;
    _visitLineShape$i(a: LineShape, b: TArg): TResult;
    visitPentagonShape(value: PentagonShape, argument: TArg): TResult;
    _visitPentagonShape$i(a: PentagonShape, b: TArg): TResult;
    visitRectangleShape(value: RectangleShape, argument: TArg): TResult;
    _visitRectangleShape$i(a: RectangleShape, b: TArg): TResult;
    visitRightTriangleShape(value: RightTriangleShape, argument: TArg): TResult;
    _visitRightTriangleShape$i(a: RightTriangleShape, b: TArg): TResult;
    visitStraightConnector1Shape(value: StraightConnector1Shape, argument: TArg): TResult;
    _visitStraightConnector1Shape$i(a: StraightConnector1Shape, b: TArg): TResult;
    visitUnknownShape(value: UnknownShape, argument: TArg): TResult;
    _visitUnknownShape$i(a: UnknownShape, b: TArg): TResult;
    visitWorksheetCellComment(value: WorksheetCellComment, argument: TArg): TResult;
    _visitWorksheetCellComment$i(a: WorksheetCellComment, b: TArg): TResult;
    visitWorksheetChart(value: WorksheetChart, argument: TArg): TResult;
    _visitWorksheetChart$i(a: WorksheetChart, b: TArg): TResult;
    visitWorksheetImage(value: WorksheetImage, argument: TArg): TResult;
    _visitWorksheetImage$i(a: WorksheetImage, b: TArg): TResult;
    visitWorksheetShapeGroup(value: WorksheetShapeGroupBase, argument: TArg): TResult;
    _visitWorksheetShapeGroup$i(a: WorksheetShapeGroupBase, b: TArg): TResult;
    a(a: WorksheetShape, b: TArg): TResult;
    b(a: WorksheetShape, b: TArg): TResult;
    c(a: WorksheetShapeWithText, b: TArg): TResult;
}
/**
 * Represents a group of shapes in a worksheet.  This group is also a shape which can be
 * positioned and contained within another group or on a worksheet.
 */
export declare class WorksheetShapeGroup extends WorksheetShapeGroupBase {
    static $t: Type;
    constructor();
    constructor(loading: boolean);
    constructor(..._rest: any[]);
}
/**
 * Represents a sparkline cell
 */
export declare class Sparkline extends Base {
    static $t: Type;
    private _e;
    private _h;
    private _d;
    private _l;
    private _n;
    constructor();
    /**
     * The region containing the data for the sparkline (read-only)
     * The data region if it is located on a worksheet within the same workbook, otherwise null.
     */
    get dataRegion(): WorksheetRegion;
    /**
     * A striing that describes the region containing the data for the sparkline (read-only)
     * Should always be non-null.
     */
    get dataRegionName(): string;
    /**
     * The cell location of the sparkline (read-only)
     */
    get location(): WorksheetRegion;
    /**
     * @hidden
     */
    get _m(): WorksheetRegionAddress;
    /**
     * @hidden
     */
    get _f(): Worksheet;
    /**
     * @hidden
     */
    get _i(): WorksheetCellAddress;
    /**
     * @hidden
     */
    get _g(): Worksheet;
    /**
     * @hidden
     */
    _a(): Sparkline;
    /**
     * @hidden
     */
    _p(a: WorksheetRegion, b: WorksheetRegion, c: string): void;
    /**
     * @hidden
     */
    _b(a: WorksheetRegionAddress): Sparkline;
    /**
     * @hidden
     */
    _c(a: number, b: number): Sparkline;
}
/**
 * @hidden
 */
export declare class SparklineCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: SparklineCollection, c: Sparkline, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly e: number;
    readonly b: SparklineCollection;
    readonly a: Sparkline;
    readonly f: number;
    readonly d: number;
    readonly h: string;
    readonly g: Nullable$1<WorksheetRegionAddress>;
    readonly c: Worksheet;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of [[Sparkline]]s exposed from a [[SparklineGroup]]
 */
export declare class SparklineCollection extends Base implements IEnumerable$1<Sparkline> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _m;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static readonly _p;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    _g: SparklineGroup;
    private _l;
    static staticInit(): void;
    constructor(a: number, b: SparklineGroup);
    constructor(a: number, b: SparklineGroup, c: Sparkline[]);
    constructor(a: number, ..._rest: any[]);
    /**
     * Returns the total number of items in the collection.
     */
    get count(): number;
    /**
     * Indexer
     * @param index The zer-based index of an item
     * @return The item at the specified index
     * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
     */
    item(a: number, b?: Sparkline): Sparkline;
    /**
     * @hidden
     */
    get _h(): Workbook;
    /**
     * @hidden
     */
    get _i(): Worksheet;
    /**
     * Adds a new [[SparklineGroup]] with no sparklines
     * @param row The zero-based row of the sparkline cell.
     * @param column The zero-based column of the sparkline cell.
     * @param dataRegion A string describing the data region.
     * @param cellReferenceMode An optional [[CellReferenceMode]] to use to parse the dataRegion. If null it defaults to the workbook's mode.
     * @return The added sparkine
     */
    add(row: number, column: number, dataRegion: string, cellReferenceMode?: CellReferenceMode): Sparkline;
    /**
     * @hidden
     */
    _add$i(a: number, b: number, c: string, d?: Nullable$1<CellReferenceMode>): Sparkline;
    /**
     * Clears all items from the collection
     */
    clear(): void;
    /**
     * Returns true if the collection contains the item
     * @param sparkline The sparkline to check
     */
    contains(sparkline: Sparkline): boolean;
    [Symbol.iterator](): EnumeratorWrapper<Sparkline>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<Sparkline>;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
    /**
     * Gets the index of the item in the collection
     * @param sparkline
     * @return The index or -1 if the item is not in the collection
     */
    indexOf(sparkline: Sparkline): number;
    /**
     * Removes a sparkline from the collection
     * @param sparkline The sparkline to remove.
     * @return true if successful, otherwise false
     */
    remove(sparkline: Sparkline): boolean;
    /**
     * Removes a sparkline from the collection
     * @param index The zero-based index of the sparkline to remove.
     * @throws [[IndexOutOfRangeException]] if the index is less than 0 or not less than the count.
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _s(a: number, b: Sparkline, c: WorksheetRegion, d: WorksheetRegion, e: string, f?: boolean): void;
    /**
     * @hidden
     */
    _c(a: Sparkline[]): Sparkline[];
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _r;
    /**
     * @hidden
     */
    private _u;
    /**
     * @hidden
     */
    private static _w;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * @hidden
 */
export declare class SparklineGroup_RegionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: SparklineGroup, c: boolean);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly a: SparklineGroup;
    readonly c: string;
    readonly b: boolean;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Represents a group of [[Sparkline]]s
 */
export declare class SparklineGroup extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _a7;
    /**
     * @hidden
     */
    private static readonly _a8;
    /**
     * @hidden
     */
    private static readonly _a9;
    /**
     * @hidden
     */
    private static readonly _ba;
    /**
     * @hidden
     */
    private static readonly _bb;
    /**
     * @hidden
     */
    private static readonly _bc;
    /**
     * @hidden
     */
    private static readonly _bd;
    /**
     * @hidden
     */
    private static readonly _be;
    /**
     * @hidden
     */
    private static readonly _bf;
    /**
     * @hidden
     */
    private static readonly _bg;
    /**
     * @hidden
     */
    private static readonly _bh;
    /**
     * @hidden
     */
    private static readonly _bi;
    /**
     * @hidden
     */
    private static readonly _bj;
    /**
     * @hidden
     */
    private static readonly _bk;
    /**
     * @hidden
     */
    private static readonly _bl;
    /**
     * @hidden
     */
    private static readonly _bm;
    /**
     * @hidden
     */
    private static readonly _bn;
    /**
     * @hidden
     */
    private static readonly _bo;
    /**
     * @hidden
     */
    private static readonly _bp;
    /**
     * @hidden
     */
    private static readonly _bq;
    /**
     * @hidden
     */
    private static readonly _bs;
    /**
     * @hidden
     */
    private static readonly _bt;
    /**
     * @hidden
     */
    private static readonly _bu;
    /**
     * @hidden
     */
    private static readonly _bv;
    /**
     * @hidden
     */
    private static readonly _bw;
    /**
     * @hidden
     */
    private static readonly _bx;
    /**
     * @hidden
     */
    private static readonly _br;
    /**
     * @hidden
     */
    private static _a;
    private _ai;
    private _m;
    private _y;
    private _x;
    private _r;
    private _w;
    private _s;
    private _u;
    private _t;
    private _v;
    private _ah;
    private _am;
    private _e;
    private _a2;
    private _a3;
    private _a1;
    private _p;
    private _k;
    private _g;
    private _h;
    private _by;
    private _o;
    static staticInit(): void;
    constructor(a: number, b: Worksheet);
    constructor(a: number, b: Worksheet, c: SparklineType);
    constructor(a: number, ..._rest: any[]);
    /**
     * Determines the color of the axis
     * <para class="note"><b>Note:</b> this property is ignored unless the [[dateAxis]] property is explicity set to true.</para>
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     * @see [[dateAxis]]
     */
    get colorAxis(): WorkbookColorInfo;
    set colorAxis(a: WorkbookColorInfo);
    /**
     * Determines the color of the first point
     * <para class="note"><b>Note:</b> this property is ignored unless the [[firstPoint]] property is explicity set to true.</para>
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     * @see [[firstPoint]]
     */
    get colorFirstPoint(): WorkbookColorInfo;
    set colorFirstPoint(a: WorkbookColorInfo);
    /**
     * Determines the color of the high point
     * <para class="note"><b>Note:</b> this property is ignored unless the [[highPoint]] property is explicity set to true.</para>
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     * @see [[highPoint]]
     */
    get colorHighPoint(): WorkbookColorInfo;
    set colorHighPoint(a: WorkbookColorInfo);
    /**
     * Determines the color of the last point
     * <para class="note"><b>Note:</b> this property is ignored unless the [[lastPoint]] property is explicity set to true.</para>
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     * @see [[lastPoint]]
     */
    get colorLastPoint(): WorkbookColorInfo;
    set colorLastPoint(a: WorkbookColorInfo);
    /**
     * Determines the color of the low point
     * <para class="note"><b>Note:</b> this property is ignored unless the [[lowPoint]] property is explicity set to true.</para>
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     * @see [[lowPoint]]
     */
    get colorLowPoint(): WorkbookColorInfo;
    set colorLowPoint(a: WorkbookColorInfo);
    /**
     * Determines the color of the markers
     * <para class="note"><b>Note:</b> this property is ignored unless the [[markers]] property is explicity set to true.</para>
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     * @see [[markers]]
     */
    get colorMarkers(): WorkbookColorInfo;
    set colorMarkers(a: WorkbookColorInfo);
    /**
     * Determines the color of the negative point
     * <para class="note"><b>Note:</b> this property is ignored unless the [[negativePoints]] property is explicity set to true.</para>
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     * @see [[negativePoints]]
     */
    get colorNegativePoints(): WorkbookColorInfo;
    set colorNegativePoints(a: WorkbookColorInfo);
    /**
     * Determines the default color for the series
     * The color to use for the series.
     * @throws [[ArgumentNullException]] Color can't be set to null.
     * @throws [[ArgumentException]] Color can't be set to 'Auto'.
     */
    get colorSeries(): WorkbookColorInfo;
    set colorSeries(a: WorkbookColorInfo);
    /**
     * Determines whether to use a date axis
     * @see [[colorAxis]]
     * @see [[dateRange]]
     * @see [[setDateRange]]
     */
    get dateAxis(): boolean;
    set dateAxis(a: boolean);
    /**
     * The date range (read-only)
     * <para class="note"><b>Note:</b> this property is ignored unless the [[dateAxis]] property is explicity set to true.</para>
     * @see [[dateAxis]]
     * @see [[dateRangeFormula]]
     * @see [[setDateRange]]
     */
    get dateRange(): WorksheetRegion;
    /**
     * The date range formula (read-only)
     * <para class="note"><b>Note:</b> this property is ignored unless the [[dateAxis]] property is explicity set to true.</para>
     * @see [[dateAxis]]
     * @see [[dateRangeFormula]]
     * @see [[setDateRange]]
     */
    get dateRangeFormula(): Formula;
    /**
     * Determines how blanks will be displayed
     */
    get displayBlanksAs(): SparklineDisplayBlanksAs;
    set displayBlanksAs(a: SparklineDisplayBlanksAs);
    /**
     * Determines whether values from cells that are hidden will be displayed
     */
    get displayHidden(): boolean;
    set displayHidden(a: boolean);
    /**
     * Determines if the x-axis will be displayed
     */
    get displayXAxis(): boolean;
    set displayXAxis(a: boolean);
    /**
     * Determines if the first point is displayed differently.
     * @see [[colorFirstPoint]]
     */
    get firstPoint(): boolean;
    set firstPoint(a: boolean);
    /**
     * A unique identifier for this group (read-only).
     * <para class="note"><b>Note:</b> this property is optional but if one group contains a guid then all groups in the collection nust also have guids generated for them.</para>
     * @see [[SparklineGroupCollection.generateGuidsForGroups]]
     */
    get guid(): Guid | null;
    set guid(a: Guid | null);
    /**
     * @hidden
     */
    get _guid$i(): Nullable$1<Guid>;
    /**
     * @hidden
     */
    set _guid$i(a: Nullable$1<Guid>);
    /**
     * Determines if the high point is displayed differently.
     * @see [[colorHighPoint]]
     */
    get highPoint(): boolean;
    set highPoint(a: boolean);
    /**
     * Determines if the last point is displayed differently.
     * @see [[colorLastPoint]]
     */
    get lastPoint(): boolean;
    set lastPoint(a: boolean);
    /**
     * Determines the weight of a line in points.
     * @throws [[ArgumentOutOfRangeException]] if the value is less than zero or greather than 1584.
     */
    get lineWeight(): number;
    set lineWeight(a: number);
    /**
     * Determines if the low point is displayed differently.
     * @see [[colorLowPoint]]
     */
    get lowPoint(): boolean;
    set lowPoint(a: boolean);
    /**
     * Determines if markers are displayed.
     * @see [[colorMarkers]]
     */
    get markers(): boolean;
    set markers(a: boolean);
    /**
     * Determines if the negative points are displayed differently.
     * @see [[colorNegativePoints]]
     */
    get negativePoints(): boolean;
    set negativePoints(a: boolean);
    /**
     * Determines if the sparkline goes from right to left.
     */
    get rightToLeft(): boolean;
    set rightToLeft(a: boolean);
    /**
     * Indexer
     * @param index The zer-based index of an item
     * @return The item at the specified index
     * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
     */
    sparklines(index: number, value?: Sparkline): Sparkline;
    /**
     * The collection of sparklines in the group (read-only)
     */
    sparklines(): SparklineCollection;
    /**
     * @hidden
     */
    get _sparklines$i(): SparklineCollection;
    /**
     * The type of sparkline
     */
    get type(): SparklineType;
    set type(a: SparklineType);
    /**
     * A custom maximum value for the Y axis.
     * <para class="note"><b>Note:</b> if [[verticalAxisMaxType]] property is not set to 'Custom' then this property is ignored.</para>
     * @see [[verticalAxisMaxType]]
     */
    get verticalAxisMax(): number;
    set verticalAxisMax(a: number);
    /**
     * Determines how the maximum value for the Y axis is calculated.
     * <para class="note"><b>Note:</b> if this property is set to 'Custom' then the [[verticalAxisMax]] value will be used.</para>
     * @see [[verticalAxisMax]]
     */
    get verticalAxisMaxType(): SparklineAxisMinMax;
    set verticalAxisMaxType(a: SparklineAxisMinMax);
    /**
     * A custom minimum value for the Y axis.
     * <para class="note"><b>Note:</b> if [[verticalAxisMinType]] property is not set to 'Custom' then this property is ignored.</para>
     * @see [[verticalAxisMinType]]
     */
    get verticalAxisMin(): number;
    set verticalAxisMin(a: number);
    /**
     * Determines how the minimum value for the Y axis is calculated.
     * <para class="note"><b>Note:</b> if this property is set to 'Custom' then the [[verticalAxisMin]] value will be used.</para>
     * @see [[verticalAxisMin]]
     */
    get verticalAxisMinType(): SparklineAxisMinMax;
    set verticalAxisMinType(a: SparklineAxisMinMax);
    /**
     * Returns a reference to the associated worksheet.
     */
    get worksheet(): Worksheet;
    /**
     * Returns a reference to the associated workbook.
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get _an(): WorksheetRegionAddress;
    /**
     * @hidden
     */
    get _aj(): Worksheet;
    /**
     * @hidden
     */
    get _au(): boolean;
    /**
     * @hidden
     */
    get _av(): boolean;
    /**
     * Assigns a new [[dateRange]].
     * <para class="note"><b>Note:</b> [[dateRange]] is ignored unless the [[dateAxis]] property is explicity set to true.</para>
     * @param dateRange The string representation of the formula.
     * @param cellReferenceMode An optional [[CellReferenceMode]] to use to parse the dateRange. If null it defaults to the workbook's mode.
     * @see [[dateRange]]
     */
    setDateRange(dateRange: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setDateRange$i(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    private _b9;
    /**
     * @hidden
     */
    _b0(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    _b2(): void;
    /**
     * @hidden
     */
    _b1(): void;
    /**
     * @hidden
     */
    _b4(a: string, b: WorksheetRegionAddress): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _as;
    /**
     * @hidden
     */
    _b3(a: string): void;
    /**
     * @hidden
     */
    private _b5;
    /**
     * @hidden
     */
    private _b6;
    /**
     * @hidden
     */
    private _b7;
    /**
     * @hidden
     */
    private static _ca;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    get sheet(): Sheet;
}
/**
 * @hidden
 */
export declare class SparklineGroupCollection_GroupModifyInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: SparklineGroup, c: string, d: WorksheetRegionAddress, e: Sparkline[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: SparklineGroup;
    readonly d: string;
    readonly c: WorksheetRegionAddress;
    readonly a: Sparkline[];
}
/**
 * @hidden
 */
export declare class SparklineGroupCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: SparklineGroupCollection, c: SparklineGroup, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly c: number;
    readonly b: SparklineGroupCollection;
    readonly a: SparklineGroup;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class SparklineGroupCollection_ShiftChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: SparklineGroupCollection, c: List$1<SparklineGroupCollection_GroupModifyInfo>, d: List$1<Tuple$2<SparklineGroup, number>>, e: List$1<SparklineGroup>);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: SparklineGroupCollection;
    readonly c: SparklineGroupCollection_GroupModifyInfo[];
    readonly b: Tuple$2<SparklineGroup, number>[];
    readonly a: SparklineGroup[];
    e(): void;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of [[SparklineGroup]]s exposed from a [[worksheet]]
 */
export declare class SparklineGroupCollection extends Base implements IEnumerable$1<SparklineGroup> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _s;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    static readonly _x: number;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    static _p: List$1<SparklineGroupCollection_GroupModifyInfo>;
    /**
     * @hidden
     */
    static _o: List$1<Tuple$2<SparklineGroup, number>>;
    /**
     * @hidden
     */
    static _q: List$1<Sparkline>;
    /**
     * @hidden
     */
    static _a: ChangeInfo[];
    /**
     * @hidden
     */
    _i: Worksheet;
    /**
     * @hidden
     */
    _r: List$1<SparklineGroup>;
    private _k;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * Returns the total number of items in the collection.
     */
    get count(): number;
    /**
     * Determines if guids will be generated for groups.
     * <para class="note"><b>Note:</b> if any group has a guid then all of them must also have guids. Therefore, when this property is set to true all
     * groups in the collection, including groups that are subsequently added, will have guids generated for them. Also note that this property can not be set to false
     * if the collection contains any group with a guid.</para>
     * @throws [[ArgumentException]] Can't set GenerateGuidsForGroups to false if the collection contains groups that already have guids generated.
     * @see [[SparklineGroup.guid]]
     */
    get generateGuidsForGroups(): boolean;
    set generateGuidsForGroups(a: boolean);
    /**
     * Indexer
     * @param index The zer-based index of an item
     * @return The item at the specified index
     * @throws [[IndexOutOfRangeException]] If the index is negative or greater than or equal to [[count]]
     */
    item(a: number): SparklineGroup;
    /**
     * @hidden
     */
    get _h(): Workbook;
    /**
     * @hidden
     */
    get _j(): Worksheet;
    /**
     * Adds a new [[SparklineGroup]]
     * @param type The type of the group.
     * @param locationRange The aggregated location for the sparklines in the group.
     * @param dataRange The aggreagated data range for all the sparklines in the group.
     * @param groupInitializer An optional callback for initializing the group before it is added to the collection.
     * @param cellReferenceMode An optional [[CellReferenceMode]] to use to parse the location and data ranges. If null it defaults to the workbook's mode.
     * @return The added group
     */
    add(type: SparklineType, locationRange: string, dataRange: string, groupInitializer?: (arg1: SparklineGroup) => void, cellReferenceMode?: CellReferenceMode): SparklineGroup;
    /**
     * @hidden
     */
    _add$i(a: SparklineType, b: string, c: string, d?: (arg1: SparklineGroup) => void, e?: Nullable$1<CellReferenceMode>): SparklineGroup;
    /**
     * Clears all items from the collection
     */
    clear(): void;
    /**
     * Returns true if the collection contains the item
     * @param group The group to check
     */
    contains(group: SparklineGroup): boolean;
    [Symbol.iterator](): EnumeratorWrapper<SparklineGroup>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<SparklineGroup>;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
    /**
     * Gets the index of the item in the collection
     * @param group
     * @return The index or -1 if the item is not in the collection
     */
    indexOf(group: SparklineGroup): number;
    /**
     * Removes a group from the collection
     * @param group The group to remove.
     * @return true if successful, otherwise false
     */
    remove(group: SparklineGroup): boolean;
    /**
     * Removes a group from the collection
     * @param index The zero-based index of the group to remove.
     * @throws [[IndexOutOfRangeException]] if the index is less than 0 or not less than the count.
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _f(a: SparklineType): SparklineGroup;
    /**
     * @hidden
     */
    _ad(): void;
    /**
     * @hidden
     */
    _ae(a: CellShiftOperation, b: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _af(a: Sparkline): void;
    /**
     * @hidden
     */
    _ab(a: IList$1<SparklineGroup>): void;
    /**
     * @hidden
     */
    private _z;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _ac;
    /**
     * @hidden
     */
    private _y;
    /**
     * @hidden
     */
    private _ag;
    /**
     * @hidden
     */
    private static _ai;
    /**
     * @hidden
     */
    private static _aj;
}
/**
 * Abstract base class for the sort conditions which describe how to sort data in a region.
 * @see [[SortSettings`1.sortConditions]]
 * @see [[WorksheetTableColumn.sortCondition]]
 * @see [[OrderedSortCondition]]
 * @see [[CustomListSortCondition]]
 * @see [[FontColorSortCondition]]
 * @see [[FillSortCondition]]
 */
export declare abstract class SortCondition extends Base {
    static $t: Type;
    private readonly _b;
    constructor(a: number);
    constructor(a: number, b: SortDirection);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    abstract _a(): SortCondition;
    /**
     * @hidden
     */
    abstract _g<T extends ISortable>($t: Type, a: SortSettings_SortOperation$1<T>, b: number, c: number, d: number, e: number): number;
    /**
     * Determines whether the [[SortCondition]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[SortCondition]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    abstract _f(a: SortCondition): boolean;
    /**
     * Gets the value which indicates the sort direction represented by the sort condition.
     * Either SortDirection.Ascending or SortDirection.Descending.
     */
    get sortDirection(): SortDirection;
    /**
     * @hidden
     */
    abstract get _d(): ST_SortBy;
}
/**
 * @hidden
 */
export interface IColorSortCondition {
    _accept$2$i<TArg, TResult>($tArg: Type, $tResult: Type, a: IColorSortConditionVisitor$2<TArg, TResult>, b: TArg): TResult;
}
/**
 * @hidden
 */
export declare let IColorSortCondition_$type: Type;
/**
 * Represents a sort condition which will sort cells based on their background fill.
 * <p class="body">
 * This sort condition specifies a single [[CellFill]]. Cells of this color will be moved to the beginning of the data range
 * for the ascending sort direction and moved to the end of the data range for the descending sort direction. All matching cells will
 * be kept in their same relative order to each other. In addition, all non-matching cells will be kept in their same relative order to
 * each other.
 * </p>
 * @see [[SortSettings`1.sortConditions]]
 * @see [[SortCondition.sortDirection]]
 */
export declare class FillSortCondition extends SortCondition implements IColorSortCondition {
    static $t: Type;
    private readonly _i;
    constructor(fill: CellFill);
    constructor(fill: CellFill, sortDirection: SortDirection);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _accept$2$i<TArg, TResult>($tArg: Type, $tResult: Type, visitor: IColorSortConditionVisitor$2<TArg, TResult>, argument: TArg): TResult;
    /**
     * @hidden
     */
    _a(): SortCondition;
    /**
     * @hidden
     */
    _g<T extends ISortable>($t: Type, a: SortSettings_SortOperation$1<T>, b: number, c: number, d: number, e: number): number;
    /**
     * Determines whether the [[FillSortCondition]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[FillSortCondition]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _f(a: SortCondition): boolean;
    /**
     * @hidden
     */
    protected get__d(): ST_SortBy;
    /**
     * @hidden
     */
    get _d(): ST_SortBy;
    /**
     * @hidden
     */
    static _k(a: WorkbookLoadManager, b: Nullable$1<number>, c: SortDirection): FillSortCondition;
    /**
     * Gets the [[CellFill]] by which the cells should be sorted.
     * <p class="body">
     * Cells with this fill will be moved to the beginning of the data range for the ascending sort direction and moved to the end
     * of the data range for the descending sort direction. All matching cells will be kept in their same relative order to each other.
     * In addition, all non-matching cells will be kept in their same relative order to each other.
     * </p>
     * The CellFill by which the cells should be sorted.
     * @see [[SortCondition.sortDirection]]
     * @see [[WorksheetCell.cellFormat]]
     * @see [[IWorksheetCellFormat.fill]]
     */
    get fill(): CellFill;
}
/**
 * Represents a sort condition which will sort cells based on their fonts colors.
 * <p class="body">
 * This sort condition specifies a single color. Cells of this color will be moved to the beginning of the data range for the ascending
 * sort direction and moved to the end of the data range for the descending sort direction. All matching cells will be kept in their same
 * relative order to each other. In addition, all non-matching cells will be kept in their same relative order to each other.
 * </p>
 * @see [[SortSettings`1.sortConditions]]
 * @see [[SortCondition.sortDirection]]
 */
export declare class FontColorSortCondition extends SortCondition implements IColorSortCondition {
    static $t: Type;
    private readonly _j;
    constructor(fontColorInfo: WorkbookColorInfo);
    constructor(fontColorInfo: WorkbookColorInfo, sortDirection: SortDirection);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _accept$2$i<TArg, TResult>($tArg: Type, $tResult: Type, visitor: IColorSortConditionVisitor$2<TArg, TResult>, argument: TArg): TResult;
    /**
     * @hidden
     */
    _a(): SortCondition;
    /**
     * @hidden
     */
    _g<T extends ISortable>($t: Type, a: SortSettings_SortOperation$1<T>, b: number, c: number, d: number, e: number): number;
    /**
     * Determines whether the [[FontColorSortCondition]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[FontColorSortCondition]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    _f(a: SortCondition): boolean;
    /**
     * @hidden
     */
    protected get__d(): ST_SortBy;
    /**
     * @hidden
     */
    get _d(): ST_SortBy;
    /**
     * @hidden
     */
    static _i(a: WorkbookLoadManager, b: Nullable$1<number>, c: SortDirection): FontColorSortCondition;
    /**
     * Gets the [[WorkbookColorInfo]] which describes the color by which the cells should be sorted.
     * <p class="body">
     * Cells of this color will be moved to the beginning of the data range for the ascending sort direction and moved to the end
     * of the data range for the descending sort direction. All matching cells will be kept in their same relative order to each other.
     * In addition, all non-matching cells will be kept in their same relative order to each other.
     * </p>
     * The WorkbookColorInfo which describes the color by which the cells should be sorted.
     * @see [[SortCondition.sortDirection]]
     * @see [[WorksheetCell.cellFormat]]
     * @see [[IWorksheetCellFormat.font]]
     * @see [[IWorkbookFont.colorInfo]]
     */
    get fontColorInfo(): WorkbookColorInfo;
}
/**
 * @hidden
 */
export interface IColorSortConditionVisitor$2<TArg, TResult> {
    _visitFillSortCondition$i(a: FillSortCondition, b: TArg): TResult;
    _visitFontColorSortCondition$i(a: FontColorSortCondition, b: TArg): TResult;
}
/**
 * @hidden
 */
export declare let IColorSortConditionVisitor$2_$type: Type;
/**
 * @hidden
 */
export declare class SortConditionCollection_SortChangeContext$1<T extends ISortable> extends ValueType implements IChangeInfoContext {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: number, b: SortConditionCollection$1<T>, c: KeyValuePair$2<T, SortCondition>, d: number);
    constructor($t: Type);
    constructor($t: Type, a: number, ..._rest: any[]);
    readonly a: SortConditionCollection$1<T>;
    readonly b: KeyValuePair$2<T, SortCondition>;
    readonly c: number;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * An ordered collection of sort conditions which are applied to a sort-able regions in a worksheet.
 * <p class="body">
 * The sort conditions in the collection are applied in order to the data.
 * </p>
 * <p class="note">
 * <B>Note:</B> The collection can hold a maximum of 64 sort condition.
 * </p>
 * @typedef T A type which logically contains data and can have sort condition applied to that data.
 * @see [[SortSettings`1.sortConditions]]
 */
export declare class SortConditionCollection$1<T extends ISortable> extends Base implements IDictionary$2<T, SortCondition>, IList$1<KeyValuePair$2<T, SortCondition>> {
    static $t: Type;
    protected $t: Type;
    private _d;
    /**
     * @hidden
     */
    _f: SortSettings$1<T>;
    /**
     * @hidden
     */
    _j: List$1<KeyValuePair$2<T, SortCondition>>;
    private _e;
    constructor($t: Type, a: SortSettings$1<T>);
    /**
     * @hidden
     */
    containsKey(key: T): boolean;
    /**
     * @hidden
     */
    _containsKey$i(a: T): boolean;
    /**
     * @hidden
     */
    get keys(): ICollection$1<T>;
    /**
     * @hidden
     */
    tryGetValue(key: T, value: SortCondition): {
        ret: boolean;
        p1: SortCondition;
    };
    /**
     * @hidden
     */
    _tryGetValue$i(a: T, b: SortCondition): {
        ret: boolean;
        p1: SortCondition;
    };
    /**
     * @hidden
     */
    get values(): ICollection$1<SortCondition>;
    /**
     * @hidden
     */
    indexOf(item: KeyValuePair$2<T, SortCondition>): number;
    /**
     * Gets the index of the specified sort condition in the collection.
     * @param sortCondition The sort condition to find in the collection.
     * @throws [[ArgumentNullException]] 'sortCondition' is null.
     * @return The 0-based index of the specified sort condition in the collection or -1 if the item is not in the collection.
     */
    indexOf(sortCondition: SortCondition): number;
    /**
     * Gets the index of the specified sort-able item in the collection.
     * @param sortableItem The sort-able item to find in the collection.
     * @throws [[ArgumentNullException]] 'sortableItem' is null.
     * @return The 0-based index of the specified sort-able item in the collection or -1 if the item is not in the collection.
     */
    indexOf(sortableItem: T): number;
    /**
     * @hidden
     */
    _indexOf$e(a: KeyValuePair$2<T, SortCondition>): number;
    /**
     * @hidden
     */
    insert(index: number, item: KeyValuePair$2<T, SortCondition>): void;
    /**
     * Inserts a sort condition into the collection.
     * @param index The 0-based index where the sort condition should be inserted.
     * @param sortableItem The sort-able item over which the sort condition will be applied.
     * @param sortCondition The sort condition to apply to the sort-able item.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than [[count]].
     * @throws [[ArgumentNullException]] 'sortableItem' is null.
     * @throws [[ArgumentNullException]] 'sortCondition' is null.
     * @throws [[ArgumentException]] 'sortableItem' is already has a sort condition applied to it in the collection.
     * @throws [[InvalidOperationException]] There are already 64 sort conditions in the collection.
     */
    insert(index: number, sortableItem: T, sortCondition: SortCondition): void;
    /**
     * @hidden
     */
    _insert$e(a: number, b: KeyValuePair$2<T, SortCondition>): void;
    /**
     * @hidden
     */
    add(item: KeyValuePair$2<T, SortCondition>): void;
    /**
     * @hidden
     */
    contains(item: KeyValuePair$2<T, SortCondition>): boolean;
    /**
     * Determines whether the specified sort condition is in the collection.
     * @param sortCondition The sort condition to find in the collection.
     * @throws [[ArgumentNullException]] 'sortCondition' is null.
     * @return True if the sort condition is in the collection; False otherwise.
     */
    contains(sortCondition: SortCondition): boolean;
    /**
     * Determines whether the specified sort-able item is in the collection.
     * @param sortableItem The sort-able item to find in the collection.
     * @throws [[ArgumentNullException]] 'sortableItem' is null.
     * @return True if the sort-able item is in the collection; False otherwise.
     */
    contains(sortableItem: T): boolean;
    /**
     * @hidden
     */
    _contains$e(a: KeyValuePair$2<T, SortCondition>): boolean;
    /**
     * @hidden
     */
    copyTo(array: KeyValuePair$2<T, SortCondition>[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    /**
     * @hidden
     */
    remove(item: KeyValuePair$2<T, SortCondition>): boolean;
    /**
     * Removes a sort condition from the collection.
     * @param sortCondition The sort condition to remove from the collection.
     * @throws [[ArgumentNullException]] 'sortCondition' is null.
     * @return True if the sort condition was found and removed; False otherwise.
     */
    remove(sortCondition: SortCondition): boolean;
    /**
     * @hidden
     */
    _remove$e(a: KeyValuePair$2<T, SortCondition>): boolean;
    [Symbol.iterator](): EnumeratorWrapper<KeyValuePair$2<T, SortCondition>>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<KeyValuePair$2<T, SortCondition>>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a sort condition to the collection.
     * @param sortableItem The sort-able item over which the sort condition will be applied.
     * @param sortCondition The sort condition to apply to the sort-able item.
     * @throws [[ArgumentNullException]] 'sortableItem' is null.
     * @throws [[ArgumentNullException]] 'sortCondition' is null.
     * @throws [[ArgumentException]] 'sortableItem' is already has a sort condition applied to it in the collection.
     * @throws [[InvalidOperationException]] There are already 64 sort conditions in the collection.
     */
    addItem(sortableItem: T, sortCondition: SortCondition): void;
    /**
     * @hidden
     */
    _addItem$i(a: T, b: SortCondition): void;
    /**
     * @hidden
     */
    _add2(a: T, b: SortCondition, c?: boolean): void;
    /**
     * Adds a range of sort conditions to the collection.
     * @param entries An enumberable of entries which contain the sort-able item over which the sort condition will be applied and the sort condition to apply to the sort-able item.
     * @throws [[ArgumentNullException]] 'entries' is null.
     * @throws [[ArgumentNullException]] If any sort condition is null.
     * @throws [[ArgumentException]] If any sortable item is already has a sort condition applied to it in the collection.
     * @throws [[InvalidOperationException]] There are already 64 sort conditions in the collection.
     */
    addRange(entries: IEnumerable$1<KeyValuePair$2<T, SortCondition>>): void;
    /**
     * Clears the collection.
     */
    clear(): void;
    /**
     * @hidden
     */
    _contains2(a: T): boolean;
    /**
     * @hidden
     */
    _contains1(a: SortCondition): boolean;
    /**
     * @hidden
     */
    _indexOf2(a: T): number;
    /**
     * @hidden
     */
    _indexOf1(a: SortCondition): number;
    /**
     * @hidden
     */
    _insert1(a: number, b: T, c: SortCondition): void;
    /**
     * Inserts a range of sort conditions into the collection.
     * @param index The 0-based index where the sort condition should be inserted.
     * @param entries An enumberable of entries which contain the sort-able item over which the sort condition will be applied and the sort condition to apply to the sort-able item.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than [[count]].
     * @throws [[ArgumentNullException]] 'entries' is null.
     * @throws [[ArgumentNullException]] If any sort condition is null.
     * @throws [[ArgumentException]] If any sortable item is already has a sort condition applied to it in the collection.
     * @throws [[InvalidOperationException]] There are already 64 sort conditions in the collection.
     */
    insertRange(index: number, entries: IEnumerable$1<KeyValuePair$2<T, SortCondition>>): void;
    /**
     * @hidden
     */
    private _y;
    /**
     * Removes a sort-able item from the collection.
     * @param sortableItem The sort-able item to remove from the collection.
     * @throws [[ArgumentNullException]] 'sortableItem' is null.
     * @return True if the sort-able item was found and removed; False otherwise.
     */
    removeItem(sortableItem: T): boolean;
    /**
     * @hidden
     */
    _removeItem$i(a: T): boolean;
    /**
     * @hidden
     */
    _remove2(a: SortCondition): boolean;
    /**
     * Removes the sort condition at the specified index.
     * @param index The 0-based index of the sort condition to remove.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     */
    removeAt(index: number): void;
    /**
     * Clears the existing sort conditions from the collection and replaces them with new entries in a single atomic operation.
     * @param entries An enumberable of entries which contain the sort-able item over which the sort condition will be applied and the sort condition to apply to the sort-able item.
     * @throws [[ArgumentNullException]] 'entries' is null.
     * @throws [[ArgumentNullException]] If any sort condition is null.
     * @throws [[ArgumentException]] If any sortable item is already has a sort condition applied to it in the collection.
     * @throws [[InvalidOperationException]] There are more than 64 sort conditions.
     */
    replaceAll(entries: IEnumerable$1<KeyValuePair$2<T, SortCondition>>): void;
    /**
     * @hidden
     */
    _s(a: T, b: SortCondition): void;
    /**
     * @hidden
     */
    _u(): void;
    /**
     * @hidden
     */
    _ad(a: T): void;
    /**
     * @hidden
     */
    _ag(a: Tuple$3<T, number, SortCondition>[]): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _w;
    /**
     * @hidden
     */
    private _z;
    /**
     * @hidden
     */
    private _q;
    /**
     * @hidden
     */
    private _aa;
    /**
     * @hidden
     */
    private _ab;
    /**
     * @hidden
     */
    private _ac;
    /**
     * @hidden
     */
    private _af;
    /**
     * @hidden
     */
    private static _ah;
    /**
     * @hidden
     */
    private static _ai;
    /**
     * @hidden
     */
    private _aj;
    /**
     * Gets the number of sort conditions in the collection.
     */
    get count(): number;
    /**
     * Gets or sets the sort condition for the specified sort-able item.
     * @param sortableItem The sort-able item for which to get or set the sort condition.
     * @throws [[ArgumentNullException]] 'sortableItem' is null.
     * @throws [[InvalidOperationException]] The sort-able item is not already in the collection and there are already 64 sort conditions in the collection.
     */
    item(sortableItem: T, value?: SortCondition): SortCondition;
    /**
     * Gets or sets the pair of item and sort condition at the specified index.
     * @param index The index at which to get the pair of item and sort condition.
     * @throws [[ArgumentNullException]] The Key or Value of the assigned value is null.
     * @throws [[InvalidOperationException]] The Key of the assigned value already in the collection at a different index.
     */
    item(index: number, value?: KeyValuePair$2<T, SortCondition>): KeyValuePair$2<T, SortCondition>;
    /**
     * @hidden
     */
    _item1(a: number, b?: KeyValuePair$2<T, SortCondition>): KeyValuePair$2<T, SortCondition>;
    /**
     * @hidden
     */
    _item(a: T, b?: SortCondition): SortCondition;
    /**
     * @hidden
     */
    private static readonly _n;
    /**
     * @hidden
     */
    private static readonly _k;
    /**
     * @hidden
     */
    private static readonly _p;
    /**
     * @hidden
     */
    private static readonly _o;
}
/**
 * @hidden
 */
export declare class SortConditionCollection_KeysCollection$1<T extends ISortable> extends Base implements ICollection$1<T> {
    static $t: Type;
    protected $t: Type;
    private _a;
    constructor($t: Type, a: SortConditionCollection$1<T>);
    private _b;
    add(a: T): void;
    clear(): void;
    contains(a: T): boolean;
    copyTo(a: T[], b: number): void;
    get count(): number;
    get isReadOnly(): boolean;
    remove(a: T): boolean;
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<T>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare class SortConditionCollection_ValuesCollection$1<T extends ISortable> extends Base implements ICollection$1<SortCondition> {
    static $t: Type;
    protected $t: Type;
    private _a;
    constructor($t: Type, a: SortConditionCollection$1<T>);
    private _b;
    add(a: SortCondition): void;
    clear(): void;
    contains(a: SortCondition): boolean;
    copyTo(a: SortCondition[], b: number): void;
    get count(): number;
    get isReadOnly(): boolean;
    remove(a: SortCondition): boolean;
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<SortCondition>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare class SortSettings_SortChangeContext$1<T extends ISortable> extends ValueType implements IChangeInfoContext {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: number, b: SortSettings$1<T>);
    constructor($t: Type);
    constructor($t: Type, a: number, ..._rest: any[]);
    readonly a: SortSettings$1<T>;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class SortSettings_ShiftFormulaChangeContext$1<T extends ISortable> extends ValueType implements IChangeInfoContext {
    static $t: Type;
    protected $t: Type;
    constructor($t: Type, a: number, b: CellShiftOperation, c: Formula);
    constructor($t: Type);
    constructor($t: Type, a: number, ..._rest: any[]);
    private readonly a;
    private readonly b;
    c(): void;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Represents the settings which apply to sorting a region of values.
 * @typedef T A type which logically contains data and can have sort condition applied to that data.
 * @see [[WorksheetTable.sortSettings]]
 */
export declare class SortSettings$1<T extends ISortable> extends Base {
    static $t: Type;
    protected $t: Type;
    private _l;
    /**
     * @hidden
     */
    _d: ISortSettingsOwner;
    private _f;
    private _p;
    private _h;
    private _k;
    constructor($t: Type, a: ISortSettingsOwner, b: (arg1: T) => void);
    /**
     * @hidden
     */
    _w(): void;
    /**
     * @hidden
     */
    _v(a: SortSettings$1<T>): void;
    /**
     * @hidden
     */
    _y(): void;
    /**
     * @hidden
     */
    _ag(a: T): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    _u(a: ExcelChangeAction): any;
    /**
     * @hidden
     */
    _x(a: any): void;
    /**
     * @hidden
     */
    private static _aa;
    /**
     * @hidden
     */
    private static _ab;
    /**
     * @hidden
     */
    private static _ac;
    /**
     * @hidden
     */
    private static _ad;
    /**
     * @hidden
     */
    private static _ae;
    /**
     * @hidden
     */
    private static _af;
    /**
     * Gets or sets the value which indicates whether strings should be compared case-sensitively when they are sorted.
     * <p class="body">
     * This is only applicable to sort conditions which sort strings.
     * </p>
     * True to sort strings case-sensitively; False to ignore case.
     */
    get caseSensitive(): boolean;
    set caseSensitive(a: boolean);
    /**
     * @hidden
     */
    private _z;
    /**
     * Gets or sets the sort condition for the specified sort-able item.
     * @param sortableItem The sort-able item for which to get or set the sort condition.
     * @throws [[ArgumentNullException]] 'sortableItem' is null.
     * @throws [[InvalidOperationException]] The sort-able item is not already in the collection and there are already 64 sort conditions in the collection.
     */
    sortConditions(sortableItem: T, value?: SortCondition): SortCondition;
    /**
     * Gets or sets the pair of item and sort condition at the specified index.
     * @param index The index at which to get the pair of item and sort condition.
     * @throws [[ArgumentNullException]] The Key or Value of the assigned value is null.
     * @throws [[InvalidOperationException]] The Key of the assigned value already in the collection at a different index.
     */
    sortConditions(index: number, value?: KeyValuePair$2<T, SortCondition>): KeyValuePair$2<T, SortCondition>;
    /**
     * Gets the collection of sort conditions to use when sorting the region of data.
     * <p class="body">
     * If these settings are used in a [[WorksheetTable]], each sort condition in the collection applies to a
     * [[WorksheetTableColumn]].
     * </p>
     * <p class="body">
     * This collection is ordered based on precedence. The first sort condition in the collection has the highest sort precedence.
     * </p>
     * @see [[WorksheetTableColumn.sortCondition]]
     */
    sortConditions(): SortConditionCollection$1<T>;
    /**
     * @hidden
     */
    get _sortConditions$i(): SortConditionCollection$1<T>;
    /**
     * @hidden
     */
    get _n(): boolean;
    /**
     * @hidden
     */
    get _o(): boolean;
    /**
     * @hidden
     */
    get _e(): ISortSettingsOwner;
    /**
     * @hidden
     */
    get _q(): CultureInfo;
    /**
     * @hidden
     */
    get _i(): SortMethod;
    /**
     * @hidden
     */
    set _i(a: SortMethod);
    /**
     * @hidden
     */
    protected get__j(): WorksheetSortType;
    /**
     * @hidden
     */
    get _j(): WorksheetSortType;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    static readonly _t: number;
    /**
     * @hidden
     */
    private static readonly _s;
}
/**
 * @hidden
 */
export declare class SortSettings_ColumnIndexComparer$1<T extends ISortable> extends Base implements IComparer$1<number> {
    static $t: Type;
    protected $t: Type;
    private _c;
    private _a;
    private _b;
    constructor($t: Type, a: SortSettings$1<T>, b: Worksheet, c: number);
    compare(a: number, b: number): number;
}
/**
 * @hidden
 */
export declare class SortSettings_RowIndexComparer$1<T extends ISortable> extends Base implements IComparer$1<number> {
    static $t: Type;
    protected $t: Type;
    private _c;
    private _a;
    private _b;
    constructor($t: Type, a: SortSettings$1<T>, b: Worksheet, c: number);
    compare(a: number, b: number): number;
}
/**
 * @hidden
 */
export declare class SortSettings_SortOperation$1<T extends ISortable> extends Base {
    static $t: Type;
    protected $t: Type;
    readonly b: SortSettings$1<T>;
    readonly c: Worksheet;
    private d;
    constructor($t: Type, a: SortSettings$1<T>, b: Worksheet);
    a(a: number, b: number): CellConditionalFormat;
}
/**
 * Represents the settings which apply to sorting a region of values based on indices relative to either the Worksheet's [[Worksheet.filterSettings]] or [[Worksheet.sortSettings]] region.
 */
export declare class RelativeIndexSortSettings extends SortSettings$1<RelativeIndex> {
    static $t: Type;
    private _ah;
    constructor(a: ISortSettingsOwner, b: (arg1: RelativeIndex) => void);
    /**
     * @hidden
     */
    _w(): void;
    /**
     * Initializes the region to null
     */
    protected initializeRegion(): void;
    /**
     * @hidden
     */
    _aj(a: WorksheetRegionAddress, b: WorksheetRegionAddress, c: CellShiftOperation): void;
    /**
     * @hidden
     */
    _ak(a: number): void;
    /**
     * @hidden
     */
    _al(): void;
}
/**
 * Exposes methods to identify a region in the wroksheet and to apply sort criteria to that region.
 */
export declare class WorksheetSortSettings extends RelativeIndexSortSettings implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _a3;
    /**
     * @hidden
     */
    private static readonly _a4;
    /**
     * @hidden
     */
    private static readonly _a5;
    /**
     * @hidden
     */
    private static readonly _a2;
    /**
     * @hidden
     */
    private static readonly _am;
    private _a7;
    private _a8;
    private _ay;
    private _as;
    private _a6;
    private _ar;
    private _aw;
    private _a1;
    constructor(a: Worksheet, b: (arg1: RelativeIndex) => void);
    /**
     * Initializes the region to null
     */
    protected initializeRegion(): void;
    /**
     * @hidden
     */
    protected get__j(): WorksheetSortType;
    /**
     * Returns the region that the filter settings is applied to (read-only).
     * @see [[setRegion]]
     * @see [[setRegion]]
     */
    get region(): WorksheetRegion;
    /**
     * Determines whether columns or rows will be sorted within the region. 'Rows' is the default.
     * <para class="note"><b>Note:</b> when this property is changed all existing sort conditions will be cleared so this property should be set before sort conditions are added.</para>
     */
    get sortType(): WorksheetSortType;
    set sortType(a: WorksheetSortType);
    /**
     * @hidden
     */
    private _bk;
    /**
     * @hidden
     */
    private get _au();
    /**
     * @hidden
     */
    private set _au(value);
    /**
     * @hidden
     */
    private _bh;
    /**
     * @hidden
     */
    private get _av();
    /**
     * @hidden
     */
    private set _av(value);
    /**
     * @hidden
     */
    private _bi;
    /**
     * Clears the region as well as any existing sort criteria
     * @see [[setRegion]]
     * @see [[setRegion]]
     */
    clearRegion(): void;
    /**
     * Re-sorts all data cells in the region based on the sort conditions.
     * @see [[SortSettings`1.sortConditions]]
     */
    reapplySortConditions(): void;
    /**
     * Sets the region where the filter settings should be applied
     * <p class="body">The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the region address.</p>
     * <p class="note"><b>Note:</b> setting the region will clear any applied filters or sort criteria.</p>
     * @param address The address of the new region.
     * @throws [[InvalidOperationException]] If the region intersects with a table of other reserved area in the worksheet.
     * @see [[region]]
     * @see [[setRegion]]
     * @see [[clearRegion]]
     */
    setRegion(address: string): void;
    /**
     * Sets the region where the filter settings should be applied
     * <p class="note"><b>Note:</b> setting the region will clear any applied filters or sort criteria.</p>
     * @param address The address of the new region.
     * @param cellReferenceMode The reference to use the parse the address.
     * @throws [[InvalidOperationException]] If the region intersects with a table of other reserved area in the worksheet.
     * @see [[region]]
     * @see [[setRegion]]
     * @see [[clearRegion]]
     */
    setRegion(address: string, cellReferenceMode: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setRegion(a: string): void;
    /**
     * @hidden
     */
    _setRegion1(a: string, b: CellReferenceMode): void;
    /**
     * @hidden
     */
    _bj(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    _bb(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    _bd(): void;
    /**
     * @hidden
     */
    _aq(a: CellShiftOperation, b: ICellShiftOperationOverride): ShiftAddressResult;
    /**
     * @hidden
     */
    _bl(a: boolean): void;
    /**
     * @hidden
     */
    _bm(): void;
    /**
     * @hidden
     */
    _bn(): void;
    /**
     * @hidden
     */
    private _ba;
    /**
     * @hidden
     */
    private _az;
    /**
     * @hidden
     */
    private get _a0();
    /**
     * @hidden
     */
    private set _a0(value);
    /**
     * @hidden
     */
    private _be;
    /**
     * @hidden
     */
    private _bo;
    /**
     * @hidden
     */
    private static _ao;
    /**
     * @hidden
     */
    private static _ap;
    /**
     * @hidden
     */
    private static _an;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
    /**
     * @hidden
     */
    get source(): any;
}
/**
 * Represents the diamond shape.
 */
export declare class DiamondShape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
}
/**
 * Represents the ellipse shape.
 */
export declare class EllipseShape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
}
/**
 * Represents the heart shape.
 */
export declare class HeartShape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
}
/**
 * Represents the irregular seal 1 shape.
 */
export declare class IrregularSeal1Shape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
}
/**
 * Represents the irregular seal 2 shape.
 */
export declare class IrregularSeal2Shape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
}
/**
 * Represents the lightning bolt shape.
 */
export declare class LightningBoltShape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
}
/**
 * Represents the line shape.
 */
export declare class LineShape extends WorksheetShape {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__a5(): boolean;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
}
/**
 * Represents the pentagon shape.
 */
export declare class PentagonShape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
}
/**
 * Represents the rectangle shape.
 */
export declare class RectangleShape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
}
/**
 * Represents the right triangle shape.
 */
export declare class RightTriangleShape extends WorksheetShapeWithText {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
}
/**
 * Represents the straight connector 1 shape.
 */
export declare class StraightConnector1Shape extends WorksheetShape {
    static $t: Type;
    constructor();
    constructor(initializeDefaults: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _am<TArg, TResult>($tArg: Type, $tResult: Type, a: IWorksheetShapeVisitor$2<TArg, TResult>, b?: TArg): TResult;
    /**
     * @hidden
     */
    protected get__a5(): boolean;
    /**
     * @hidden
     */
    protected get__b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    get _b0(): Nullable$1<ShapeType>;
    /**
     * @hidden
     */
    protected get__b1(): Nullable$1<ST_ShapeType>;
    /**
     * @hidden
     */
    get _b1(): Nullable$1<ST_ShapeType>;
}
/**
 * @hidden
 */
export declare class CellAddress extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, c: boolean, d: number, e: boolean);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly s;
    private readonly o;
    private readonly q;
    private readonly f;
    equals(a: any): boolean;
    getHashCode(): number;
    static u(a: number, b: number, c?: WorkbookFormat, d?: boolean, e?: boolean, f?: number, g?: number, h?: boolean, i?: CellReferenceMode): string;
    static v(a: number, b: boolean, c: WorkbookFormat, d: number, e: boolean, f: CellReferenceMode): string;
    static w(a: number, b: boolean, c: number, d: number, e: boolean, f: CellReferenceMode): string;
    static x(a: number, b: boolean, c: WorkbookFormat, d: number, e: boolean, f: CellReferenceMode): string;
    static y(a: number, b: boolean, c: number, d: number, e: boolean, f: CellReferenceMode): string;
    a(a: FormulaContext, b: Point, c?: boolean): CellAddress;
    b(a: WorkbookFormat, b: WorkbookFormat, c: boolean): CellAddress;
    c(a: FormulaContext, b: boolean): CellAddress;
    e(a: FormulaContext, b: boolean, c?: boolean): WorksheetCellAddress;
    d(a: FormulaContext): CellAddress;
    z(a: FormulaContext, b: boolean): string;
    aa(a: FormatLimitErrors, b: WorkbookFormat): void;
    ab(a: FormatLimitErrors, b: WorkbookFormat, c: boolean, d: boolean): void;
    get r(): number;
    get g(): boolean;
    get h(): boolean;
    get t(): number;
    get p(): boolean;
    static i(a: CellAddress, b: CellAddress): boolean;
    static j(a: Nullable$1<CellAddress>, b: Nullable$1<CellAddress>): boolean;
    static k(a: CellAddress, b: CellAddress): boolean;
    static l(a: Nullable$1<CellAddress>, b: Nullable$1<CellAddress>): boolean;
}
/**
 * @hidden
 */
export declare class CellAddressRange extends ValueType {
    static $t: Type;
    constructor(a: number, b: CellAddress, c: CellAddress);
    constructor(a: number, b: WorksheetRegion);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private readonly c;
    private readonly a;
    equals(a: any): boolean;
    getHashCode(): number;
    i(a: FormulaContext, b: boolean): WorksheetRegion;
    j(a: Worksheet, b: number, c: number, d: boolean): WorksheetRegion;
    e(a: FormulaContext, b: Point, c?: boolean): CellAddressRange;
    f(a: WorkbookFormat, b: WorkbookFormat, c: boolean): CellAddressRange;
    g(a: FormulaContext, b: boolean): CellAddressRange;
    k(a: FormulaContext, b: boolean, c?: boolean): WorksheetRegionAddress;
    h(a: FormulaContext): CellAddressRange;
    s(a: FormulaContext, b: boolean): string;
    t(a: FormatLimitErrors, b: WorkbookFormat): void;
    get b(): CellAddress;
    get l(): boolean;
    get d(): CellAddress;
    static m(a: CellAddressRange, b: CellAddressRange): boolean;
    static n(a: Nullable$1<CellAddressRange>, b: Nullable$1<CellAddressRange>): boolean;
    static o(a: CellAddressRange, b: CellAddressRange): boolean;
    static p(a: Nullable$1<CellAddressRange>, b: Nullable$1<CellAddressRange>): boolean;
}
/**
 * @hidden
 */
export declare class FormulaParser_FormulaTokenInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: FormulaToken, c: number, d: AttrSpaceToken[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: FormulaToken;
    a: AttrSpaceToken[];
    c: number;
    d(a: AttrSpaceToken[]): void;
}
/**
 * @hidden
 */
export declare class FormulaParser_SelectorFunctionOptimizationInfo extends ValueType {
    static $t: Type;
    constructor(a: number, b: ISelectorFunctionOptimizationToken);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: List$1<AttrSkipToken>;
    readonly a: ISelectorFunctionOptimizationToken;
}
/**
 * @hidden
 */
export declare class FormulaParser_StructuredTableReferenceParser extends Base {
    static $t: Type;
    private a;
    constructor(a: FormulaParser);
    c(a: string, b: string, c: FormulaParser_TextSpan): boolean;
    private d;
    private e;
    private m;
    private f;
    private b;
    private l;
    private g;
    private n;
    private h;
    private i;
    private j;
    private k;
}
/**
 * @hidden
 */
export declare abstract class FormulaTokenVisitor$2<TArgument, TResult> extends Base {
    static $t: Type;
    protected $tArgument: Type;
    protected $tResult: Type;
    private b;
    private az;
    private aw;
    constructor($tArgument: Type, $tResult: Type);
    d(a: FormulaToken, b: TArgument): TResult;
    protected a1(): void;
    a2(): void;
    ax(a: TArgument): boolean;
    protected ay(a: TArgument, b: FormulaToken): {
        ret: boolean;
        p1: FormulaToken;
    };
    e(a: Area3DNToken, b: TArgument): TResult;
    f(a: Area3DToken, b: TArgument): TResult;
    g(a: AreaErr3DToken, b: TArgument): TResult;
    h(a: AreaErrToken, b: TArgument): TResult;
    i(a: AreaNToken, b: TArgument): TResult;
    j(a: AreaToken, b: TArgument): TResult;
    k(a: ArrayToken, b: TArgument): TResult;
    l(a: AttrChooseToken, b: TArgument): TResult;
    m(a: AttrIfToken, b: TArgument): TResult;
    n(a: AttrSkipToken, b: TArgument): TResult;
    o(a: AttrSpaceToken, b: TArgument): TResult;
    p(a: AttrSumToken, b: TArgument): TResult;
    q(a: AttrVolatileToken, b: TArgument): TResult;
    r(a: BinaryOperatorToken, b: TArgument): TResult;
    s(a: BoolToken, b: TArgument): TResult;
    t(a: CellReferenceToken, b: TArgument): TResult;
    u(a: ErrToken, b: TArgument): TResult;
    v(a: ExpToken, b: TArgument): TResult;
    w(a: FunctionOperator, b: TArgument): TResult;
    x(a: IFunctionToken, b: TArgument): TResult;
    y(a: FunctionVOperator, b: TArgument): TResult;
    z(a: IntToken, b: TArgument): TResult;
    aa(a: MemAreaOperator, b: TArgument): TResult;
    ab(a: MemErrOperator, b: TArgument): TResult;
    ac(a: MemFuncOperator, b: TArgument): TResult;
    ad(a: MemNoMemOperator, b: TArgument): TResult;
    ae(a: MissArgToken, b: TArgument): TResult;
    af(a: NameToken, b: TArgument): TResult;
    ag(a: NameXToken, b: TArgument): TResult;
    ah(a: NumberToken, b: TArgument): TResult;
    ai(a: OperandToken, b: TArgument): TResult;
    aj(a: ParenToken, b: TArgument): TResult;
    am(a: ReferenceToken, b: TArgument): TResult;
    ak(a: Ref3DNToken, b: TArgument): TResult;
    al(a: Ref3DToken, b: TArgument): TResult;
    an(a: RefErr3dToken, b: TArgument): TResult;
    ao(a: RefErrToken, b: TArgument): TResult;
    ap(a: RefNToken, b: TArgument): TResult;
    aq(a: RefToken, b: TArgument): TResult;
    ar(a: StrToken, b: TArgument): TResult;
    as(a: StructuredTableReference, b: TArgument): TResult;
    at(a: TblToken, b: TArgument): TResult;
    protected au(a: FormulaToken, b: TArgument, c: FormulaToken): {
        ret: TResult;
        p2: FormulaToken;
    };
    av(a: UnaryOperatorToken, b: TArgument): TResult;
    get c(): FormulaContext;
    set c(a: FormulaContext);
    protected get a0(): number;
    protected set a0(a: number);
    protected get_a(): FormulaToken[];
    protected get a(): FormulaToken[];
}
/**
 * @hidden
 */
export declare class FormulaParser_ParseFormulaValidator extends FormulaTokenVisitor$2<FormulaParser, boolean> {
    static $t: Type;
    private static a3;
    constructor();
    static a4(a: FormulaParser): number;
    d(a: FormulaToken, b: FormulaParser): boolean;
    k(a: ArrayToken, b: FormulaParser): boolean;
    r(a: BinaryOperatorToken, b: FormulaParser): boolean;
    af(a: NameToken, b: FormulaParser): boolean;
    as(a: StructuredTableReference, b: FormulaParser): boolean;
}
/**
 * @hidden
 */
export declare class TokenClassResolver_FormulaTokenNode extends ValueType {
    static $t: Type;
    constructor(a: number, b: number, ...c: TokenClassResolver_FormulaTokenNode[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    static readonly b: TokenClassResolver_FormulaTokenNode[];
    private readonly d;
    private readonly a;
    f(a: TokenClassResolver, b: TokenClass, c: boolean): void;
    get e(): number;
    c(a: TokenClassResolver): TokenClass;
}
/**
 * @hidden
 */
export declare class TokenClassResolver extends FormulaTokenEvaluator$1<TokenClassResolver_FormulaTokenNode> {
    static $t: Type;
    private static bi;
    bh: FormulaType;
    constructor();
    a2(): EvaluationResult$1<TokenClassResolver_FormulaTokenNode>;
    protected a5(a: BinaryOperatorToken, b: TokenClassResolver_FormulaTokenNode, c: TokenClassResolver_FormulaTokenNode): TokenClassResolver_FormulaTokenNode;
    protected a6(a: IFunctionToken, b: TokenClassResolver_FormulaTokenNode, c: TokenClassResolver_FormulaTokenNode[]): TokenClassResolver_FormulaTokenNode;
    protected a7(a: OperandToken): TokenClassResolver_FormulaTokenNode;
    protected a8(a: ParenToken, b: TokenClassResolver_FormulaTokenNode): TokenClassResolver_FormulaTokenNode;
    protected a9(a: UnaryOperatorToken, b: TokenClassResolver_FormulaTokenNode): TokenClassResolver_FormulaTokenNode;
    a1(): void;
    static bj(a: FormulaContext, b: FormulaType): TokenClassResolver;
    bk(a: number, b: TokenClass): void;
}
/**
 * @hidden
 */
export declare class XLSXFormulaStringGenerator extends FormulaStringGenerator {
    static $t: Type;
    private static bw;
    private by;
    constructor();
    protected a4(a: IFunctionToken, b: string): string;
    protected a6(a: IFunctionToken, b: string, c: string[]): string;
    protected bs(a: FormulaToken): string;
    static bx(a: Formula, b: GetFormulaStringInfo): XLSXFormulaStringGenerator;
    a1(): void;
    protected get_bn(): boolean;
}
/**
 * @hidden
 */
export declare abstract class OperatorToken extends FormulaToken {
    static $t: Type;
    constructor(a: TokenClass);
    protected get_n(): boolean;
    get n(): boolean;
    abstract get o(): number;
}
/**
 * @hidden
 */
export declare abstract class BinaryOperatorToken extends OperatorToken {
    static $t: Type;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_y(): boolean;
    get y(): boolean;
}
/**
 * @hidden
 */
export declare class AddOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: AddOperator;
    static readonly aa: AddOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare abstract class OperandToken extends FormulaToken {
    static $t: Type;
    constructor(a: TokenClass);
    abstract n(a: FormulaContext): any;
}
/**
 * @hidden
 */
export declare abstract class ReferenceToken extends OperandToken {
    static $t: Type;
    constructor(a: TokenClass);
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    s(a: WorkbookReferenceBase): void;
    protected get_p(): boolean;
    get p(): boolean;
    protected get_q(): boolean;
    get q(): boolean;
    protected get_r(): boolean;
    get r(): boolean;
    protected get_o(): WorksheetReference;
    protected set_o(a: WorksheetReference): void;
    get o(): WorksheetReference;
    set o(a: WorksheetReference);
}
/**
 * @hidden
 */
export declare abstract class CellReferenceToken extends ReferenceToken {
    static $t: Type;
    constructor(a: TokenClass);
    abstract get v(): boolean;
    abstract t(): CellReferenceToken;
    u(a: FormulaContext): Worksheet;
    protected get_w(): boolean;
    get w(): boolean;
}
/**
 * @hidden
 */
export declare class AreaToken extends CellReferenceToken {
    static $t: Type;
    private y;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: CellAddressRange);
    constructor(a: number, b: CellAddressRange, c: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    get v(): boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    protected get_p(): boolean;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_f(): Token;
    get f(): Token;
    get x(): CellAddressRange;
    set x(a: CellAddressRange);
}
/**
 * @hidden
 */
export declare class AreaNToken extends AreaToken {
    static $t: Type;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: CellAddressRange);
    constructor(a: number, b: CellAddressRange, c: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    protected get_f(): Token;
}
/**
 * @hidden
 */
export declare class Area3DNToken extends AreaNToken {
    static $t: Type;
    private z;
    constructor(a: number, b: WorksheetReference, c: CellAddressRange);
    constructor(a: number, b: WorksheetReference, c: CellAddressRange, d: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_o(): WorksheetReference;
    protected set_o(a: WorksheetReference): void;
}
/**
 * @hidden
 */
export declare class Area3DToken extends AreaToken {
    static $t: Type;
    private z;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: WorksheetReference, c: CellAddressRange);
    constructor(a: number, b: WorksheetReference, c: CellAddressRange, d: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    protected get_f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_o(): WorksheetReference;
    protected set_o(a: WorksheetReference): void;
}
/**
 * @hidden
 */
export declare class AreaErr3DToken extends Area3DToken {
    static $t: Type;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: WorksheetReference, c: CellAddressRange, d: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    n(a: FormulaContext): any;
    protected get_w(): boolean;
    protected get_f(): Token;
}
/**
 * @hidden
 */
export declare class AreaErrToken extends CellReferenceToken {
    static $t: Type;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    get v(): boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    protected get_w(): boolean;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class ArrayToken extends OperandToken {
    static $t: Type;
    private o;
    private p;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: Constant[][]);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    get q(): Constant[][];
    set q(a: Constant[][]);
}
/**
 * @hidden
 */
export declare class AttrChooseToken extends AttrTokenBase implements ISelectorFunctionOptimizationToken {
    static $t: Type;
    private s;
    private r;
    constructor();
    get selectorFunctionTokenIndex(): number;
    set selectorFunctionTokenIndex(a: number);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_p(): AttrTokenBase_AttrType;
    get p(): AttrTokenBase_AttrType;
    get t(): number;
    set t(a: number);
    get skipTokenIndexes(): List$1<number>;
}
/**
 * @hidden
 */
export declare class AttrIfToken extends AttrTokenBase implements ISelectorFunctionOptimizationToken {
    static $t: Type;
    private u;
    private t;
    constructor();
    get selectorFunctionTokenIndex(): number;
    set selectorFunctionTokenIndex(a: number);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_p(): AttrTokenBase_AttrType;
    get p(): AttrTokenBase_AttrType;
    get r(): boolean;
    get v(): number;
    set v(a: number);
    get skipTokenIndexes(): List$1<number>;
}
/**
 * @hidden
 */
export declare class AttrSkipToken extends AttrTokenBase {
    static $t: Type;
    private s;
    constructor();
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_p(): AttrTokenBase_AttrType;
    get p(): AttrTokenBase_AttrType;
    get t(): number;
    set t(a: number);
}
/**
 * @hidden
 */
export declare class AttrSpaceVolitileToken extends AttrSpaceToken {
    static $t: Type;
    constructor(a: number);
    constructor(a: number, b: AttrSpaceToken);
    constructor(a: number, ..._rest: any[]);
    protected get_p(): AttrTokenBase_AttrType;
    protected get_q(): boolean;
}
/**
 * @hidden
 */
export interface IFunctionToken {
    readonly argumentCount: number;
    $function: Function;
    readonly formulaToken: FormulaToken;
}
/**
 * @hidden
 */
export declare let IFunctionToken_$type: Type;
/**
 * @hidden
 */
export declare class AttrSumToken extends AttrTokenBase implements IFunctionToken {
    static $t: Type;
    constructor();
    get argumentCount(): number;
    get $function(): Function;
    set $function(a: Function);
    get formulaToken(): FormulaToken;
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_p(): AttrTokenBase_AttrType;
    get p(): AttrTokenBase_AttrType;
}
/**
 * @hidden
 */
export declare class AttrVolatileToken extends AttrTokenBase {
    static $t: Type;
    constructor();
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_p(): AttrTokenBase_AttrType;
    get p(): AttrTokenBase_AttrType;
    protected get_q(): boolean;
}
/**
 * @hidden
 */
export declare class BoolToken extends OperandToken {
    static $t: Type;
    static readonly o: BoolToken;
    static readonly p: BoolToken;
    private q;
    constructor(a: number);
    constructor(a: number, b: boolean);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    get r(): boolean;
    set r(a: boolean);
}
/**
 * @hidden
 */
export declare class ConcatOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: ConcatOperator;
    static readonly aa: ConcatOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class DivOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: DivOperator;
    static readonly aa: DivOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class EQOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: EQOperator;
    static readonly aa: EQOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class ErrToken extends OperandToken {
    static $t: Type;
    private o;
    constructor(a: number);
    constructor(a: number, b: ErrorValue);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    get p(): ErrorValue;
    set p(a: ErrorValue);
}
/**
 * @hidden
 */
export declare class ExpToken extends SpecialFormulaToken {
    static $t: Type;
    private o;
    constructor(a: number);
    constructor(a: number, b: number, c: number);
    constructor(a: number, b: CellAddress);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_n(): boolean;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    get p(): CellAddress;
    set p(a: CellAddress);
}
/**
 * @hidden
 */
export declare class CloneTokenVisitor extends FormulaTokenVisitor$1<FormulaToken> {
    static $t: Type;
    constructor();
    static a2: CloneTokenVisitor;
    d(a: FormulaToken): FormulaToken;
    a1(): void;
    e(a: Area3DNToken): FormulaToken;
    f(a: Area3DToken): FormulaToken;
    g(a: AreaErr3DToken): FormulaToken;
    i(a: AreaNToken): FormulaToken;
    j(a: AreaToken): FormulaToken;
    l(a: AttrChooseToken): FormulaToken;
    m(a: AttrIfToken): FormulaToken;
    n(a: AttrSkipToken): FormulaToken;
    v(a: ExpToken): FormulaToken;
    aa(a: MemAreaOperator): FormulaToken;
    af(a: NameToken): FormulaToken;
    ag(a: NameXToken): FormulaToken;
    an(a: RefErr3dToken): FormulaToken;
    ak(a: Ref3DNToken): FormulaToken;
    al(a: Ref3DToken): FormulaToken;
    ap(a: RefNToken): FormulaToken;
    aq(a: RefToken): FormulaToken;
    at(a: TblToken): FormulaToken;
    as(a: StructuredTableReference): FormulaToken;
}
/**
 * @hidden
 */
export declare class ExpectedParameterClassVisitor extends FormulaTokenVisitor$2<number, TokenClass> {
    static $t: Type;
    constructor();
    static readonly a3: ExpectedParameterClassVisitor;
    d(a: FormulaToken, b: number): TokenClass;
    a2(): void;
    r(a: BinaryOperatorToken, b: number): TokenClass;
    x(a: IFunctionToken, b: number): TokenClass;
    av(a: UnaryOperatorToken, b: number): TokenClass;
}
/**
 * @hidden
 */
export declare class GetCalcFunctionVisitor extends FormulaTokenVisitor$2<UltraCalcFunctionFactory, ExcelCalcFunction> {
    static $t: Type;
    constructor();
    static readonly a3: GetCalcFunctionVisitor;
    d(a: FormulaToken, b: UltraCalcFunctionFactory): ExcelCalcFunction;
    a2(): void;
    r(a: BinaryOperatorToken, b: UltraCalcFunctionFactory): ExcelCalcFunction;
    x(a: IFunctionToken, b: UltraCalcFunctionFactory): ExcelCalcFunction;
    aj(a: ParenToken, b: UltraCalcFunctionFactory): ExcelCalcFunction;
    av(a: UnaryOperatorToken, b: UltraCalcFunctionFactory): ExcelCalcFunction;
}
/**
 * @hidden
 */
export declare class FunctionOperator extends OperatorToken implements IFunctionToken {
    static $t: Type;
    private z;
    private y;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: Function);
    constructor(a: number, b: Function, c: number);
    constructor(a: number, ..._rest: any[]);
    get formulaToken(): FormulaToken;
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    get argumentCount(): number;
    set argumentCount(a: number);
    get $function(): Function;
    set $function(a: Function);
}
/**
 * @hidden
 */
export declare class FunctionVOperator extends FunctionOperator {
    static $t: Type;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: Function, c: number);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_f(): Token;
}
/**
 * @hidden
 */
export declare class GEOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: GEOperator;
    static readonly aa: GEOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class GTOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: GTOperator;
    static readonly aa: GTOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class IntToken extends OperandToken {
    static $t: Type;
    private o;
    constructor(a: number);
    constructor(a: number, b: number);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    get p(): number;
    set p(a: number);
}
/**
 * @hidden
 */
export declare class IsectOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: IsectOperator;
    constructor();
    protected get_y(): boolean;
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class LEOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: LEOperator;
    static readonly aa: LEOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class LTOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: LTOperator;
    static readonly aa: LTOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class MatrixRowSeparatorToken extends SpecialFormulaToken {
    static $t: Type;
    constructor();
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare abstract class MemOperatorBase extends SpecialFormulaToken {
    static $t: Type;
    private o;
    constructor(a: TokenClass);
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    get p(): number;
    set p(a: number);
}
/**
 * @hidden
 */
export declare class MemAreaOperator extends MemOperatorBase {
    static $t: Type;
    private q;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    get f(): Token;
    get r(): CellAddressRange[];
    set r(a: CellAddressRange[]);
}
/**
 * @hidden
 */
export declare class MemErrOperator extends MemOperatorBase {
    static $t: Type;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_f(): Token;
    get f(): Token;
}
/**
 * @hidden
 */
export declare class MemFuncOperator extends MemOperatorBase {
    static $t: Type;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_f(): Token;
    get f(): Token;
}
/**
 * @hidden
 */
export declare class MemNoMemOperator extends MemOperatorBase {
    static $t: Type;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_f(): Token;
    get f(): Token;
}
/**
 * @hidden
 */
export declare class MissArgToken extends OperandToken {
    static $t: Type;
    static readonly o: MissArgToken;
    static readonly p: MissArgToken;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class MulOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: MulOperator;
    static readonly aa: MulOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class NameToken extends ReferenceToken {
    static $t: Type;
    private t;
    constructor(a: number, b: TokenClass, c?: boolean);
    constructor(a: number, b: string, c: FormulaContext, d: NameType, e?: boolean);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    get w(): string;
    get u(): NamedReferenceBase;
    set u(a: NamedReferenceBase);
    protected get_v(): any;
    get v(): any;
}
/**
 * @hidden
 */
export declare class NameXToken extends NameToken {
    static $t: Type;
    private x;
    constructor(a: number, b: TokenClass, c?: boolean);
    constructor(a: number, b: string, c: string, d: string, e: FormulaContext, f: NameType, g?: boolean);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_q(): boolean;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_r(): boolean;
    protected get_v(): any;
    protected get_f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_o(): WorksheetReference;
    protected set_o(a: WorksheetReference): void;
}
/**
 * @hidden
 */
export declare class NEOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: NEOperator;
    static readonly aa: NEOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class NumberToken extends OperandToken {
    static $t: Type;
    private o;
    constructor(a: number);
    constructor(a: number, b: number);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    get p(): number;
    set p(a: number);
}
/**
 * @hidden
 */
export declare class OpenParenOperator extends OperatorToken {
    static $t: Type;
    static readonly y: OpenParenOperator;
    constructor();
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare abstract class UnaryOperatorToken extends OperatorToken {
    static $t: Type;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
}
/**
 * @hidden
 */
export declare class ParenToken extends FormulaToken {
    static $t: Type;
    constructor();
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class PercentOperator extends UnaryOperatorToken {
    static $t: Type;
    static readonly y: PercentOperator;
    static readonly z: PercentOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class PowerOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: PowerOperator;
    static readonly aa: PowerOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class RangeOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: RangeOperator;
    constructor();
    protected get_y(): boolean;
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class RefToken extends CellReferenceToken {
    static $t: Type;
    private x;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: CellAddress);
    constructor(a: number, b: CellAddress, c: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    get v(): boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    protected get_p(): boolean;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    get y(): CellAddress;
    set y(a: CellAddress);
}
/**
 * @hidden
 */
export declare class RefNToken extends RefToken {
    static $t: Type;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: CellAddress);
    constructor(a: number, b: CellAddress, c: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    protected get_f(): Token;
}
/**
 * @hidden
 */
export declare class Ref3DNToken extends RefNToken {
    static $t: Type;
    private z;
    constructor(a: number, b: WorksheetReference, c: CellAddress);
    constructor(a: number, b: WorksheetReference, c: CellAddress, d: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_o(): WorksheetReference;
    protected set_o(a: WorksheetReference): void;
}
/**
 * @hidden
 */
export declare class Ref3DToken extends RefToken {
    static $t: Type;
    private z;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: WorksheetReference, c: CellAddress);
    constructor(a: number, b: WorksheetReference, c: CellAddress, d: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    protected get_f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_o(): WorksheetReference;
    protected set_o(a: WorksheetReference): void;
}
/**
 * @hidden
 */
export declare class RefErr3dToken extends Ref3DToken {
    static $t: Type;
    constructor(a: number, b: TokenClass);
    constructor(a: number, b: WorksheetReference);
    constructor(a: number, b: WorksheetReference, c: CellAddress, d: TokenClass);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    n(a: FormulaContext): any;
    protected get_w(): boolean;
    protected get_f(): Token;
}
/**
 * @hidden
 */
export declare class RefErrToken extends CellReferenceToken {
    static $t: Type;
    constructor(a: TokenClass);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_v(): boolean;
    get v(): boolean;
    t(): CellReferenceToken;
    n(a: FormulaContext): any;
    protected get_w(): boolean;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class StrToken extends OperandToken {
    static $t: Type;
    private o;
    constructor(a: number);
    constructor(a: number, b: string);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    get p(): string;
    set p(a: string);
}
/**
 * @hidden
 */
export declare class StructuredTableReference extends ReferenceToken {
    static $t: Type;
    private t;
    private ab;
    private ac;
    private v;
    private x;
    constructor(a: number, b: string, c: string, d: WorkbookFormat);
    constructor(a: number, b: string, c: string, d: StructuredTableReferenceKeywordType, e: WorkbookFormat);
    constructor(a: number, b: string, c: string, d: string, e: WorkbookFormat);
    constructor(a: number, b: string, c: string, d: StructuredTableReference_InnerReference, e: WorkbookFormat);
    constructor(a: number, b: StructuredTableReference);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    n(a: FormulaContext): any;
    protected get_q(): boolean;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_r(): boolean;
    s(a: WorkbookReferenceBase): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    protected get_f(): Token;
    get f(): Token;
    z(a: FormulaContext): WorksheetTable;
    static ad(a: string): string;
    private ae;
    static af(a: string, b: boolean): string;
    ai(a: WorksheetTable, b: List$1<KeyValuePair$2<WorksheetTableColumn, string>>): void;
    get aa(): boolean;
    get u(): StructuredTableReference_InnerReference;
    get ag(): string;
    get ah(): string;
    get w(): NamedReferenceBase;
    set w(a: NamedReferenceBase);
    get y(): WorkbookReferenceBase;
    set y(a: WorkbookReferenceBase);
}
/**
 * @hidden
 */
export declare class StructuredTableReference_InnerReference extends Base {
    static $t: Type;
    private n;
    private l;
    private b;
    private c;
    private d;
    private e;
    private o;
    private m;
    constructor(a: number, b: StructuredTableReferenceKeywordType, c: boolean, d: Nullable$1<StructuredTableReferenceKeywordType>);
    constructor(a: number, b: StructuredTableReferenceKeywordType, c: boolean, d: Nullable$1<StructuredTableReferenceKeywordType>, e: boolean, f: string, g: string);
    constructor(a: number, b: string, c: string);
    constructor(a: number, ..._rest: any[]);
    equals(a: any): boolean;
    getHashCode(): number;
    toString(): string;
    s(a: CultureInfo, b: GetFormulaStringInfo): string;
    a(a: WorksheetTable, b: WorksheetRow): RefBase;
    t(a: WorksheetTable, b: string, c: string): void;
    get p(): string;
    get i(): boolean;
    get g(): boolean;
    set g(a: boolean);
    get h(): boolean;
    set h(a: boolean);
    get j(): boolean;
    get q(): string;
}
/**
 * @hidden
 */
export declare class SubOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: SubOperator;
    static readonly aa: SubOperator;
    constructor(a: TokenClass);
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class TblToken extends SpecialFormulaToken {
    static $t: Type;
    private o;
    constructor(a: number);
    constructor(a: number, b: number, c: number);
    constructor(a: number, b: CellAddress);
    constructor(a: number, ..._rest: any[]);
    m(a: FormulaTokenVisitor): void;
    d<TResult>($tResult: Type, a: FormulaTokenVisitor$1<TResult>): TResult;
    e<TArgument, TResult>($tArgument: Type, $tResult: Type, a: FormulaTokenVisitor$2<TArgument, TResult>, b: TArgument): TResult;
    protected get_n(): boolean;
    j(a: FormulaContext, b: FormulaToken, c: FormulaContext): boolean;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
    get p(): CellAddress;
    set p(a: CellAddress);
}
/**
 * @hidden
 */
export declare class UminusOperator extends UnaryOperatorToken {
    static $t: Type;
    static readonly y: UminusOperator;
    static readonly z: UminusOperator;
    constructor(a: TokenClass);
    protected get_n(): boolean;
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class UnionOperator extends BinaryOperatorToken {
    static $t: Type;
    static readonly z: UnionOperator;
    constructor();
    protected get_y(): boolean;
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare class UplusOperator extends UnaryOperatorToken {
    static $t: Type;
    static readonly y: UplusOperator;
    static readonly z: UplusOperator;
    constructor(a: TokenClass);
    protected get_n(): boolean;
    protected get_o(): number;
    get o(): number;
    protected get_f(): Token;
    get f(): Token;
    protected get_h(): TokenClass;
    protected set_h(a: TokenClass): void;
    l(a: FormulaContext, b: GetFormulaStringInfo): string;
}
/**
 * @hidden
 */
export declare abstract class Constant extends Base {
    static $t: Type;
    abstract get c(): any;
    abstract f(a: IBiffRecordStream, b: number[], c: number): {
        p1?: number[];
        p2?: number;
    };
    abstract g(a: IBiffRecordStream): void;
    abstract e(a: CultureInfo): string;
    abstract get b(): number;
    static a(a: IBiffRecordStream, b: number[], c: number): {
        ret: Constant;
        p1?: number[];
        p2?: number;
    };
    toString(): string;
}
/**
 * @hidden
 */
export declare class BooleanConstant extends Constant {
    static $t: Type;
    private h;
    constructor(a: number);
    constructor(a: number, b: boolean);
    constructor(a: number, ..._rest: any[]);
    equals(a: any): boolean;
    getHashCode(): number;
    f(a: IBiffRecordStream, b: number[], c: number): {
        p1?: number[];
        p2?: number;
    };
    g(a: IBiffRecordStream): void;
    e(a: CultureInfo): string;
    protected get_b(): number;
    get b(): number;
    protected get_c(): any;
    get c(): any;
}
/**
 * @hidden
 */
export declare class EmptyConstant extends Constant {
    static $t: Type;
    equals(a: any): boolean;
    getHashCode(): number;
    f(a: IBiffRecordStream, b: number[], c: number): {
        p1?: number[];
        p2?: number;
    };
    g(a: IBiffRecordStream): void;
    e(a: CultureInfo): string;
    protected get_b(): number;
    get b(): number;
    protected get_c(): any;
    get c(): any;
}
/**
 * @hidden
 */
export declare class ErrorConstant extends Constant {
    static $t: Type;
    private h;
    constructor(a: number);
    constructor(a: number, b: ErrorValue);
    constructor(a: number, ..._rest: any[]);
    equals(a: any): boolean;
    getHashCode(): number;
    f(a: IBiffRecordStream, b: number[], c: number): {
        p1?: number[];
        p2?: number;
    };
    g(a: IBiffRecordStream): void;
    e(a: CultureInfo): string;
    protected get_b(): number;
    get b(): number;
    protected get_c(): any;
    get c(): any;
}
/**
 * @hidden
 */
export declare class NumberConstant extends Constant {
    static $t: Type;
    private h;
    constructor(a: number);
    constructor(a: number, b: number);
    constructor(a: number, ..._rest: any[]);
    equals(a: any): boolean;
    getHashCode(): number;
    f(a: IBiffRecordStream, b: number[], c: number): {
        p1?: number[];
        p2?: number;
    };
    g(a: IBiffRecordStream): void;
    e(a: CultureInfo): string;
    protected get_b(): number;
    get b(): number;
    protected get_c(): any;
    get c(): any;
}
/**
 * @hidden
 */
export declare class StringConstant extends Constant {
    static $t: Type;
    private h;
    constructor(a: number);
    constructor(a: number, b: string);
    constructor(a: number, ..._rest: any[]);
    equals(a: any): boolean;
    getHashCode(): number;
    f(a: IBiffRecordStream, b: number[], c: number): {
        p1?: number[];
        p2?: number;
    };
    g(a: IBiffRecordStream): void;
    e(a: CultureInfo): string;
    protected get_b(): number;
    get b(): number;
    protected get_c(): any;
    get c(): any;
}
/**
 * @hidden
 */
export declare class ExternalCellCalcReference extends RefBase {
    static $t: Type;
    private _a3;
    private _a2;
    constructor(a: WorksheetReferenceExternal, b: number, c: number);
    protected get__ao(): number;
    get _ao(): number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__w(): WorksheetRow;
    get _w(): WorksheetRow;
    protected get__as(): number;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
    protected get__t(): Workbook;
    get _a4(): WorksheetCellAddress;
    protected get__q(): WorksheetReference;
}
/**
 * @hidden
 */
export declare class ExternalNamedCalcReference extends NamedCalcReferenceBase {
    static $t: Type;
    private _a3;
    private _a2;
    constructor(a: ExternalNamedReference);
    protected get__formula(): SingleTargetFormula;
    protected get__x(): boolean;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    _az(a: SingleTargetFormula): void;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
    protected get__t(): Workbook;
}
/**
 * @hidden
 */
export declare class ExternalRegionCalcReference extends RefBase {
    static $t: Type;
    _a4: WorksheetRegionAddress;
    private _a2;
    _a3: WorksheetReferenceExternal;
    constructor(a: WorksheetReferenceExternal, b: WorksheetRegionAddress);
    protected get__ao(): number;
    get _ao(): number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__w(): WorksheetRow;
    get _w(): WorksheetRow;
    protected get__as(): number;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
    protected get__t(): Workbook;
    get _a5(): WorksheetRegionAddress;
    protected get__q(): WorksheetReference;
}
/**
 * @hidden
 */
export declare class ExternalRegionCalcReference_ExternalRegionValuesArray extends ArrayProxy {
    static $t: Type;
    private _q;
    private _p;
    constructor(a: ExternalRegionCalcReference);
    protected get__h(): boolean;
    get _h(): boolean;
    private __k;
    _k(a: number, b: number): IEnumerable$1<KeyValuePair$2<number, ExcelCalcValue>>;
    getLength(a: number): number;
    _b(a: number, b: number, c: number, d: number): ArrayProxy;
    _d(a: ArrayValueContext): ExcelCalcValue;
    _a(): ExcelCalcValue[][];
}
/**
 * @hidden
 */
export declare class MultiSheetCellCalcReference extends RefBase {
    static $t: Type;
    private readonly _a6;
    private readonly _a4;
    private readonly _a5;
    private readonly _a3;
    readonly _a7: List$1<WorksheetRegion>;
    private readonly _a2;
    constructor(a: Worksheet, b: Worksheet, c: WorksheetCellAddress);
    protected get__ao(): number;
    get _ao(): number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    _am(): IList$1<WorksheetRegion>;
    protected get_isEnumerable(): boolean;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__references(): IExcelCalcReferenceCollectionEx;
    protected get__w(): WorksheetRow;
    get _w(): WorksheetRow;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
}
/**
 * @hidden
 */
export declare class MultiSheetCellCalcReference_MultiSheetCellReferencesCollection extends Base implements IExcelCalcReferenceCollectionEx {
    static $t: Type;
    private _a;
    constructor(a: MultiSheetCellCalcReference);
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<IExcelCalcReference>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare class MultiSheetExternalCellCalcReference extends RefBase {
    static $t: Type;
    private readonly _a7;
    private readonly _a5;
    private readonly _a6;
    private readonly _a2;
    constructor(a: WorksheetReferenceExternal, b: WorksheetReferenceExternal, c: WorksheetCellAddress);
    protected get__ao(): number;
    get _ao(): number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__w(): WorksheetRow;
    get _w(): WorksheetRow;
    protected get__as(): number;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
    protected get__q(): WorksheetReference;
    protected get__t(): Workbook;
    get _a8(): WorksheetCellAddress;
    get _a3(): WorksheetReference;
    get _a4(): WorksheetReference;
}
/**
 * @hidden
 */
export declare class MultiSheetExternalRegionCalcReference extends RefBase {
    static $t: Type;
    private readonly _a7;
    private readonly _a5;
    private readonly _a6;
    private readonly _a2;
    constructor(a: WorksheetReferenceExternal, b: WorksheetReferenceExternal, c: WorksheetRegionAddress);
    protected get__ao(): number;
    get _ao(): number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__w(): WorksheetRow;
    get _w(): WorksheetRow;
    protected get__as(): number;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
    protected get__t(): Workbook;
    protected get__q(): WorksheetReference;
    get _a8(): WorksheetRegionAddress;
    get _a3(): WorksheetReference;
    get _a4(): WorksheetReference;
}
/**
 * @hidden
 */
export declare class MultiSheetRegionCalcReference extends RefBase {
    static $t: Type;
    private readonly _a4;
    private readonly _a5;
    private readonly _a3;
    private readonly _a6;
    readonly _a7: List$1<WorksheetRegion>;
    private readonly _a2;
    constructor(a: Worksheet, b: Worksheet, c: WorksheetRegionAddress);
    protected get__ao(): number;
    get _ao(): number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    _am(): IList$1<WorksheetRegion>;
    protected get_isEnumerable(): boolean;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__references(): IExcelCalcReferenceCollectionEx;
    protected get__w(): WorksheetRow;
    get _w(): WorksheetRow;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
}
/**
 * @hidden
 */
export declare class MultiSheetRegionCalcReference_MultiSheetRegionReferencesCollection extends Base implements IExcelCalcReferenceCollectionEx {
    static $t: Type;
    private _a;
    constructor(a: MultiSheetRegionCalcReference);
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<IExcelCalcReference>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare abstract class RegionArrayProxyBase extends ArrayProxy {
    static $t: Type;
    private _p;
    constructor();
    protected get__h(): boolean;
    get _h(): boolean;
    protected get__i(): boolean;
    private __k;
    _k(a: number, b: number): IEnumerable$1<KeyValuePair$2<number, ExcelCalcValue>>;
    getLength(a: number): number;
    _d(a: ArrayValueContext): ExcelCalcValue;
    _n(a: boolean, b: (arg1: ExcelCalcValue, arg2: ArrayValueContext) => void): void;
    _a(): ExcelCalcValue[][];
    private static _r;
    private _q;
    abstract get _s(): WorksheetRegion;
}
/**
 * @hidden
 */
export declare class RegionCalcReference extends RegionCalcReferenceBase {
    static $t: Type;
    private _ba;
    private _a9;
    constructor(a: WorksheetRegion);
    _a4(a: number, b: number): boolean;
    _a5(a: number, b: number): boolean;
    protected get_elementName(): string;
    get elementName(): string;
    _a6(a: number, b: number): boolean;
    _a7(a: number, b: number): boolean;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
    protected get__a3(): WorksheetRegion;
    get _a3(): WorksheetRegion;
}
/**
 * @hidden
 */
export declare class RegionCalcReference_RegionArrayProxy extends RegionArrayProxyBase {
    static $t: Type;
    private _t;
    constructor(a: WorksheetRegion);
    protected get__s(): WorksheetRegion;
    get _s(): WorksheetRegion;
    _b(a: number, b: number, c: number, d: number): ArrayProxy;
}
/**
 * @hidden
 */
export declare class RegionCalcReferenceBase_RegionReferencesCollection extends Base implements IExcelCalcReferenceCollectionEx {
    static $t: Type;
    private _a;
    constructor(a: RegionCalcReferenceBase);
    getEnumeratorObject(): IEnumerator;
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<IExcelCalcReference>;
    get _b(): WorksheetRegion;
}
/**
 * @hidden
 */
export declare class RegionGroupCalcReference extends RefBase {
    static $t: Type;
    readonly _bb: ReadOnlyCollection$1<WorksheetRegion>;
    private _a8;
    private _a2;
    private _a9;
    constructor(a: number, b: List$1<WorksheetRegion>, c: WorksheetRegion);
    constructor(a: number, b: WorksheetRow, c: number);
    constructor(a: number, b: WorksheetRegion);
    constructor(a: number, ..._rest: any[]);
    private _bc;
    protected get__ao(): number;
    get _ao(): number;
    containsReference(a: IExcelCalcReference): boolean;
    protected get_context(): any;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    _v(): WorksheetRegion;
    _am(): IList$1<WorksheetRegion>;
    protected get_isEnumerable(): boolean;
    isSubsetReference(a: IExcelCalcReference): boolean;
    protected get__references(): IExcelCalcReferenceCollectionEx;
    _n(a: CellCalcReference, b: ExcelCalcErrorValue): {
        ret: RefBase;
        p1: ExcelCalcErrorValue;
    };
    protected get__w(): WorksheetRow;
    get _w(): WorksheetRow;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
    static _a7(a: IExcelCalcReference): RegionGroupCalcReference;
    static _a3(a: RegionGroupCalcReference, b: RegionGroupCalcReference): IExcelCalcReference;
    static _a4(a: RegionGroupCalcReference, b: RegionGroupCalcReference): IExcelCalcReference;
    static _a6(a: RegionGroupCalcReference, b: RegionGroupCalcReference): RefBase;
    private _a5;
    get _ba(): ReadOnlyCollection$1<WorksheetRegion>;
}
/**
 * @hidden
 */
export declare class RegionGroupCalcReference_GeneralReferencesCollection extends Base implements IExcelCalcReferenceCollectionEx {
    static $t: Type;
    private _a;
    constructor(a: RegionGroupCalcReference);
    private _getEnumerator;
    getEnumerator(): IEnumerator$1<IExcelCalcReference>;
    getEnumeratorObject(): IEnumerator;
}
/**
 * @hidden
 */
export declare abstract class TableCalcReferenceBase extends RegionCalcReferenceBase {
    static $t: Type;
    private readonly _bg;
    private readonly _bh;
    private readonly _bd;
    private readonly _a9;
    constructor(a: WorksheetRow, b: Nullable$1<StructuredTableReferenceKeywordType>, c: Nullable$1<StructuredTableReferenceKeywordType>);
    _m(a: CalculationContext, b: boolean, c: ExcelCalcErrorValue): {
        ret: RefBase;
        p0?: CalculationContext;
        p2: ExcelCalcErrorValue;
    };
    protected get__t(): Workbook;
    protected get__c(): ExcelCalcValue;
    get _c(): ExcelCalcValue;
    protected abstract _ba(a: WorksheetRow): TableCalcReferenceBase;
    private _bb;
    protected _bf(a: TableCalcReferenceBase): boolean;
    protected get _bi(): Nullable$1<StructuredTableReferenceKeywordType>;
    protected get _bj(): Nullable$1<StructuredTableReferenceKeywordType>;
    abstract get _be(): WorksheetTable;
    protected get _bc(): WorksheetRegion;
}
/**
 * @hidden
 */
export declare class TableCalcReference extends TableCalcReferenceBase {
    static $t: Type;
    private _bk;
    constructor(a: WorksheetRow, b: WorksheetTable, c: Nullable$1<StructuredTableReferenceKeywordType>, d: Nullable$1<StructuredTableReferenceKeywordType>);
    protected _ba(a: WorksheetRow): TableCalcReferenceBase;
    _a4(a: number, b: number): boolean;
    _a5(a: number, b: number): boolean;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    _a6(a: number, b: number): boolean;
    _a7(a: number, b: number): boolean;
    getHashCode(): number;
    protected get__a3(): WorksheetRegion;
    get _a3(): WorksheetRegion;
    protected get__be(): WorksheetTable;
    get _be(): WorksheetTable;
}
/**
 * @hidden
 */
export declare class TableCalcReferenceBase_TableReferenceArrayProxy extends RegionArrayProxyBase {
    static $t: Type;
    private _t;
    constructor(a: TableCalcReferenceBase);
    protected get__s(): WorksheetRegion;
    get _s(): WorksheetRegion;
    _b(a: number, b: number, c: number, d: number): ArrayProxy;
}
/**
 * @hidden
 */
export declare class TableColumnCalcReference extends TableCalcReferenceBase {
    static $t: Type;
    private _bk;
    constructor(a: WorksheetRow, b: WorksheetTableColumn, c: Nullable$1<StructuredTableReferenceKeywordType>, d: Nullable$1<StructuredTableReferenceKeywordType>);
    protected _ba(a: WorksheetRow): TableCalcReferenceBase;
    _a4(a: number, b: number): boolean;
    _a5(a: number, b: number): boolean;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    _a6(a: number, b: number): boolean;
    _a7(a: number, b: number): boolean;
    getHashCode(): number;
    protected get__a3(): WorksheetRegion;
    get _a3(): WorksheetRegion;
    protected get__be(): WorksheetTable;
    get _be(): WorksheetTable;
}
/**
 * @hidden
 */
export declare class TableColumnRangeCalcReference extends TableCalcReferenceBase {
    static $t: Type;
    private _bk;
    private _bl;
    constructor(a: WorksheetRow, b: WorksheetTableColumn, c: WorksheetTableColumn, d: Nullable$1<StructuredTableReferenceKeywordType>, e: Nullable$1<StructuredTableReferenceKeywordType>);
    protected _ba(a: WorksheetRow): TableCalcReferenceBase;
    _a4(a: number, b: number): boolean;
    _a5(a: number, b: number): boolean;
    protected get_elementName(): string;
    get elementName(): string;
    _z(a: IExcelCalcReference): boolean;
    getHashCode(): number;
    _a6(a: number, b: number): boolean;
    _a7(a: number, b: number): boolean;
    protected get__a3(): WorksheetRegion;
    get _a3(): WorksheetRegion;
    protected get__be(): WorksheetTable;
    get _be(): WorksheetTable;
}
/**
 * Abstract base class for all filter types which filter data based on a dynamic condition, such as the data present in the filtered
 * data range, the date when the filter was applied, or the date when the filter is evaluated.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[AverageFilter]]
 * @see [[RelativeDateRangeFilter]]
 * @see [[DatePeriodFilter]]
 * @see [[YearToDateFilter]]
 */
export declare abstract class DynamicValuesFilter extends Filter {
    static $t: Type;
    constructor(a: IFilterable);
    /**
     * @hidden
     */
    static _l(a: WorkbookLoadManager, b: IFilterable, c: ST_DynamicFilterType, d: Nullable$1<number>, e: Nullable$1<number>): DynamicValuesFilter;
    /**
     * @hidden
     */
    static _k(a: IFilterable, b: ST_DynamicFilterType, c: Nullable$1<number>, d: Nullable$1<Date>, e: Nullable$1<Date>): DynamicValuesFilter;
    /**
     * @hidden
     */
    private static _o;
    /**
     * @hidden
     */
    get _n(): number;
    /**
     * @hidden
     */
    abstract get _m(): ST_DynamicFilterType;
}
/**
 * Represents a filter which can filter data based on whether the data is below or above the average of the entire data range.
 * @see [[WorksheetTableColumn.filter]]
 */
export declare class AverageFilter extends DynamicValuesFilter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _x;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _p;
    private _u;
    private _s;
    constructor(a: number, b: IFilterable, c: AverageFilterType);
    constructor(a: number, b: IFilterable, c: AverageFilterType, d: number);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _f(a: Worksheet, b: number, c: number, d: number): boolean;
    /**
     * @hidden
     */
    protected get__m(): ST_DynamicFilterType;
    /**
     * @hidden
     */
    get _m(): ST_DynamicFilterType;
    /**
     * Gets the average that was computed the last time the filter was applied or 0 if any errors or all non-numeric values
     * were found when applying the filter.
     */
    get average(): number;
    /**
     * Gets or sets the value indicating whether to filter in values below or above the average of the data range.
     * AboveAverage to show cells above the average of the data range; BelowAverage to show cells below the average.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[AverageFilterType]] enumeration.
     */
    get type(): AverageFilterType;
    set type(a: AverageFilterType);
    /**
     * @hidden
     */
    private _y;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _q;
}
/**
 * A filter condition used in a [[CustomFilter]].
 * <p class="body">
 * The CustomFilterCondition contains a comparison operator and a value. The value of each cell in the data range is compared against
 * the condition value using the comparison operator.
 * </p>
 * @see [[CustomFilter.condition1]]
 * @see [[CustomFilter.condition2]]
 */
export declare class CustomFilterCondition extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _n: string;
    /**
     * @hidden
     */
    static readonly _o: string;
    private readonly _b;
    private readonly _d;
    private readonly _p;
    private readonly _l;
    private readonly _j;
    constructor(comparisonOperator: ExcelComparisonOperator, value: any);
    /**
     * Determines whether the [[CustomFilterCondition]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[CustomFilterCondition]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * @hidden
     */
    static _a(a: ST_FilterOperator, b: any): CustomFilterCondition;
    /**
     * @hidden
     */
    _m(): string;
    /**
     * @hidden
     */
    _q(a: WorkbookSaveManager, b: ST_FilterOperator, c: any): {
        p1: ST_FilterOperator;
        p2: any;
    };
    /**
     * @hidden
     */
    _g(a: Worksheet, b: WorksheetRow, c: number, d: number, e: any): boolean;
    /**
     * @hidden
     */
    static _h(a: ExcelComparisonOperator): boolean;
    /**
     * Gets the operator which describes how the cell values should be compared against [[value]].
     * @see [[value]]
     */
    get comparisonOperator(): ExcelComparisonOperator;
    /**
     * Gets the value against which the cell values should be compared.
     * @see [[comparisonOperator]]
     */
    get value(): any;
    /**
     * @hidden
     */
    get _f(): boolean;
}
/**
 * Represents a filter which can filter data based on one or two custom conditions.
 * This filter type allows you to specify one or two filter conditions which have a comparison operator and value.
 * These two filter conditions can be combined with a logical and or a logical or operation.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyCustomFilter]]
 * @see [[WorksheetTableColumn.applyCustomFilter]]
 * @see [[CustomFilterCondition]]
 */
export declare class CustomFilter extends Filter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _t;
    /**
     * @hidden
     */
    private static readonly _u;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _k;
    private _p;
    private _q;
    private _n;
    constructor(a: number, b: IFilterable, c: CustomFilterCondition);
    constructor(a: number, b: IFilterable, c: CustomFilterCondition, d: CustomFilterCondition, e: ConditionalOperator);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _g(a: boolean, b: IList$1<string>): {
        ret: boolean;
        p0: boolean;
        p1: IList$1<string>;
    };
    /**
     * Gets or sets the first condition by which to filter the cells in the data range.
     * <p class="body">
     * The first filter condition is required. Setting Condition1 to null will cause an exception to be thrown.
     * </p>
     * <p class="body">
     * When both Condition1 and [[condition2]] are set, the [[conditionalOperator]] is used to determine
     * how the conditions should be logically combined.
     * </p>
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @see [[condition2]]
     * @see [[conditionalOperator]]
     */
    get condition1(): CustomFilterCondition;
    set condition1(a: CustomFilterCondition);
    /**
     * @hidden
     */
    private _x;
    /**
     * Gets or sets the second condition by which to filter the cells in the data range.
     * <p class="body">
     * The second filter condition is optional. A value of null indicates that only [[condition1]] should be used to
     * filter the data.
     * </p>
     * <p class="body">
     * When both Condition1 and Condition2 are set, the [[conditionalOperator]] is used to determine how the conditions
     * should be logically combined.
     * </p>
     * @see [[condition1]]
     * @see [[conditionalOperator]]
     */
    get condition2(): CustomFilterCondition;
    set condition2(a: CustomFilterCondition);
    /**
     * @hidden
     */
    private _y;
    /**
     * Gets or sets the operator which defines how to logically combine [[condition1]] and [[condition2]]
     * <p class="body">
     * When both Condition1 and Condition2 are set, the ConditionalOperator is used to determine how the conditions should be logically
     * combined. If only Condition1 is set and Condition2 is null, then ConditionalOperator is ignored.
     * </p>
     * And to require both conditions to pass for the data to be filtered in. Or to allow data to be filtered in when one or both
     * conditions are met.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[conditionalOperator]] enumeration.
     * @see [[condition1]]
     * @see [[condition2]]
     */
    get conditionalOperator(): ConditionalOperator;
    set conditionalOperator(a: ConditionalOperator);
    /**
     * @hidden
     */
    private _z;
    /**
     * @hidden
     */
    private static _m;
    /**
     * @hidden
     */
    private static _l;
}
/**
 * Represents a filter which can filter dates in a specific period.
 * <p class="body">
 * This filter allows dates to be filtered in if they are in a specific month or quarter of any year.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyDatePeriodFilter]]
 * @see [[WorksheetTableColumn.applyDatePeriodFilter]]
 */
export declare class DatePeriodFilter extends DynamicValuesFilter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _y;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    private static readonly _p;
    private _s;
    private _u;
    constructor(a: IFilterable, b: DatePeriodFilterType, c: number);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    protected get__m(): ST_DynamicFilterType;
    /**
     * @hidden
     */
    get _m(): ST_DynamicFilterType;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _q;
    /**
     * @hidden
     */
    private static _ab;
    /**
     * Gets or sets the type of date period to filter in.
     * Month to filter in dates in a specific month of any year; Quarter to filter in dates in a specific quarter of any year.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[DatePeriodFilterType]] enumeration.
     * @throws [[ArgumentException]] The value assigned is Quarter and the [[value]] is less than 1 or greater than 4 or
     * the value assigned is Month and the Value is less than 1 or greater than 12.
     * @see [[value]]
     */
    get type(): DatePeriodFilterType;
    set type(a: DatePeriodFilterType);
    /**
     * @hidden
     */
    private _z;
    /**
     * Gets or sets the 1-based value of the month or quarter to filter in.
     * <p class="body">
     * If the [[type]] is Month, a Value of 1 indicates January, 2 indicates February, and so on. If Type is Quarter,
     * a Value of 1 indicates Quarter 1, and so on.
     * </p>
     * The 1-based value of the month or quarter to filter in.
     * @throws [[ArgumentException]] [[type]] is Quarter and the value assigned is less than 1 or greater than 4 or
     * Type is Month and the value assigned is less than 1 or greater than 12.
     * @see [[type]]
     */
    get value(): number;
    set value(a: number);
    /**
     * @hidden
     */
    private _aa;
}
/**
 * Abstract base class for filters which filter dates based on whether they are within a specified range of dates or not.
 * @see [[RelativeDateRangeFilter]]
 * @see [[YearToDateFilter]]
 */
export declare abstract class DateRangeFilter extends DynamicValuesFilter {
    static $t: Type;
    private _q;
    private _p;
    private _r;
    constructor(a: number, b: IFilterable);
    constructor(a: number, b: IFilterable, c: Date, d: Date);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _f(a: Worksheet, b: number, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _u(): void;
    /**
     * @hidden
     */
    abstract _v(a: Date, b: Date): {
        p0: Date;
        p1: Date;
    };
    /**
     * Gets the exclusive end date of the filtered in date range.
     * @see [[start]]
     */
    get end(): Date;
    /**
     * Gets the inclusive start date of the filtered in date range.
     * @see [[end]]
     */
    get start(): Date;
}
/**
 * @hidden
 */
export interface IColorFilter {
    _accept$2$i<TArg, TResult>($tArg: Type, $tResult: Type, a: IColorFilterVisitor$2<TArg, TResult>, b: TArg): TResult;
    readonly isCellColorFilter: boolean;
}
/**
 * @hidden
 */
export declare let IColorFilter_$type: Type;
/**
 * Represents a filter which will filter cells based on their background fills.
 * <p class="body">
 * This filter specifies a single [[CellFill]]. Cells of with this fill will be visible in the data range.
 * All other cells will be hidden.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 */
export declare class FillFilter extends Filter implements IColorFilter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    private static readonly _k;
    private _m;
    constructor(a: IFilterable, b: CellFill);
    /**
     * @hidden
     */
    _accept$2$i<TArg, TResult>($tArg: Type, $tResult: Type, visitor: IColorFilterVisitor$2<TArg, TResult>, argument: TArg): TResult;
    /**
     * @hidden
     */
    get isCellColorFilter(): boolean;
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    static _p(a: WorksheetTableColumn, b: WorksheetCellFormatData): FillFilter;
    /**
     * @hidden
     */
    private static _o;
    /**
     * @hidden
     */
    private static _l;
    /**
     * Gets or sets the [[CellFill]] by which the cells should be filtered.
     * <p class="body">
     * Cells of with this fill will be visible in the the data range. All other cells will be hidden.
     * </p>
     * The CellFill by which the cells should be filtered.
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @see [[WorksheetCell.cellFormat]]
     * @see [[IWorksheetCellFormat.fill]]
     */
    get fill(): CellFill;
    set fill(a: CellFill);
    /**
     * @hidden
     */
    private _s;
}
/**
 * Represents a fixed range of dates.
 * @see [[FixedValuesFilter.dateGroups]]
 */
export declare class FixedDateGroup extends Base {
    static $t: Type;
    private readonly _c;
    private readonly _h;
    private readonly _d;
    private readonly _i;
    constructor(type: FixedDateGroupType, value: Date);
    /**
     * Determines whether the [[FixedDateGroup]] is equal to the specified object.
     * @param obj The object to test for equality.
     * @return True if the object is equal to this instance; False otherwise.
     */
    equals(obj: any): boolean;
    /**
     * Gets the hash code for the [[FixedDateGroup]].
     * @return A number which can be used to hash this instance.
     */
    getHashCode(): number;
    /**
     * Gets the accepted date range based on the specified calendar type.
     * @param calendarType The calendar type in which to get the accepted date range.
     * @throws [[InvalidEnumArgumentException]] 'calendarType' is not defined in the [[CalendarType]] enumeration.
     * @see [[start]]
     * @see [[end]]
     * @return A [[DateRange]] where the start is the inclusive start date of the accepted date range and the end is
     * the exclusive end date.
     */
    getRange(calendarType: CalendarType): DateRange;
    /**
     * @hidden
     */
    static _b(a: ST_DateTimeGrouping, b: number, c: Nullable$1<number>, d: Nullable$1<number>, e: Nullable$1<number>, f: Nullable$1<number>, g: Nullable$1<number>): FixedDateGroup;
    /**
     * @hidden
     */
    _n(a: Calendar, b: CalendarType, c: FixedDateGroup_DateRange): {
        p2: FixedDateGroup_DateRange;
    };
    /**
     * Gets the exclusive end date of the accepted date range with a [[CalendarType]] of None.
     * @see [[start]]
     * @see [[getRange]]
     */
    get end(): Date;
    /**
     * Gets the inclusive start date of the accepted date range with a [[CalendarType]] of None.
     * @see [[end]]
     * @see [[getRange]]
     */
    get start(): Date;
    /**
     * Gets the type, or precision, of the group.
     * <p class="body">
     * The group type indicates the precision of the [[value]], which defines the range of accepted dates in the group.
     * For example, if the Type is Hour and the Value is 12/19/2011 1:29:13 PM, the date range allowed by the [[FixedDateGroup]]
     * would be 12/19/2011 1:00:00 PM to 12/19/2011 1:59:59 PM.
     * </p>
     * @see [[value]]
     */
    get type(): FixedDateGroupType;
    /**
     * Gets the reference date which determines range of accepted dates.
     * <p class="body">
     * [[type]] indicates the precision of the Value, which defines the range of accepted dates in the group.
     * For example, if the Type is Hour and the Value is 12/19/2011 1:29:13 PM, the date range allowed by the [[FixedDateGroup]]
     * would be 12/19/2011 1:00:00 PM to 12/19/2011 1:59:59 PM.
     * </p>
     * @see [[type]]
     */
    get value(): Date;
    /**
     * @hidden
     */
    get _f(): ST_DateTimeGrouping;
}
/**
 * @hidden
 */
export declare class FixedDateGroupCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: FixedDateGroupCollection, c: FixedDateGroup, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: FixedDateGroupCollection;
    readonly a: FixedDateGroup;
    readonly c: number;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of fixed date groups.
 * @see [[FixedValuesFilter.dateGroups]]
 */
export declare class FixedDateGroupCollection extends Base implements IList$1<FixedDateGroup> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _f;
    /**
     * @hidden
     */
    private static readonly _h;
    /**
     * @hidden
     */
    private static readonly _g;
    /**
     * @hidden
     */
    private static _a;
    /**
     * @hidden
     */
    _d: FixedValuesFilter;
    private _e;
    static staticInit(): void;
    constructor(a: FixedValuesFilter);
    /**
     * @hidden
     */
    copyTo(array: FixedDateGroup[], arrayIndex: number): void;
    /**
     * @hidden
     */
    get isReadOnly(): boolean;
    [Symbol.iterator](): EnumeratorWrapper<FixedDateGroup>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<FixedDateGroup>;
    /**
     * @hidden
     */
    getEnumeratorObject(): IEnumerator;
    /**
     * Adds a fixed date group to the collection.
     * @param item The fixed date group to add to the collection.
     * @throws [[ArgumentNullException]] 'item' is null.
     * @throws [[ArgumentException]] 'item' is already in the collection.
     */
    add(item: FixedDateGroup): void;
    /**
     * Clears the collection.
     * @throws [[InvalidOperationException]] The collection is owned by a [[FixedValuesFilter]] which only allowed the values in the collection.
     * Clearing the collection would prevent the filter from including any values, which is not allowed for a FixedValuesFilter.
     */
    clear(): void;
    /**
     * Determines whether the specified fixed date group is in the collection.
     * @param item The fixed date group to find in the collection.
     * @return True if the item is in the collection; False otherwise.
     */
    contains(item: FixedDateGroup): boolean;
    /**
     * Gets the index of the specified fixed date group in the collection.
     * @param item The fixed date group to find in the collection.
     * @return The 0-based index of the specified fixed date group in the collection or -1 if the item is not in the collection.
     */
    indexOf(item: FixedDateGroup): number;
    /**
     * Inserts a fixed date group into the collection.
     * @param index The 0-based index where the value should be inserted.
     * @param item The fixed date group to insert into the collection.
     * @throws [[ArgumentNullException]] 'item' is null.
     * @throws [[ArgumentException]] 'item' is already in the collection.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than [[count]].
     */
    insert(index: number, item: FixedDateGroup): void;
    /**
     * Removes the fixed date group from the collection.
     * @param item The fixed date group to remove from the collection.
     * @return True if the value was found and removed; False otherwise.
     */
    remove(item: FixedDateGroup): boolean;
    /**
     * Removes the fixed date group at the specified index.
     * @param index The 0-based index of the value to remove.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @throws [[InvalidOperationException]] This operation removes the last item in the collection and it is owned by a [[FixedValuesFilter]] which only
     * allowed the values in the collection. Clearing the collection would prevent the filter from including any values, which
     * is not allowed for a FixedValuesFilter.
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _j;
    /**
     * @hidden
     */
    private _k;
    /**
     * @hidden
     */
    private _i;
    /**
     * @hidden
     */
    private _l;
    /**
     * @hidden
     */
    private static _m;
    /**
     * @hidden
     */
    private static _n;
    /**
     * @hidden
     */
    private _o;
    /**
     * Gets the number of fixed date groups in the collection.
     */
    get count(): number;
    /**
     * Gets or sets the fixed date group at the specified index.
     * @param index The 0-based index of the value to get or set.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @throws [[ArgumentException]] The value assigned is already in the collection.
     */
    item(a: number, b?: FixedDateGroup): FixedDateGroup;
}
/**
 * Represents a filter which can filter cells based on specific, fixed values, which are allowed to display.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyFixedValuesFilter]]
 * @see [[WorksheetTableColumn.applyFixedValuesFilter]]
 * @see [[WorksheetTableColumn.applyFixedValuesFilter]]
 * @see [[WorksheetTableColumn.applyFixedValuesFilter]]
 */
export declare class FixedValuesFilter extends Filter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static readonly _k;
    private _x;
    private _p;
    private _r;
    private _n;
    private _t;
    constructor(a: IFilterable);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _g(a: boolean, b: IList$1<string>): {
        ret: boolean;
        p0: boolean;
        p1: IList$1<string>;
    };
    /**
     * @hidden
     */
    _aa(): number;
    /**
     * @hidden
     */
    _ab(a: boolean, b: IList$1<string>): {
        ret: number;
        p1: IList$1<string>;
    };
    /**
     * @hidden
     */
    private static _m;
    /**
     * @hidden
     */
    private static _l;
    /**
     * Gets or sets the calendar type used to interpret values in the [[dateGroups]] collection.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[calendarType]] enumeration.
     */
    get calendarType(): CalendarType;
    set calendarType(a: CalendarType);
    /**
     * @hidden
     */
    private _ae;
    /**
     * Gets or sets the fixed date group at the specified index.
     * @param index The 0-based index of the value to get or set.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @throws [[ArgumentException]] The value assigned is already in the collection.
     */
    dateGroups(index: number, value?: FixedDateGroup): FixedDateGroup;
    /**
     * Gets the collection of fixed date groups which should be filtered in.
     * @see [[displayValues]]
     */
    dateGroups(): FixedDateGroupCollection;
    /**
     * @hidden
     */
    get _dateGroups$i(): FixedDateGroupCollection;
    /**
     * Gets or sets the display text value at the specified index.
     * @param index The 0-based index of the value to get or set.
     * @throws [[ArgumentOutOfRangeException]] 'index' is less than 0 or greater than or equal to [[count]].
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @throws [[ArgumentException]] The value assigned matches another value in the collection. Values are compared case-insensitively.
     */
    displayValues(index: number, value?: string): string;
    /**
     * Gets the collection of cell text values which should be filtered in.
     * <p class="body">
     * Text values are compared case-insensitively.
     * </p>
     * <p class="note">
     * <b>Note:</b> If any text values are longer than 255 characters in length and the workbook is saved in one of the 2003 formats,
     * the correct rows will be hidden in the saved file, but the filter may be missing from the column or reapplying the filter
     * may hide some of the matching cells.
     * </p>
     * @see [[dateGroups]]
     * @see [[WorksheetCell.getText]]
     * @see [[WorksheetRow.getCellText]]
     */
    displayValues(): DisplayValueCollection;
    /**
     * @hidden
     */
    get _displayValues$i(): DisplayValueCollection;
    /**
     * Gets or sets the value which indicates whether blank cells should be filtered in.
     * @throws [[InvalidOperationException]] The value is set to False and both [[dateGroups]] and [[displayValues]] contain no values.
     * This would prevent the filter from including any values, which is not allowed for a [[FixedValuesFilter]].
     */
    get includeBlanks(): boolean;
    set includeBlanks(a: boolean);
    /**
     * @hidden
     */
    private set _v(value);
    /**
     * @hidden
     */
    private _af;
    /**
     * @hidden
     */
    get _y(): Calendar;
    /**
     * @hidden
     */
    get _w(): boolean;
}
/**
 * Represents a filter which will filter cells based on their font colors.
 * <p class="body">
 * This filter specifies a single color. Cells with this color font will be visible in the data range. All other cells
 * will be hidden.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyFontColorFilter]]
 */
export declare class FontColorFilter extends Filter implements IColorFilter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _q;
    /**
     * @hidden
     */
    private static readonly _r;
    /**
     * @hidden
     */
    private static readonly _k;
    private _o;
    constructor(a: IFilterable, b: WorkbookColorInfo);
    /**
     * @hidden
     */
    _accept$2$i<TArg, TResult>($tArg: Type, $tResult: Type, visitor: IColorFilterVisitor$2<TArg, TResult>, argument: TArg): TResult;
    /**
     * @hidden
     */
    get isCellColorFilter(): boolean;
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    static _n(a: WorksheetTableColumn, b: WorksheetCellFormatData): FontColorFilter;
    /**
     * @hidden
     */
    private static _m;
    /**
     * @hidden
     */
    private static _l;
    /**
     * Gets or sets the [[WorkbookColorInfo]] which describes the font color by which the cells should be filtered.
     * <p class="body">
     * Cells of this font color will be visible in the the data range. All other cells will be hidden.
     * </p>
     * The WorkbookColorInfo which describes the color by which the cells should be filtered.
     * @throws [[ArgumentNullException]] The value assigned is null.
     * @see [[Type]]
     * @see [[WorksheetCell.cellFormat]]
     * @see [[IWorksheetCellFormat.font]]
     * @see [[IWorkbookFont.colorInfo]]
     */
    get fontColorInfo(): WorkbookColorInfo;
    set fontColorInfo(a: WorkbookColorInfo);
    /**
     * @hidden
     */
    private _s;
}
/**
 * Represents a filter which can filter cells based on their conditional formatting icon.
 * <p class="body">
 * This filter allows cells to be filtered in if their conditional formatting icon matches the criteria.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 * @see [[ConditionalFormatCollection.addIconSetCondition]]
 */
export declare class IconFilter extends Filter {
    static $t: Type;
    private readonly _n;
    private readonly _l;
    constructor(a: IFilterable, b: ST_IconSetType, c: Nullable$1<number>);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * The icon set (read-only).
     */
    get iconIndex(): number | null;
    /**
     * @hidden
     */
    get _iconIndex$i(): Nullable$1<number>;
    /**
     * The icon's index in the associated icon set or null for 'NoCellIcon' (read-only).
     */
    get iconSet(): FormatConditionIconSet;
    /**
     * @hidden
     */
    get _p(): Nullable$1<number>;
    /**
     * @hidden
     */
    get _m(): ST_IconSetType;
}
/**
 * Represents a filter which can filter date cells based on dates relative to the when the filter was applied.
 * <p class="body">
 * The RelativeDateRangeFilter allows you to filter in dates which are in the previous, current, or next time period
 * relative to the date when the filter was applied. The time periods available are day, week, month, quarter, year.
 * So when using the previous filter type with a day duration, a 'yesterday' filter is created. Or when using a current
 * filter type with a year duration, a 'this year' filter is created. However, these filters compare the data against
 * the date when the filter was created. So a 'this year' filter created in 1999 will filter in all cells containing
 * dates in 1999, even if the workbook is opened in 2012.
 * </p>
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyRelativeDateRangeFilter]]
 */
export declare class RelativeDateRangeFilter extends DateRangeFilter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _w;
    private _z;
    private _ab;
    constructor(a: number, b: IFilterable, c: RelativeDateRangeOffset, d: RelativeDateRangeDuration);
    constructor(a: number, b: IFilterable, c: RelativeDateRangeOffset, d: RelativeDateRangeDuration, e: Date, f: Date);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    private _ag;
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _v(a: Date, b: Date): {
        p0: Date;
        p1: Date;
    };
    /**
     * @hidden
     */
    protected get__m(): ST_DynamicFilterType;
    /**
     * @hidden
     */
    get _m(): ST_DynamicFilterType;
    /**
     * Gets or sets the duration of the full range of accepted dates.
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[RelativeDateRangeDuration]] enumeration.
     * @see [[offset]]
     */
    get duration(): RelativeDateRangeDuration;
    set duration(a: RelativeDateRangeDuration);
    /**
     * @hidden
     */
    private _ah;
    /**
     * Gets or sets the offset of relative filter (previous, current, or next).
     * <p class="body">
     * Type combined with [[duration]] determines the relative date range to filter.
     * </p>
     * @throws [[InvalidEnumArgumentException]] The value assigned is not defined in the [[RelativeDateRangeOffset]] enumeration.
     * @see [[duration]]
     */
    get offset(): RelativeDateRangeOffset;
    set offset(a: RelativeDateRangeOffset);
    /**
     * @hidden
     */
    private _ai;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * Represents a filter which can filter in cells in the upper or lower portion of the sorted values.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyTopOrBottomFilter]]
 * @see [[WorksheetTableColumn.applyTopOrBottomFilter]]
 */
export declare class TopOrBottomFilter extends DynamicValuesFilter {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _ab;
    /**
     * @hidden
     */
    private static readonly _p;
    private _y;
    private _s;
    private _aa;
    constructor(a: number, b: IFilterable);
    constructor(a: number, b: IFilterable, c: TopOrBottomFilterType, d: number);
    constructor(a: number, b: IFilterable, c: TopOrBottomFilterType, d: number, e: number);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRow, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _f(a: Worksheet, b: number, c: number, d: number): boolean;
    /**
     * @hidden
     */
    _g(a: boolean, b: IList$1<string>): {
        ret: boolean;
        p0: boolean;
        p1: IList$1<string>;
    };
    /**
     * @hidden
     */
    protected get__m(): ST_DynamicFilterType;
    /**
     * @hidden
     */
    get _m(): ST_DynamicFilterType;
    /**
     * @hidden
     */
    static _t(a: boolean, b: boolean): TopOrBottomFilterType;
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _q;
    /**
     * @hidden
     */
    private static _ah;
    /**
     * Gets or sets the type of the filter.
     * TopValues or BottomValues to filter in the top or bottom N value in the list of sorted values; TopPercentage or BottomPercentage
     * to filter in the top or bottom N percentage of values in the list of sorted values.
     * @throws [[InvalidEnumArgumentException]] The value assign is not defined in the [[TopOrBottomFilterType]] enumeration.
     * @see [[value]]
     */
    get type(): TopOrBottomFilterType;
    set type(a: TopOrBottomFilterType);
    /**
     * @hidden
     */
    private _af;
    /**
     * Gets or sets the number or percentage of value of values which should be filtered in.
     * <p class="body">
     * When [[type]] is TopValues or BottomValues, Value indicates the number of value which should be filtered in.
     * When Type is TopPercentage or BottomPercentage, Value indicates percentage to filter in. For example, a Value of 15 and
     * a Type of BottomPercentage will filter in the bottom 15 percent of values.
     * </p>
     * The number or percentage of items which should be filtered in.
     * @throws [[ArgumentOutOfRangeException]] The value assigned is less than 1 or greater than 500.
     */
    get value(): number;
    set value(a: number);
    /**
     * @hidden
     */
    private _ag;
    /**
     * @hidden
     */
    get _v(): ST_FilterOperator;
    /**
     * @hidden
     */
    get _w(): boolean;
    /**
     * @hidden
     */
    get _x(): boolean;
    /**
     * @hidden
     */
    get _z(): number;
}
/**
 * @hidden
 */
export declare class WorksheetColumnFilter extends Base implements IFilterable, IComparable$1<WorksheetColumnFilter> {
    static $t: Type;
    private readonly _c;
    private _d;
    private _a;
    constructor(a: number, b: Worksheet);
    constructor(a: number, b: Worksheet, c: number);
    constructor(a: number, ..._rest: any[]);
    _g(a: Filter): void;
    _h(a: number): void;
    get columnIndex(): number;
    get filter(): Filter;
    get _e(): WorksheetRegionAddress;
    get _f(): number;
    get workbook(): Workbook;
    get worksheet(): Worksheet;
    onFilterModified(): void;
    _b(a: CellShiftOperation, b: ICellShiftOperationOverride): ShiftAddressResult;
    compareTo(a: WorksheetColumnFilter): number;
    getDataAreaRowIndexes(a: number, b: number): {
        p0: number;
        p1: number;
    };
}
/**
 * @hidden
 */
export declare class WorksheetFilterSettings_AddFilterChangeInfo extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetColumnFilter);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private a;
    readonly c: number;
    readonly b: WorksheetRegionAddress;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * @hidden
 */
export declare class WorksheetFilterSettings_RemoveFilterChangeInfo extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: WorksheetColumnFilter);
    constructor();
    constructor(a: number, ..._rest: any[]);
    private b;
    a: Filter;
    readonly d: number;
    readonly c: WorksheetRegionAddress;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Exposes methods to identify a region in the wroksheet and to apply filters and optionally sort criteria to that region.
 */
export declare class WorksheetFilterSettings extends Base implements ISortSettingsOwner, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _as;
    /**
     * @hidden
     */
    private static readonly _av;
    /**
     * @hidden
     */
    private static readonly _aw;
    /**
     * @hidden
     */
    private static readonly _ax;
    /**
     * @hidden
     */
    private static readonly _au;
    /**
     * @hidden
     */
    private static _a;
    private _ap;
    private _aq;
    private _az;
    private _a0;
    private _ak;
    private _ac;
    private _ay;
    private _ai;
    private _ar;
    private _x;
    private _aa;
    private _am;
    private _al;
    static staticInit(): void;
    constructor(a: Worksheet);
    /**
     * Returns the total region including the filter headers (read-only).
     * @see [[setRegion]]
     * @see [[setRegion]]
     * @see [[sortAndFilterAreaRegion]]
     */
    get region(): WorksheetRegion;
    /**
     * Returns the region that the filters and sort settings are applied to (read-only).
     * @see [[setRegion]]
     * @see [[setRegion]]
     * @see [[region]]
     * @see [[sortSettings]]
     */
    get sortAndFilterAreaRegion(): WorksheetRegion;
    /**
     * Gets the settings which determine how the data within the worksheet's filer region should be sorted.
     * <p class="note">
     * <B>Note:</B> Sort conditions are not constantly evaluated as data within the region changes. Sort conditions are applied to the region
     * only when they are are added or removed or when the [[reapplySortConditions]] method is called.
     * </p>
     * @see [[reapplySortConditions]]
     */
    get sortSettings(): RelativeIndexSortSettings;
    /**
     * @hidden
     */
    get _at(): number;
    /**
     * @hidden
     */
    private get _aj();
    /**
     * @hidden
     */
    get _ag(): WorksheetRegionAddress;
    /**
     * @hidden
     */
    set _ag(a: WorksheetRegionAddress);
    /**
     * @hidden
     */
    private _bk;
    /**
     * @hidden
     */
    private get _ah();
    /**
     * @hidden
     */
    private set _ah(value);
    /**
     * @hidden
     */
    private _bl;
    /**
     * Applies an [[AverageFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param type The value indicating whether to filter in values below or above the average of the data range.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[AverageFilterType]] enumeration.
     * @see [[AverageFilter]]
     * @see [[getFilter]]
     * @see [[clearFilters]]
     */
    applyAverageFilter(relativeColumnIndex: number, type: AverageFilterType): AverageFilter;
    /**
     * Applies a [[CustomFilter]] to the column.
     * <p class="note">
     * <b>Note:</b> If the filter condition value is longer than 255 characters in length and the workbook is saved in one of
     * the 2003 formats, the correct rows will be hidden in the saved file, but the filter will be missing from the column.
     * </p>
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param condition The condition which must pass for the data to be filtered in.
     * @throws [[ArgumentNullException]] 'condition' is null.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[CustomFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyCustomFilter(relativeColumnIndex: number, condition: CustomFilterCondition): CustomFilter;
    /**
     * Applies a [[CustomFilter]] to the column.
     * <p class="body">
     * If 'condition2' is null, the 'conditionalOperator' value is irrelevant.
     * </p>
     * <p class="note">
     * <b>Note:</b> If one of the filter condition values is longer than 255 characters in length and the workbook is saved in one of
     * the 2003 formats, the correct rows will be hidden in the saved file, but the filter will be missing from the column.
     * </p>
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param condition1 The first condition used to filter the data.
     * @param condition2 The second condition used to filter the data.
     * @param conditionalOperator The operator which defines how to logically combine 'condition1' and 'condition2'.
     * @throws [[ArgumentNullException]] 'condition1' is null.
     * @throws [[InvalidEnumArgumentException]] 'conditionalOperator' is not defined in the [[ConditionalOperator]] enumeration.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[CustomFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyCustomFilter(relativeColumnIndex: number, condition1: CustomFilterCondition, condition2: CustomFilterCondition, conditionalOperator: ConditionalOperator): CustomFilter;
    /**
     * @hidden
     */
    _applyCustomFilter(a: number, b: CustomFilterCondition): CustomFilter;
    /**
     * @hidden
     */
    _applyCustomFilter1(a: number, b: CustomFilterCondition, c: CustomFilterCondition, d: ConditionalOperator): CustomFilter;
    /**
     * Applies an [[DatePeriodFilter]] to the column.
     * <p class="body">
     * If the 'type' is Month, a 'value' of 1 indicates January, 2 indicates February, and so on.
     * If type is Quarter, a value of 1 indicates Quarter 1, and so on.
     * </p>
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param type The type of date period to filter in.
     * @param value The 1-based value of the month or quarter to filter in.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[DatePeriodFilterType]] enumeration.
     * @throws [[ArgumentException]] 'type' is Quarter and 'value' is less than 1 or greater than 4 or
     * type is Month and value is less than 1 or greater than 12.
     * @see [[DatePeriodFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyDatePeriodFilter(relativeColumnIndex: number, type: DatePeriodFilterType, value: number): DatePeriodFilter;
    /**
     * Applies a [[FillFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param fill A [[CellFill]] by which the cells should be filtered.
     * @throws [[ArgumentNullException]] 'fill' is null.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[FillFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyFillFilter(relativeColumnIndex: number, fill: CellFill): FillFilter;
    /**
     * @hidden
     */
    _k(a: number, b: boolean, ...c: string[]): FixedValuesFilter;
    /**
     * @hidden
     */
    _n(a: number, b: boolean, c: IEnumerable$1<string>): FixedValuesFilter;
    /**
     * @hidden
     */
    _o(a: number, b: boolean, c: IEnumerable$1<FixedDateGroup>): FixedValuesFilter;
    /**
     * Applies a [[FixedValuesFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param includeBlanks The value which indicates whether blank cells should be filtered in.
     * @param calendarType The calendar type used to interpret values in the 'dateGroups' collection.
     * @param dateGroups The collection of fixed date groups which should be filtered in.
     * @throws [[ArgumentNullException]] 'dateGroups' is null.
     * @throws [[InvalidEnumArgumentException]] 'calendarType' is not defined in the [[CalendarType]] enumeration.
     * @throws [[ArgumentNullException]] A FixedDateGroup in the 'dateGroups' collection is null.
     * @throws [[ArgumentException]] Multiple items in 'dateGroups' are equal to each other.
     * @throws [[InvalidOperationException]] 'includeBlanks' is False and 'dateGroups' has no items. At least one value must be allowed.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[FixedValuesFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyFixedValuesFilter(relativeColumnIndex: number, includeBlanks: boolean, calendarType: CalendarType, ...dateGroups: FixedDateGroup[]): FixedValuesFilter;
    /**
     * @hidden
     */
    _applyFixedValuesFilter1(a: number, b: boolean, c: CalendarType, ...d: FixedDateGroup[]): FixedValuesFilter;
    /**
     * @hidden
     */
    _m(a: number, b: boolean, c: CalendarType, d: IEnumerable$1<FixedDateGroup>): FixedValuesFilter;
    /**
     * Applies a [[FontColorFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param fontColorInfo A [[WorkbookColorInfo]] which describes the font color by which the cells should be filtered.
     * @throws [[ArgumentNullException]] 'fontColorInfo' is null.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[FontColorFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyFontColorFilter(relativeColumnIndex: number, fontColorInfo: WorkbookColorInfo): FontColorFilter;
    /**
     * Applies a [[FontColorFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param fontColor The font color by which the cells should be filtered.
     * @throws [[ArgumentNullException]] 'fontColor' is empty.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[FontColorFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyFontColorFilter(relativeColumnIndex: number, fontColor: string | Color): FontColorFilter;
    /**
     * @hidden
     */
    _applyFontColorFilter1(a: number, b: Color): FontColorFilter;
    /**
     * @hidden
     */
    _applyFontColorFilter(a: number, b: WorkbookColorInfo): FontColorFilter;
    /**
     * Applies a [[IconFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param iconSet The icon set containing the icon.
     * @throws [[ArgumentException]] If the icon set is not valid.
     * @param iconIndex The zero-based index of the icon in the set or null for 'NoCellIcon'.
     * @throws [[IndexOutOfRangeException]] If the index is less than zero or greater than or equal to the number of icons in the icon set..
     * @throws [[InvalidOperationException]] The [[WorksheetTable.isFilterUIVisible]] value of the owning table is False.
     * Filters cannot be applied when the header row or filter button is hidden.
     * @throws [[InvalidOperationException]] If column was removed from the table.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @throws [[InvalidEnumArgumentException]] 'iconSet' is not defined in the [[FormatConditionIconSet]] enumeration.
     * @see [[IconFilter]]
     * @see [[Filter]]
     * @see [[clearFilter]]
     * @see [[ConditionalFormatCollection.addIconSetCondition]]
     */
    applyIconFilter(relativeColumnIndex: number, iconSet: FormatConditionIconSet, iconIndex: number | null): IconFilter;
    /**
     * @hidden
     */
    _applyIconFilter$i(a: number, b: FormatConditionIconSet, c: Nullable$1<number>): IconFilter;
    /**
     * @hidden
     */
    _s(a: number, b: ST_IconSetType, c: Nullable$1<number>): IconFilter;
    /**
     * Applies a [[RelativeDateRangeFilter]] to the column.
     * <p class="body">
     * The RelativeDateRangeFilter allows you to filter in dates which are in the previous, current, or next time period
     * relative to the date when the filter was applied. The time periods available are day, week, month, quarter, year.
     * So when using the previous filter type with a day duration, a 'yesterday' filter is created. Or when using a current
     * filter type with a year duration, a 'this year' filter is created. However, these filters compare the data against
     * the date when the filter was created. So a 'this year' filter created in 1999 will filter in all cells containing
     * dates in 1999, even if the workbook is opened in 2012.
     * </p>
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param offset The offset of relative filter. This combined with the 'duration' determines the full range of accepted dates.
     * @param duration The duration of the full range of accepted dates.
     * @throws [[InvalidEnumArgumentException]] 'offset' is not defined in the [[RelativeDateRangeOffset]] enumeration.
     * @throws [[InvalidEnumArgumentException]] 'duration' is not defined in the [[RelativeDateRangeDuration]] enumeration.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[RelativeDateRangeFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyRelativeDateRangeFilter(relativeColumnIndex: number, offset: RelativeDateRangeOffset, duration: RelativeDateRangeDuration): RelativeDateRangeFilter;
    /**
     * Applies a [[TopOrBottomFilter]] to the column which will filter in the top 10 values in the list of sorted values.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[TopOrBottomFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyTopOrBottomFilter(relativeColumnIndex: number): TopOrBottomFilter;
    /**
     * Applies a [[TopOrBottomFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @param type The type of the filter.
     * @param value The number or percentage of value of values which should be filtered in.
     * @throws [[InvalidEnumArgumentException]] 'type' is not defined in the [[TopOrBottomFilterType]] enumeration.
     * @throws [[ArgumentOutOfRangeException]] 'value' is less than 1 or greater than 500.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[TopOrBottomFilter]]
     * @see [[getFilter]]
     * @see [[clearFilter]]
     */
    applyTopOrBottomFilter(relativeColumnIndex: number, type: TopOrBottomFilterType, value: number): TopOrBottomFilter;
    /**
     * @hidden
     */
    _applyTopOrBottomFilter(a: number): TopOrBottomFilter;
    /**
     * @hidden
     */
    _applyTopOrBottomFilter1(a: number, b: TopOrBottomFilterType, c: number): TopOrBottomFilter;
    /**
     * Applies a [[YearToDateFilter]] to the column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     * @see [[YearToDateFilter]]
     * @see [[Filter]]
     * @see [[clearFilter]]
     */
    applyYearToDateFilter(relativeColumnIndex: number): YearToDateFilter;
    /**
     * Clears the filter that is applied to a specific column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     */
    clearFilter(relativeColumnIndex: number): void;
    /**
     * Clears all previously applied filters
     */
    clearFilters(): void;
    /**
     * Clears the region as well as any existing filters and sort criteria
     * @see [[setRegion]]
     * @see [[setRegion]]
     */
    clearRegion(): void;
    /**
     * Gets the filter that is applied to a specific column.
     * @param relativeColumnIndex A zero based column index relative to the [[region]]
     * @return The apllied filter or null if no filter was applied to this column.
     * @throws [[InvalidOperationException]] If the [[region]] was not set.
     * @throws [[ArgumentOutOfRangeException]] If the relativeColumnIndex is outside of the [[region]].
     */
    getFilter(relativeColumnIndex: number): Filter;
    /**
     * Re-filters all data cells in the filter region based on the applied filters.
     * <p class="body">
     * Filters are not constantly evaluated as data within the region changes. Filters are applied to the region only when they are
     * added or removed or when the ReapplyFilters method is called.
     * </p>
     * <p class="body">
     * If no filters are applied this method will not do anything to the data.
     * </p>
     * <p class="note">
     * <B>Note:</B> When the filters are reevaluated, the rows of any cells which don't meet the filter criteria of their column will
     * be hidden. When a row is filtered out, the entire row is hidden from the worksheet, so any data outside the table but in the
     * same row will also be hidden.
     * </p>
     * @see [[clearFilters]]
     */
    reapplyFilters(): void;
    /**
     * @hidden
     */
    private _be;
    /**
     * Re-sorts all data cells in the region based on the sort conditions.
     * @see [[sortSettings]]
     */
    reapplySortConditions(): void;
    /**
     * Sets the region where the filter settings should be applied
     * <p class="body">The [[Workbook.cellReferenceMode]] of the workbook will be used to parse the region address.</p>
     * <p class="note"><b>Note:</b> setting the region will clear any applied filters or sort criteria.</p>
     * @param address The address of the new region.
     * @throws [[InvalidOperationException]] If the region intersects with a table of other reserved area in the worksheet.
     * @see [[region]]
     * @see [[setRegion]]
     * @see [[clearRegion]]
     */
    setRegion(address: string): void;
    /**
     * Sets the region where the filter settings should be applied
     * <p class="note"><b>Note:</b> setting the region will clear any applied filters or sort criteria.</p>
     * @param address The address of the new region.
     * @param cellReferenceMode The reference to use the parse the address.
     * @throws [[InvalidOperationException]] If the region intersects with a table of other reserved area in the worksheet.
     * @see [[region]]
     * @see [[setRegion]]
     * @see [[clearRegion]]
     */
    setRegion(address: string, cellReferenceMode: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setRegion(a: string): void;
    /**
     * @hidden
     */
    _setRegion1(a: string, b: CellReferenceMode): void;
    /**
     * @hidden
     */
    _bm(a: WorksheetRegion): void;
    /**
     * @hidden
     */
    _a3(a: WorksheetColumnFilter): void;
    /**
     * @hidden
     */
    _ad(a: RelativeIndex): WorksheetRegion;
    /**
     * @hidden
     */
    _ba(a: WorkbookFormat): void;
    /**
     * @hidden
     */
    _bc(): void;
    /**
     * @hidden
     */
    _bg(): void;
    /**
     * @hidden
     */
    _z(a: CellShiftOperation, b: ICellShiftOperationOverride): ShiftAddressResult;
    /**
     * @hidden
     */
    _bn(): void;
    /**
     * @hidden
     */
    _bo(): void;
    /**
     * @hidden
     */
    _bp(): void;
    /**
     * @hidden
     */
    _bq(a: NamedReference, b: boolean): void;
    /**
     * @hidden
     */
    _bu(a: boolean, b: NamedReference, c: boolean): {
        p1?: NamedReference;
        p2: boolean;
    };
    /**
     * @hidden
     */
    private _a4;
    /**
     * @hidden
     */
    private _a2;
    /**
     * @hidden
     */
    private _a5;
    /**
     * @hidden
     */
    private _a9;
    /**
     * @hidden
     */
    private _w;
    /**
     * @hidden
     */
    private _an;
    /**
     * @hidden
     */
    private get _ao();
    /**
     * @hidden
     */
    private set _ao(value);
    /**
     * @hidden
     */
    private _bh;
    /**
     * @hidden
     */
    private _bv;
    /**
     * @hidden
     */
    private _bt;
    /**
     * @hidden
     */
    private _bw;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _d;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _a1;
    /**
     * @hidden
     */
    private _bb;
    /**
     * @hidden
     */
    private static _br;
    /**
     * @hidden
     */
    private static _bs;
    /**
     * @hidden
     */
    onSortSettingsModified(): void;
    /**
     * @hidden
     */
    get culture(): string | CultureInfo;
    /**
     * @hidden
     */
    get _culture$i(): CultureInfo;
    /**
     * @hidden
     */
    get sortRegion(): WorksheetRegion;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get worksheet(): Worksheet;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    get sheet(): Sheet;
}
/**
 * Represents a filter which can filter in date cells if the dates occur between the start of the current year
 * and the time when the filter is evaluated.
 * @see [[WorksheetTableColumn.filter]]
 * @see [[WorksheetTableColumn.applyYearToDateFilter]]
 */
export declare class YearToDateFilter extends DateRangeFilter {
    static $t: Type;
    constructor(a: number, b: IFilterable);
    constructor(a: number, b: IFilterable, c: Date, d: Date);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _d(a: Filter): boolean;
    /**
     * @hidden
     */
    _v(a: Date, b: Date): {
        p0: Date;
        p1: Date;
    };
    /**
     * @hidden
     */
    protected get__m(): ST_DynamicFilterType;
    /**
     * @hidden
     */
    get _m(): ST_DynamicFilterType;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's value is above or below the average or standard deviation
 * for the associated range.
 */
export declare class AverageConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ca: string;
    /**
     * @hidden
     */
    static readonly _cb: string;
    /**
     * @hidden
     */
    private static readonly _b6;
    /**
     * @hidden
     */
    private static readonly _b9;
    /**
     * @hidden
     */
    private static readonly _b7;
    /**
     * @hidden
     */
    private static readonly _b0;
    private _b3;
    private _b5;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: FormatConditionAboveBelow);
    constructor(a: number, ..._rest: any[]);
    /**
     * Returns or sets a value which determines the manner in which cell values
     * are compared against the average or standard deviation for the associated
     * range.
     */
    get aboveBelow(): FormatConditionAboveBelow;
    set aboveBelow(a: FormatConditionAboveBelow);
    /**
     * @hidden
     */
    protected get__j(): FormatConditionNotificationType;
    /**
     * Returns or sets the numeric standard deviation for this condition.
     * Applicable only when the [[aboveBelow]] property is set
     * to 'AboveStandardDeviation' or 'BelowStandardDeviation'.
     */
    get numericStandardDeviation(): number;
    set numericStandardDeviation(a: number);
    /**
     * @hidden
     */
    private static _b2;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value is not set.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells with no value.
 * </p>
 * <p class="body">
 * To negate this condition, use the [[NoBlanksConditionalFormat]] class.
 * </p>
 * <p class="body">
 * Since empty cells do not display content, the foreground-related properties of the
 * [[ConditionalFormatBase.cellFormat]] are not applicable.
 * </p>
 * @see [[NoBlanksConditionalFormat]]
 */
export declare class BlanksConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__x(): boolean;
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Base class for the [[DataBarConditionalFormat]], [[IconSetConditionalFormat]],
 * and [[ColorScaleConditionalFormat]] classes.
 */
export declare abstract class ThresholdConditionBase extends ConditionBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _b4: string;
    /**
     * @hidden
     */
    private static readonly _b2;
    /**
     * @hidden
     */
    private static readonly _b3;
    /**
     * @hidden
     */
    private static readonly _bt;
    private _bx;
    constructor();
    constructor(regions: IList$1<WorksheetRegion>, conditionType: FormatConditionType);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    protected get__z(): boolean;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _a9(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    protected get__j(): FormatConditionNotificationType;
    /**
     * @hidden
     */
    _bb(): void;
    /**
     * @hidden
     */
    _bd(): void;
    /**
     * @hidden
     */
    _bf(): void;
    /**
     * @hidden
     */
    protected get__ah(): boolean;
    /**
     * @hidden
     */
    _bq(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _a4(a: any, b: string): string;
    /**
     * Returns the <see cref="Excel.Formula">formula</see> which determines the values to which
     * this condition applies.
     * <para class="note"><b>Note:</b> the formula should return a boolean result. When the formula is applied to cells in the region if the formula returns false then those cells will not be included in the formatting.</para>
     * @see [[setFormula]]
     */
    get formula(): Formula;
    /**
     * @hidden
     */
    get _by(): SingleTargetFormula;
    /**
     * @hidden
     */
    set _by(a: SingleTargetFormula);
    /**
     * @hidden
     */
    private static _bv;
    /**
     * @hidden
     */
    private static _bu;
    /**
     * @hidden
     */
    _b1(a: number, b: number, c: ConditionValue, d: RefBase): number;
    /**
     * @hidden
     */
    _b0(a: number, b: FormatConditionValueType): number;
    /**
     * Assigns a new [[Formula]] to the [[formula]] property.
     * <para class="note"><b>Note:</b> the formula should return a boolean result. When the formula is applied to cells in the region if the formula returns false then those cells will not be included in the formatting.</para>
     * @param formula The string representation of the formula.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     * @see [[formula]]
     */
    setFormula(formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setFormula$i(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    _bz(a: RefBase): boolean;
    /**
     * @hidden
     */
    _b6(a: SingleTargetFormula): void;
}
/**
 * Exposes properties which control the coloring of a [[WorksheetCell]]
 * based on the cell's value as relative to minimum, midpoint, and maximum threshold values.
 * <p class="body">
 * This class support either a 2-color or 3-color scale, as determined by the value of the
 * <see cref="ColorScaleConditionalFormat.ColorScaleConditionalFormat(IList<WorksheetRegion>, ColorScaleType)">colorScaleType</see>
 * parameter of the constructor.
 * </p>
 * <p class="body">
 * For 2-color scales, cells in the associated range are colored based on how their
 * value relates to the <see cref="MinimumThreshold">minimum</see> and <see cref="MaximumThreshold">maximum</see>
 * thresholds.
 * </p>
 * <p class="body">
 * For 3-color scales, cells in the associated range are colored based on how their
 * value relates to the minimum, <see cref="MidpointThreshold">midpoint</see>, and
 * maximum thresholds.
 * </p>
 * <p class="body">
 * This class supports a maximum of three separate and distinct color thresholds.
 * </p>
 * <p class="body">
 * Specifying only one threshold is not supported and may result in unexpected behavior.
 * </p>
 * <p class="body">
 * If this instance is created as a 2-color scale, the [[midpointThreshold]]
 * property is not applicable. Attempting to set a property on the object returned from
 * the MidpointThreshold property in this case will cause an exception to be thrown.
 * </p>
 * @see [[minimumThreshold]]
 * @see [[maximumThreshold]]
 * @see [[midpointThreshold]]
 * @see [[colorScaleType]]
 * @see [[ColorScaleCriterion]]
 */
export declare class ColorScaleConditionalFormat extends ThresholdConditionBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ci: string;
    /**
     * @hidden
     */
    static readonly _cg: string;
    /**
     * @hidden
     */
    static readonly _ch: string;
    private _cd;
    private _b9;
    private _b7;
    private _b8;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: ColorScaleType);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a5(): void;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _a9(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _bb(): void;
    /**
     * @hidden
     */
    _bf(): void;
    /**
     * @hidden
     */
    _bg(): void;
    /**
     * @hidden
     */
    _bq(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * Returns a [[ColorScaleType]] value which
     * identifies this instance as a 2-color or 3-color scale.
     * <p class="body">
     * A [[ColorScaleConditionalFormat]] instance which is created with
     * the 'TwoColor' value does not support the [[midpointThreshold]];
     * attempting to set a property on the object retuned from the MidpointThreshold
     * property will cause an exception to be thrown.
     * </p>
     */
    get colorScaleType(): ColorScaleType;
    /**
     * Returns a [[ColorScaleCriterion]] object which defines the properties
     * of the minimum threshold for this instance.
     * <p class="body">
     * The minimum threshold defines the criteria for the lowest or minimum value
     * across the associated range.
     * </p>
     * <p class="body">
     * For a 2-color scale, the [[maximumThreshold]] defines the next "stop";
     * for a 3-color scale, the [[midpointThreshold]] property defines the next stop.
     * </p>
     * <p class="body">
     * The following <see cref="ConditionValue.ValueType">value types</see> are not valid for the
     * minimum threshold, and will cause an exception to be thrown:
     * </p>
     * <p class="body">
     * <ul>
     * <li>HighestValue</li>
     * <li>AutomaticMinimum</li>
     * <li>AutomaticMaximum</li>
     * </ul>
     * </p>
     * @see [[midpointThreshold]]
     * @see [[maximumThreshold]]
     */
    get minimumThreshold(): ColorScaleCriterion;
    /**
     * Returns a [[ColorScaleCriterion]] object which defines the properties
     * of the maximum threshold for this instance.
     * <p class="body">
     * The following <see cref="ConditionValue.ValueType">value types</see> are not valid for the
     * maximum threshold, and will cause an exception to be thrown:
     * </p>
     * <p class="body">
     * <ul>
     * <li>LowestValue</li>
     * <li>AutomaticMinimum</li>
     * <li>AutomaticMaximum</li>
     * </ul>
     * </p>
     * @see [[midpointThreshold]]
     * @see [[minimumThreshold]]
     */
    get maximumThreshold(): ColorScaleCriterion;
    /**
     * Returns a [[ColorScaleCriterion]] object which defines the properties
     * of the midpoint threshold for this instance.
     * <p class="body" >
     * The midpoint threshold is only supported for a [[ColorScaleConditionalFormat]]
     * instance with a value of 'ThreeColor' specified for the <see cref="ColorScaleConditionalFormat.ColorScaleConditionalFormat(IList<WorksheetRegion>, ColorScaleType)">colorScaleType</see>
     * parameter.
     * </p>
     * <p class="body" >
     * Attempting to set a property on the instance returned from this property will cause
     * an exception to be thrown if this instance was created as a 2-color scale.
     * </p>
     * <p class="body">
     * The following <see cref="ConditionValue.ValueType">value types</see> are not valid for the
     * midpoint threshold, and will cause an exception to be thrown:
     * </p>
     * <p class="body">
     * <ul>
     * <li>LowestValue</li>
     * <li>HighestValue</li>
     * <li>AutomaticMinimum</li>
     * <li>AutomaticMaximum</li>
     * </ul>
     * </p>
     * @see [[minimumThreshold]]
     * @see [[maximumThreshold]]
     */
    get midpointThreshold(): ColorScaleCriterion;
    /**
     * @hidden
     */
    protected get__z(): boolean;
    /**
     * @hidden
     */
    _cj(): void;
    /**
     * @hidden
     */
    private _cf;
    /**
     * @hidden
     */
    _ck(a: ColorScaleCriterion, b: string): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Base class for the [[IconCriterion]] and [[ColorScaleCriterion]] classes.
 * @see [[IconCriterion]]
 * @see [[ColorScaleCriterion]]
 */
export declare abstract class CriterionBase extends Base implements ISupportFormulaShifts, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _k: string;
    /**
     * @hidden
     */
    static readonly _i: string;
    /**
     * @hidden
     */
    static readonly _l: string;
    private _a;
    constructor();
    /**
     * @hidden
     */
    abstract get _d(): ThresholdConditionBase;
    /**
     * Returns the numeric value for this instance.
     * <p class="body">
     * This property is read-only; to assign a value type, use the
     * [[setValue]] or
     * [[setValue]]
     * methods.
     * </p>
     * <p class="body">
     * Note that the unit of measure for this value is determined by the
     * [[valueType]] property; for example, when <i>ValueType</i>
     * is set to <i>Number</i>, the value is interpreted as a numeric value,
     * but when set to <i>Percentage</i>, it is interpreted as a percentage.
     * </p>
     * @see [[valueType]]
     * @see [[formula]]
     * @see [[setValue]]
     */
    get value(): number;
    /**
     * @hidden
     */
    get _b(): ConditionValue;
    /**
     * Returns a [[FormatConditionValueType]] value which specifies
     * the manner in which the threshold values for this instance are determined.
     * <p class="body">
     * This property is read-only; to assign one of the following value types, use the
     * [[setValue]] method:
     * </p>
     * <p class="body">
     * <ul>
     * <li>AutomaticLowest</li>
     * <li>AutomaticHighest</li>
     * <li>LowestValue</li>
     * <li>HighestValue</li>
     * </ul>
     * </p>
     * <p class="body">
     * To assign a value type of <i>Number</i>, <i>Percentage</i>, or <i>Percentile</i>use the
     * [[setValue]] method.
     * </p>
     * <p class="body">
     * To assign a [[formula]], use the [[setFormula]] method.
     * </p>
     * @see [[setValue]]
     */
    get valueType(): FormatConditionValueType;
    /**
     * Returns the <see cref="Excel.Formula">formula</see> which determines
     * whether cell values meet the criteria defined by the associated condition.
     * <p class="body">
     * This property is only applicable when the [[valueType]] property is set to <i>Formula</i>.
     * </p>
     * <p class="body">
     * To assign a <see cref="Excel.Formula">formula</see>, use the [[setFormula]]
     * method.
     * </p>
     * @see [[setFormula]]
     */
    get formula(): Formula;
    /**
     * @hidden
     */
    _o(a: CriterionBase, b: boolean): void;
    /**
     * @hidden
     */
    _p(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * Assigns the specified formula to the [[formula]] property, and assigns
     * a value of <i>Formula</i> to the [[valueType]] property.
     * @param formula The string representation of the [[formula]] to be assigned to the [[value]] property.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     * @param valueType A [[FormatConditionValueType]] value which specifies the manner in which
     * the value returned from the formula is interpreted. This parameter is optional and
     * defaults to 'Formula'.
     * @see [[formula]]
     * @see [[valueType]]
     * @see [[Formula]]
     */
    setFormula(formula: string, cellReferenceMode?: CellReferenceMode, valueType?: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _setFormula$i(a: string, b?: Nullable$1<CellReferenceMode>, c?: FormatConditionValueType): void;
    /**
     * Sets the [[valueType]] property to the specified
     * [[FormatConditionValueType]] value.
     * <p class="body">
     * The 'valueType' parameter must be set to one of the following values
     * or an exception is thrown:
     * </p>
     * <p class="body">
     * <ul>
     * <li>AutomaticLowest</li>
     * <li>AutomaticHighest</li>
     * <li>LowestValue</li>
     * <li>HighestValue</li>
     * </ul>
     * </p>
     * <p class="body">
     * To set the [[value]] property to a numeric value, use the
     * [[setValue]] method.
     * </p>
     * <p class="body">
     * To set the [[valueType]] property to <i>Formula</i>, use the
     * [[setFormula]] method.
     * </p>
     * @param valueType The new value for the [[valueType]] property.
     */
    setValue(valueType: FormatConditionValueType): void;
    /**
     * Sets the [[value]] and [[valueType]] properties to the
     * specified values.
     * <p class="body">
     * To set the [[valueType]] property to <i>Formula</i>, use the
     * [[setFormula]] method.
     * </p>
     * <p class="body">
     * To set the [[valueType]] property to a [[FormatConditionValueType]]
     * value for which the [[value]] is not applicable, use the
     * [[setValue]] method.
     * </p>
     * @param value The new value for the [[value]] property.
     * @param valueType The new value for the [[valueType]] property. Must be set to either
     * <i>Number</i>, <i>Percentage</i>, or <i>Percentile</i> or an exception is thrown.
     */
    setValue(value: number, valueType: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _setValue1(a: number, b: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _setValue(a: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _v(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _j(a: any, b: string): string;
    /**
     * @hidden
     */
    private _n;
    /**
     * @hidden
     */
    _m(): void;
    /**
     * @hidden
     */
    abstract _q(a: ConditionValue, b: string): void;
    /**
     * @hidden
     */
    _r(a: string): void;
    /**
     * @hidden
     */
    abstract _w(a: ConditionValue, b: number, c: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _g(): boolean;
    /**
     * @hidden
     */
    _f(): boolean;
    /**
     * @hidden
     */
    shiftFormulas(callback: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, shiftOperation: CellShiftOperation, operationOverride: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    undoFormulaShift(context: any, originalFormula: string): string;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
}
/**
 * Defines the criterion for a [[ColorScaleConditionalFormat]] threshold.
 * @see [[ColorScaleConditionalFormat.minimumThreshold]]
 * @see [[ColorScaleConditionalFormat.maximumThreshold]]
 * @see [[ColorScaleConditionalFormat.midpointThreshold]]
 */
export declare class ColorScaleCriterion extends CriterionBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ar: string;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _aq;
    /**
     * @hidden
     */
    private static readonly _x;
    private _aa;
    private _ac;
    private _aj;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    private static readonly _ae;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _af;
    constructor(a: ColorScaleConditionalFormat, b: ColorScaleCriterionThreshold);
    /**
     * @hidden
     */
    protected get__d(): ThresholdConditionBase;
    /**
     * @hidden
     */
    get _d(): ThresholdConditionBase;
    /**
     * Returns or sets a [[WorkbookColorInfo]] object which defines the color
     * information for the threshold associated with this instance.
     * <p class="body">
     * This property returns null if not explicitly set by the caller.
     * </p>
     */
    get formatColor(): WorkbookColorInfo;
    set formatColor(a: WorkbookColorInfo);
    /**
     * @hidden
     */
    get _al(): WorkbookColorInfo;
    /**
     * @hidden
     */
    get _ad(): ColorScaleCriterionThreshold;
    /**
     * @hidden
     */
    _ab(a: ColorScaleConditionalFormat, b: boolean): ColorScaleCriterion;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    _o(a: CriterionBase, b: boolean): void;
    /**
     * @hidden
     */
    _q(a: ConditionValue, b: string): void;
    /**
     * @hidden
     */
    _w(a: ConditionValue, b: number, c: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _ao(): boolean;
    /**
     * @hidden
     */
    _f(): boolean;
    /**
     * @hidden
     */
    get _an(): boolean;
    /**
     * @hidden
     */
    private _am;
    /**
     * Returns the string representation of this instance.
     */
    toString(): string;
}
/**
 * @hidden
 */
export declare class ConditionBase_ShiftChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: ConditionBase, c: Tuple$3<number, number, WorksheetRegionAddress>[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: ConditionBase;
    readonly a: Tuple$3<number, number, WorksheetRegionAddress>[];
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Exposes properties which define the value and its unit of measure
 * for a conditional format threshold.
 * <p class="body">
 * When the [[valueType]] property is set to <i>Number</i>, <i>Percentage</i>,
 * or <i>Percentile</i>, only the [[value]] property is applicable.
 * </p>
 * <p class="body">
 * Similarly, the [[formula]] property is only applicable when<i>ValueType</i>
 * is set to <i>Formula</i>.
 * </p>
 * <p class="body">
 * For the following settings of <i>ValueType</i>, neither <i>Value</i> nor <i>Formula</i>
 * is applicable, and the actual threshold is derived based on the highest and/or lowest
 * values in the associated range:
 * </p>
 * <p class="body">
 * <ul>
 * <li>AutomaticMinimum</li>
 * <li>AutomaticMaximum</li>
 * <li>LowestValue</li>
 * <li>HighestValue</li>
 * </ul>
 * </p>
 * @see [[value]]
 * @see [[formula]]
 * @see [[setFormula]]
 */
export declare class ConditionValue extends Base implements ISupportFormulaShifts, IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _y: string;
    /**
     * @hidden
     */
    static readonly _aa: string;
    /**
     * @hidden
     */
    static readonly _ab: string;
    /**
     * @hidden
     */
    private static readonly _x;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _a;
    private _k;
    private _l;
    private _h;
    private _t;
    private _e;
    private _j;
    constructor(a: ThresholdConditionBase, b: (arg1: ConditionValue, arg2: string) => void, c: (arg1: ConditionValue, arg2: number, arg3: FormatConditionValueType) => void);
    /**
     * @hidden
     */
    get _u(): number;
    /**
     * @hidden
     */
    set _u(a: number);
    /**
     * Returns the <see cref="Excel.Formula">formula</see> which determines
     * whether cell values meet the criteria defined by the associated condition.
     * <p class="body">
     * This property is only applicable when the [[valueType]] property is set to <i>Formula</i>.
     * </p>
     * <p class="body">
     * To assign a <see cref="Excel.Formula">formula</see>, use the [[setFormula]]
     * method.
     * </p>
     * @see [[setFormula]]
     */
    get formula(): Formula;
    /**
     * Returns the numeric value for this instance.
     * <p class="body">
     * This property is read-only; to assign a value type, use the
     * [[setValue]] or
     * [[setValue]]
     * methods.
     * </p>
     * <p class="body">
     * Note that the unit of measure for this value is determined by the
     * [[valueType]] property; for example, when <i>ValueType</i>
     * is set to <i>Number</i>, the value is interpreted as a numeric value,
     * but when set to <i>Percentage</i>, it is interpreted as a percentage.
     * </p>
     * @see [[valueType]]
     * @see [[formula]]
     * @see [[setValue]]
     */
    get value(): number;
    /**
     * @hidden
     */
    get _f(): ConditionValueInfo;
    /**
     * @hidden
     */
    set _f(a: ConditionValueInfo);
    /**
     * Returns a [[FormatConditionValueType]] value which specifies
     * the manner in which the threshold values for this instance are determined.
     * <p class="body">
     * This property is read-only; to assign one of the following value types, use the
     * [[setValue]] method:
     * </p>
     * <p class="body">
     * <ul>
     * <li>AutomaticLowest</li>
     * <li>AutomaticHighest</li>
     * <li>LowestValue</li>
     * <li>HighestValue</li>
     * </ul>
     * </p>
     * <p class="body">
     * To assign a value type of <i>Number</i>, <i>Percentage</i>, or <i>Percentile</i>use the
     * [[setValue]] method.
     * </p>
     * <p class="body">
     * To assign a [[formula]], use the [[setFormula]] method.
     * </p>
     * @see [[setValue]]
     */
    get valueType(): FormatConditionValueType;
    /**
     * @hidden
     */
    _ac(): void;
    /**
     * @hidden
     */
    _d(a: ThresholdConditionBase, b: (arg1: ConditionValue, arg2: string) => void, c: (arg1: ConditionValue, arg2: number, arg3: FormatConditionValueType) => void): ConditionValue;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    _ad(a: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _ae(a: number, b: FormatConditionValueType): void;
    /**
     * @hidden
     */
    private _af;
    /**
     * @hidden
     */
    _ag(a: string): void;
    /**
     * @hidden
     */
    _o(): boolean;
    /**
     * @hidden
     */
    _n(): boolean;
    /**
     * @hidden
     */
    _p(): boolean;
    /**
     * @hidden
     */
    _m(): boolean;
    /**
     * Assigns the specified formula to the [[formula]] property, and assigns
     * a value of <i>Formula</i> to the [[valueType]] property.
     * @param formula The string representation of the [[formula]] to be assigned to the [[value]] property.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     * @param valueType A [[FormatConditionValueType]] value which specifies the manner in which
     * the value returned from the formula is interpreted. This parameter is optional and
     * defaults to 'Formula'.
     * @see [[formula]]
     * @see [[valueType]]
     * @see [[Formula]]
     */
    setFormula(formula: string, cellReferenceMode?: CellReferenceMode, valueType?: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _setFormula$i(a: string, b?: Nullable$1<CellReferenceMode>, c?: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _ai(a: SingleTargetFormula, b?: FormatConditionValueType): void;
    /**
     * Sets the [[valueType]] property to the specified
     * [[FormatConditionValueType]] value.
     * <p class="body">
     * The 'valueType' parameter must be set to one of the following values
     * or an exception is thrown:
     * </p>
     * <p class="body">
     * <ul>
     * <li>AutomaticLowest</li>
     * <li>AutomaticHighest</li>
     * <li>LowestValue</li>
     * <li>HighestValue</li>
     * </ul>
     * </p>
     * <p class="body">
     * To set the [[value]] property to a numeric value, use the
     * [[setValue]] method.
     * </p>
     * <p class="body">
     * To set the [[valueType]] property to <i>Formula</i>, use the
     * [[setFormula]] method.
     * </p>
     * @param valueType The new value for the [[valueType]] property.
     */
    setValue(valueType: FormatConditionValueType): void;
    /**
     * Sets the [[value]] and [[valueType]] properties to the
     * specified values.
     * <p class="body">
     * To set the [[valueType]] property to <i>Formula</i>, use the
     * [[setFormula]] method.
     * </p>
     * <p class="body">
     * To set the [[valueType]] property to a [[FormatConditionValueType]]
     * value for which the [[value]] is not applicable, use the
     * [[setValue]] method.
     * </p>
     * @param value The new value for the [[value]] property.
     * @param valueType The new value for the [[valueType]] property. Must be set to either
     * <i>Number</i>, <i>Percentage</i>, or <i>Percentile</i> or an exception is thrown.
     * @throws [[ArgumentException]] If the value type or value is not appropriate for the condition.
     * @throws [[ArgumentOutOfRangeException]] If the value is out of range.
     */
    setValue(value: number, valueType: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _setValue1(a: number, b: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _setValue(a: FormatConditionValueType): void;
    /**
     * @hidden
     */
    private _al;
    /**
     * Returns the string representation of this instance.
     */
    toString(): string;
    /**
     * @hidden
     */
    static _s(a: string, b: Nullable$1<number>, c: Nullable$1<number>): {
        ret: boolean;
        p1: Nullable$1<number>;
        p2: Nullable$1<number>;
    };
    /**
     * @hidden
     */
    private static _r;
    /**
     * @hidden
     */
    private static _q;
    /**
     * @hidden
     */
    shiftFormulas(callback: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, shiftOperation: CellShiftOperation, operationOverride: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    undoFormulaShift(context: any, originalFormula: string): string;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
}
/**
 * Exposes properties which displays data bars in a [[WorksheetCell]]
 * based on the cell's value as relative to the associated range.
 * <p class="body">
 * </p>
 */
export declare class DataBarConditionalFormat extends ThresholdConditionBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _dj: string;
    /**
     * @hidden
     */
    static readonly _dk: string;
    /**
     * @hidden
     */
    static readonly _dl: string;
    /**
     * @hidden
     */
    static readonly _dm: string;
    /**
     * @hidden
     */
    static readonly _dn: string;
    /**
     * @hidden
     */
    static readonly _dp: string;
    /**
     * @hidden
     */
    static readonly _dt: string;
    /**
     * @hidden
     */
    static readonly _ds: string;
    /**
     * @hidden
     */
    static readonly _du: string;
    /**
     * @hidden
     */
    static readonly _dq: string;
    /**
     * @hidden
     */
    static readonly _dr: string;
    /**
     * @hidden
     */
    static readonly _dw: string;
    /**
     * @hidden
     */
    static readonly _dv: string;
    /**
     * @hidden
     */
    static readonly _de: number;
    /**
     * @hidden
     */
    static readonly _db: number;
    /**
     * @hidden
     */
    private static readonly _c4;
    /**
     * @hidden
     */
    private static readonly _c5;
    /**
     * @hidden
     */
    private static readonly _c7;
    /**
     * @hidden
     */
    private static readonly _c6;
    /**
     * @hidden
     */
    private static readonly _c8;
    /**
     * @hidden
     */
    private static readonly _c9;
    /**
     * @hidden
     */
    private static readonly _dc;
    /**
     * @hidden
     */
    private static readonly _df;
    /**
     * @hidden
     */
    private static readonly _dh;
    /**
     * @hidden
     */
    private static readonly _di;
    /**
     * @hidden
     */
    private static readonly _dg;
    /**
     * @hidden
     */
    private static readonly _b7;
    private _cm;
    private _ce;
    private _cn;
    private _co;
    /**
     * @hidden
     */
    private static readonly _cq;
    /**
     * @hidden
     */
    private static readonly _cp;
    private _ci;
    private _cg;
    private _ca;
    private _cb;
    private _ck;
    private _c2;
    private _c3;
    private _cy;
    private _cx;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a5(): void;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _a9(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _bq(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * Returns or sets a [[WorkbookColorInfo]] object which defines the
     * color of the axis.
     */
    get axisColor(): WorkbookColorInfo;
    set axisColor(a: WorkbookColorInfo);
    /**
     * Returns or sets a [[DataBarAxisPosition]] value which determines
     * whether an axis is displayed.
     * @see [[DataBarAxisPosition]]
     */
    get axisPosition(): DataBarAxisPosition;
    set axisPosition(a: DataBarAxisPosition);
    /**
     * Returns or sets a [[WorkbookColorInfo]] object which defines the
     * fill color of the data bar.
     */
    get barColor(): WorkbookColorInfo;
    set barColor(a: WorkbookColorInfo);
    /**
     * @hidden
     */
    get _cv(): WorkbookColorInfo;
    /**
     * Returns or sets a [[WorkbookColorInfo]] object which defines the
     * border color of the data bar.
     */
    get barBorderColor(): WorkbookColorInfo;
    set barBorderColor(a: WorkbookColorInfo);
    /**
     * @hidden
     */
    get _ct(): WorkbookColorInfo;
    /**
     * @hidden
     */
    static get _cw(): WorkbookColorInfo;
    /**
     * Returns or sets a [[DataBarFillType]] value which determines
     * whether the data bar is filled with a solid color or a gradient.
     */
    get barFillType(): DataBarFillType;
    set barFillType(a: DataBarFillType);
    /**
     * Returns or sets a [[DataBarDirection]] value which determines
     * the direction in which the data bar extends.
     */
    get direction(): DataBarDirection;
    set direction(a: DataBarDirection);
    /**
     * Returns or sets a value which determines the manner in which the longest
     * bar is evaluated for this condition.
     * <p class="body">
     * The following values are not supported for the [[ConditionValue.valueType]]
     * property, and will cause an exception to be thrown:
     * </p>
     * <p class="body">
     * <ul>
     * <li>LowestValue</li>
     * <li>AutomaticMinimum</li>
     * <li>None</li>
     * </ul>
     * </p>
     * @see [[minPoint]]
     * @see [[ConditionValue]]
     */
    get maxPoint(): ConditionValue;
    /**
     * Returns or sets a value which determines the manner in which the shortest
     * bar is evaluated for this condition.
     * <p class="body">
     * The following values are not supported for the [[ConditionValue.valueType]]
     * property, and will cause an exception to be thrown:
     * </p>
     * <p class="body">
     * <ul>
     * <li>HighestValue</li>
     * <li>AutomaticMaximum</li>
     * <li>None</li>
     * </ul>
     * </p>
     * @see [[minPoint]]
     * @see [[ConditionValue]]
     */
    get minPoint(): ConditionValue;
    /**
     * Returns a [[negativeBarFormat]] object which defines the visual
     * attributes of negative-value data bars.
     */
    get negativeBarFormat(): NegativeBarFormat;
    /**
     * Returns or sets an integer value which determines the length of
     * the longest data bar, expressed as a percentage of the cell's width.
     */
    get fillPercentMax(): number;
    set fillPercentMax(a: number);
    /**
     * Returns or sets an integer value which determines the length of
     * the shortest data bar, expressed as a percentage of the cell's width.
     */
    get fillPercentMin(): number;
    set fillPercentMin(a: number);
    /**
     * Returns or sets a boolean value indicating whether borders
     * are displayed for both negative-value and positive-value
     * databars.
     */
    get showBorder(): boolean;
    set showBorder(a: boolean);
    /**
     * Returns or sets a boolean value indicating whether the cell
     * value is shown along with the data bar.
     * <p class="body">
     * By default, the cell value is displayed along with the databar;
     * use this property to prevent the cell value from appearing.
     * </p>
     */
    get showValue(): boolean;
    set showValue(a: boolean);
    /**
     * @hidden
     */
    protected get__z(): boolean;
    /**
     * @hidden
     */
    get _cz(): boolean;
    /**
     * @hidden
     */
    private static _b9;
    /**
     * @hidden
     */
    private static _b8;
    /**
     * @hidden
     */
    _dx(): void;
    /**
     * @hidden
     */
    _dz(a: string): void;
    /**
     * @hidden
     */
    _dy(a: ConditionValue, b: string): void;
    /**
     * @hidden
     */
    private _d2;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    private static _d1;
    /**
     * @hidden
     */
    private _d0;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's date/time value falls within a given range of time.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells with date/time
 * values which fall within a range of time as specified by the [[dateOperator]]
 * property.
 * </p>
 * <p class="body">
 * This condition provides only limited support for defining date/time ranges, i.e., the
 * current, previous, or next day, week or month. For wider ranges, or more precise conditions,
 * use the [[FormulaConditionalFormat]] class, and assign the desired date/time
 * formula to the [[FormulaConditionalFormat.formula]] property.
 * </p>
 * @see [[dateOperator]]
 * @see [[FormatConditionTimePeriod]]
 */
export declare class DateTimeConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _b8: string;
    /**
     * @hidden
     */
    private static readonly _b6;
    /**
     * @hidden
     */
    private static readonly _b7;
    /**
     * @hidden
     */
    private static readonly _b0;
    private _b3;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: FormatConditionTimePeriod);
    constructor(a: number, ..._rest: any[]);
    /**
     * Returns or sets a [[FormatConditionTimePeriod]] value which
     * defines the range of time against which cell values are compared when
     * evaluating this condition.
     */
    get dateOperator(): FormatConditionTimePeriod;
    set dateOperator(a: FormatConditionTimePeriod);
    /**
     * @hidden
     */
    protected get__ai(): boolean;
    /**
     * @hidden
     */
    private static _b2;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    private static _b5;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's value is unique or duplicated across the associated range.
 * <p class="body">
 * This condition evaluates to true only for cell values which are non-unique across
 * the associated range.
 * </p>
 * @see [[UniqueConditionalFormat]]
 */
export declare class DuplicateConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    private _b0;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__j(): FormatConditionNotificationType;
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    protected get__am(): boolean;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    _bb(): void;
    /**
     * @hidden
     */
    _bf(): void;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value is in error.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells
 * with a value which represents an error condition. For example, a cell
 * which displays the result of a formula whereby the formula results in
 * a divide-by-zero error meets the criteria of this condition.
 * </p>
 * <p class="body">
 * To negate this condition, use the [[NoErrorsConditionalFormat]] class.
 * </p>
 * @see [[NoErrorsConditionalFormat]]
 */
export declare class ErrorsConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value meets the criteria defined by a <see cref="Excel.Formula">formula</see>.
 * @see [[formula]]
 */
export declare class FormulaConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _b8: string;
    /**
     * @hidden
     */
    private static readonly _b6;
    /**
     * @hidden
     */
    private static readonly _b7;
    /**
     * @hidden
     */
    private static readonly _b0;
    private _b4;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: string, d?: Nullable$1<CellReferenceMode>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__x(): boolean;
    /**
     * Returns or sets the <see cref="Excel.Formula">formula</see> which defines the criteria for this condition.
     * <p class="body">
     * This property is not settable; however, the [[setFormula]]
     * method can be used to assign the formula.
     * </p>
     * @see [[setFormula]]
     */
    get formula(): Formula;
    /**
     * @hidden
     */
    get _b5(): SingleTargetFormula;
    /**
     * @hidden
     */
    set _b5(a: SingleTargetFormula);
    /**
     * @hidden
     */
    protected get__z(): boolean;
    /**
     * @hidden
     */
    protected get__j(): FormatConditionNotificationType;
    /**
     * @hidden
     */
    protected get__ah(): boolean;
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    private static _b2;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _a9(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    _bd(): void;
    /**
     * Assigns a new [[Formula]] to this instance.
     * @param formula The string representation of the formula.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     */
    setFormula(formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setFormula$i(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    _bq(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _a4(a: any, b: string): string;
    /**
     * @hidden
     */
    static _b9(a: string): string;
    /**
     * @hidden
     */
    static _ca(a: string): string;
}
/**
 * Defines the criterion for an [[IconSetConditionalFormat]] threshold.
 * <p class="body">
 * This class provides the ability to override the default behavior of the
 * associated <see cref="IconSetConditionalFormat">condition</see> for the
 * threshold defined by this instance.
 * </p>
 * <p class="body">
 * For example, the icon displayed for cell values which fall within this threshold
 * is determined by the value of the [[IconSetConditionalFormat.iconSet]],
 * but can be overridden using the [[icon]] property.
 * </p>
 * <p class="body">
 * Similarly, the default unit for this criterion's <see cref="ConditionValue.Value">value</see> is percentage,
 * but this can be overridden using the [[ConditionValue.valueType]]
 * property. For example, to define the unit for the value as a specific number, assign
 * a value of <i>Number</i> to the <i>ValueType</i> property.
 * </p>
 * <p class="body">
 * The value for this threshold is defined by the parent condition, based on the
 * total number of thresholds. For [[IconSetConditionalFormat.iconSet]]
 * values which yield three thresholds, for example, the effective value is dependent
 * on the threshold, so that each threshold represents approximately 33% of the associated
 * range. This can be overridden using the [[CriterionBase.value]] property; for example, setting
 * the <i>ValueType</i> property to <i>Number</i> and the <i>Value</i> property to
 * a specific number overrides the behavior as defined by the parent condition, and forces
 * the threshold boundary to the specific numeric value.
 * </p>
 * <p class="body">
 * For this reason, the [[icon]], [[ConditionValue.value]], and [[ConditionValue.valueType]]
 * properties support null values, and are in fact set to null by default; this is interpreted
 * by the parent condition as "not set", resulting in the threshold criterion being determined
 * solely by the parent condition.
 * </p>
 * @see [[icon]]
 * @see [[CriterionBase.value]]
 * @see [[ValueType]]
 * @see [[IconSetConditionalFormat.iconSet]]
 */
export declare class IconCriterion extends CriterionBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _at: string;
    /**
     * @hidden
     */
    static readonly _as: string;
    /**
     * @hidden
     */
    _ah: ThresholdComparison;
    /**
     * @hidden
     */
    private static readonly _am;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    private static readonly _ar;
    /**
     * @hidden
     */
    private static readonly _x;
    private _ad;
    private _al;
    private _ab;
    private _af;
    constructor(a: number, b: IconSetCriterionCollection, c: number);
    constructor(a: number, b: IconSetCriterionCollection, c: number, d: FormatConditionIconSet, e: FormatConditionIcon);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__d(): ThresholdConditionBase;
    /**
     * @hidden
     */
    get _d(): ThresholdConditionBase;
    /**
     * @hidden
     */
    get _ae(): IconSetCriterionCollection;
    /**
     * Returns or sets a [[comparison]] value which
     * determines whether a "greater than" or "greater than or equal to"
     * comparison is made when comparing cell values to the <see cref="CriterionBase.Value">value</see>
     * of this instance.
     */
    get comparison(): ThresholdComparison;
    set comparison(a: ThresholdComparison);
    /**
     * Returns or sets a [[FormatConditionIcon]] value which
     * identifies the icon displayed for this threshold as defined by the
     * [[IconSetConditionalFormat.iconSet]] and [[index]]
     * properties.
     * <p class="body">
     * By default, the icon displayed for this threshold is defined by the
     * parent <see cref="IconSetConditionalFormat">condition</see>, via the
     * value of the [[IconSetConditionalFormat.iconSet]] property.
     * </p>
     * <p class="body">
     * This property provides a way to override the default icon as defined by
     * the parent condition.
     * </p>
     * <p class="body">
     * This property defaults to the appropriate value given the <i>IconSet</i>
     * as defined by the parent condition and this instance's <i>Threshold</i>.
     * </p>
     * @see [[FormatConditionIcon]]
     * @see [[IconSetConditionalFormat.iconSet]]
     */
    get icon(): FormatConditionIcon;
    set icon(a: FormatConditionIcon);
    /**
     * @hidden
     */
    _av(a: FormatConditionIcon): void;
    /**
     * @hidden
     */
    get _ac(): IconCriterionInfo;
    /**
     * @hidden
     */
    set _ac(a: IconCriterionInfo);
    /**
     * Returns a [[FormatConditionIconSet]] value which
     * identifies the icon set that includes this icon (read-only).
     * @see [[FormatConditionIconSet]]
     * @see [[IconSetConditionalFormat.iconSet]]
     */
    get iconSet(): FormatConditionIconSet;
    /**
     * @hidden
     */
    get _ap(): number;
    /**
     * @hidden
     */
    get _ak(): boolean;
    /**
     * @hidden
     */
    get _aq(): number;
    /**
     * @hidden
     */
    _aa(a: IconSetCriterionCollection): IconCriterion;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    static _an(a: FormatConditionIconSet): number;
    /**
     * @hidden
     */
    _au(a: FormatConditionIconSet, b: FormatConditionIcon, c: number): void;
    /**
     * @hidden
     */
    _o(a: CriterionBase, b: boolean): void;
    /**
     * @hidden
     */
    _q(a: ConditionValue, b: string): void;
    /**
     * @hidden
     */
    _w(a: ConditionValue, b: number, c: FormatConditionValueType): void;
    /**
     * @hidden
     */
    _f(): boolean;
}
/**
 * @hidden
 */
export declare class IconSetConditionalFormat_IconSetChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: IconSetConditionalFormat, c: FormatConditionIconSet);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: FormatConditionIconSet;
    readonly c: FormatConditionIconSet;
    readonly b: IconSetConditionalFormat;
    readonly a: IconCriterion[];
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * Exposes properties which displays icons in a [[WorksheetCell]]
 * based on the cell's value as relative to threshold values.
 * <p class="body">
 * This class provides the ability to display an icon inside a cell when that cell's
 * value meets the criteria defined by the relevant [[IconCriterion]].
 * </p>
 * <p class="body">
 * Each icon set contains between three and five individual icons. The number of icons
 * defines the number of thresholds; for example, a 3-icon set implies 3 thresholds, with
 * each threshold representing approximately 33% of the associated range. A 4-icon set
 * provides 4 thresholds, each representing 25% of the range; a 5-icon set contains 5
 * thresholds with each representing 20% of the range.
 * </p>
 * <p class="body">
 * Threshold ranges are pre-defined based on the number of icons in the associated set,
 * although this can be customized using the <see cref="CriterionBase.Value">Value</see> property
 * of the [[IconCriterion]] associated with that threshold.
 * </p>
 * <p class="body">
 * By default thresholds are expressed as percentages; use the <i>Value</i>
 * property to customize this to support a percentile rating or a specific value. How the
 * <i>Value</i> property is interpreted is dependent on the <see cref="CriterionBase.ValueType">ValueType</see> property.
 * </p>
 * <p class="body">
 * While the number of thresholds is always fixed at 3, 4, or 5, the icon which is displayed
 * for a given threshold can be customized using the [[IconCriterion.icon]] property.
 * </p>
 */
export declare class IconSetConditionalFormat extends ThresholdConditionBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _cv: string;
    /**
     * @hidden
     */
    static readonly _cu: string;
    /**
     * @hidden
     */
    static readonly _cw: string;
    /**
     * @hidden
     */
    static readonly _cx: string;
    /**
     * @hidden
     */
    static readonly _cg: FormatConditionIconSet;
    /**
     * @hidden
     */
    private static readonly _cq;
    /**
     * @hidden
     */
    private static readonly _cr;
    /**
     * @hidden
     */
    private static readonly _ct;
    /**
     * @hidden
     */
    private static readonly _cs;
    /**
     * @hidden
     */
    private static _b7;
    private _ci;
    private _cj;
    private _ck;
    private _cd;
    private _cf;
    static staticInit(): void;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: FormatConditionIconSet);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a5(): void;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _a9(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _bq(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    protected get__z(): boolean;
    /**
     * Returns the [[IconCriterion]] object corresponding to the
     * specified 'index'.
     * @param index A zero-based index.
     * @return The corresponding [[IconCriterion]] object
     */
    iconCriteria(index: number): IconCriterion;
    /**
     * Returns a <see cref="IconSetCriterionCollection">collection</see>
     * which defines the criteria for this condition.
     */
    iconCriteria(): IconSetCriterionCollection;
    /**
     * @hidden
     */
    get _iconCriteria$i(): IconSetCriterionCollection;
    /**
     * Returns or sets a [[FormatConditionIconSet]] value which identifies
     * the set of icons used to express this condition.
     */
    get iconSet(): FormatConditionIconSet;
    set iconSet(a: FormatConditionIconSet);
    /**
     * @hidden
     */
    private _c0;
    /**
     * Returns true if the <see cref="IconCriterion.Icon">Icon</see>
     * property of one or more <see cref="IconCriterion">criterion</see>
     * returns a value which is from a different icon set as the one
     * returned from the [[iconSet]] property.
     */
    get isCustom(): boolean;
    /**
     * @hidden
     */
    get _cm(): boolean;
    /**
     * @hidden
     */
    set _cm(a: boolean);
    /**
     * Returns or sets a boolean value indicating whether the order in
     * which icons appear is reversed.
     */
    get isReverseOrder(): boolean;
    set isReverseOrder(a: boolean);
    /**
     * Returns or sets a boolean value indicating whether the cell
     * value is shown along with the icon.
     * <p class="body">
     * By default, the cell value is displayed along with the icon;
     * use this property to prevent the cell value from appearing.
     * </p>
     */
    get showValue(): boolean;
    set showValue(a: boolean);
    /**
     * @hidden
     */
    private _cy;
    /**
     * @hidden
     */
    private static _cb;
    /**
     * @hidden
     */
    private static _cc;
    /**
     * @hidden
     */
    private static _b8;
    /**
     * @hidden
     */
    static _b9(a: FormatConditionIconSet, b?: boolean): FormatConditionIcon[];
    /**
     * @hidden
     */
    private static _ca;
    /**
     * @hidden
     */
    static _cp(a: FormatConditionIcon, b: FormatConditionIconSet): {
        ret: number;
        p1?: FormatConditionIconSet;
    };
    /**
     * @hidden
     */
    _cz(a: IconCriterion, b: string): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    private static _c1;
}
/**
 * Collection class for objects of type [[IconCriterion]].
 * <p class="body">
 * This class does not expose an Add method because [[IconCriterion]]
 * instances are created based on the iconset.
 * </p>
 * <p class="body">
 * Enumerating this class causes immediate creation of all
 * [[IconCriterion]] objects.
 * </p>
 * <p class="body">
 * The <see cref="IconSetCriterionCollection.Count">Count</see> property
 * always returns either 3, 4, or 5, depending on the value of the
 * [[IconSetConditionalFormat.iconSet]] property.
 * </p>
 * @see [[IconCriterion]]
 * @see [[IconSetConditionalFormat.iconCriteria]]
 * @see [[IconSetConditionalFormat.iconSet]]
 * @see [[IconSetConditionalFormat]]
 * @see [[FormatConditionIconSet]]
 */
export declare class IconSetCriterionCollection extends Base implements IEnumerable$1<IconCriterion>, ISupportFormulaShifts {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _j;
    private _c;
    private _a;
    private _f;
    constructor(a: IconSetConditionalFormat, b: FormatConditionIconSet);
    /**
     * Returns the [[IconCriterion]] object corresponding to the
     * specified 'index'.
     * @param index A zero-based index.
     * @return The corresponding [[IconCriterion]] object
     */
    item(a: number): IconCriterion;
    /**
     * @hidden
     */
    get _d(): IconSetConditionalFormat;
    /**
     * Returns the number of [[IconCriterion]] objects
     * contained within this collection.
     * <p class="body">
     * This property returns a value of 3, 4, or 5, depending on the
     * value of the [[IconSetConditionalFormat.iconSet]]
     * property.
     * </p>
     * @see [[FormatConditionIconSet]]
     */
    get count(): number;
    /**
     * @hidden
     */
    get _h(): boolean;
    /**
     * @hidden
     */
    _e(a: IconSetConditionalFormat, b: FormatConditionIconSet): IconSetCriterionCollection;
    /**
     * @hidden
     */
    _k(): void;
    /**
     * @hidden
     */
    get _g(): boolean;
    /**
     * @hidden
     */
    _l(a: FormatConditionIconSet): void;
    /**
     * @hidden
     */
    _m(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _o(a: IconCriterion[]): void;
    /**
     * @hidden
     */
    _p(): void;
    /**
     * @hidden
     */
    _q(a: IconCriterion[]): void;
    /**
     * @hidden
     */
    _n(a: IconCriterion, b: string): void;
    /**
     * @hidden
     */
    shiftFormulas(callback: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, shiftOperation: CellShiftOperation, operationOverride: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    undoFormulaShift(context: any, originalFormula: string): string;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
    [Symbol.iterator](): EnumeratorWrapper<IconCriterion>;
    /**
     * @hidden
     */
    getEnumerator(): IEnumerator$1<IconCriterion>;
    /**
     * @hidden
     */
    _getEnumerator$e(): IEnumerator$1<IconCriterion>;
}
/**
 * Exposes properties which control the appearance of negative-value
 * <see cref="DataBarConditionalFormat">data bars</see>.
 */
export declare class NegativeBarFormat extends Base implements IChangeInfoContext {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _aa: string;
    /**
     * @hidden
     */
    static readonly _ac: string;
    /**
     * @hidden
     */
    static readonly _ab: string;
    /**
     * @hidden
     */
    static readonly _ad: string;
    /**
     * @hidden
     */
    static readonly _i: DataBarNegativeBarColorType;
    /**
     * @hidden
     */
    static readonly _j: DataBarNegativeBarColorType;
    /**
     * @hidden
     */
    private static readonly _x;
    /**
     * @hidden
     */
    private static readonly _y;
    /**
     * @hidden
     */
    private static readonly _v;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _z;
    /**
     * @hidden
     */
    private static readonly _a;
    private _d;
    private _t;
    private _e;
    private _f;
    private _l;
    private _m;
    /**
     * @hidden
     */
    private static readonly _n;
    constructor(a: DataBarConditionalFormat, b: (arg1: string) => void);
    /**
     * Returns or sets a [[DataBarNegativeBarColorType]] value which specifies
     * whether the same border color as that which is used for data bars with positive cell
     * values is also used for data bars with negative cell values.
     * <p class="body">
     * By default, databars for cells with negative values use the same color
     * as those with positive values, and the [[barBorderColor]]
     * property is not used.
     * </p>
     * <p class="body">
     * Use this property to apply the color specified by the
     * [[barBorderColor]] property to the borders of databars
     * with negative cell values.
     * </p>
     * @see [[barBorderColor]]
     * @see [[DataBarConditionalFormat.barBorderColor]]
     */
    get barBorderColorType(): DataBarNegativeBarColorType;
    set barBorderColorType(a: DataBarNegativeBarColorType);
    /**
     * Returns or sets a [[DataBarNegativeBarColorType]] value which specifies
     * whether the same color as that which is used for the positive data bars is used.
     * <p class="body">
     * By default, databars for cells with negative values have a different color
     * than those with positive values.
     * </p>
     * <p class="body">
     * Use this property to apply the same color to databars regardless of whether
     * the cell value is positive or negative.
     * </p>
     * @see [[barColor]]
     * @see [[DataBarConditionalFormat.barColor]]
     */
    get barColorType(): DataBarNegativeBarColorType;
    set barColorType(a: DataBarNegativeBarColorType);
    /**
     * Returns a [[WorkbookColorInfo]] which defines the border color
     * applied to data bars with a negative value.
     * <p class="body">
     * This property is only applicable when the [[barBorderColorType]]
     * property is set to <i>Color</i>.
     * </p>
     * @see [[barBorderColorType]]
     */
    get barBorderColor(): WorkbookColorInfo;
    set barBorderColor(a: WorkbookColorInfo);
    /**
     * @hidden
     */
    get _p(): WorkbookColorInfo;
    /**
     * Returns a [[WorkbookColorInfo]] which defines the fill color
     * applied to data bars with a negative value.
     * <p class="body">
     * This property is only applicable when the [[barColorType]]
     * property is set to <i>Color</i>.
     * </p>
     * @see [[barBorderColorType]]
     */
    get barColor(): WorkbookColorInfo;
    set barColor(a: WorkbookColorInfo);
    /**
     * @hidden
     */
    get _r(): WorkbookColorInfo;
    /**
     * @hidden
     */
    static get _s(): WorkbookColorInfo;
    /**
     * @hidden
     */
    _k(a: DataBarConditionalFormat, b: boolean): NegativeBarFormat;
    /**
     * @hidden
     */
    private static _c;
    /**
     * @hidden
     */
    private static _b;
    /**
     * @hidden
     */
    private _ae;
    /**
     * @hidden
     */
    _u(): boolean;
    /**
     * @hidden
     */
    get source(): any;
    /**
     * @hidden
     */
    get workbook(): Workbook;
    /**
     * @hidden
     */
    get sheet(): Sheet;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value is not set.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells
 * with a non-empty value.
 * </p>
 * <p class="body">
 * To negate this condition, use the [[NoBlanksConditionalFormat]] class.
 * </p>
 * @see [[NoBlanksConditionalFormat]]
 */
export declare class NoBlanksConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value is in error.
 * <p class="body">
 * This condition can be used to control the visual attributes of cells
 * with a value which does not constitute an error.
 * </p>
 * <p class="body">
 * To negate this condition, use the [[ErrorsConditionalFormat]] class.
 * </p>
 * @see [[ErrorsConditionalFormat]]
 */
export declare class NoErrorsConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's value meets the criteria defined by a logical operator.
 * @see [[operator]]
 * @see [[operand1]]
 */
export declare class OperatorConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _cj;
    /**
     * @hidden
     */
    private static readonly _ch;
    /**
     * @hidden
     */
    private static readonly _ci;
    /**
     * @hidden
     */
    private static readonly _cg;
    /**
     * @hidden
     */
    private static readonly _b0;
    private _b7;
    private _cb;
    private _cc;
    private _b2;
    private _b3;
    private _b4;
    private _b5;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: FormatConditionOperator);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__x(): boolean;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _a9(a: (arg1: Worksheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _a5(): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    _bd(): void;
    /**
     * @hidden
     */
    protected get__ah(): boolean;
    /**
     * @hidden
     */
    _bq(a: (arg1: ISupportFormulaShifts, arg2: any, arg3: string) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _a4(a: any, b: string): string;
    /**
     * Returns a [[FormatConditionOperator]] constant which determines the
     * manner in which the cell value is compared against the [[operand1]]
     * property.
     * <p class="body">
     * This property determines how the cell value is compared to the [[operand1]]
     * property; for example, whether it is equal, greater than, less than, etc.
     * </p>
     * <p class="body">
     * For the [[FormatConditionOperator]] values 'Between' and 'NotBetween',
     * the [[operand2]] property must also be set.
     * </p>
     * @see [[operand1]]
     * @see [[operand2]]
     */
    get operator(): FormatConditionOperator;
    set operator(a: FormatConditionOperator);
    /**
     * Returns the <see cref="Excel.Formula">formula</see> which defines
     * the criteria for the first operand of this condition.
     * <p class="body">
     * This property is not directly settable; however, the following methods can be used to
     * assign a formula:
     * </p>
     * <p class="body">
     * <ul>
     *     <li>[[setOperand1]]</li>
     *     <li>[[setOperand1]]</li>
     *     <li>[[setOperand1]]</li>
     *     <li>[[setOperand1Formula]]</li>
     * </ul>
     * </p>
     * <p class="body">
     * When the [[operator]] property is set
     * to <i>Between</i> or <i>NotBetween</i>, this property defines the
     * lower limit of the range for "between" comparisons.
     * </p>
     * <p class="body">
     * Use the [[operand2]] property to define the
     * upper limit of the range for "between" comparisons.
     * </p>
     * @see [[setOperand1]]
     * @see [[setOperand1]]
     * @see [[setOperand1]]
     * @see [[setOperand1Formula]]
     * @see [[operand2]]
     */
    get operand1(): Formula;
    /**
     * @hidden
     */
    get _cd(): SingleTargetFormula;
    /**
     * @hidden
     */
    set _cd(a: SingleTargetFormula);
    /**
     * Returns or sets a <see cref="Excel.Formula">formula</see> for the second operand
     * which defines the criteria for this condition when the [[operator]]
     * property is set to <i>Between</i> or <i>NotBetween</i>
     * <p class="body">
     * This property is only applicable when the [[operator]] property is set
     * to <i>Between</i> or <i>NotBetween</i>.
     * </p>
     * <p class="body">
     * Use this property to define the upper limit of the range for "between" comparisons, and the
     * [[operand1]] property to define the lower limit.
     * </p>
     * <p class="body">
     * This property is not directly settable; however, the following methods can be used to
     * assign a formula:
     * </p>
     * <p class="body">
     * <ul>
     *     <li>[[setOperand2]]</li>
     *     <li>[[setOperand2]]</li>
     *     <li>[[setOperand2]]</li>
     *     <li>[[setOperand2Formula]]</li>
     * </ul>
     * </p>
     * @see [[setOperand2]]
     * @see [[setOperand2]]
     * @see [[setOperand2]]
     * @see [[setOperand2Formula]]
     * @see [[operand1]]
     */
    get operand2(): Formula;
    /**
     * @hidden
     */
    get _ce(): SingleTargetFormula;
    /**
     * @hidden
     */
    set _ce(a: SingleTargetFormula);
    /**
     * @hidden
     */
    private static _b6;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * @hidden
     */
    private static _ck;
    /**
     * @hidden
     */
    private static _cf;
    /**
     * Assigns a [[Formula]] to the [[operand1]] property.
     * <p class="body">
     * Note that the value of the 'formula' parameter must begin with an
     * equals sign (=).
     * </p>
     * @param formula The string representation of the [[Formula]] to be assigned to the [[operand1]] property.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     * @see [[operand1]]
     * @see [[setOperand1]]
     * @see [[setOperand1]]
     * @see [[setOperand1]]
     * @see [[setOperand2Formula]]
     */
    setOperand1Formula(formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setOperand1Formula$i(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * Assigns a [[Formula]] to the [[operand2]] property.
     * <p class="body">
     * Note that the value of the 'formula' parameter must begin with an
     * equals sign (=).
     * </p>
     * @param formula The string representation of the [[Formula]] to be assigned to the [[operand2]] property.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     * @see [[operand2]]
     * @see [[operand1]]
     * @see [[setOperand2]]
     * @see [[setOperand2]]
     * @see [[setOperand2]]
     * @see [[setOperand1Formula]]
     */
    setOperand2Formula(formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setOperand2Formula$i(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * Assigns the specified <i>System.DateTime</i> value to the [[operand1]] property.
     * @param value The <i>System.DateTime</i> value to assign.
     */
    setOperand1(value: Date): void;
    /**
     * Assigns the specified <i>System.Double</i> value to the [[operand1]] property.
     * @param value The <i>System.Double</i> value to assign.
     */
    setOperand1(value: number): void;
    /**
     * Assigns the specified <i>System.String</i> value to the [[operand1]] property.
     * @param value The <i>System.String</i> value to assign.
     */
    setOperand1(value: string): void;
    /**
     * @hidden
     */
    _setOperand11(a: number): void;
    /**
     * @hidden
     */
    _setOperand12(a: string): void;
    /**
     * @hidden
     */
    _setOperand1(a: Date): void;
    /**
     * Assigns the specified <i>System.DateTime</i> value to the [[operand2]] property.
     * @param value The <i>System.DateTime</i> value to assign.
     */
    setOperand2(value: Date): void;
    /**
     * Assigns the specified <i>System.Double</i> value to the [[operand2]] property.
     * @param value The <i>System.Double</i> value to assign.
     */
    setOperand2(value: number): void;
    /**
     * Assigns the specified <i>System.String</i> value to the [[operand2]] property.
     * @param value The <i>System.String</i> value to assign.
     */
    setOperand2(value: string): void;
    /**
     * @hidden
     */
    _setOperand21(a: number): void;
    /**
     * @hidden
     */
    _setOperand22(a: string): void;
    /**
     * @hidden
     */
    _setOperand2(a: Date): void;
    /**
     * @hidden
     */
    protected get__z(): boolean;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's value is within the top or bottom rank of values across the
 * associated range.
 * <p class="body">
 * A rank condition evaluates to true if a cell value is within the range defined by
 * the top or bottom <i>n</i> values across the associated range, where <i>n</i> represents
 * the [[rank]].
 * </p>
 * <p class="body">
 * A popular example of a rank condition is "top ten ", where cell values which are within
 * the range of the ten highest values across the range meet the condition. The [[rank]]
 * property, however, can be set to any arbitrary number or percentage, and is not limited to only
 * the top or bottom ten values.
 * </p>
 * <p class="body">
 * By default, this condition evaluates to true if a cell's value is at or above the specified rank;
 * to change this to the bottom of the ranking, set the [[topBottom]] property to 'Bottom'.
 * </p>
 * <p class="body">
 * The numeric criteria can be changed to a percentage using the [[isPercent]] property.
 * In this case, the <i>Rank</i> property is interepreted as a percentage.
 * </p>
 */
export declare class RankConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _ch: string;
    /**
     * @hidden
     */
    static readonly _cf: string;
    /**
     * @hidden
     */
    static readonly _cg: string;
    /**
     * @hidden
     */
    static readonly _b9: number;
    /**
     * @hidden
     */
    private static readonly _ca;
    /**
     * @hidden
     */
    private static readonly _cd;
    /**
     * @hidden
     */
    private static readonly _ce;
    /**
     * @hidden
     */
    private static readonly _cb;
    /**
     * @hidden
     */
    private static readonly _b0;
    private _b3;
    private _b6;
    private _b8;
    private _b5;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: FormatConditionTopBottom, d?: number);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _a5(): void;
    /**
     * @hidden
     */
    protected get__j(): FormatConditionNotificationType;
    /**
     * Returns or sets a boolean value indicating whether the [[rank]] is determined
     * by a percentage value.
     * <p class="body">
     * By default, this condition evaluates cell values against the value of the [[rank]]
     * property, with the rank representing an explicit numeric value. Set this property to true
     * to identify the rank as a percentage.
     * </p>
     * <p class="body">
     * If the <i>IsPercent</i> property is set to true, this property supports only values
     * between 1 and 100, inclusively.
     * </p>
     */
    get isPercent(): boolean;
    set isPercent(a: boolean);
    /**
     * Returns or sets a value which specifies either the number or percentage
     * of the rank value for the associated condition.
     * <p class="body">
     * The default value of this property is 10, and the default value for the [[topBottom]]
     * property is 'Top', so that creating an instance of this class without specifying non-default
     * property values results in a "top ten" condition.
     * </p>
     * <p class="body">
     * The value of this property is interepreted as either a number or a percentage,
     * depending on the value of the [[isPercent]] property.
     * </p>
     * <p class="body">
     * If the <i>IsPercent</i> property is set to true, this property supports only values
     * between 1 and 100, inclusively.
     * </p>
     * @see [[isPercent]]
     */
    get rank(): number;
    set rank(a: number);
    /**
     * @hidden
     */
    protected get__ah(): boolean;
    /**
     * Returns or sets a value indicating whether a cell value must fall within
     * the top or bottom of the ranking across the associated range.
     */
    get topBottom(): FormatConditionTopBottom;
    set topBottom(a: FormatConditionTopBottom);
    /**
     * @hidden
     */
    private static _b2;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * @hidden
 */
export declare class RankConditionalFormat_ValueCache extends Base {
    static $t: Type;
    private b;
    constructor(a: RankConditionalFormat);
    get c(): number;
    a(a: number): boolean;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether the cell's text value meets the criteria defined by a string and a
 * [[FormatConditionTextOperator]] value.
 */
export declare class TextOperatorConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _cc: string;
    /**
     * @hidden
     */
    static readonly _cb: string;
    /**
     * @hidden
     */
    private static readonly _b6;
    /**
     * @hidden
     */
    private static readonly _b7;
    /**
     * @hidden
     */
    private static readonly _b5;
    /**
     * @hidden
     */
    private static readonly _b0;
    private _b8;
    private _b9;
    private _b3;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>, c?: string, d?: FormatConditionTextOperator);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    protected get__am(): boolean;
    /**
     * Returns or sets the string value against which cell text is compared.
     */
    get text(): string;
    set text(a: string);
    /**
     * Returns or sets a [[FormatConditionTextOperator]] value which
     * determines the manner in which the cell text is compared to the value of the
     * [[text]] property.
     */
    get textOperator(): FormatConditionTextOperator;
    set textOperator(a: FormatConditionTextOperator);
    /**
     * @hidden
     */
    private static _b2;
    /**
     * @hidden
     */
    private static _b1;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a5(): void;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
}
/**
 * Exposes properties which control the visual attributes of a [[WorksheetCell]]
 * based on whether a cell's value is unique across the associated range.
 * <p class="body">
 * This condition evaluates to true only for cell values which are unique across
 * the associated range.
 * </p>
 * @see [[DuplicateConditionalFormat]]
 */
export declare class UniqueConditionalFormat extends ConditionalFormatBase {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _b1: string;
    private _b0;
    constructor(a: number);
    constructor(a: number, b: IList$1<WorksheetRegion>);
    constructor(a: number, ..._rest: any[]);
    /**
     * @hidden
     */
    protected get__j(): FormatConditionNotificationType;
    /**
     * @hidden
     */
    protected get__al(): boolean;
    /**
     * @hidden
     */
    protected get__am(): boolean;
    /**
     * @hidden
     */
    _h(): ConditionBase;
    /**
     * @hidden
     */
    _a7(a: ConditionBase, b: boolean): void;
    /**
     * @hidden
     */
    _i(a: any, b: number, c: number, d: RefBase): ConditionMatchResult;
    /**
     * @hidden
     */
    _bb(): void;
    /**
     * @hidden
     */
    _bf(): void;
}
/**
 * @hidden
 */
export declare class UniqueConditionalFormat_DuplicateValueHolder extends Base {
    static $t: Type;
    private e;
    private d;
    private b;
    private a;
    constructor(a: IEnumerable$1<WorksheetRegion>);
    c(a: any): boolean;
}
/**
 * Represents a unit label on an axis in a chart.
 */
export declare class DisplayUnitLabel extends ChartTextAreaBase {
    static $t: Type;
    constructor();
}
/**
 * Represents the major/minor gridlines for an [[Axis]].
 * <p class="body">
 * The color of the grid lines is controlled by the [[ChartLineBase.fill]] property.
 * </p>
 * <p class="body">
 * The width of the grid lines is controlled by the [[ChartLineBase.widthInPoints]] property.
 * </p>
 */
export declare class ChartGridLines extends ChartLineBase {
    static $t: Type;
    private _al;
    constructor();
    constructor(owner: IChartObject);
    constructor(..._rest: any[]);
    private _gridLineType;
    /**
     * Returns a value indicating whether this instance
     * represents a major or minor gridline.
     */
    get gridLineType(): GridLineType;
    set gridLineType(a: GridLineType);
    /**
     * @hidden
     */
    _an(a: IChartObject, b: GridLineType): void;
    /**
     * @hidden
     */
    get _ak(): ChartFillBase;
}
/**
 * Represents the tick lines for an [[Axis]].
 * <p class="body">
 * The color of the tick line is controlled by the [[ChartLineBase.fill]] property.
 * </p>
 * <p class="body">
 * The width of the tick line is controlled by the [[ChartLineBase.widthInPoints]] property.
 * </p>
 * @see [[Axis.tickLines]]
 */
export declare class ChartTickLines extends ChartLineBase {
    static $t: Type;
    constructor();
    constructor(owner: IChartObject);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    get _ak(): ChartFillBase;
}
/**
 * Represents a single axis in a chart.
 * <p class="body">
 * To change the color of the ticklines, use the [[ChartLineBase.fill]] property.
 * </p>
 */
export declare class Axis extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _cf;
    /**
     * @hidden
     */
    private static readonly _ch;
    /**
     * @hidden
     */
    private static readonly _ci;
    /**
     * @hidden
     */
    private static readonly _cj;
    /**
     * @hidden
     */
    private static readonly _ck;
    /**
     * @hidden
     */
    private static readonly _cm;
    /**
     * @hidden
     */
    private static readonly _cl;
    /**
     * @hidden
     */
    private static readonly _co;
    /**
     * @hidden
     */
    private static readonly _cn;
    /**
     * @hidden
     */
    private static readonly _cp;
    /**
     * @hidden
     */
    private static readonly _cq;
    /**
     * @hidden
     */
    private static readonly _cr;
    /**
     * @hidden
     */
    private static readonly _cs;
    /**
     * @hidden
     */
    private static readonly _ct;
    /**
     * @hidden
     */
    private static readonly _cu;
    /**
     * @hidden
     */
    private static readonly _cv;
    /**
     * @hidden
     */
    private static readonly _cw;
    /**
     * @hidden
     */
    private static readonly _cx;
    /**
     * @hidden
     */
    private static readonly _cy;
    /**
     * @hidden
     */
    private static readonly _cz;
    /**
     * @hidden
     */
    private static readonly _c0;
    /**
     * @hidden
     */
    private static readonly _c1;
    /**
     * @hidden
     */
    private static readonly _c2;
    /**
     * @hidden
     */
    private static readonly _c3;
    /**
     * @hidden
     */
    private static readonly _c4;
    /**
     * @hidden
     */
    private static readonly _c5;
    /**
     * @hidden
     */
    private static readonly _c7;
    /**
     * @hidden
     */
    private static readonly _da;
    /**
     * @hidden
     */
    private static readonly _db;
    /**
     * @hidden
     */
    private static readonly _df;
    /**
     * @hidden
     */
    private static readonly _dh;
    /**
     * @hidden
     */
    private static readonly _di;
    /**
     * @hidden
     */
    private static readonly _dj;
    /**
     * @hidden
     */
    private static readonly _dl;
    /**
     * @hidden
     */
    private static readonly _dm;
    /**
     * @hidden
     */
    private static readonly _c6;
    /**
     * @hidden
     */
    static readonly _b2: number;
    /**
     * @hidden
     */
    static readonly _b3: number;
    /**
     * @hidden
     */
    static readonly _c8: number;
    /**
     * @hidden
     */
    static readonly _c9: number;
    /**
     * @hidden
     */
    static readonly _dd: number;
    /**
     * @hidden
     */
    static readonly _dc: number;
    /**
     * @hidden
     */
    static readonly _de: number;
    /**
     * @hidden
     */
    static readonly _b7: number;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _ae;
    private _ad;
    private _ah;
    private _av;
    private _bc;
    private _an;
    private _af;
    private _bu;
    private _aa;
    private _ax;
    private _bv;
    private _az;
    private _dn;
    private _bw;
    private _ap;
    private _a8;
    private _bx;
    private _bd;
    private _by;
    private _bz;
    private _aq;
    private _a9;
    private _b0;
    private _be;
    private _aj;
    private _a1;
    private _a4;
    private _a6;
    private _cd;
    private _at;
    private _ce;
    private _al;
    constructor(a: IChartObject, b: AxisType, c: AxisGroup);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * True if the value axis crosses the category axis between categories.
     */
    get axisBetweenCategories(): boolean;
    set axisBetweenCategories(a: boolean);
    /**
     * Returns the group for the specified axis. Read-only
     */
    get axisGroup(): AxisGroup;
    /**
     * Returns or sets a [[ChartTitle]] object that represents the title of the axis.
     */
    get axisTitle(): ChartTitle;
    set axisTitle(a: ChartTitle);
    /**
     * Returns or sets the base unit for the axis.
     * <para class="note">
     * Setting this property has no visible effect if the [[categoryType]]  property for the specified axis is set to 'CategoryScale'.
     * The set value is retained, however, and takes effect when the <b>CategoryType</b> property is set to 'TimeScale'.
     * </para>
     */
    get baseUnit(): TimeUnit;
    set baseUnit(a: TimeUnit);
    /**
     * True if Excel chooses appropriate base units for the specified category axis. The default value is True.
     */
    get baseUnitIsAuto(): boolean;
    set baseUnitIsAuto(a: boolean);
    /**
     * Returns or sets the category axis type.
     * <p class="body">
     * This property applies only to <see cref="Charts.AxisType">category</see> axes.
     * </p>
     * <p class="body">
     * When set to <i>Automatic</i>, the axis will resolve the
     * category type to either <i>CategoryScale</i> or <i>TimeScale</i>,
     * based on the type of the selected data.
     * </p>
     */
    get categoryType(): CategoryType;
    set categoryType(a: CategoryType);
    /**
     * Returns or sets the point on the specified axis where the other axis crosses.
     * <p class="body">
     * This property is only applicable to a category axis.
     * </p>
     * <p class="body">
     * Set this property to <i>Custom</i> to specify a data value as a crossing point,
     * using the [[crossesAt]] property to specify that value.
     * </p>
     * @see [[crossesAt]]
     */
    get crosses(): AxisCrosses;
    set crosses(a: AxisCrosses);
    /**
     * Returns or sets the point on the [[Axis]] at which the
     * perpendicular axis intersects it.
     * <p class="body">
     * For a category axis, this value is interpreted as the value of a data point.
     * For example, on a category axis with a minimum data value of 0 and a maximum
     * of 500, setting this property to 250 causes this axis to appear near the center
     * of the plot area.
     * </p>
     * <p class="body">
     * For a value axis, this value is interpreted as the one-based number of the
     * category with which this axis should intersect.
     * </p>
     * <p class="body">
     * Setting this property causes the [[crosses]] property to change to 'Custom'.
     * </p>
     * <p class="body">
     * This property cannot be used on radar charts.
     * </p>
     * <p class="body">
     * For 3-D charts, this property indicates where the plane defined
     * by the category axes crosses the value axis.
     * </p>
     */
    get crossesAt(): number;
    set crossesAt(a: number);
    /**
     * @hidden
     */
    _dy(a: number, b?: boolean): void;
    /**
     * @hidden
     */
    get _dp(): Nullable$1<number>;
    /**
     * @hidden
     */
    get _ab(): Axis;
    /**
     * @hidden
     */
    set _ab(a: Axis);
    /**
     * @hidden
     */
    get _ac(): Axis;
    /**
     * @hidden
     */
    get _cg(): number;
    /**
     * @hidden
     */
    _dr(a: Axis): Nullable$1<number>;
    /**
     * Returns or sets the unit label for the value axis.
     */
    get displayUnit(): DisplayUnit;
    set displayUnit(a: DisplayUnit);
    /**
     * If the value of the DisplayUnit property 'Custom' , the DisplayUnitCustom property returns or sets the value of the displayed units. The value must be from 0 through 10E307
     */
    get displayUnitCustom(): number;
    set displayUnitCustom(a: number);
    /**
     * Returns or sets an [[displayUnitLabel]] object.
     */
    get displayUnitLabel(): DisplayUnitLabel;
    set displayUnitLabel(a: DisplayUnitLabel);
    /**
     * Returns or sets a value indicating the width of the gaps between data points
     * or series, expressed as a percentage.
     * <p class="body">
     * This property is only applicable for <i>Box and Whisker</i>, <i>Histogram</i>,
     * <i>Pareto</i>, and <i>Waterfall</i> charts.
     * </p>
     */
    get gapWidth(): number | null;
    set gapWidth(a: number | null);
    /**
     * @hidden
     */
    get _gapWidth$i(): Nullable$1<number>;
    /**
     * @hidden
     */
    set _gapWidth$i(a: Nullable$1<number>);
    /**
     * Returns or sets the base of the logarithm when you are using log scales.
     * <para class="note">
     * Attempting to set this property to a value less than 2 causes an error. The default value is 10.
     * </para>
     */
    get logBase(): number;
    set logBase(a: number);
    /**
     * Returns a [[ChartGridLines]] object which defines
     * the color and weight of the major ticklines.
     */
    get majorGridLines(): ChartGridLines;
    set majorGridLines(a: ChartGridLines);
    /**
     * Returns or sets the type of major tick mark for the specified axis.
     */
    get majorTickMark(): TickMark;
    set majorTickMark(a: TickMark);
    /**
     * True if Excel calculates the major units for the value axis.
     */
    get majorUnitIsAuto(): boolean;
    set majorUnitIsAuto(a: boolean);
    /**
     * Returns the major interval unit.
     * <p class="body">
     * To set the value of this property, use the [[setMajorMinorUnit]] method.
     * </p>
     * @see [[setMajorMinorUnit]]
     * @see [[minorUnit]]
     */
    get majorUnit(): number;
    set majorUnit(a: number);
    /**
     * Returns or sets the major unit scale value for the category axis when the [[categoryType]] property is set to 'TimeScale'.
     */
    get majorUnitScale(): TimeUnit;
    set majorUnitScale(a: TimeUnit);
    /**
     * Returns or sets the maximum value on the value axis.
     */
    get maximumScale(): number;
    set maximumScale(a: number);
    /**
     * True if Excel calculates the maximum value for the value axis.
     */
    get maximumScaleIsAuto(): boolean;
    set maximumScaleIsAuto(a: boolean);
    /**
     * Returns or sets the minimum value on the value axis.
     */
    get minimumScale(): number;
    set minimumScale(a: number);
    /**
     * True if Excel calculates the minimum value for the value axis.
     */
    get minimumScaleIsAuto(): boolean;
    set minimumScaleIsAuto(a: boolean);
    /**
     * Returns a [[ChartGridLines]] object which defines
     * the color and weight of the minor ticklines.
     */
    get minorGridLines(): ChartGridLines;
    set minorGridLines(a: ChartGridLines);
    /**
     * Returns or sets the type of minor tick mark for the specified axis.
     */
    get minorTickMark(): TickMark;
    set minorTickMark(a: TickMark);
    /**
     * Returns the minor interval unit.
     * <p class="body">
     * To set the value of this property, use the [[setMajorMinorUnit]] method.
     * </p>
     * @see [[setMajorMinorUnit]]
     * @see [[majorUnit]]
     */
    get minorUnit(): number;
    set minorUnit(a: number);
    /**
     * True if Excel calculates the minor units for the value axis.
     */
    get minorUnitIsAuto(): boolean;
    set minorUnitIsAuto(a: boolean);
    /**
     * Returns or sets the minor unit scale value for the category axis when the [[categoryType]] property is set to 'TimeScale'.
     */
    get minorUnitScale(): TimeUnit;
    set minorUnitScale(a: TimeUnit);
    /**
     * Returns or sets an [[AxisPosition]] value which determines
     * the placement of the axis as relative to the chart space.
     * <p class="body">
     * This property is not applicable for series axes.
     * </p>
     */
    get position(): AxisPosition;
    set position(a: AxisPosition);
    /**
     * True if Excel plots data points from last to first.
     */
    get reversePlotOrder(): boolean;
    set reversePlotOrder(a: boolean);
    /**
     * Returns or sets a value indicating whether the axis scale is linear or logarithmic.
     * <p class="body">
     * This property is only applicable for <see cref="Type">value</see> axes.
     * </p>
     * <p class="body">
     * Logarithmic scaling is not supported for axes which are associated with a series
     * that contains negative values.
     * </p>
     */
    get scaleType(): ScaleType;
    set scaleType(a: ScaleType);
    /**
     * Describes the position of tick-mark labels on the specified axis.
     */
    get tickLabelPosition(): TickLabelPosition;
    set tickLabelPosition(a: TickLabelPosition);
    /**
     * Returns a TickLabels object that represents the tick-mark labels for the specified axis. Read-only.
     */
    get tickLabels(): TickLabels;
    /**
     * Returns or sets the number of categories or series between tick-mark labels. Applies only to category and series axes. Can be a value from 1 through 31999.
     */
    get tickLabelSpacing(): number;
    set tickLabelSpacing(a: number);
    /**
     * Returns or sets whether or not the tick label spacing is automatic.
     */
    get tickLabelSpacingIsAuto(): boolean;
    set tickLabelSpacingIsAuto(a: boolean);
    /**
     * Determines the appearance of the tick lines.
     * @see [[majorTickMark]]
     * @see [[minorTickMark]]
     */
    get tickLines(): ChartTickLines;
    set tickLines(a: ChartTickLines);
    /**
     * Returns or sets the number of categories or series between tick marks. Applies only to category and series axes. Can be a value from 1 through 31999.
     */
    get tickMarkSpacing(): number;
    set tickMarkSpacing(a: number);
    /**
     * Returns the type of the axis (read-only)
     */
    get type(): AxisType;
    /**
     * Returns or sets whether or not the axis is visible.
     */
    get visible(): boolean;
    set visible(a: boolean);
    /**
     * @hidden
     */
    get _ds(): string;
    /**
     * @hidden
     */
    get _b9(): number;
    /**
     * @hidden
     */
    get _cb(): number;
    /**
     * Sets the values of the [[majorUnit]] and [[minorUnit]] properties.
     * <p class="body">The value of the 'majorUnit' parameter must exceed the value of the 'minorUnit' parameter or an exception is thrown.</p>
     * <p class="body">
     * Typically the value of 'majorUnit' is an exact
     * multiple of 'minorUnit'; for example, for 5 minor
     * units per major unit, set majorUnit to 1 and minorUnit to .2.
     * </p>
     * @param majorUnit The new value for the [[majorUnit]] property.
     * @param minorUnit The new value for the [[minorUnit]] property.
     * @see [[majorUnit]]
     * @see [[minorUnit]]
     */
    setMajorMinorUnit(majorUnit: number, minorUnit: number): void;
    /**
     * @hidden
     */
    _dt(a: Nullable$1<number>, b: Nullable$1<number>): void;
    /**
     * @hidden
     */
    _du(a: Nullable$1<number>, b: Nullable$1<number>): {
        p0: Nullable$1<number>;
        p1: Nullable$1<number>;
    };
    /**
     * @hidden
     */
    _bt(): List$1<Series>;
    /**
     * @hidden
     */
    _a3(): Series;
    /**
     * @hidden
     */
    _dv(a: IChartObject, b: AxisGroup): void;
    /**
     * @hidden
     */
    _y(): ValueFormatter;
    /**
     * @hidden
     */
    private _bi;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    private _bl;
    /**
     * @hidden
     */
    private _dw;
    /**
     * @hidden
     */
    private _dx;
    /**
     * @hidden
     */
    private _d0;
}
/**
 * @hidden
 */
export declare class AxisCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: AxisCollection, c: Axis);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: AxisCollection;
    readonly a: Axis;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of [[Axis]] objects for a [[WorksheetChart]]
 */
export declare class AxisCollection extends ChartObject implements IEnumerable$1<Axis> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static _x;
    private _w;
    private _ae;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Returns the number of items in the collection (read-only)
     */
    get count(): number;
    /**
     * Indexer
     * @param type The type of the axis.
     * @param group The axis group, defaults to primary.
     * @return The corresponding axis or null if not in the collection.
     */
    item(a: AxisType, b?: AxisGroup): Axis;
    /**
     * Determines if the collecion can be modified (read-only)
     */
    get isReadOnly(): boolean;
    /**
     * Adds a new [[Axis]] into the collection with the specified type and groupo.
     * <para class="note">
     * <b>Note:</b> If there is an axis already in the collection of the type and group specified it will be replaced with the newly added one.
     * </para>
     * @param type The type of the axis.
     * @param group The axis group, defaults to primary.
     * @return The newly added [[Axis]]
     */
    add(type: AxisType, group?: AxisGroup): Axis;
    /**
     * @hidden
     */
    private _an;
    /**
     * Clears the collection.
     */
    clear(): void;
    [Symbol.iterator](): EnumeratorWrapper<Axis>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<Axis>;
    /**
     * Removes an axis from the collection.
     * @param type The type of the axis.
     * @param group The axis group, defaults to primary.
     * @return True if the axis was removed, otherwise false.
     */
    remove(type: AxisType, group: AxisGroup): boolean;
    /**
     * @hidden
     */
    _ao(a: Axis): void;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private _ah;
    /**
     * @hidden
     */
    private _aq;
    /**
     * @hidden
     */
    private static _ar;
    /**
     * @hidden
     */
    private static _as;
    /**
     * @hidden
     */
    private _at;
    /**
     * @hidden
     */
    _al(): void;
    /**
     * @hidden
     */
    _am(): void;
    /**
     * @hidden
     */
    _ap(a: TickMark, b: TickMark): void;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
}
/**
 * Base class for chart area elements
 */
export declare class ChartAreaBase extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    static readonly _ai: number;
    /**
     * @hidden
     */
    static readonly _aj: number;
    /**
     * @hidden
     */
    private static readonly _am;
    /**
     * @hidden
     */
    static readonly _al: number;
    /**
     * @hidden
     */
    static readonly _an: number;
    /**
     * @hidden
     */
    static readonly _ao: number;
    /**
     * @hidden
     */
    private static readonly _ak;
    /**
     * @hidden
     */
    private static _w;
    private _aa;
    private _ac;
    private _ae;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * Determines the appearance of the border drawn around
     * the chart element area, as well as whether a border appears.
     */
    get border(): ChartBorder;
    set border(a: ChartBorder);
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill properties for the chart element area.
     * <p class="body">
     * This property returns null by default, indicating that no fill is applied.
     * </p>
     * <p class="body">
     * To apply a solid color fill, assign an instance of the
     * [[ChartSolidFill]] class to this property.
     * </p>
     * <p class="body">
     * To apply a gradient fill, assign an instance of the
     * [[ChartGradientFill]] class to this property.
     * </p>
     * <p class="body">
     * To make the area transparent, assign an instance of the
     * [[ChartEmptyFill]] class to this property.
     * </p>
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     * @see [[ChartEmptyFill]]
     */
    get fill(): ChartFillBase;
    set fill(a: ChartFillBase);
    /**
     * Detrmines if the chart area is displayed with rounded corners
     */
    get roundedCorners(): boolean;
    set roundedCorners(a: boolean);
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _z;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * Represents the area in which the chart series is plotted.
 */
export declare class PlotArea extends ChartAreaBase {
    static $t: Type;
    private _as;
    private _at;
    private _au;
    private _av;
    private _aq;
    constructor(a: IChartObject);
    /**
     * Returns or sets the height of the area, expressed as a fraction of the
     * height of the containing chart element.
     * @see [[width]]
     * @see [[top]]
     * @see [[height]]
     */
    get height(): number;
    set height(a: number);
    /**
     * Returns or sets a value which represents the left edge of the area,
     * expressed as a fraction of the width of the containing chart element.
     * <p class="body">
     * This property can be set to a value between zero and one, where one
     * represents the total width of the containing element.
     * </p>
     * <p class="body">
     * For example, to situate the area such that it's left edge coincides
     * with the center of the containing element, set this property to .5.
     * </p>
     * @see [[top]]
     * @see [[width]]
     * @see [[height]]
     */
    get left(): number;
    set left(a: number);
    /**
     * Returns or sets a value which represents the top edge of the area,
     * expressed as a fraction of the height of the containing chart element.
     * <p class="body">
     * This property can be set to a value between zero and one, where one
     * represents the total height of the containing element.
     * </p>
     * <p class="body">
     * For example, to situate the area such that it's top edge coincides
     * with the center of the containing element, set this property to .5.
     * </p>
     * @see [[left]]
     * @see [[width]]
     * @see [[height]]
     */
    get top(): number;
    set top(a: number);
    /**
     * Returns or sets the width of the area, expressed as a fraction of the
     * width of the containing chart element.
     * @see [[height]]
     * @see [[top]]
     * @see [[height]]
     */
    get width(): number;
    set width(a: number);
    /**
     * Returns or sets the position of the plot area on the chart.
     */
    get position(): ElementPosition;
    set position(a: ElementPosition);
    /**
     * @hidden
     */
    get _ap(): ChartFillBase;
}
/**
 * Represents the area in which the chart is displayed.
 */
export declare class ChartArea extends ChartAreaBase {
    static $t: Type;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    get _ap(): ChartFillBase;
}
/**
 * Exposes properties which control the appearance of a line in a [[Series]].
 */
export declare class ChartLine extends ChartLineBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _aq;
    /**
     * @hidden
     */
    private static readonly _ar;
    /**
     * @hidden
     */
    static readonly _ap: number;
    private _an;
    static staticInit(): void;
    constructor();
    /**
     * Returns or sets the style for the line, i.e., solid, dashed, dotted, etc.
     */
    get lineStyle(): LineStyle;
    set lineStyle(a: LineStyle);
    /**
     * @hidden
     */
    protected get__ai(): Nullable$1<LineStyle>;
    /**
     * @hidden
     */
    private static _ak;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _am;
    /**
     * @hidden
     */
    private static _al;
}
/**
 * Base class for the display options for a chart sheet that are used for the display as well as its custom view.
 */
export declare abstract class ChartsheetDisplayOptionsBase extends DisplayOptionsBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ac;
    /**
     * @hidden
     */
    private static readonly _aa;
    /**
     * @hidden
     */
    private static readonly _ab;
    /**
     * @hidden
     */
    private static readonly _t;
    private _y;
    private _w;
    constructor(a: Chartsheet);
    /**
     * @hidden
     */
    _n(a: DisplayOptionsBase): void;
    /**
     * Resets the display options to their default settings.
     */
    protected resetCore(): void;
    /**
     * Gets or sets the magnification level of the chartsheet.
     * <p class="body">
     * Magnifications are stored as percentages of the normal viewing magnification. A value of 100 indicates normal magnification
     * whereas a value of 200 indicates a zoom that is twice the normal viewing magnification.
     * </p>
     * The magnification level of the chartsheet in the current View.
     * @throws [[ArgumentOutOfRangeException]] The assigned value is outside the valid range of magnification levels for a chartsheet. The level must be between 10 and 400.
     */
    get magnification(): number;
    set magnification(a: number);
    /**
     * Gets or sets whether the chart should be resized to match the size of the chart sheet window.
     */
    get sizeWithWindow(): boolean;
    set sizeWithWindow(a: boolean);
    /**
     * @hidden
     */
    private static _v;
    /**
     * @hidden
     */
    private static _u;
}
/**
 * Class which exposes the display options which can only be controlled through the chartsheet.
 * @see [[Chartsheet.displayOptions]]
 * @see [[CustomViewChartDisplayOptions]]
 */
export declare class ChartsheetDisplayOptions extends ChartsheetDisplayOptionsBase {
    static $t: Type;
    constructor(a: Chartsheet);
    /**
     * @hidden
     */
    _e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    protected get__j(): boolean;
    /**
     * @hidden
     */
    get _j(): boolean;
}
/**
 * Class which exposes the chartsheet display options which can only be controlled through the custom view.
 * @see [[CustomView.getSheetDisplayOptions]]
 * @see [[ChartsheetDisplayOptions]]
 */
export declare class CustomViewChartDisplayOptions extends ChartsheetDisplayOptionsBase {
    static $t: Type;
    /**
     * @hidden
     */
    readonly _ad: CustomView;
    constructor(a: Chartsheet, b: CustomView);
    /**
     * @hidden
     */
    _e(): DisplayOptionsBase;
    /**
     * @hidden
     */
    protected get__j(): boolean;
    /**
     * @hidden
     */
    get _j(): boolean;
}
/**
 * Class which exposes the various print options available for a chartsheet which can be saved with both a
 * chartsheet and a custom view.
 * <p class="body">
 * This class provides a way to control how a chartsheet is printed.
 * </p>
 * @see [[Chartsheet.printOptions]]
 * @see [[CustomView.getSheetPrintOptions]]
 */
export declare class ChartsheetPrintOptions extends PrintOptionsBase {
    static $t: Type;
    constructor(a: Chartsheet, b: boolean);
}
/**
 * Provides information about the types of changes that are disabled when the associated Chartsheet is protected.
 * @see [[Sheet.hasProtectionPassword]]
 * @see [[Sheet.isProtected]]
 * @see [[Worksheet.protection]]
 * @see@see */
export declare class ChartsheetProtection extends SheetProtection {
    static $t: Type;
    private _e;
    constructor(a: Chartsheet);
    /**
     * Returns a boolean indicating if objects such as shapes and controls may be created or changed when the chartsheet is protected.
     */
    get allowEditObjects(): boolean;
    set allowEditObjects(a: boolean);
    /**
     * Returns a boolean indicating if the chart is protected when the chartsheet is protected.
     */
    get allowEditContents(): boolean;
    set allowEditContents(a: boolean);
    /**
     * @hidden
     */
    get _f(): ChartsheetProtectionType;
    /**
     * @hidden
     */
    _j(a: any, b?: Nullable$1<boolean>, c?: Nullable$1<boolean>): void;
    /**
     * @hidden
     */
    private _i;
    /**
     * @hidden
     */
    private _k;
    /**
     * @hidden
     */
    private _l;
}
/**
 * Base class for chart elements which behave as a label.
 */
export declare class ChartLabelBase extends ChartTextAreaBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ca;
    /**
     * @hidden
     */
    private static readonly _cb;
    /**
     * @hidden
     */
    static readonly _b9: number;
    private _cc;
    private _b7;
    constructor(a: IChartObject);
    /**
     * Returns or sets the format to use for numbers.
     * @see [[numberFormatLinked]]
     */
    get numberFormat(): string;
    set numberFormat(a: string);
    /**
     * True if the number format is linked to the cells (so that the number format changes in the labels when it changes in the cells).
     * @see [[numberFormat]]
     */
    get numberFormatLinked(): boolean;
    set numberFormatLinked(a: boolean);
    /**
     * @hidden
     */
    private static _b4;
    static staticInit(): void;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _b6;
    /**
     * @hidden
     */
    private static _b5;
}
/**
 * Represents the label of a specific [[DataPoint]].
 */
export declare class DataLabel extends ChartLabelBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _cz;
    /**
     * @hidden
     */
    private static readonly _c0;
    /**
     * @hidden
     */
    private static readonly _c1;
    /**
     * @hidden
     */
    private static readonly _c3;
    /**
     * @hidden
     */
    private static readonly _c4;
    /**
     * @hidden
     */
    private static readonly _c5;
    /**
     * @hidden
     */
    private static readonly _c6;
    /**
     * @hidden
     */
    private static readonly _c7;
    /**
     * @hidden
     */
    private static readonly _c8;
    /**
     * @hidden
     */
    private static readonly _c9;
    /**
     * @hidden
     */
    private static readonly _da;
    /**
     * @hidden
     */
    private static readonly _db;
    /**
     * @hidden
     */
    static readonly _c2: number;
    /**
     * @hidden
     */
    private static _ce;
    private _cv;
    private _cm;
    private _ci;
    private _dr;
    private _dc;
    private _dd;
    private _de;
    private _df;
    private _dg;
    private _dh;
    private _di;
    private _cw;
    static staticInit(): void;
    constructor();
    constructor(owner: IChartObject);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * Not supported.
     */
    protected get_formula(): Formula;
    /**
     * Returns or sets a value that represents the height of the
     * label, expressed as a ratio, relative to the size of the
     * chart area.
     */
    protected get_height(): number;
    protected set_height(a: number): void;
    /**
     * Returns or sets a value that represents the height of the
     * label, expressed as a ratio, relative to the size of the
     * chart area.
     */
    get height(): number;
    set height(a: number);
    /**
     * Returns or sets a boolean value indicating whether this label
     * has been deleted.
     */
    protected get_isDeleted(): boolean;
    protected set_isDeleted(a: boolean): void;
    /**
     * Returns or sets a boolean value indicating whether this label
     * has been deleted.
     */
    get isDeleted(): boolean;
    set isDeleted(a: boolean);
    /**
     * Returns or sets a value which determines the label's position
     * as relative to the series bar/line.
     * <p class="body">
     * When this property is set to <i>Custom</i>, the position is determined
     * by the values of the <see cref="ChartTextAreaBase.Left">Left</see> and
     * <see cref="ChartTextAreaBase.Top">Top</see> properties.
     * </p>
     * <p class="body">
     * When a custom label position is assigned, connecting lines appear between
     * the label and its respective [[DataPoint]]. These lines are referred
     * to as 'leader lines'; use the [[Series.leaderLines]] property to control
     * their appearance.
     * </p>
     * <p class="body">
     * Note that leader lines can be hidden by setting the [[SeriesDataLabels.showLeaderLines]]
     * property to <i>false</i>.
     * </p>
     * @see [[ChartTextAreaBase.left]]
     * @see [[ChartTextAreaBase.top]]
     * @see [[Series.leaderLines]]
     * @see [[SeriesDataLabels.showLeaderLines]]
     */
    get labelPosition(): DataLabelPosition;
    set labelPosition(a: DataLabelPosition);
    /**
     * This property is not supported. Use the [[labelPosition]] property instead.
     */
    protected get_position(): ElementPosition;
    protected set_position(a: ElementPosition): void;
    /**
     * Returns or sets the separator used between multiple values in the label.
     */
    get separator(): string;
    set separator(a: string);
    /**
     * Returns or sets if the bubble size is shown.
     * Applies only to [[Series]] which are displayed
     * within a bubble chart.
     */
    get showBubbleSize(): boolean | null;
    set showBubbleSize(a: boolean | null);
    /**
     * @hidden
     */
    get _showBubbleSize$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _showBubbleSize$i(a: Nullable$1<boolean>);
    /**
     * @hidden
     */
    protected get__co(): boolean;
    /**
     * @hidden
     */
    get _co(): boolean;
    /**
     * Returns or sets a value indicating whether the category name is shown.
     * <p class="body">
     * The category name is not shown by default; to show the category name in the label, set this property to <i>true</i>.
     * </p>
     */
    get showCategoryName(): boolean | null;
    set showCategoryName(a: boolean | null);
    /**
     * @hidden
     */
    get _showCategoryName$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _showCategoryName$i(a: Nullable$1<boolean>);
    /**
     * @hidden
     */
    get _cp(): boolean;
    /**
     * Returns or sets if the [[Legend]] key is shown.
     * <p class="body">
     * The legend key is not shown by default; to show the legend key in the label, set this property to <i>true</i>.
     * </p>
     */
    get showLegendKey(): boolean | null;
    set showLegendKey(a: boolean | null);
    /**
     * @hidden
     */
    get _showLegendKey$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _showLegendKey$i(a: Nullable$1<boolean>);
    /**
     * @hidden
     */
    get _cq(): boolean;
    /**
     * Returns or sets a value indicating whether the percentage of the range is shown.
     * <p class="body">
     * The percentage is not shown by default; to show the percentage in the label, set this property to <i>true</i>.
     * </p>
     */
    get showPercentage(): boolean | null;
    set showPercentage(a: boolean | null);
    /**
     * @hidden
     */
    get _showPercentage$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _showPercentage$i(a: Nullable$1<boolean>);
    /**
     * @hidden
     */
    get _cr(): boolean;
    /**
     * Returns or sets a value indicating whether the series
     * <see cref="Series.Name">name</see> is shown in the label.
     * <p class="body">
     * The series name  is not shown by default; to show the series name in the label, set this property to <i>true</i>.
     * </p>
     */
    get showSeriesName(): boolean | null;
    set showSeriesName(a: boolean | null);
    /**
     * @hidden
     */
    get _showSeriesName$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _showSeriesName$i(a: Nullable$1<boolean>);
    /**
     * @hidden
     */
    get _ct(): boolean;
    /**
     * Returns or sets a boolean value indicating whether the data label range is shown.
     * <p class="body">
     * The data label range is defined by the [[SeriesDataLabels.dataLabelsRange]]
     * </p>
     * <p class="body">
     * The data label range is not shown by default; to show the range in the label, set this property to <i>true</i>.
     * </p>
     * @see [[SeriesDataLabels.dataLabelsRange]]
     */
    get showRange(): boolean | null;
    set showRange(a: boolean | null);
    /**
     * @hidden
     */
    get _showRange$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _showRange$i(a: Nullable$1<boolean>);
    /**
     * @hidden
     */
    get _cs(): boolean;
    /**
     * Returns or sets a value indicating whether the value is shown.
     * <p class="body">
     * The value is shown by default; to prevent the value from displaying in the label, set this property to <i>false</i>.
     * </p>
     */
    get showValue(): boolean | null;
    set showValue(a: boolean | null);
    /**
     * @hidden
     */
    get _showValue$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _showValue$i(a: Nullable$1<boolean>);
    /**
     * @hidden
     */
    get _cu(): boolean;
    /**
     * Returns or sets a value that represents the width of the
     * label, expressed as a ratio, relative to the size of the
     * chart area.
     */
    protected get_width(): number;
    protected set_width(a: number): void;
    /**
     * Returns or sets a value that represents the width of the
     * label, expressed as a ratio, relative to the size of the
     * chart area.
     */
    get width(): number;
    set width(a: number);
    /**
     * @hidden
     */
    protected get__ad(): ChartFillBase;
    /**
     * @hidden
     */
    get _ch(): ChartBorder;
    /**
     * @hidden
     */
    get _cl(): IWorkbookFont;
    /**
     * @hidden
     */
    protected get__ck(): SeriesDataLabels;
    /**
     * @hidden
     */
    get _ck(): SeriesDataLabels;
    /**
     * Not supported.
     */
    setFormula(formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setFormula1(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    _dt(a?: Nullable$1<boolean>): void;
    /**
     * @hidden
     */
    private static _cg;
    /**
     * @hidden
     */
    private static _cf;
}
/**
 * Defines the properties for all <see cref="DataLabel">data labels</see>
 * displayed for this [[Series]].
 * <p class="body">
 * This property provides a way to set properties on multiple <see cref="DataLabel">data labels</see>.
 * </p>
 * <p class="body">
 * Use the [[DataPoint.dataLabel]] property to customize an individual data label.
 * </p>
 * <p class="body">
 * The property values of the [[DataPoint.dataLabel]] class take precedence
 * over the properties of this class.
 * </p>
 * @see [[DataLabel]]
 * @see [[DataPoint.dataLabel]]
 * @see [[Series.dataPointCollection]]
 */
export declare class SeriesDataLabels extends DataLabel {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _d6;
    /**
     * @hidden
     */
    private static readonly _d8;
    /**
     * @hidden
     */
    private static readonly _d9;
    /**
     * @hidden
     */
    static readonly _d7: number;
    /**
     * @hidden
     */
    private static readonly _d5;
    private _d0;
    private _dx;
    private _d3;
    static staticInit(): void;
    constructor(a: Series);
    /**
     * Not supported.
     */
    protected get_left(): number;
    protected set_left(a: number): void;
    /**
     * Not supported.
     */
    protected get_top(): number;
    protected set_top(a: number): void;
    /**
     * Not supported.
     */
    protected get_text(): FormattedString;
    protected set_text(a: FormattedString): void;
    /**
     * Not supported.
     */
    protected get_isDeleted(): boolean;
    protected set_isDeleted(a: boolean): void;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * Not supported.
     */
    protected get_height(): number;
    protected set_height(a: number): void;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _k(a: any): any;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Not supported.
     */
    protected get_width(): number;
    protected set_width(a: number): void;
    /**
     * Returns a [[Formula]] which defines the cell range
     * from which part or all of the label text is obtained.
     * <p class="body">
     * Use the [[setDataLabelsRange]]
     * method to assign a new value.
     * </p>
     * <p class="body">
     * The cell values obtained from this property are only displayed when the
     * [[DataLabel.showRange]] property is set to true.
     * </p>
     * <p class="body">
     * The specified range must contain only one column or one row, or an exception is thrown.
     * </p>
     * @see [[setDataLabelsRange]]
     * @see [[DataLabel.showRange]]
     */
    get dataLabelsRange(): Formula;
    /**
     * @hidden
     */
    get _d1(): SingleTargetFormula;
    /**
     * @hidden
     */
    set _d1(a: SingleTargetFormula);
    /**
     * @hidden
     */
    get _ea(): string;
    /**
     * Returns or sets a value which determines the label positioning
     * for a <i>Treemap</i> chart.
     * <p class="body">
     * This property is only applicable for <i>Treemap</i> charts.
     * </p>
     */
    get parentLabelLayout(): ParentLabelLayout;
    set parentLabelLayout(a: ParentLabelLayout);
    /**
     * Returns or sets a boolean value indicating whether <see cref="Series.LeaderLines">leader lines</see>
     * are displayed for the data labels associated with this instance.
     * <p class="body">
     * Leader lines connect <see cref="DataLabel">data labels</see> to their respective
     * <see cref="DataPoint">data points</see>.
     * </p>
     * <p class="body">
     * The [[LeaderLines]] property provides a way to customize the appearance
     * of the connecting lines. These lines are only drawn, however, for data labels whose
     * [[DataLabel.labelPosition]] property is set to <i>Custom</i>.
     * </p>
     * <p class="body">
     * Use this property to allow leader lines to be shown using the default appearance, i.e.,
     * setting this property to true without specifying a custom appearance causes them to
     * acquire the default appearance as determined by Excel.
     * </p>
     * <p class="body">
     * Leader lines can be hidden by setting this property to <i>false</i>.
     * </p>
     * @see [[Series.leaderLines]]
     * @see [[DataLabel]]
     * @see [[DataLabel.labelPosition]]
     * @see [[ChartTextAreaBase.left]]
     * @see [[ChartTextAreaBase.top]]
     * @see [[DataPoint]]
     */
    get showLeaderLines(): boolean;
    set showLeaderLines(a: boolean);
    /**
     * @hidden
     */
    protected get__ck(): SeriesDataLabels;
    /**
     * Assigns a [[Formula]] to the [[dataLabelsRange]]
     * @param formula The string representation of the formula used to obtain the data label text.
     * @param cellReferenceMode A [[CellReferenceMode]] value which specifies whether the 'formula' parameter should be interpreted as an <b>A1</b> or <b>R1C1</b> expression. This parameter is optional and defaults to null, in which case the [[Workbook.cellReferenceMode]] property is used.
     */
    setDataLabelsRange(formula: string, cellReferenceMode?: CellReferenceMode): void;
    /**
     * @hidden
     */
    _setDataLabelsRange1(a: string, b?: Nullable$1<CellReferenceMode>): void;
    /**
     * @hidden
     */
    _eb(a: Sheet, b: SingleTargetFormula): void;
    /**
     * @hidden
     */
    private static _d2;
    /**
     * @hidden
     */
    private static _du;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _dw;
    /**
     * @hidden
     */
    private static _dv;
}
/**
 * Represents the a specific data point in a [[series]].
 * <p class="body">
 * This class encapsulates an individual point of data in a [[series]].
 * </p>
 * <p class="body">
 * A data point manifests differently depending on the chart type; for example,
 * on a bar chart it represents the bar itself, and for a line chart, it represents
 * a point on the line. For pie and doughnut charts, a data point represents a slice
 * or wedge in the pie/doughnut.
 * </p>
 * <p class="body">
 * Many of the properties exposed by this class are also found on the
 * [[series]] class; setting the property on the series affects
 * all points on the series, whereas setting a property on this class affects
 * only one individual point in the series.
 * </p>
 * <p class="body">
 * In cases where <i>most</i> of the data points share the same property values, use
 * the property of the Series class, overriding the property values for any individual
 * points using this class.
 * </p>
 * @see [[series]]
 * @see [[Series.explosion]]
 * @see [[Series.markerStyle]]
 */
export declare class DataPoint extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ax;
    /**
     * @hidden
     */
    private static readonly _ay;
    /**
     * @hidden
     */
    private static readonly _az;
    /**
     * @hidden
     */
    private static readonly _a0;
    /**
     * @hidden
     */
    private static readonly _a1;
    /**
     * @hidden
     */
    private static readonly _a2;
    /**
     * @hidden
     */
    private static readonly _a4;
    /**
     * @hidden
     */
    private static readonly _a5;
    /**
     * @hidden
     */
    private static readonly _a6;
    /**
     * @hidden
     */
    private static readonly _a7;
    /**
     * @hidden
     */
    private static readonly _a8;
    /**
     * @hidden
     */
    private static readonly _ba;
    /**
     * @hidden
     */
    private static readonly _bc;
    /**
     * @hidden
     */
    private static readonly _bb;
    /**
     * @hidden
     */
    private static _w;
    private _bd;
    private _be;
    private _bf;
    private _z;
    private _am;
    private _bg;
    private _af;
    private _bh;
    private _aa;
    private _ag;
    private _bi;
    private _bj;
    private _aq;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Returns or sets a value indicating whether a picture is applied to the end
     * of the point or all points in the series.
     */
    get applyPicToEnd(): boolean | null;
    set applyPicToEnd(a: boolean | null);
    /**
     * @hidden
     */
    get _applyPicToEnd$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _applyPicToEnd$i(a: Nullable$1<boolean>);
    /**
     * @hidden
     */
    get _ar(): boolean;
    /**
     * Returns or sets a value indicating whether a picture is applied to the front
     * of the point or all points in the series.
     */
    get applyPicToFront(): boolean | null;
    set applyPicToFront(a: boolean | null);
    /**
     * @hidden
     */
    get _applyPicToFront$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _applyPicToFront$i(a: Nullable$1<boolean>);
    /**
     * @hidden
     */
    get _as(): boolean;
    /**
     * Returns or sets a value indicating whether a picture is applied to the sides
     * of the point or all points in the series.
     */
    get applyPicToSides(): boolean | null;
    set applyPicToSides(a: boolean | null);
    /**
     * @hidden
     */
    get _applyPicToSides$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _applyPicToSides$i(a: Nullable$1<boolean>);
    /**
     * @hidden
     */
    get _at(): boolean;
    /**
     * Determines the appearance of the border drawn around the
     * data point's [[fill]] area.
     * <p class="body">
     * For series which support <see cref="Fill">fills</see>, this property controls the
     * color and size of the line drawn around the data point's fill region.
     * </p>
     * @see [[fill]]
     */
    get border(): ChartBorder;
    set border(a: ChartBorder);
    /**
     * @hidden
     */
    get _ac(): ChartBorder;
    /**
     * Returns or sets a [[dataLabel]] instance which defines
     * the properties of the label displayed for this data point.
     * <p class="body">
     * In order to display data labels, the [[Series.showDataLabels]]
     * property must be set to true.
     * </p>
     * <p class="body">
     * Use the [[Series.dataLabels]] property to apply property
     * settings to all data labels in the series.
     * </p>
     * <p class="body">
     * Use the [[DataLabel.isDeleted]] property to hide the label
     * for a specific data point.
     * </p>
     * @see [[Series.showDataLabels]]
     * @see [[Series.dataLabels]]
     */
    get dataLabel(): DataLabel;
    set dataLabel(a: DataLabel);
    /**
     * Returns or sets the explosion value for a pie-chart or doughnut-chart slice.
     * <p class="body">
     * In the context of a pie or doughnut chart, a [[DataPoint]]
     * is synonymous with an individual slice of the pie/doughnut.
     * </p>
     * <p class="body">
     * <i>Explosion</i> refers to the amount by which a slice in the pie is
     * offset from the center point of the circle.
     * </p>
     * <p class="body">
     * The valid range of values is between 0 and 400, inclusive.
     * </p>
     * <p class="body">
     * Use the [[Series.explosion]] property to set the explosion
     * for all slices in the pie.
     * </p>
     * @see [[Series.explosion]]
     * @throws [[ArgumentOutOfRangeException]] The value is outside the range of 0 and 400.
     */
    get explosion(): number | null;
    set explosion(a: number | null);
    /**
     * @hidden
     */
    get _explosion$i(): Nullable$1<number>;
    /**
     * @hidden
     */
    set _explosion$i(a: Nullable$1<number>);
    /**
     * @hidden
     */
    get _a3(): number;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill properties for the data point.
     * <p class="body">
     * This property returns null by default, indicating that no fill is applied.
     * In this case, the default fill color for the associated [[series]]
     * is used.
     * </p>
     * <p class="body">
     * To apply a solid color fill, assign an instance of the
     * [[ChartSolidFill]] class to this property.
     * </p>
     * <p class="body">
     * To apply a gradient fill, assign an instance of the
     * [[ChartGradientFill]] class to this property.
     * </p>
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     */
    get fill(): ChartFillBase;
    set fill(a: ChartFillBase);
    /**
     * @hidden
     */
    get _ai(): ChartFillBase;
    /**
     * Returns or sets a value indicating whether the pattern is inverted
     * in the item when it corresponds to a negative number.
     */
    get invertIfNegative(): boolean | null;
    set invertIfNegative(a: boolean | null);
    /**
     * @hidden
     */
    get _invertIfNegative$i(): Nullable$1<boolean>;
    /**
     * @hidden
     */
    set _invertIfNegative$i(a: Nullable$1<boolean>);
    /**
     * @hidden
     */
    get _au(): boolean;
    /**
     * Determines the appearance of the <see cref="ChartBorder">border</see>
     * (a.k.a. outline) of the marker for this data point.
     * <p class="body">
     * This property provides a way to customize the marker border for
     * an individual data point in the series.
     * </p>
     * <p class="body">
     * A value of null implies that the marker border is not explicitly
     * set on this data point, and should inherit the value from it's
     * associated [[series]].
     * </p>
     * <p class="body">
     * Use the [[Series.markerBorder]] property to customize the border
     * for all markers in the series.
     * </p>
     * @see [[Series.markerBorder]]
     */
    get markerBorder(): ChartBorder;
    set markerBorder(a: ChartBorder);
    /**
     * @hidden
     */
    get _ae(): ChartBorder;
    /**
     * Defines the <see cref="ChartFillBase">fill</see> appearance of the marker for this data point.
     * <p class="body">
     * This property provides a way to customize the marker fill color for
     * an individual data point in the series.
     * </p>
     * <p class="body">
     * A value of null implies that the marker fill color is not explicitly
     * set on this data point, and should inherit the value from it's
     * associated [[series]].
     * </p>
     * <p class="body">
     * Use the [[Series.markerFill]] property to customize the fill color
     * for all markers in the series.
     * </p>
     * @see [[Series.markerFill]]
     */
    get markerFill(): ChartFillBase;
    set markerFill(a: ChartFillBase);
    /**
     * @hidden
     */
    get _al(): ChartFillBase;
    /**
     * Determines the size of the marker for this data point.
     * <p class="body">
     * This property provides a way to customize the marker size for
     * an individual data point in the series.
     * </p>
     * <p class="body">
     * A value of null implies that the marker size is not explicitly
     * set on this data point, and should inherit the value from it's
     * associated [[series]].
     * </p>
     * <p class="body">
     * Use the [[Series.markerSize]] property to customize the size
     * of all markers in the series.
     * </p>
     * @see [[Series.markerSize]]
     */
    get markerSize(): number | null;
    set markerSize(a: number | null);
    /**
     * @hidden
     */
    get _markerSize$i(): Nullable$1<number>;
    /**
     * @hidden
     */
    set _markerSize$i(a: Nullable$1<number>);
    /**
     * @hidden
     */
    get _a9(): number;
    /**
     * Determines the style of the marker for this data point.
     * <p class="body">
     * This property provides a way to customize the marker style for
     * an individual data point in the series.
     * </p>
     * <p class="body">
     * A value of null implies that the marker style is not explicitly
     * set on this data point, and should inherit the value from it's
     * associated [[series]].
     * </p>
     * <p class="body">
     * Use the [[Series.markerStyle]] property to customize the style
     * of all markers in the series.
     * </p>
     * @see [[Series.markerStyle]]
     */
    get markerStyle(): MarkerStyle | null;
    set markerStyle(a: MarkerStyle | null);
    /**
     * @hidden
     */
    get _markerStyle$i(): Nullable$1<MarkerStyle>;
    /**
     * @hidden
     */
    set _markerStyle$i(a: Nullable$1<MarkerStyle>);
    /**
     * @hidden
     */
    get _ao(): MarkerStyle;
    /**
     * Returns or sets a boolean value indicating whether this data point represents
     * a total or subtotal in a waterfall chart.
     * <p class="body">
     * This property is only applicable for waterfall charts.
     * </p>
     * @see [[Series.showWaterfallConnectorLines]]
     */
    get setAsTotal(): boolean;
    set setAsTotal(a: boolean);
    /**
     * @hidden
     */
    get _ap(): Series;
    /**
     * @hidden
     */
    _aw(a: boolean): boolean;
    /**
     * @hidden
     */
    _aj(a: number): ChartFillBase;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * A collection of [[DataPoint]]s for a [[series]]
 */
export declare class DataPointCollection extends ChartObject implements IEnumerable$1<DataPoint> {
    static $t: Type;
    private _af;
    private _ad;
    private _z;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _k(a: any): any;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * @hidden
     */
    get _y(): Series;
    /**
     * Returns the [[DataPoint]] instance at the specified
     * ordinal position within this collection.
     * @param index A zero based index
     * @return A [[DataPoint]] instance.
     */
    item(a: number): DataPoint;
    /**
     * @hidden
     */
    private _ai;
    /**
     * Returns the number of items in the collection (read-only)
     */
    get count(): number;
    /**
     * Determines if the collection contains thhe item
     * @param item The item to check
     * @return True if the item is in the collection, otherwise false.
     */
    contains(item: DataPoint): boolean;
    [Symbol.iterator](): EnumeratorWrapper<DataPoint>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<DataPoint>;
    /**
     * Returns the index of the item in the collection
     * @param item The item to check
     * @return the zero-based index or -1 if the item isn't in the collection.
     */
    indexOf(item: DataPoint): number;
    /**
     * @hidden
     */
    _al(a: number, b: List$1<Tuple$3<boolean, number, number>>, c: (arg1: IChartObject, arg2: any) => void): void;
    /**
     * @hidden
     */
    _an(): void;
    /**
     * @hidden
     */
    private _ac;
    /**
     * @hidden
     */
    _w(): DataPoint[];
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
    /**
     * @hidden
     */
    _aj(): void;
    /**
     * @hidden
     */
    _ab(a: Series, b: boolean): boolean;
    /**
     * @hidden
     */
    private _ae;
    /**
     * @hidden
     */
    _ak(a: Dictionary$2<number, DataPoint>): void;
    /**
     * @hidden
     */
    _am(): void;
}
/**
 * @hidden
 */
export declare class DataPointCollection_UndoContext extends ValueType {
    static $t: Type;
    constructor(a: number, b: boolean, c: number, d: DataPoint[]);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly b: boolean;
    readonly c: number;
    readonly a: DataPoint[];
}
/**
 * Exposes properties which control the appearance and behavior
 * of a geographic map chart.
 * <p class="body">
 * This class is immutable.
 * </p>
 * <p class="body">
 * This class is only used by <i>RegionMap</i> charts.
 * </p>
 */
export declare class GeographicMapSettings extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _g: string;
    /**
     * @hidden
     */
    static readonly _j: string;
    /**
     * @hidden
     */
    static readonly _k: string;
    /**
     * @hidden
     */
    static readonly _l: string;
    constructor(cultureLanguage: string, cultureRegion: string, attribution: string, projection?: GeographicMapProjection, area?: GeographicMappingArea, labels?: GeographicMapLabels, colors?: GeographicMapColors);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    static _c(): GeographicMapSettings;
    /**
     * @hidden
     */
    get _m(): string;
    private _cultureLanguage;
    /**
     * Returns the culture language for this instance.
     */
    get cultureLanguage(): string;
    set cultureLanguage(a: string);
    private _cultureRegion;
    /**
     * Returns the culture region for this instance.
     */
    get cultureRegion(): string;
    set cultureRegion(a: string);
    private _attribution;
    /**
     * Returns the attribution for this instance.
     */
    get attribution(): string;
    set attribution(a: string);
    /**
     * Returns the map projection for this instance.
     */
    get projection(): GeographicMapProjection | null;
    set projection(a: GeographicMapProjection | null);
    private _projection$i_1;
    /**
     * @hidden
     */
    get _projection$i(): Nullable$1<GeographicMapProjection>;
    /**
     * @hidden
     */
    set _projection$i(a: Nullable$1<GeographicMapProjection>);
    /**
     * Returns the mapping area for this instance.
     */
    get area(): GeographicMappingArea | null;
    set area(a: GeographicMappingArea | null);
    private _area$i_1;
    /**
     * @hidden
     */
    get _area$i(): Nullable$1<GeographicMappingArea>;
    /**
     * @hidden
     */
    set _area$i(a: Nullable$1<GeographicMappingArea>);
    private _labels;
    /**
     * Returns a value indicating the manner in which map area labels are displayed.
     */
    get labels(): GeographicMapLabels;
    set labels(a: GeographicMapLabels);
    private _colors;
    /**
     * Returns a [[GeographicMapColors]] instance which defines the minimum,
     * midpoint, and maximum colors used for the applicable areas of a geographic map
     * chart.
     * @see [[GeographicMapColors]]
     */
    get colors(): GeographicMapColors;
    set colors(a: GeographicMapColors);
}
/**
 * Exposes properties related to series coloring for a geographic map chart.
 * <p class="body">
 * This class is immutable.
 * </p>
 * <p class="body">
 * Assign an instance of this class to the <see cref="GeographicMapSettings.Colors">Colors</see>
 * property of the [[GeographicMapSettings]] class to provide custom colors for map areas.
 * </p>
 */
export declare class GeographicMapColors extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    readonly _c: number[];
    /**
     * @hidden
     */
    readonly _b: number[];
    /**
     * @hidden
     */
    readonly _a: number[];
    constructor(seriesColor: GeographicMapSeriesColor, minimum: WorkbookColorInfo, midpoint: WorkbookColorInfo, maximum: WorkbookColorInfo);
    private _minimum;
    /**
     * Returns the color used for the minimum value.
     */
    get minimum(): WorkbookColorInfo;
    set minimum(a: WorkbookColorInfo);
    /**
     * @hidden
     */
    get _j(): WorkbookColorInfo;
    private _midpoint;
    /**
     * Returns the color used for the midpoint value.
     */
    get midpoint(): WorkbookColorInfo;
    set midpoint(a: WorkbookColorInfo);
    /**
     * @hidden
     */
    get _h(): WorkbookColorInfo;
    private _maximum;
    /**
     * Returns the color used for the maximum value.
     */
    get maximum(): WorkbookColorInfo;
    set maximum(a: WorkbookColorInfo);
    /**
     * @hidden
     */
    get _f(): WorkbookColorInfo;
    private _seriesColor;
    /**
     * Returns a value indicating whether a sequential (two-color)
     * or divergent (three-color) scheme is used to color regions in
     * a geographic map chart.
     */
    get seriesColor(): GeographicMapSeriesColor;
    set seriesColor(a: GeographicMapSeriesColor);
}
/**
 * Represents leader lines on a chart. Leader lines connect data labels to data points.
 * <para class="note">
 * <b>Note:</b> this object is not a collection and there is no object that represents a single leader line.
 * </para>
 */
export declare class LeaderLines extends ChartLineBase {
    static $t: Type;
    private _ak;
    constructor();
    constructor(owner: IChartObject);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    get _al(): ChartFillBase;
}
/**
 * Represents a [[Trendline]] label.
 */
export declare class TrendlineLabel extends ChartLabelBase {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _cl;
    /**
     * @hidden
     */
    private static readonly _cm;
    /**
     * @hidden
     */
    static readonly _cn: number;
    private _ch;
    private _ci;
    constructor();
    /**
     * Returns or sets a boolean value indicating whether the
     * default trendline equation is displayed within the label.
     * @see [[Trendline.label]]
     */
    get displayEquation(): boolean;
    set displayEquation(a: boolean);
    /**
     * Returns or sets a boolean value indicating whether the
     * default R-squared function is displayed within the label.
     * @see [[Trendline.label]]
     */
    get displayRSquared(): boolean;
    set displayRSquared(a: boolean);
    /**
     * @hidden
     */
    private static _ce;
    static staticInit(): void;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _cg;
    /**
     * @hidden
     */
    private static _cf;
}
/**
 * Represents the title of a [[WorksheetChart]] or [[Axis]].
 */
export declare class TrendlineLine extends ChartLine {
    static $t: Type;
    constructor();
    /**
     * @hidden
     */
    _as(a: number): ChartFillBase;
}
/**
 * Represents a [[Series]] trendline.
 * @see [[Series.trendlineCollection]]
 */
export declare class Trendline extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _ar;
    /**
     * @hidden
     */
    private static readonly _as;
    /**
     * @hidden
     */
    private static readonly _at;
    /**
     * @hidden
     */
    private static readonly _au;
    /**
     * @hidden
     */
    private static readonly _av;
    /**
     * @hidden
     */
    private static readonly _ax;
    /**
     * @hidden
     */
    private static readonly _az;
    /**
     * @hidden
     */
    private static readonly _a0;
    /**
     * @hidden
     */
    private static readonly _aw;
    /**
     * @hidden
     */
    static readonly _aq: number;
    private _aj;
    private _ak;
    private _a1;
    private _ab;
    private _z;
    private _ad;
    private _a3;
    private _af;
    private _ao;
    private _ah;
    /**
     * @hidden
     */
    static readonly _am: number;
    constructor(a: TrendlineCollection);
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Specifies the number of periods or units by which the
     * trendline extends backward.
     */
    get backward(): number;
    set backward(a: number);
    /**
     * Specifies the number of periods or units by which the
     * trendline extends forward.
     */
    get forward(): number;
    set forward(a: number);
    /**
     * Specifies the value axis intercept for the trendline.
     * <p class="body">
     * If this property is left unset, or assigned a value of null,
     * the intercept is automatically determined by Excel.
     * </p>
     */
    get intercept(): number | null;
    set intercept(a: number | null);
    /**
     * @hidden
     */
    get _intercept$i(): Nullable$1<number>;
    /**
     * @hidden
     */
    set _intercept$i(a: Nullable$1<number>);
    /**
     * Returns or sets a [[TrendlineLabel]] instance
     * which determines the text and appearance of the trendline label.
     * <p class="body">
     * This property is null by default, which prevents a label from appearing.
     * </p>
     * <p class="body">
     * To display a label for the trendline, assign a [[TrendlineLabel]]
     * instance to this property.
     * </p>
     * @see [[TrendlineLabel]]
     */
    get label(): TrendlineLabel;
    set label(a: TrendlineLabel);
    /**
     * Returns a [[legendEntry]] instance which determines the
     * appearance of this trendline's appearance in the [[WorksheetChart.legend]].
     * @see [[WorksheetChart.legend]]
     */
    get legendEntry(): LegendEntry;
    set legendEntry(a: LegendEntry);
    /**
     * Returns or sets a [[TrendlineLine]] instance which controls
     * the color and width of the trendline.
     * <p class="body">
     * To prevent the trendline from appearing in the chart, set this property to null.
     * </p>
     */
    get line(): TrendlineLine;
    set line(a: TrendlineLine);
    /**
     * Specifies the name of the trendline.
     */
    get name(): string;
    set name(a: string);
    /**
     * Specifies the order/degree of the polynomial function
     * which defines the trendline. Applicable only when the
     * [[trendlineType]] property is set to <i>Polynomial</i>.
     * <p class="body">
     * This property is only applicable when the [[trendlineType]]
     * property is set to <i>Polynomial</i>.
     * </p>
     * <p class="body">
     * Trendlines support second-degree through sixth-degree polynomials.
     * </p>
     */
    get order(): TrendlinePolynomialOrder;
    set order(a: TrendlinePolynomialOrder);
    /**
     * Specifies the period for a moving-average trendline.
     * Applicable only when the [[trendlineType]]
     * property is set to <i>MovingAverage</i>.
     */
    get period(): number;
    set period(a: number);
    /**
     * Specifies the type of trendline, i.e., linear, exponential, polynomial, etc.
     */
    get trendlineType(): TrendlineType;
    set trendlineType(a: TrendlineType);
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * @hidden
 */
export declare class TrendlineCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: TrendlineCollection, c: Trendline, d: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly c: number;
    readonly b: TrendlineCollection;
    readonly a: Trendline;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of [[Trendline]] objects belonging to the same [[Series]].
 * @see [[Series.trendlineCollection]]
 */
export declare class TrendlineCollection extends ChartObject implements IEnumerable$1<Trendline> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _ak;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    private static _w;
    private _af;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Returns the [[Trendline]] instance at the specified
     * ordinal position within the collection.
     * @param index A zero based index
     */
    item(a: number): Trendline;
    /**
     * Returns the number of items in the collection (read-only)
     */
    get count(): number;
    /**
     * Determines if the collecion can be modified (read-only)
     */
    get isReadOnly(): boolean;
    /**
     * Adds a new [[Trendline]] to the collection
     * @return The newly added [[Series]]
     */
    add(): Trendline;
    /**
     * @hidden
     */
    _al(a: Trendline): void;
    /**
     * Clears the collection.
     */
    clear(): void;
    /**
     * Returns a boolean value indicating whether the specified
     * instance is contained within this collection.
     * @param item The item to check
     * @return True if the item is in the collection, otherwise false.
     */
    contains(item: Trendline): boolean;
    [Symbol.iterator](): EnumeratorWrapper<Trendline>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<Trendline>;
    /**
     * Returns the index of the item in the collection.
     * @param item The item to check
     * @return the zero-based index or -1 if the item isn't in the collection.
     */
    indexOf(item: Trendline): number;
    /**
     * Inserts a new [[Trendline]] into the collection at the specified index.
     * @param index The index at which to insert the new trendline.
     * @return The newly inserted [[Trendline]]
     */
    insert(index: number): Trendline;
    /**
     * @hidden
     */
    private _an;
    /**
     * Removes an item from the collection.
     * @param item The [[Trendline]] to remove
     * @return True if the trendline was removed, otherwise false.
     */
    remove(item: Trendline): boolean;
    /**
     * Removes the series at the specified index
     * @param index The zero-based index
     */
    removeAt(index: number): void;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    private static _ap;
    /**
     * @hidden
     */
    private static _aq;
}
/**
 * Represents the error bars on a chart series.
 * <para>
 * Error bars indicate the degree of uncertainty for chart data. Only series in area, bar, column, line, and scatter groups on a 2-D chart can have error bars. Only series in scatter groups can have x and y error bars. This object isn't a collection. There's no object that represents a single error bar; you either have x error bars or y error bars turned on for all points in a series or you have them turned off.
 * </para>
 */
export declare class ErrorBars extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _am;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _ar;
    /**
     * @hidden
     */
    private static readonly _as;
    /**
     * @hidden
     */
    private static readonly _aq;
    /**
     * @hidden
     */
    private static readonly _w;
    private _ae;
    private _ac;
    private _ag;
    private _z;
    private _ai;
    private _aj;
    constructor();
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * Returns or sets a value which determines the direction in which
     * the error bars extend from the data points.
     */
    get direction(): ErrorBarDirection;
    set direction(a: ErrorBarDirection);
    /**
     * Returns or sets the end style for the error bars.
     */
    get endStyle(): EndStyleCap;
    set endStyle(a: EndStyleCap);
    /**
     * Returns or sets a value which determines the units used to
     * evaluate the error.
     */
    get errorValueType(): ErrorValueType;
    set errorValueType(a: ErrorValueType);
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill color/gradient for the line.
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     */
    get fill(): ChartFillBase;
    set fill(a: ChartFillBase);
    /**
     * @hidden
     */
    get _ab(): ChartFillBase;
    /**
     * Determines the width of the line, expressed in points.
     * <p class="body">
     * A point is a graphical unit equal to 1/72", i.e., there are 72 points in one inch.
     * </p>
     */
    get widthInPoints(): number;
    set widthInPoints(a: number);
    /**
     * Returns or sets a value which defines the error range.
     * <p class="body">
     * The unit for this property is determined by the [[errorValueType]] property.
     * </p>
     * @see [[errorValueType]]
     */
    get value(): number;
    set value(a: number);
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * Represents a solid color fill for a chart element.
 */
export declare class ChartSolidFill extends ChartFillBase {
    static $t: Type;
    private _x;
    constructor(color: WorkbookColorInfo);
    /**
     * @hidden
     */
    static _w(a: WorkbookThemeColorType, b?: Nullable$1<number>, c?: Nullable$1<number>, d?: Nullable$1<number>): ChartSolidFill;
    /**
     * Returns the color which is applied to the fill.
     */
    get color(): WorkbookColorInfo;
}
/**
 * Placeholder which indicates that no fill should be
 * rendered for the associated chart element.
 * <p class="body">
 * Some chart elements require an explicit setting to prevent the fill from appearing.
 * </p>
 * <p class="body">
 * Whether a fill is automatically rendered by Excel is dependent on the chart element.
 * </p>
 * <p class="body">
 * Use this class to ensure that no fill is rendered for the associated chart element.
 * </p>
 * @see [[ChartSolidFill]]
 * @see [[ChartGradientFill]]
 */
export declare class ChartEmptyFill extends ChartFillBase {
    static $t: Type;
    constructor();
}
/**
 * Represents the legend in a chart. Each chart can have only one legend.
 */
export declare class Legend extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _a4;
    /**
     * @hidden
     */
    private static readonly _a5;
    /**
     * @hidden
     */
    private static readonly _a6;
    /**
     * @hidden
     */
    private static readonly _a7;
    /**
     * @hidden
     */
    private static readonly _a8;
    /**
     * @hidden
     */
    private static readonly _ba;
    /**
     * @hidden
     */
    private static readonly _bb;
    /**
     * @hidden
     */
    private static readonly _bc;
    /**
     * @hidden
     */
    private static readonly _bd;
    /**
     * @hidden
     */
    private static readonly _be;
    /**
     * @hidden
     */
    private static readonly _bf;
    /**
     * @hidden
     */
    private static readonly _a9;
    /**
     * @hidden
     */
    private static readonly _w;
    private _z;
    private _ao;
    private _ab;
    private _ap;
    private _ac;
    private _au;
    private _av;
    private _ag;
    private _aq;
    private _ai;
    private _aw;
    private _ak;
    private _ax;
    private _ay;
    constructor();
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * Determines the appearance of the border drawn around
     * the text area, as well as whether a border appears.
     */
    get border(): ChartBorder;
    set border(a: ChartBorder);
    /**
     * Defines the font properties for <see cref="LegendEntries">legend entries</see>
     * which have no specific font settings. Read-only.
     * <p class="body">
     * To apply font settings to a specific legend entry, use the
     * [[LegendEntry.font]] property.
     * </p>
     * <para class="note"><b>Note:</b> this property will return null until the [[Legend]]
     * is set on the <see cref="WorksheetChart.Legend">WorksheetChart.Legend</see> property.</para>
     * @see [[LegendEntry.font]]
     */
    get defaultFont(): IWorkbookFont;
    /**
     * @hidden
     */
    _e(a: Workbook): WorkbookFontProxy;
    /**
     * @hidden
     */
    get _an(): IWorkbookFont;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the font color(s) for <see cref="LegendEntry">legend entries</see>.
     * <p class="body">
     * Use this property to apply the same font color(s) to all legend entries.
     * </p>
     * <p class="body">
     * Use the [[LegendEntry.fontFill]] property to apply font color(s) for a particular legend entry.
     * </p>
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     */
    get defaultFontFill(): ChartFillBase;
    set defaultFontFill(a: ChartFillBase);
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill properties for the legend's text area.
     * <p class="body">
     * This property returns null by default, indicating that no fill is applied.
     * </p>
     * <p class="body">
     * To apply a solid color fill, assign an instance of the
     * [[ChartSolidFill]] class to this property.
     * </p>
     * <p class="body">
     * To apply a gradient fill, assign an instance of the
     * [[ChartGradientFill]] class to this property.
     * </p>
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     */
    get fill(): ChartFillBase;
    set fill(a: ChartFillBase);
    /**
     * @hidden
     */
    get _af(): ChartFillBase;
    /**
     * Returns or sets a value that represents the height of the legend area,
     * expressed as a fraction of the chart area's height.
     * <p class="body">
     * Valid values for this property range between zero and one, with a value of one
     * representing the total height of the chart area.
     * </p>
     * <p class="body">
     * A value of .1 (for example) represents a height that is equal to one-tenth the height
     * of the chart area.
     * </p>
     * @see [[width]]
     */
    get height(): number;
    set height(a: number);
    /**
     * Returns or sets a value that represents the position of the left edge
     * of the legend area, expressed as a fraction of the chart area's width.
     * <p class="body">
     * Valid values for this property range between zero and one, with a value of one
     * representing the total width of the chart area.
     * </p>
     * @see [[top]]
     */
    get left(): number;
    set left(a: number);
    /**
     * Indexer (read-only)
     * @param index A zero based index
     * @return
     */
    legendEntries(index: number): LegendEntry;
    /**
     * Returns a read only collection of <see cref="LegendEntry">legend entries</see>.
     * <p class="body">
     * This collection contains one entry for each [[Series]] in the associated
     * chart's [[WorksheetChart.seriesCollection]].
     * </p>
     * <p class="body">
     * This collection does <b>not</b> include legend entries for <see cref="Trendline">trendlines</see>.
     * </p>
     * <p class="body">
     * Use the [[Trendline.legendEntry]] property to obtain a reference to the
     * legend entry associated with a trendline.
     * </p>
     * @see [[WorksheetChart.legend]]
     */
    legendEntries(): LegendEntries;
    /**
     * @hidden
     */
    get _legendEntries$i(): LegendEntries;
    /**
     * Returns or sets a boolean value indicating whether the legend
     * can intersect with the chart's plot area.
     */
    get overlay(): boolean;
    set overlay(a: boolean);
    /**
     * Returns or sets a value that represents the position of the legend on the chart.
     */
    get position(): LegendPosition;
    set position(a: LegendPosition);
    /**
     * Determines the rotation of the legend's text area,
     * expressed in degrees.
     */
    get rotation(): number;
    set rotation(a: number);
    /**
     * Determines the orientation and direction in which text flows.
     * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
     * @see [[rotation]]
     */
    get textDirection(): TextDirection;
    set textDirection(a: TextDirection);
    /**
     * Returns or sets a value that represents the position of the top edge
     * of the legend area, expressed as a fraction of the chart area's height.
     * <p class="body">
     * Valid values for this property range between zero and one, with a value of one
     * representing the total height of the chart area.
     * </p>
     * @see [[left]]
     */
    get top(): number;
    set top(a: number);
    /**
     * Returns or sets a value that represents the width of the legend area,
     * expressed as a fraction of the chart area's width.
     * <p class="body">
     * Valid values for this property range between zero and one, with a value of one
     * representing the total width of the chart area.
     * </p>
     * @see [[height]]
     */
    get width(): number;
    set width(a: number);
    /**
     * @hidden
     */
    _at(): IList$1<ILegendEntry>;
    /**
     * @hidden
     */
    _as(): boolean;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * @hidden
 */
export interface ILegendEntry {
    readonly names: string[];
    readonly fill: ChartFillBase;
    readonly fontFill: ChartFillBase;
    readonly borderFill: ChartFillBase;
    readonly font: IWorkbookFont;
}
/**
 * @hidden
 */
export declare let ILegendEntry_$type: Type;
/**
 * @hidden
 */
export declare class LegendEntryProxy extends Base implements ILegendEntry {
    static $t: Type;
    private a;
    private g;
    private c;
    private d;
    private b;
    constructor();
    static f(a: LegendEntry): LegendEntryProxy;
    static e(a: DataPoint, b: number): LegendEntryProxy;
    get borderFill(): ChartFillBase;
    get fill(): ChartFillBase;
    get fontFill(): ChartFillBase;
    get font(): IWorkbookFont;
    get names(): string[];
}
/**
 * Represents a legend entry in a chart legend.
 * <p class="body">
 * <b>NOTE: </b> Legend entries are not supported for the following chart types:
 * </p>
 * <p>
 * <ul>
 * <li>Box and Whisker</li>
 * <li>Histogram</li>
 * <li>Pareto</li>
 * <li>Sunburst</li>
 * <li>Treemap</li>
 * <li>Waterfall</li>
 * </ul>
 * </p>
 */
export declare class LegendEntry extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _al;
    /**
     * @hidden
     */
    private static readonly _am;
    /**
     * @hidden
     */
    private static readonly _an;
    /**
     * @hidden
     */
    private static readonly _w;
    private _ah;
    private _z;
    private _ai;
    constructor(a: IChartObject);
    /**
     * Returns or sets the <see cref="IWorkbookFont">font</see>
     * for this legend entry. Read-only.
     * <p class="body">
     * This property provides a way to specify font settings
     * for a particular legend entry; to apply font settings
     * to all legend entries, use the [[Legend.defaultFont]]
     * property.
     * </p>
     * @see [[Legend.defaultFont]]
     */
    get font(): IWorkbookFont;
    /**
     * @hidden
     */
    _e(a: Workbook): WorkbookFontProxy;
    /**
     * @hidden
     */
    get _af(): IWorkbookFont;
    /**
     * @hidden
     */
    get _ag(): WorkbookColorInfo;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the font color(s) for this legend entry.
     * <p class="body">
     * This property returns null by default, indicating that no fill is applied.
     * </p>
     * <p class="body">
     * To apply a solid color fill, assign an instance of the
     * [[ChartSolidFill]] class to this property.
     * </p>
     * <p class="body">
     * To apply a gradient fill, assign an instance of the
     * [[ChartGradientFill]] class to this property.
     * </p>
     * @see [[ChartSolidFill]]
     * @see [[ChartGradientFill]]
     */
    get fontFill(): ChartFillBase;
    set fontFill(a: ChartFillBase);
    /**
     * @hidden
     */
    get _ab(): ChartFillBase;
    /**
     * Returns or sets a boolean value indicating whether this entry
     * has been removed from the [[WorksheetChart.legend]]
     * <p class="body">
     * Deletion does not remove the entry from the [[Legend.legendEntries]]
     * collection, but rather marks it as deleted, so that it does not appear
     * in the legend.
     * </p>
     * @see [[WorksheetChart.legend]]
     * @see [[legend]]
     * @see [[Trendline.legendEntry]]
     */
    get isDeleted(): boolean;
    set isDeleted(a: boolean);
    /**
     * @hidden
     */
    get _ac(): Legend;
    /**
     * Marks the entry as being deleted.
     */
    del(): void;
    /**
     * @hidden
     */
    _ad(a: number): {
        ret: Series;
        p0: number;
    };
    /**
     * @hidden
     */
    _ak(): boolean;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * A collection of [[LegendEntry]]s for a [[WorksheetChart]]
 */
export declare class LegendEntries extends ChartObject implements IEnumerable$1<LegendEntry> {
    static $t: Type;
    private _aa;
    constructor(a: IChartObject);
    /**
     * Indexer (read-only)
     * @param index A zero based index
     * @return
     */
    item(a: number): LegendEntry;
    /**
     * @hidden
     */
    _ad(): void;
    /**
     * Returns the number of items in the collection (read-only)
     */
    get count(): number;
    /**
     * Determines if the collection contains thhe item
     * @param item The item to check
     * @return True if the item is in the collection, otherwise false.
     */
    contains(item: LegendEntry): boolean;
    [Symbol.iterator](): EnumeratorWrapper<LegendEntry>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<LegendEntry>;
    /**
     * Returns the index of the item in the collection
     * @param item The item to check
     * @return the zero-based index or -1 if the item isn't in the collection.
     */
    indexOf(item: LegendEntry): number;
    /**
     * @hidden
     */
    _x(a: number): LegendEntry;
    /**
     * @hidden
     */
    _ae(a: number, b: LegendEntry): void;
    /**
     * @hidden
     */
    _af(a: number): void;
    /**
     * @hidden
     */
    _ag(a: LegendEntry[]): void;
    /**
     * @hidden
     */
    _w(): LegendEntry[];
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
}
/**
 * Exposes properties related to category axis binning.
 * Applicable only for Histogram and Pareto charts.
 * <p class="body">
 * This class is immutable.
 * </p>
 * @see [[Series.axisBinning]]
 */
export declare class CategoryAxisBinning extends Base {
    static $t: Type;
    constructor(binWidth?: number, numberOfBins?: number, overflow?: boolean, overflowThreshold?: number, underflow?: boolean, underflowThreshold?: number);
    constructor();
    constructor(binWidth: number | null, numberOfBins: number | null, overflow: boolean, overflowThreshold: number | null, underflow: boolean, underflowThreshold: number | null, intervalClosedSide: IntervalClosedSide);
    constructor(..._rest: any[]);
    /**
     * Returns the number of data points in each range, i.e., how many
     * data points exist in each bin.
     * <p class="body">
     * Use this property to control the number of data points that should appear
     * in each bin, allowing the total number of bins to be determined automatically.
     * </p>
     * <p class="body">
     * BinWidth and [[numberOfBins]] are mutually exclusive.
     * </p>
     * @see [[numberOfBins]]
     */
    get binWidth(): number | null;
    set binWidth(a: number | null);
    private _binWidth$i_1;
    /**
     * @hidden
     */
    get _binWidth$i(): Nullable$1<number>;
    /**
     * @hidden
     */
    set _binWidth$i(a: Nullable$1<number>);
    /**
     * @hidden
     */
    _a: IntervalClosedSide;
    /**
     * Returns the total number of bins.
     * <p class="body">
     * Use this property to control the number of bins that should appear,
     * allowing the number of data points per bin to be determined automatically.
     * </p>
     * <p class="body">
     * NumberOfBins and [[binWidth]] are mutually exclusive.
     * </p>
     * @see [[binWidth]]
     */
    get numberOfBins(): number | null;
    set numberOfBins(a: number | null);
    private _numberOfBins$i_1;
    /**
     * @hidden
     */
    get _numberOfBins$i(): Nullable$1<number>;
    /**
     * @hidden
     */
    set _numberOfBins$i(a: Nullable$1<number>);
    private _overflow;
    /**
     * Specifies whether a bin is created for all values above a given threshold.
     * <p class="body">
     * Setting this property to true causes a bin to be created for values
     * above a given threshold.
     * </p>
     * <p class="body">
     * The threshold is determined automatically by default; use the
     * [[overflowThreshold]] property to specify a threshold
     * value.
     * </p>
     * @see [[overflowThreshold]]
     * @see [[underflow]]
     */
    get overflow(): boolean;
    set overflow(a: boolean);
    /**
     * Determines the threshold for the [[overflow]] bin.
     * <p class="body">
     * This property is only applicable when the [[overflow]]
     * property is set to true.
     * </p>
     * <p class="body">
     * When this property is left unset, the threshold is determined automatically.
     * </p>
     * @see [[overflow]]
     * @see [[underflowThreshold]]
     */
    get overflowThreshold(): number | null;
    set overflowThreshold(a: number | null);
    private _overflowThreshold$i_1;
    /**
     * @hidden
     */
    get _overflowThreshold$i(): Nullable$1<number>;
    /**
     * @hidden
     */
    set _overflowThreshold$i(a: Nullable$1<number>);
    private _underflow;
    /**
     * Specifies whether a bin is created for all values below a given threshold.
     * <p class="body">
     * Setting this property to true causes a bin to be created for values
     * below a given threshold.
     * </p>
     * <p class="body">
     * The threshold is determined automatically by default; use the
     * [[underflowThreshold]] property to specify a threshold
     * value.
     * </p>
     * @see [[overflowThreshold]]
     * @see [[overflow]]
     */
    get underflow(): boolean;
    set underflow(a: boolean);
    /**
     * Determines the threshold for the [[underflow]] bin.
     * <p class="body">
     * This property is only applicable when the [[underflow]]
     * property is set to true.
     * </p>
     * <p class="body">
     * When this property is left unset, the threshold is determined automatically.
     * </p>
     * @see [[underflow]]
     * @see [[underflowThreshold]]
     */
    get underflowThreshold(): number | null;
    set underflowThreshold(a: number | null);
    private _underflowThreshold$i_1;
    /**
     * @hidden
     */
    get _underflowThreshold$i(): Nullable$1<number>;
    /**
     * @hidden
     */
    set _underflowThreshold$i(a: Nullable$1<number>);
}
/**
 * Abstract base class that defines a set of values in a [[Series]].
 */
export declare abstract class SeriesValuesBase extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    static readonly _h: boolean;
    /**
     * @hidden
     */
    _a: any[];
    /**
     * @hidden
     */
    _e: Sheet;
    /**
     * @hidden
     */
    _f: SingleTargetFormula;
    /**
     * @hidden
     */
    _k: string;
    constructor(values: IEnumerable);
    constructor(sheet: Sheet, formula: string, cellReferenceMode?: CellReferenceMode);
    constructor(sheet: Sheet, formula: SingleTargetFormula, values: any[], dummy: boolean);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    protected get__d(): SeriesValuesType;
    /**
     * @hidden
     */
    get _d(): SeriesValuesType;
    /**
     * Returns an object array containing the value of
     * each data point in the associated [[Series]].
     * @return An array of values where each element in the array represents the value of a data point in the associated Series.
     */
    getValues(): any[];
    /**
     * @hidden
     */
    _n(): void;
    /**
     * @hidden
     */
    static _b<T>($t: Type, a: SingleTargetFormula, b: Sheet, c: boolean, d: (arg1: IList$1<ExcelCalcValue>) => T[]): T[];
    /**
     * @hidden
     */
    static _i(a: ExcelCalcValue): any;
    /**
     * @hidden
     */
    static _l(a: ExcelCalcValue): string;
    /**
     * @hidden
     */
    _g(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _o(a: Series, b: number, c: (arg1: IChartObject, arg2: any) => void, d: CellShiftOperation, e: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    private static _m;
    /**
     * @hidden
     */
    _j(a: number, b: string): any;
    /**
     * @hidden
     */
    private _p;
    /**
     * @hidden
     */
    private _q;
    /**
     * @hidden
     */
    private _r;
}
/**
 * Defines a set of values in a series
 */
export declare class SeriesValues extends SeriesValuesBase {
    static $t: Type;
    /**
     * @hidden
     */
    readonly _s: number[];
    /**
     * @hidden
     */
    _v: boolean;
    constructor(values: IEnumerable);
    constructor(sheet: Sheet, formula: SingleTargetFormula, values: any[], dummy: boolean);
    constructor(sheet: Sheet, sourceRange: string, cellReferenceMode?: CellReferenceMode, colorBy?: SeriesValuesColorBy);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    static _u(a: Sheet, b: SingleTargetFormula, c: any[]): SeriesValues;
    /**
     * @hidden
     */
    _t(a: string, b: number[]): {
        ret: any[];
        p0: string;
        p1: number[];
    };
}
/**
 * Defines the name of a series
 */
export declare class SeriesName extends Base {
    static $t: Type;
    /**
     * @hidden
     */
    readonly _g: string;
    private readonly _c;
    /**
     * @hidden
     */
    _d: SingleTargetFormula;
    /**
     * @hidden
     */
    _h: string;
    constructor(name: string);
    constructor(sheet: Sheet, formula: string, cellReferenceMode?: CellReferenceMode);
    constructor(sheet: Sheet, formula: SingleTargetFormula);
    constructor(..._rest: any[]);
    /**
     * Gets the string representation of the [[SeriesName]].
     */
    toString(): string;
    /**
     * @hidden
     */
    static _b(a: Sheet, b: SingleTargetFormula, c: string): SeriesName;
    /**
     * @hidden
     */
    _a(): string[];
    /**
     * @hidden
     */
    _e(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _j(a: Series, b: number, c: (arg1: IChartObject, arg2: any) => void, d: CellShiftOperation, e: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _f(a: number, b: string): any;
    /**
     * @hidden
     */
    private _k;
}
/**
 * Defines a set of values in a series
 */
export declare class XValues extends SeriesValuesBase {
    static $t: Type;
    /**
     * @hidden
     */
    readonly _s: number[];
    private _y;
    /**
     * @hidden
     */
    _ae: Nullable$1<boolean>;
    /**
     * @hidden
     */
    _ad: number;
    /**
     * @hidden
     */
    _ab: XValuesDataType;
    constructor(values: IEnumerable);
    constructor(dataType: XValuesDataType, values: IEnumerable, levels: number[]);
    constructor(sheet: Sheet, formula: SingleTargetFormula, dataType: XValuesDataType, values: any[], levels: number[]);
    constructor(sheet: Sheet, formula: string, cellReferenceMode?: CellReferenceMode);
    constructor(sheet: Sheet, plotByRows: boolean, dataType: XValuesDataType, formula: string, cellReferenceMode?: CellReferenceMode);
    constructor(..._rest: any[]);
    /**
     * @hidden
     */
    _n(): void;
    /**
     * @hidden
     */
    protected get__d(): SeriesValuesType;
    /**
     * @hidden
     */
    get _z(): Series;
    /**
     * @hidden
     */
    _ac: boolean;
    /**
     * Returns the actual values for this [[XValues]] instance.
     * @return An object array containing the actual data point values for the associated [[Series]].
     */
    getValues(): any[];
    /**
     * @hidden
     */
    _t(): any[];
    /**
     * @hidden
     */
    private _ah;
    /**
     * @hidden
     */
    static _aa(a: Sheet, b: SingleTargetFormula, c: any[], d: number[], e: XValuesDataType): XValues;
    /**
     * @hidden
     */
    _u(): GetXValuesResult;
    /**
     * @hidden
     */
    private static _v;
    /**
     * @hidden
     */
    private static _w;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    _af(a: Series): void;
    /**
     * @hidden
     */
    _ag(): void;
}
/**
 * An object that represents a specific series in a chart
 */
export declare class Series extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _cd;
    /**
     * @hidden
     */
    private static readonly _ce;
    /**
     * @hidden
     */
    private static readonly _cf;
    /**
     * @hidden
     */
    private static readonly _cg;
    /**
     * @hidden
     */
    private static readonly _ch;
    /**
     * @hidden
     */
    private static readonly _ci;
    /**
     * @hidden
     */
    private static readonly _cj;
    /**
     * @hidden
     */
    private static readonly _ck;
    /**
     * @hidden
     */
    private static readonly _cl;
    /**
     * @hidden
     */
    private static readonly _cm;
    /**
     * @hidden
     */
    private static readonly _cq;
    /**
     * @hidden
     */
    private static readonly _cs;
    /**
     * @hidden
     */
    private static readonly _ct;
    /**
     * @hidden
     */
    private static readonly _cu;
    /**
     * @hidden
     */
    private static readonly _cv;
    /**
     * @hidden
     */
    private static readonly _cw;
    /**
     * @hidden
     */
    private static readonly _cx;
    /**
     * @hidden
     */
    private static readonly _cy;
    /**
     * @hidden
     */
    private static readonly _cz;
    /**
     * @hidden
     */
    private static readonly _c1;
    /**
     * @hidden
     */
    private static readonly _c2;
    /**
     * @hidden
     */
    private static readonly _c4;
    /**
     * @hidden
     */
    private static readonly _c6;
    /**
     * @hidden
     */
    private static readonly _c7;
    /**
     * @hidden
     */
    private static readonly _c8;
    /**
     * @hidden
     */
    private static readonly _da;
    /**
     * @hidden
     */
    private static readonly _db;
    /**
     * @hidden
     */
    private static readonly _dc;
    /**
     * @hidden
     */
    private static readonly _dd;
    /**
     * @hidden
     */
    private static readonly _de;
    /**
     * @hidden
     */
    private static readonly _dg;
    /**
     * @hidden
     */
    static readonly _df: number;
    /**
     * @hidden
     */
    private static readonly _c5;
    /**
     * @hidden
     */
    static readonly _cn: number;
    /**
     * @hidden
     */
    static readonly _cp: number;
    /**
     * @hidden
     */
    static readonly _co: number;
    /**
     * @hidden
     */
    static readonly _c3: number;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    private static readonly _bd;
    private _bc;
    private _af;
    private _aa;
    private _dh;
    private _ah;
    private _ad;
    private _bk;
    private _av;
    private _be;
    private _ax;
    private _az;
    private _cb;
    private _al;
    private _a1;
    private _a3;
    private _at;
    private _ai;
    private _am;
    private _di;
    private _a5;
    private _bg;
    private _ba;
    private _a8;
    private _b9;
    private _cc;
    private _bo;
    private _bi;
    private _bl;
    private _bq;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _k(a: any): any;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Apply the picture to the end of the series.
     */
    get applyPicToEnd(): boolean;
    set applyPicToEnd(a: boolean);
    /**
     * Apply the picture to the front of the series.
     */
    get applyPicToFront(): boolean;
    set applyPicToFront(a: boolean);
    /**
     * Apply the picture to the sides.
     */
    get applyPicToSides(): boolean;
    set applyPicToSides(a: boolean);
    /**
     * Returns or sets a [[CategoryAxisBinning]] instance which determines
     * the binning properties for the category axis on a histogram or pareto chart.
     * <p class="body">
     * This property is only applicable for histogram and pareto charts.
     * </p>
     */
    get axisBinning(): CategoryAxisBinning;
    set axisBinning(a: CategoryAxisBinning);
    /**
     * Specifies which axis group this series applies to.
     * <p class="body">
     * This property is only applicable for combo charts.
     * </p>
     * <p class="body">
     * This property defaults to <i>Primary</i>, causing all series to
     * be plotted on the primary axis unless otherwise specified.
     * </p>
     * <p class="body">
     * To plot this series on the secondary value axis, set this property to <i>Secondary</i>.
     * </p>
     * <p class="body">
     * Setting this property to <i>Secondary</i> triggers creation of secondary
     * category and value axes.
     * </p>
     * <p class="body">
     * Not all series can be plotted on the same axis; the following table lists
     * each ChartType along with the other ChartTypes which can be plotted on the
     * same axis:
     * </p>
     * <p class="body">
     * <table border="1">
     * <tr><th>ChartType</th><th>Valid on same axis</th></tr>
     * <tr><td>ColumnClustered</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>ColumnStacked</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>ColumnStacked100</td><td>Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>BarClustered</td><td>BarClustered only</td></tr>
     * <tr><td>BarStacked</td><td>BarStacked only</td></tr>
     * <tr><td>BarStacked100</td><td>BarStacked100 only</td></tr>
     * <tr><td>Line</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkers, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>LineStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkersStacked, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>LineStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>LineMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>LineMarkersStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineStacked, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>LineMarkersStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, LineStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>Area</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>AreaStacked</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>AreaStacked100</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>Pie</td><td>PieExploded, BarOfPie, PieOfPie, Doughnut, DoughnutExploded</td></tr>
     * <tr><td>PieExploded</td><td>Pie, BarOfPie, PieOfPie, Doughnut, DoughnutExploded</td></tr>
     * <tr><td>BarOfPie</td><td>Pie, PieExploded, PieOfPie, Doughnut, DoughnutExploded</td></tr>
     * <tr><td>PieOfPie</td><td>Pie, PieExploded, BarOfPie, Doughnut, DoughnutExploded</td></tr>
     * <tr><td>Doughnut</td><td>Pie, PieExploded, BarOfPie, PieOfPie, DoughnutExploded</td></tr>
     * <tr><td>DoughnutExploded</td><td>Pie, PieExploded, BarOfPie, PieOfPie, Doughnut</td></tr>
     * <tr><td>XYScatter</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>XYScatterLines</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLinesNoMarkers, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>XYScatterLinesNoMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterSmooth, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>XYScatterSmooth</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmoothNoMarkers</td></tr>
     * <tr><td>XYScatterSmoothNoMarkers</td><td>ColumnClustered, ColumnStacked, ColumnStacked100, Line, LineStacked, LineStacked100, LineMarkers, LineMarkersStacked, LineMarkersStacked100, Area, AreaStacked, AreaStacked100, XYScatter, XYScatterLines, XYScatterLinesNoMarkers, XYScatterSmooth</td></tr>
     * <tr><td>Radar</td><td>RadarFilled, RadarMarkers</td></tr>
     * <tr><td>RadarFilled</td><td>Radar, RadarMarkers</td></tr>
     * <tr><td>RadarMarkers</td><td>Radar, RadarFilled</td></tr>
     * </table>
     * </p>
     * <p class="body">
     * Attempting to set the series axis to the same value as an incompatible series
     * causes an exception to be thrown.
     * </p>
     * @see [[chartType]]
     * @see [[Axis]]
     * @see [[WorksheetChart.axisCollection]]
     * @throws [[NotSupportedException]] The target axis already contains a chart type which cannot share axes with this series
     * because of the value of the [[chartType]] property of this series.
     */
    get axisGroup(): AxisGroup;
    set axisGroup(a: AxisGroup);
    /**
     * Determines the shape of the bar for this series.
     * Applicable only for 3D bar charts.
     * <p class="body">
     * This property controls the shape of the bar displayed for this series only.
     * </p>
     * <p class="body">
     * To set the bar shape for all series in the chart, use the [[WorksheetChart.barShape]] property.
     * </p>
     * @see [[WorksheetChart.barShape]]
     */
    get barShape(): BarShape | null;
    set barShape(a: BarShape | null);
    /**
     * @hidden
     */
    get _barShape$i(): Nullable$1<BarShape>;
    /**
     * @hidden
     */
    set _barShape$i(a: Nullable$1<BarShape>);
    /**
     * Returns the resolved value of the [[barShape]] property.
     * @see [[barShape]]
     * @see [[WorksheetChart.barShape]]
     */
    get barShapeResolved(): BarShape;
    /**
     * Determines the appearance of the border drawn around the
     * [[fill]] area. Applicable only for chart series
     * which support fills, such as bar charts, area charts, and
     * pie charts.
     * <p class="body">
     * For series which support <see cref="Fill">fills</see>, this property controls the
     * color and size of the line drawn around the fill region.
     * </p>
     * <p class="body">
     * For line-based series, use the [[line]] property.
     * </p>
     * @see [[fill]]
     * @see [[line]]
     */
    get border(): ChartBorder;
    set border(a: ChartBorder);
    /**
     * Returns or sets a [[boxAndWhiskerSettings]] instance which determines
     * the properties for a box and whisker chart.
     * <p class="body">
     * This property is only applicable for box and whisker charts.
     * </p>
     */
    get boxAndWhiskerSettings(): BoxAndWhiskerSettings;
    set boxAndWhiskerSettings(a: BoxAndWhiskerSettings);
    /**
     * Returns or sets a [[values]] instance that determines the bubble sizes in a bubble chart.
     */
    get bubbleSizes(): SeriesValues;
    set bubbleSizes(a: SeriesValues);
    /**
     * Specifies the type of chart for this series. Applicable only
     * for combo charts.
     * <p class="body">
     * This property is only applicable for combo charts. Setting this
     * property for any other type of chart causes an exception to be thrown.
     * </p>
     * <p class="body">
     * Not all ChartType values are supported for series which are plotted within
     * a combo chart. For a list of the supported values, see documentation for
     * the WorksheetChart.<see cref="WorksheetChart.SetComboChartSourceData(string, ChartType[], bool, CellReferenceMode?)">SetComboChartSourceData</see>
     * method.
     * </p>
     * <p class="body">
     * If the value assigned to this property necessitates plotting this series
     * on a different axis than the one referenced by the [[axisGroup]]
     * property, and the other axis can accommodate this series, the AxisGroup
     * property is changed accordingly.
     * </p>
     * <p class="body">
     * If the other axis cannot accommodate this series, and other series which are
     * of the same series type exist on the same axis, an attempt is made to change
     * the ChartType of those other series. For example, if a different series exists
     * with a ChartType of <i>BarClustered</i>, and a value of <i>BarStacked</i> is
     * assigned to this series, the ChartType of   the other series is changed to
     * <i>BarStacked</i> in order to accommodate the setting of the property on this
     * series.
     * </p>
     * <p class="body">
     * If no adjustment can be made that would allow the ChartType to be changed to the
     * specified value, an exception is thrown.
     * </p>
     * <p class="body">
     * Note that in all cases, the value of the [[type]] property is
     * automatically changed to a value which is appropriate for the assigned ChartType.
     * </p>
     * @see [[type]]
     * @see [[axisGroup]]
     * @throws [[NotSupportedException]] The [[axisGroup]] on which this series currently resides cannot share an axis
     * with a series of this <i>ChartType</i>, and no adjustment could be made to avoid this.
     */
    get chartType(): ChartType;
    set chartType(a: ChartType);
    /**
     * @hidden
     */
    _ds(a: ChartType, b: boolean): void;
    /**
     * @hidden
     */
    private _b7;
    /**
     * Returns a [[SeriesDataLabels]] instance which applies to all [[DataLabel]]
     * instances which do not have a specific setting for a given property.
     * <p class="body">
     * Use the [[DataPoint.dataLabel]] property to customize an individual data label.
     * </p>
     */
    get dataLabels(): SeriesDataLabels;
    /**
     * @hidden
     */
    private _dn;
    /**
     * Returns the [[DataPoint]] instance at the specified
     * ordinal position within this collection.
     * @param index A zero based index
     * @return A [[DataPoint]] instance.
     */
    dataPointCollection(index: number): DataPoint;
    /**
     * Returns a <see cref="DataPointCollection">collection</see>
     * of [[DataPoint]] instances which represent the
     * individual data points in this series.
     */
    dataPointCollection(): DataPointCollection;
    /**
     * @hidden
     */
    get _dataPointCollection$i(): DataPointCollection;
    /**
     * Returns or sets an [[ErrorBars]] object.
     */
    get errorBars(): ErrorBars;
    set errorBars(a: ErrorBars);
    /**
     * Returns or sets a value which determines the amount by which individual slices
     * are offset from the center of the pie or doughnut, expressed as a percentage
     * of the radius.
     * <p class="body">
     * The valid range of values is between 0 and 400, inclusive.
     * </p>
     * @throws [[ArgumentOutOfRangeException]] The value is outside the range of 0 and 400.
     */
    get explosion(): number;
    set explosion(a: number);
    /**
     * @hidden
     */
    get _dk(): Nullable$1<number>;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill for this series. Not applicable for
     * line charts.
     * <p class="body">
     * This property is not applicable to charts which depict the data
     * series as a line. For these chart types, use the [[line]]
     * property, which controls the color and width of the line.
     * </p>
     * @see [[border]]
     */
    get fill(): ChartFillBase;
    set fill(a: ChartFillBase);
    /**
     * Returns or sets a [[geographicMapSettings]] instance
     * which defines the appearance and behavior for a geographic map chart.
     * <p class="body">
     * This property is only applicable when the <see cref="WorksheetChart.ChartType">ChartType</see>
     * property is set to <i>RegionMap</i>.
     * </p>
     */
    get geographicMapSettings(): GeographicMapSettings;
    set geographicMapSettings(a: GeographicMapSettings);
    /**
     * Determines if negative values will be inverted.
     */
    get invertIfNegative(): boolean;
    set invertIfNegative(a: boolean);
    /**
     * Returns or sets the  instance.
     * <p class="body">
     * A leader line connects a [[DataLabel]] to it's associated series.
     * </p>
     * @see [[leaderLines]]
     * @see [[DataLabel]]
     * @see [[dataPointCollection]]
     */
    get leaderLines(): LeaderLines;
    set leaderLines(a: LeaderLines);
    /**
     * Determines the <see cref="ChartLineBase.Fill">fill</see> and
     * <see cref="ChartLineBase.WidthInPoints">width</see> of a series line.
     * <p class="body">
     * This property is not applicable for series which support <see cref="Fill">fills</see>,
     * such as bar, area, or pie charts.
     * </p>
     * <p class="body">
     * For chart series which supports fills, use the [[fill]] property
     * to control the fill color, and the [[border]] property for the
     * line drawn around that fill area.
     * </p>
     * @see [[fill]]
     * @see [[border]]
     * @see [[markerFill]]
     * @see [[markerBorder]]
     */
    get line(): ChartLine;
    set line(a: ChartLine);
    /**
     * Determines the appearance of the <see cref="ChartBorder">border</see>
     * (a.k.a. outline) for the marker.
     */
    get markerBorder(): ChartBorder;
    set markerBorder(a: ChartBorder);
    /**
     * Defines the <see cref="ChartFillBase">fill</see> appearance for the marker.
     */
    get markerFill(): ChartFillBase;
    set markerFill(a: ChartFillBase);
    /**
     * Determines the size of the markers.
     */
    get markerSize(): number;
    set markerSize(a: number);
    /**
     * @hidden
     */
    get _dl(): Nullable$1<number>;
    /**
     * Determines the style of the markers
     */
    get markerStyle(): MarkerStyle;
    set markerStyle(a: MarkerStyle);
    /**
     * @hidden
     */
    get _a7(): MarkerStyle;
    /**
     * The name of the series
     */
    get name(): SeriesName;
    set name(a: SeriesName);
    /**
     * Returns or sets a reference to the owning [[Series]].
     * Applicable only for a line series in a <i>Pareto</i> chart.
     * <p class="body">
     * This property is only applicable for Series contained within a
     * <i>Pareto</i> chart.
     * </p>
     * <p class="body">
     * If the [[chartType]] property of this series, as well as that of
     * the associated <see cref="WorksheetChart">chart</see>, are not both set to
     * 'Pareto', an exception is thrown.
     * </p>
     * <p class="body">
     * If the value assigned to this property has a [[chartType]] of any value
     * other than 'ClusteredColumn', an exception is thrown.
     * </p>
     */
    get owningSeries(): Series;
    set owningSeries(a: Series);
    /**
     * Determines whether pictures are scaled, stacked, or stretched.
     */
    get pictureType(): PictureType;
    set pictureType(a: PictureType);
    /**
     * Returns or sets a value which defines the unit of measure
     * when [[pictureType]] is set to <i>Stack</i>.
     */
    get pictureUnit(): number;
    set pictureUnit(a: number);
    /**
     * The plotting order for the data series.
     * <para class="note">
     * <b>Note:</b> this is the order in which the series names will appear in the legend. When there is only one series then this is omitted. This must be a whole number between 1 and the number of series on the chart. If you enter zero then 1 is used. If you enter a number greater than the number of series then the total number of series is used.
     * </para>
     */
    get plotOrder(): number;
    set plotOrder(a: number);
    /**
     * Returns or sets a boolean value indicating whether to display
     * [[dataLabels]].
     */
    get showDataLabels(): boolean;
    set showDataLabels(a: boolean);
    /**
     * Returns or sets a boolean value indicating whether to display
     * connecting lines between the data points in a waterfall chart.
     * <p class="body">
     * This property is only applicable for waterfall charts.
     * </p>
     * <p class="body">
     * Use the [[border]] property to control the visual
     * appearance of the connector lines.
     * </p>
     */
    get showWaterfallConnectorLines(): boolean;
    set showWaterfallConnectorLines(a: boolean);
    /**
     * Determines whether a smoothing effect should be applied.
     */
    get smooth(): boolean;
    set smooth(a: boolean);
    /**
     * @hidden
     */
    get _b6(): boolean;
    /**
     * Returns the [[Trendline]] instance at the specified
     * ordinal position within the collection.
     * @param index A zero based index
     */
    trendlineCollection(index: number): Trendline;
    /**
     * Returns a collection of [[Trendline]] instances for this series.
     * <p class="body">
     * Trendlines are supported for Area, Bar, Bubble, Line, and Scatter charts,
     * and are not supported for other chart types.
     * </p>
     * @see [[Trendline]]
     */
    trendlineCollection(): TrendlineCollection;
    /**
     * @hidden
     */
    get _trendlineCollection$i(): TrendlineCollection;
    /**
     * @hidden
     */
    get _bx(): boolean;
    /**
     * Returns or sets a [[SeriesType]] value which determines
     * the type of this series. Applicable only for combo charts.
     * <p class="body">
     * This property is only applicable for combo charts. Setting this
     * property for any other type of chart causes an exception to be thrown.
     * </p>
     * <p class="body">
     * Combo charts do not support <i>Bubble</i> or <i>Surface</i>; setting this property
     * to either of those values causes an exception to be thrown.
     * </p>
     * <p class="body">
     * The [[chartType]] property must be set to a value that is compatible
     * with assigned series type. If the current value of the ChartType property is
     * not compatible with the value assigned to this property, a reasonable default
     * value, which is compatible, is assigned to the ChartType property.
     * </p>
     * @see [[chartType]]
     */
    get type(): SeriesType;
    set type(a: SeriesType);
    /**
     * @hidden
     */
    private _b8;
    /**
     * Returns or sets a [[xValues]] instance that contains a collection of all the x values in the series.
     * <para>The value of this property can be a range on a worksheet or an array of constant values, but not a combination of both.
     * </para>
     */
    get xValues(): XValues;
    set xValues(a: XValues);
    /**
     * @hidden
     */
    _dt(a: XValues, b: boolean): void;
    /**
     * @hidden
     */
    get _b2(): boolean;
    /**
     * Returns or sets a [[values]] instance that contains a collection of all the values in the series.
     * <para>The value of this property can be a range on a worksheet or an array of constant values, but not a combination of both.
     * </para>
     */
    get values(): SeriesValues;
    set values(a: SeriesValues);
    /**
     * @hidden
     */
    get _b1(): boolean;
    /**
     * @hidden
     */
    get _z(): Axis;
    /**
     * @hidden
     */
    _dm(a: any[], b: any[]): {
        p0: any[];
        p1: any[];
    };
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    private _bv;
    /**
     * @hidden
     */
    private _dq;
    /**
     * @hidden
     */
    private _dr;
    /**
     * @hidden
     */
    _ao(a: number): ChartFillBase;
    /**
     * @hidden
     */
    private static _ap;
    /**
     * @hidden
     */
    _aq(a: number): ChartFillBase;
    /**
     * @hidden
     */
    _ar(a: number): ChartFillBase;
    /**
     * @hidden
     */
    _bw(a: Workbook): boolean;
    /**
     * @hidden
     */
    static _b0(a: SeriesType): boolean;
    /**
     * @hidden
     */
    static _bz(a: SeriesType, b: ChartType, c: ChartType): {
        ret: boolean;
        p2: ChartType;
    };
    /**
     * @hidden
     */
    _dp(): void;
    /**
     * @hidden
     */
    _du(): void;
}
/**
 * @hidden
 */
export declare class SeriesCollection_CollectionChangeContext extends ValueType implements IChangeInfoContext {
    static $t: Type;
    constructor(a: number, b: SeriesCollection, c: Series, d: LegendEntry, e: number);
    constructor();
    constructor(a: number, ..._rest: any[]);
    readonly d: number;
    readonly c: SeriesCollection;
    readonly b: Series;
    readonly a: LegendEntry;
    get workbook(): Workbook;
    get sheet(): Sheet;
    get source(): any;
}
/**
 * A collection of [[Series]] for a [[WorksheetChart]]
 */
export declare class SeriesCollection extends ChartObject implements IEnumerable$1<Series> {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _al;
    /**
     * @hidden
     */
    private static readonly _ap;
    /**
     * @hidden
     */
    private static readonly _ao;
    /**
     * @hidden
     */
    private static _w;
    private _aj;
    private _ai;
    static staticInit(): void;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _m(a: (arg1: Sheet, arg2: Formula) => void): void;
    /**
     * @hidden
     */
    _i(a: Worksheet, b: WorksheetRegionAddress): boolean;
    /**
     * @hidden
     */
    _o(a: (arg1: IChartObject, arg2: any) => void, b: CellShiftOperation, c: ICellShiftOperationOverride): void;
    /**
     * @hidden
     */
    _t(a: Worksheet): void;
    /**
     * Indexer
     * @param index A zero based index
     * @return
     */
    item(a: number): Series;
    /**
     * Returns the number of items in the collection (read-only)
     */
    get count(): number;
    /**
     * Determines if the collecion can be modified (read-only)
     */
    get isReadOnly(): boolean;
    /**
     * Adds a new series to the collection
     * @return The newly added [[Series]]
     */
    add(): Series;
    /**
     * Clears the collection.
     */
    clear(): void;
    /**
     * Determines if the collection contains thhe item
     * @param item The item to check
     * @return True if the item is in the collection, otherwise false.
     */
    contains(item: Series): boolean;
    [Symbol.iterator](): EnumeratorWrapper<Series>;
    getEnumerator(): any;
    /**
     * @hidden
     */
    _getEnumerator(): IEnumerator$1<Series>;
    /**
     * Returns the index of the item in the collection
     * @param item The item to check
     * @return the zero-based index or -1 if the item isn't in the collection.
     */
    indexOf(item: Series): number;
    /**
     * Inserts a new [[Series]] into the collection at the specified index.
     * @param index The index to insert the new series
     * @return The newly inserted [[Series]]
     */
    insert(index: number): Series;
    /**
     * @hidden
     */
    private _at;
    /**
     * Removes an item from the collection.
     * @param item The series to remove
     * @return True if the series was removed, otherwise false.
     */
    remove(item: Series): boolean;
    /**
     * Removes the series at the specified index
     * @param index The zero-based index
     */
    removeAt(index: number): void;
    /**
     * @hidden
     */
    _a0(): void;
    /**
     * @hidden
     */
    _a1(a: number): void;
    getEnumeratorObject(): any;
    /**
     * @hidden
     */
    _getEnumeratorObject$e(): IEnumerator;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
    /**
     * @hidden
     */
    private static _a2;
    /**
     * @hidden
     */
    private static _a3;
    /**
     * @hidden
     */
    _az(a: boolean, b?: boolean): void;
    /**
     * @hidden
     */
    _ay(a: MarkerStyle): void;
    /**
     * @hidden
     */
    _aw(a: ChartType, b: ChartType): void;
    /**
     * @hidden
     */
    _ax(a: ChartFillBase): void;
    /**
     * @hidden
     */
    _av(): void;
    /**
     * @hidden
     */
    _aq(a: Series): Nullable$1<number>;
    /**
     * @hidden
     */
    _ad(a: SeriesType): boolean;
    /**
     * @hidden
     */
    get _ae(): boolean;
    /**
     * @hidden
     */
    get _ah(): boolean;
    /**
     * @hidden
     */
    _ak(a: Nullable$1<SeriesType>, b: Nullable$1<AxisGroup>, c?: Series): List$1<Series>;
    /**
     * @hidden
     */
    _as(a: boolean, b: boolean): {
        p0: boolean;
        p1: boolean;
    };
}
/**
 * @hidden
 */
export declare class SeriesCollection_PlotOrderSortItem extends Base {
    static $t: Type;
    a: Series;
    b: number;
    c: number;
}
/**
 * @hidden
 */
export declare class SeriesCollection_PlotOrderSortComparer extends Base implements IComparer$1<SeriesCollection_PlotOrderSortItem> {
    static $t: Type;
    compare(a: SeriesCollection_PlotOrderSortItem, b: SeriesCollection_PlotOrderSortItem): number;
}
/**
 * Represents the tick-mark labels associated with tick marks on a chart [[Axis]].
 */
export declare class TickLabels extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _a1;
    /**
     * @hidden
     */
    private static readonly _a3;
    /**
     * @hidden
     */
    private static readonly _a4;
    /**
     * @hidden
     */
    private static readonly _a6;
    /**
     * @hidden
     */
    private static readonly _a7;
    /**
     * @hidden
     */
    private static readonly _a9;
    /**
     * @hidden
     */
    private static readonly _ba;
    /**
     * @hidden
     */
    private static readonly _bb;
    /**
     * @hidden
     */
    private static readonly _bc;
    /**
     * @hidden
     */
    private static readonly _a5;
    /**
     * @hidden
     */
    private static readonly _ak;
    /**
     * @hidden
     */
    private static readonly _as;
    /**
     * @hidden
     */
    private static readonly _at;
    /**
     * @hidden
     */
    private static readonly _a2;
    /**
     * @hidden
     */
    private static readonly _ad;
    /**
     * @hidden
     */
    private static readonly _ay;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _w;
    private _ai;
    private _z;
    private _al;
    private _ap;
    private _aq;
    private _bd;
    private _ar;
    private _a0;
    private _ac;
    private _ax;
    private _af;
    constructor(a: IChartObject);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * Specifies the alignment of the tick labels
     */
    get alignment(): TickLabelAlignment;
    set alignment(a: TickLabelAlignment);
    /**
     * Specifies which font to use. Read-only.
     * <para class="note"><b>Note:</b> this property will return null until the [[TickLabels]]
     * is set on the <see cref="Axis.TickLabels">Axis.TickLabels</see> property.</para>
     */
    get font(): IWorkbookFont;
    /**
     * @hidden
     */
    _e(a: Workbook): WorkbookFontProxy;
    /**
     * @hidden
     */
    get _ao(): WorkbookColorInfo;
    /**
     * @hidden
     */
    get _an(): IWorkbookFont;
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill applied to the background of tick labels.
     * <p class="body">
     * This property is not applicable for <i>BoxAndWhisker</i>, <i>Histogram</i>,
     * <i>Pareto</i>, <i>Sunburst</i>, <i>Treemap</i>, or <i>Waterfall</i> charts.
     * </p>
     */
    get fill(): ChartFillBase;
    set fill(a: ChartFillBase);
    /**
     * @hidden
     */
    get _ab(): ChartFillBase;
    /**
     * Specifies whether an axis is multilevel or not.
     */
    get multiLevel(): boolean;
    set multiLevel(a: boolean);
    /**
     * Returns or sets the format to use for numbers.
     * <p class="body">
     * Note that in some cases it may be necessary to set [[numberFormatLinked]]
     * to false in order to see the format applied. If the tick labels are not displaying the
     * format you specified, try setting NumberFormatLinked to false.
     * </p>
     * @see [[numberFormatLinked]]
     */
    get numberFormat(): string;
    set numberFormat(a: string);
    /**
     * True if the number format is linked to the cells (so that the number format changes in the labels when it changes in the cells).
     * <p class="body">
     * Note that in some cases it may be necessary to set this property
     * to false in order to see the [[numberFormat]] applied.
     * If the tick labels are not displaying the format you specified,
     * try setting this property to false.
     * </p>
     * @see [[numberFormat]]
     */
    get numberFormatLinked(): boolean;
    set numberFormatLinked(a: boolean);
    /**
     * Returns or sets a Long value that represents the distance between the levels of labels, and the distance between the first level and the axis line.
     */
    get offset(): number;
    set offset(a: number);
    /**
     * Determines the reading order
     */
    get readingOrder(): ReadingOrder;
    set readingOrder(a: ReadingOrder);
    /**
     * Determines the rotation of the text area, expressed in degrees.
     * <p class="body">
     * The Rotation property is only applicable when [[textDirection]]
     * is set to <i>Horizontal</i>.
     * </p>
     * @see [[textDirection]]
     */
    get rotation(): number;
    set rotation(a: number);
    /**
     * Determines the orientation and direction in which text flows.
     * <p class="body">Note that the [[rotation]] property is only applicable when this property is set to <i>Horizontal</i>.</p>
     * @see [[rotation]]
     */
    get textDirection(): TextDirection;
    set textDirection(a: TextDirection);
    /**
     * @hidden
     */
    _aw(): boolean;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * Represents the bar which depicts gain or loss on a stock chart.
 */
export declare class UpDownBar extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _ai;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    static readonly _ah: number;
    private _ae;
    private _z;
    private _ab;
    constructor(a: UpDownBars, b: UpDownBarType);
    /**
     * Returns a value which identifies this instance as as up or down bar.
     */
    get barType(): UpDownBarType;
    /**
     * Determines the appearance of the border drawn around
     * the bar, as well as whether a border appears.
     * @see [[fill]]
     */
    get border(): ChartBorder;
    set border(a: ChartBorder);
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill properties for the bar.
     * @see [[border]]
     */
    get fill(): ChartFillBase;
    set fill(a: ChartFillBase);
    /**
     * @hidden
     */
    get _ad(): ChartFillBase;
    /**
     * @hidden
     */
    private static readonly _w;
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * Represents the walls and floor of a 3-D chart.
 * This object isn't a collection. There's no object
 * that represents a single wall; you must return all
 * the walls as a unit.
 */
export declare class Wall extends ChartObject {
    static $t: Type;
    /**
     * @hidden
     */
    private static readonly _af;
    /**
     * @hidden
     */
    private static readonly _ag;
    /**
     * @hidden
     */
    private static readonly _aj;
    /**
     * @hidden
     */
    private static readonly _ah;
    /**
     * @hidden
     */
    private static readonly _w;
    private _z;
    private _ab;
    private _ae;
    constructor(a: IChartObject, b: WallType);
    /**
     * @hidden
     */
    _a(a: number): ChangeInfo;
    /**
     * Determines the appearance of the border drawn around
     * the text area, as well as whether a border appears.
     * @see [[fill]]
     */
    get border(): ChartBorder;
    set border(a: ChartBorder);
    /**
     * Returns or sets a [[ChartFillBase]] derived object
     * which defines the fill for this series.
     * @see [[border]]
     */
    get fill(): ChartFillBase;
    set fill(a: ChartFillBase);
    /**
     * The thickness of the wall
     */
    get thickness(): number;
    set thickness(a: number);
    private _type;
    /**
     * Returns the type of the wall, i.e., back, side, floor, or all.
     */
    get type(): WallType;
    set type(a: WallType);
    /**
     * @hidden
     */
    private static _y;
    /**
     * @hidden
     */
    private static _x;
}
/**
 * @hidden
 */
export declare class DdeLinkNamedReference extends NamedReferenceBase {
    static $t: Type;
    private _bf;
    constructor(a: DdeLinkWorkbookReference, b: any);
    protected get__f(): RefBase;
    get _f(): RefBase;
    protected get__n(): boolean;
    get _n(): boolean;
    protected get__z(): CultureInfo;
    get _z(): CultureInfo;
    toString(): string;
    _a1(a: GetFormulaStringInfo, b?: boolean): string;
    protected get__g(): NameType;
    protected get__k(): Workbook;
    get _k(): Workbook;
    protected get__h(): WorkbookReferenceBase;
}
/**
 * @hidden
 */
export declare abstract class WorkbookReferenceBase extends Base {
    static $t: Type;
    private p;
    private q;
    private v;
    private s;
    private k;
    private r;
    constructor(a: Workbook);
    abstract b(a: string, b: any, c: boolean): NamedReferenceBase;
    abstract h(a: number): WorksheetReferenceSingle;
    abstract aa(a: number): string;
    abstract j(a: string): WorksheetReferenceSingle;
    abstract ab(a: number, b: number, c: GetFormulaStringInfo, d: boolean): string;
    ac(): void;
    d(a: FormulaContext): WorkbookReferenceBase;
    e(): WorkbookReferenceUnconnected;
    f(a: WorksheetReferenceSingle, b: WorksheetReferenceSingle): WorksheetReference;
    c(a: string, b: any, c: boolean): NamedReferenceBase;
    z(a: GetFormulaStringInfo, b?: boolean): string;
    g(a: string, b: string): WorksheetReference;
    i(a: number): WorksheetReferenceSingle;
    ad(): void;
    ae(a: number): void;
    protected y(a: GetFormulaStringInfo, b: boolean): {
        ret: string;
        p1: boolean;
    };
    protected o(a: string): Dictionary$2<any, NamedReferenceBase>;
    protected get_x(): string;
    get x(): string;
    protected get_m(): boolean;
    get m(): boolean;
    abstract get n(): boolean;
    protected abstract get a(): FormulaType;
    protected get t(): List$1<NamedReferenceBase>;
    get u(): ReadOnlyCollection$1<NamedReferenceBase>;
    get l(): Workbook;
    protected get_w(): any;
    get w(): any;
}
/**
 * @hidden
 */
export declare class DdeLinkWorkbookReference extends WorkbookReferenceBase {
    static $t: Type;
    private readonly af;
    private readonly ah;
    private readonly ai;
    constructor(a: string, b: string, c: Workbook);
    b(a: string, b: any, c: boolean): NamedReferenceBase;
    h(a: number): WorksheetReferenceSingle;
    e(): WorkbookReferenceUnconnected;
    aa(a: number): string;
    j(a: string): WorksheetReferenceSingle;
    ab(a: number, b: number, c: GetFormulaStringInfo, d: boolean): string;
    protected get_x(): string;
    static aj(a: string, b: string): string;
    protected get_n(): boolean;
    get n(): boolean;
    get ag(): List$1<DdeItem>;
    protected get_a(): FormulaType;
    protected get a(): FormulaType;
    get ak(): string;
    get al(): string;
}
/**
 * @hidden
 */
export declare class AddInFunctionNamedReference extends NamedReferenceBase {
    static $t: Type;
    private _bf;
    constructor(a: AddInFunctionsWorkbookReference, b: any);
    protected get__f(): RefBase;
    get _f(): RefBase;
    protected get__n(): boolean;
    get _n(): boolean;
    protected get__z(): CultureInfo;
    get _z(): CultureInfo;
    protected get__l(): WorkbookFormat;
    toString(): string;
    protected get__g(): NameType;
    protected get__k(): Workbook;
    get _k(): Workbook;
    protected get__h(): WorkbookReferenceBase;
}
/**
 * @hidden
 */
export declare class AddInFunctionsWorkbookReference extends WorkbookReferenceBase {
    static $t: Type;
    constructor(a: Workbook);
    b(a: string, b: any, c: boolean): NamedReferenceBase;
    h(a: number): WorksheetReferenceSingle;
    protected get_x(): string;
    aa(a: number): string;
    j(a: string): WorksheetReferenceSingle;
    ab(a: number, b: number, c: GetFormulaStringInfo, d: boolean): string;
    protected get_n(): boolean;
    get n(): boolean;
    protected get_a(): FormulaType;
    protected get a(): FormulaType;
}
/**
 * @hidden
 */
export declare class CurrentWorkbookReference extends WorkbookReferenceBase {
    static $t: Type;
    private ai;
    private af;
    constructor(a: Workbook);
    b(a: string, b: any, c?: boolean): NamedReferenceBase;
    h(a: number): WorksheetReferenceSingle;
    protected get_x(): string;
    aa(a: number): string;
    j(a: string): WorksheetReferenceSingle;
    ag(a: string): WorksheetReferenceSingle;
    ab(a: number, b: number, c: GetFormulaStringInfo, d: boolean): string;
    protected get_n(): boolean;
    get n(): boolean;
    protected get_a(): FormulaType;
    protected get a(): FormulaType;
    protected get_w(): any;
    aj(a: NamedReference): void;
    private ah;
    ak(a: Worksheet): void;
}
/**
 * @hidden
 */
export declare class ExternalNamedReference extends NamedReferenceBase {
    static $t: Type;
    private _bf;
    private _bg;
    constructor(a: ExternalWorkbookReference, b: any);
    protected get__f(): RefBase;
    get _f(): RefBase;
    protected get__z(): CultureInfo;
    get _z(): CultureInfo;
    protected get__l(): WorkbookFormat;
    _a6(a: boolean): void;
    toString(): string;
    _a1(a: GetFormulaStringInfo, b?: boolean): string;
    protected get__k(): Workbook;
    get _k(): Workbook;
    protected get__h(): WorkbookReferenceBase;
    protected get__n(): boolean;
    get _n(): boolean;
}
/**
 * @hidden
 */
export declare class ExternalWorkbookReference extends WorkbookReferenceBase {
    static $t: Type;
    private ah;
    private af;
    constructor(a: string, b: Workbook);
    b(a: string, b: any, c: boolean): NamedReferenceBase;
    h(a: number): WorksheetReferenceSingle;
    protected get_x(): string;
    aa(a: number): string;
    j(a: string): WorksheetReferenceSingle;
    ab(a: number, b: number, c: GetFormulaStringInfo, d: boolean): string;
    protected get_n(): boolean;
    get n(): boolean;
    protected get_a(): FormulaType;
    protected get a(): FormulaType;
    toString(): string;
    get ag(): List$1<string>;
}
/**
 * @hidden
 */
export declare class GetFormulaStringInfo extends Base {
    static $t: Type;
    static a: GetFormulaStringInfo;
    readonly c: Dictionary$2<WorkbookReferenceBase, number>;
    readonly b: boolean;
    constructor(a: Dictionary$2<WorkbookReferenceBase, number>, b: boolean);
}
/**
 * @hidden
 */
export declare class OleLinkNamedReference extends NamedReferenceBase {
    static $t: Type;
    private _bf;
    constructor(a: OleLinkWorkbookReference, b: any);
    protected get__f(): RefBase;
    get _f(): RefBase;
    protected get__n(): boolean;
    get _n(): boolean;
    protected get__z(): CultureInfo;
    get _z(): CultureInfo;
    toString(): string;
    _a1(a: GetFormulaStringInfo, b?: boolean): string;
    protected get__g(): NameType;
    protected get__k(): Workbook;
    get _k(): Workbook;
    protected get__h(): WorkbookReferenceBase;
}
/**
 * @hidden
 */
export declare class OleLinkWorkbookReference extends WorkbookReferenceBase {
    static $t: Type;
    private readonly af;
    private readonly aj;
    private readonly ah;
    constructor(a: string, b: Uri, c: Workbook);
    b(a: string, b: any, c: boolean): NamedReferenceBase;
    h(a: number): WorksheetReferenceSingle;
    e(): WorkbookReferenceUnconnected;
    aa(a: number): string;
    j(a: string): WorksheetReferenceSingle;
    ab(a: number, b: number, c: GetFormulaStringInfo, d: boolean): string;
    protected get_x(): string;
    protected get_n(): boolean;
    get n(): boolean;
    get ag(): List$1<OleItem>;
    protected get_a(): FormulaType;
    protected get a(): FormulaType;
    get ak(): Uri;
    get ai(): string;
}
/**
 * @hidden
 */
export declare abstract class WorkbookLoadManager extends WorkbookSerializationManager {
    static $t: Type;
    private readonly _t;
    constructor(a: Workbook, b: string);
    abstract _r(): WorksheetCellFormatData;
    protected abstract _p(): WorkItem;
    _y(a: NamedReference, b: boolean): void;
    static _v(a: Workbook, b: string, c: string): any;
    _ae(a: CT_Transform2D, b: number, c: CT_GroupTransform2D, d: Rect): Rect;
    _q(a: number): WorksheetReference;
    _o(): WorkItem;
    _z(): void;
    _ac<T>($t: Type, a: WorksheetTableAreaFormatsCollection$1<T>, b: T, c: (arg1: T, arg2: CellFormatValue) => boolean, d: WorkbookStyle, e: WorksheetCellFormatData): void;
    _ad<T>($t: Type, a: WorksheetTableAreaFormatsCollection$1<T>, b: T, c: (arg1: T, arg2: CellFormatValue) => boolean, d: WorkbookStyle, e: WorksheetCellFormatData, f: WorksheetCellFormatData, ...g: CellFormatValue[]): void;
    private static _aa;
    private static _ab;
    private _s;
    private static _w;
    private static get _x();
    get _u(): List$1<StringElement>;
}
/**
 * @hidden
 */
export declare class WorkbookReferenceUnconnected extends WorkbookReferenceBase {
    static $t: Type;
    private readonly af;
    private readonly ag;
    constructor(a: string, b: boolean);
    d(a: FormulaContext): WorkbookReferenceBase;
    b(a: string, b: any, c: boolean): NamedReferenceBase;
    h(a: number): WorksheetReferenceSingle;
    e(): WorkbookReferenceUnconnected;
    protected get_x(): string;
    aa(a: number): string;
    j(a: string): WorksheetReferenceSingle;
    ab(a: number, b: number, c: GetFormulaStringInfo, d: boolean): string;
    protected get_m(): boolean;
    protected get_n(): boolean;
    get n(): boolean;
    protected get_a(): FormulaType;
    protected get a(): FormulaType;
}
/**
 * @hidden
 */
export declare class WorkbookSaveManager_InitSerializationCacheFormulaHelper extends FormulaTokenVisitor {
    static $t: Type;
    private static a0;
    private az;
    constructor();
    g(): void;
    aj(a: NameToken): void;
    aq(a: ReferenceToken): void;
    aw(a: StructuredTableReference): void;
    static a1(a: FormulaContext, b: WorkbookSaveManager): WorkbookSaveManager_InitSerializationCacheFormulaHelper;
    private a2;
    private a3;
    private a4;
}
/**
 * @hidden
 */
export declare class WorkbookSaveManager_InitSerializationCacheHelper extends WorksheetShapeVisitor$2<WorkbookSaveManager, boolean> implements IStringElementVisitor$2<Tuple$2<WorkbookSaveManager, IWorkbookFontDefaultsResolver>, boolean> {
    static $t: Type;
    static readonly d: WorkbookSaveManager_InitSerializationCacheHelper;
    constructor();
    _visitFormattedStringElement$i(a: FormattedStringElement, b: Tuple$2<WorkbookSaveManager, IWorkbookFontDefaultsResolver>): boolean;
    _visitStringElement$i(a: StringElement, b: Tuple$2<WorkbookSaveManager, IWorkbookFontDefaultsResolver>): boolean;
    visitWorksheetCellComment(value: WorksheetCellComment, saveManager: WorkbookSaveManager): boolean;
    _visitWorksheetCellComment$i(a: WorksheetCellComment, b: WorkbookSaveManager): boolean;
    visitWorksheetChart(value: WorksheetChart, saveManager: WorkbookSaveManager): boolean;
    _visitWorksheetChart$i(a: WorksheetChart, b: WorkbookSaveManager): boolean;
    visitWorksheetShapeGroup(value: WorksheetShapeGroupBase, saveManager: WorkbookSaveManager): boolean;
    _visitWorksheetShapeGroup$i(a: WorksheetShapeGroupBase, b: WorkbookSaveManager): boolean;
    c(a: WorksheetShapeWithText, b: WorkbookSaveManager): boolean;
}
/**
 * @hidden
 */
export declare class WorkbookSaveManager_ColorSortConditionVisitorProxy$1<TArg> extends Base implements IColorSortConditionVisitor$2<TArg, boolean> {
    static $t: Type;
    protected $tArg: Type;
    private readonly a;
    private readonly c;
    private readonly d;
    private readonly e;
    constructor($tArg: Type, a: WorkbookSaveManager, b: boolean, c: boolean, d: Dictionary$2<TArg, number>);
    private b;
    visitFillSortCondition(value: FillSortCondition, arg: TArg): boolean;
    _visitFillSortCondition$i(a: FillSortCondition, b: TArg): boolean;
    visitFontColorSortCondition(value: FontColorSortCondition, arg: TArg): boolean;
    _visitFontColorSortCondition$i(a: FontColorSortCondition, b: TArg): boolean;
}
/**
 * @hidden
 */
export declare class CellContext extends Base {
    static $t: Type;
    constructor(a: WorksheetRow, b: WorksheetRowSerializationCache);
    b: WorksheetRow;
    a: WorksheetRowSerializationCache;
    c: any;
}
/**
 * @hidden
 */
export declare abstract class WorksheetReference extends Base {
    static $t: Type;
    private d;
    constructor(a: WorkbookReferenceBase);
    f(a: FormulaContext): WorksheetReference;
    g(a: WorkbookReferenceBase): WorksheetReference;
    abstract h(): WorksheetReference;
    abstract a(a: WorksheetCellAddress): IExcelCalcReference;
    abstract b(a: WorksheetRegionAddress): IExcelCalcReference;
    abstract o(a: GetFormulaStringInfo, b: boolean): string;
    abstract get l(): number;
    abstract c(a: string): NamedReferenceBase;
    protected get_i(): boolean;
    get i(): boolean;
    abstract get j(): boolean;
    abstract get k(): boolean;
    protected get_m(): number;
    get m(): number;
    protected get_n(): any;
    get n(): any;
    get p(): string;
    get e(): WorkbookReferenceBase;
}
/**
 * @hidden
 */
export declare abstract class WorksheetReferenceSingle extends WorksheetReference {
    static $t: Type;
    constructor(a: WorkbookReferenceBase);
    h(): WorksheetReference;
    o(a: GetFormulaStringInfo, b: boolean): string;
    protected get_k(): boolean;
    get k(): boolean;
    abstract q(a: WorksheetReference, b: WorksheetCellAddress): IExcelCalcReference;
    abstract r(a: WorksheetReference, b: WorksheetRegionAddress): IExcelCalcReference;
    abstract get s(): string;
}
/**
 * @hidden
 */
export declare class WorksheetReferenceError extends WorksheetReferenceSingle {
    static $t: Type;
    constructor(a: WorkbookReferenceBase);
    g(a: WorkbookReferenceBase): WorksheetReference;
    protected get_l(): number;
    get l(): number;
    a(a: WorksheetCellAddress): IExcelCalcReference;
    b(a: WorksheetRegionAddress): IExcelCalcReference;
    q(a: WorksheetReference, b: WorksheetCellAddress): IExcelCalcReference;
    r(a: WorksheetReference, b: WorksheetRegionAddress): IExcelCalcReference;
    c(a: string): NamedReferenceBase;
    protected get_i(): boolean;
    protected get_j(): boolean;
    get j(): boolean;
    protected get_s(): string;
    get s(): string;
}
/**
 * @hidden
 */
export declare class WorksheetReferenceExternal extends WorksheetReferenceSingle {
    static $t: Type;
    private w;
    private v;
    private y;
    constructor(a: WorkbookReferenceBase, b: number);
    protected get_l(): number;
    get l(): number;
    a(a: WorksheetCellAddress): IExcelCalcReference;
    b(a: WorksheetRegionAddress): IExcelCalcReference;
    q(a: WorksheetReference, b: WorksheetCellAddress): IExcelCalcReference;
    r(a: WorksheetReference, b: WorksheetRegionAddress): IExcelCalcReference;
    c(a: string): NamedReferenceBase;
    protected get_j(): boolean;
    get j(): boolean;
    protected get_s(): string;
    get s(): string;
    z(a: number, b: number): any;
    t(a: number): WorksheetReferenceExternalRowValues;
    aa(a: number, b: number, c: any): void;
    u(a: number): WorksheetReferenceExternalRowValues;
    get x(): IEnumerable$1<WorksheetReferenceExternalRowValues>;
}
/**
 * @hidden
 */
export declare class WorksheetReferenceExternalRowValues extends Base {
    static $t: Type;
    private d;
    private c;
    private b;
    private f;
    constructor(a: WorksheetReferenceExternal, b: number);
    h(a: number): any;
    a(a: number): IExcelCalcReference;
    i(a: number, b: any): void;
    get e(): IEnumerable$1<KeyValuePair$2<number, any>>;
    get g(): number;
}
/**
 * @hidden
 */
export declare class WorksheetReferenceLocal extends WorksheetReferenceSingle {
    static $t: Type;
    private t;
    constructor(a: CurrentWorkbookReference, b: Worksheet);
    protected get_l(): number;
    get l(): number;
    a(a: WorksheetCellAddress): IExcelCalcReference;
    b(a: WorksheetRegionAddress): IExcelCalcReference;
    q(a: WorksheetReference, b: WorksheetCellAddress): IExcelCalcReference;
    r(a: WorksheetReference, b: WorksheetRegionAddress): IExcelCalcReference;
    c(a: string): NamedReferenceBase;
    protected get_j(): boolean;
    get j(): boolean;
    protected get_s(): string;
    get s(): string;
    protected get_n(): any;
    get u(): Worksheet;
}
/**
 * @hidden
 */
export declare class WorksheetReferenceSingleUnconnected extends WorksheetReferenceSingle {
    static $t: Type;
    private t;
    constructor(a: number, b: string, c: string);
    constructor(a: number, b: WorkbookReferenceUnconnected, c: string);
    constructor(a: number, ..._rest: any[]);
    g(a: WorkbookReferenceBase): WorksheetReference;
    h(): WorksheetReference;
    equals(a: any): boolean;
    protected get_l(): number;
    get l(): number;
    a(a: WorksheetCellAddress): IExcelCalcReference;
    b(a: WorksheetRegionAddress): IExcelCalcReference;
    getHashCode(): number;
    q(a: WorksheetReference, b: WorksheetCellAddress): IExcelCalcReference;
    r(a: WorksheetReference, b: WorksheetRegionAddress): IExcelCalcReference;
    c(a: string): NamedReferenceBase;
    o(a: GetFormulaStringInfo, b: boolean): string;
    protected get_i(): boolean;
    protected get_j(): boolean;
    get j(): boolean;
    protected get_s(): string;
    get s(): string;
}
/**
 * @hidden
 */
export declare class WorksheetReferenceToWorkbook extends WorksheetReferenceSingle {
    static $t: Type;
    constructor(a: WorkbookReferenceBase);
    g(a: WorkbookReferenceBase): WorksheetReference;
    protected get_l(): number;
    get l(): number;
    a(a: WorksheetCellAddress): IExcelCalcReference;
    b(a: WorksheetRegionAddress): IExcelCalcReference;
    q(a: WorksheetReference, b: WorksheetCellAddress): IExcelCalcReference;
    r(a: WorksheetReference, b: WorksheetRegionAddress): IExcelCalcReference;
    c(a: string): NamedReferenceBase;
    protected get_i(): boolean;
    protected get_j(): boolean;
    get j(): boolean;
    protected get_s(): string;
    get s(): string;
    protected get_n(): any;
}
/**
 * @hidden
 */
export declare class WorksheetReferenceMulti extends WorksheetReference {
    static $t: Type;
    private q;
    private s;
    constructor(a: WorksheetReferenceSingle, b: WorksheetReferenceSingle);
    g(a: WorkbookReferenceBase): WorksheetReference;
    h(): WorksheetReference;
    protected get_l(): number;
    get l(): number;
    a(a: WorksheetCellAddress): IExcelCalcReference;
    b(a: WorksheetRegionAddress): IExcelCalcReference;
    c(a: string): NamedReferenceBase;
    o(a: GetFormulaStringInfo, b: boolean): string;
    protected get_i(): boolean;
    protected get_j(): boolean;
    get j(): boolean;
    protected get_k(): boolean;
    get k(): boolean;
    protected get_m(): number;
    protected get_n(): any;
    get r(): WorksheetReferenceSingle;
    get t(): WorksheetReferenceSingle;
}
/**
 * @hidden
 */
export declare class WorksheetSerializationCache extends SheetSerializationCache {
    static $t: Type;
    readonly n: number;
    readonly o: number;
    readonly p: number;
    readonly q: number;
    readonly e: number;
    readonly f: number;
    readonly k: number;
    private readonly i;
    readonly g: Dictionary$2<number, number>;
    readonly h: Dictionary$2<number, number>;
    constructor(a: number, b: number, c: number, d: number, e: number, f: number, g: number);
    get j(): List$1<WorksheetCellComment>;
    l(a: number): Nullable$1<number>;
    m(a: number): Nullable$1<number>;
}
/**
 * @hidden
 */
export interface IBiffRecordStream {
    parentStreamRaw: IBiffRecordStream;
    readonly endUnderlyingStreamPosition: number;
    readonly saveManager: WorkbookSaveManager;
    readByteFromBuffer(a: number[], b: number): {
        ret: number;
        p0?: number[];
        p1?: number;
    };
    readBytesFromBuffer(a: number, b: number[], c: number): {
        ret: number[];
        p1?: number[];
        p2?: number;
    };
    readDoubleFromBuffer(a: number[], b: number): {
        ret: number;
        p0?: number[];
        p1?: number;
    };
    readFormattedStringFromBuffer(a: LengthType, b: number[], c: number): {
        ret: StringElement;
        p1?: number[];
        p2?: number;
    };
    writeByte(a: number): void;
    writeByteArray(a: number[]): void;
    writeDouble(a: number): void;
    writeString(a: string, b: LengthType): void;
    writeFullColorExt(a: WorkbookColorInfo, b: ColorableItem): void;
    writeXFExtGradient(a: CellFillGradient): void;
}
/**
 * @hidden
 */
export declare let IBiffRecordStream_$type: Type;
/**
 * @hidden
 */
export declare abstract class ExtProp extends Base {
    static $t: Type;
    abstract b(a: WorkbookLoadManager, b: WorksheetCellFormatData): void;
    abstract get a(): ExtPropType;
    abstract c(a: IBiffRecordStream): void;
}
/**
 * @hidden
 */
export declare abstract class ExtPropColorBase extends ExtProp {
    static $t: Type;
    private d;
    constructor(a: ExtPropType);
    b(a: WorkbookLoadManager, b: WorksheetCellFormatData): void;
    protected get_a(): ExtPropType;
    get a(): ExtPropType;
    c(a: IBiffRecordStream): void;
    abstract e(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class ExtPropColor extends ExtPropColorBase {
    static $t: Type;
    private f;
    constructor(a: WorkbookColorInfo, b: ExtPropType);
    e(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class ExtPropFontScheme extends ExtProp {
    static $t: Type;
    private d;
    constructor(a: FontScheme);
    b(a: WorkbookLoadManager, b: WorksheetCellFormatData): void;
    protected get_a(): ExtPropType;
    get a(): ExtPropType;
    c(a: IBiffRecordStream): void;
}
/**
 * @hidden
 */
export declare abstract class ExtPropGradientFillBase extends ExtProp {
    static $t: Type;
    b(a: WorkbookLoadManager, b: WorksheetCellFormatData): void;
    c(a: IBiffRecordStream): void;
    abstract d(a: Workbook): CellFillGradient;
}
/**
 * @hidden
 */
export declare class ExtPropGradientFill extends ExtPropGradientFillBase {
    static $t: Type;
    private e;
    constructor(a: CellFillGradient);
    b(a: WorkbookLoadManager, b: WorksheetCellFormatData): void;
    d(a: Workbook): CellFillGradient;
    protected get_a(): ExtPropType;
    get a(): ExtPropType;
    c(a: IBiffRecordStream): void;
}
/**
 * @hidden
 */
export declare class ExtPropTextIndentationLevel extends ExtProp {
    static $t: Type;
    private d;
    constructor(a: number);
    b(a: WorkbookLoadManager, b: WorksheetCellFormatData): void;
    protected get_a(): ExtPropType;
    get a(): ExtPropType;
    c(a: IBiffRecordStream): void;
}
/**
 * @hidden
 */
export declare abstract class XFProp extends Base {
    static $t: Type;
    abstract b(a: Workbook, b: WorksheetCellFormatData): void;
    abstract get a(): XFPropType;
}
/**
 * @hidden
 */
export declare class XFPropBool extends XFProp {
    static $t: Type;
    private d;
    private c;
    constructor(a: number, b: XFPropType, c: boolean);
    constructor(a: number, b: XFPropType, c: Nullable$1<boolean>);
    constructor(a: number, b: XFPropType, c: number);
    constructor(a: number, ..._rest: any[]);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get e(): boolean;
    get f(): number;
}
/**
 * @hidden
 */
export declare abstract class XFPropBorderBase extends XFProp {
    static $t: Type;
    private c;
    private e;
    constructor(a: XFPropType, b: CellBorderLineStyle);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): CellBorderLineStyle;
    abstract f(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class XFPropBorder extends XFPropBorderBase {
    static $t: Type;
    private g;
    constructor(a: XFPropType, b: WorkbookColorInfo, c: CellBorderLineStyle);
    f(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare abstract class XFPropColorBase extends XFProp {
    static $t: Type;
    b(a: Workbook, b: WorksheetCellFormatData): void;
    abstract c(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class XFPropColor extends XFPropColorBase {
    static $t: Type;
    private e;
    private d;
    constructor(a: XFPropType, b: WorkbookColorInfo);
    c(a: Workbook): WorkbookColorInfo;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get f(): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class XFPropFillPattern extends XFProp {
    static $t: Type;
    private c;
    constructor(a: FillPatternStyle);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): FillPatternStyle;
}
/**
 * @hidden
 */
export declare class XFPropFontBold extends XFProp {
    static $t: Type;
    private c;
    constructor(a: number, b: number);
    constructor(a: number, b: Nullable$1<boolean>);
    constructor(a: number, ..._rest: any[]);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): boolean;
    get e(): number;
}
/**
 * @hidden
 */
export declare class XFPropFontHeight extends XFProp {
    static $t: Type;
    private c;
    constructor(a: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): number;
}
/**
 * @hidden
 */
export declare class XFPropFontName extends XFProp {
    static $t: Type;
    private c;
    constructor(a: string);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): string;
}
/**
 * @hidden
 */
export declare class XFPropFontSubscriptSuperscript extends XFProp {
    static $t: Type;
    private c;
    constructor(a: FontSuperscriptSubscriptStyle);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): FontSuperscriptSubscriptStyle;
}
/**
 * @hidden
 */
export declare class XFPropFontScheme extends XFProp {
    static $t: Type;
    private c;
    constructor(a: FontScheme);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): FontScheme;
}
/**
 * @hidden
 */
export declare class XFPropFontUnderline extends XFProp {
    static $t: Type;
    private c;
    constructor(a: FontUnderlineStyle);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): FontUnderlineStyle;
}
/**
 * @hidden
 */
export declare class XFPropGradientFill extends XFProp {
    static $t: Type;
    private c;
    private e;
    private g;
    private h;
    private i;
    private f;
    constructor(a: boolean, b: number, c: number, d: number, e: number, f: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): boolean;
    get j(): number;
    get l(): number;
    get m(): number;
    get n(): number;
    get k(): number;
}
/**
 * @hidden
 */
export declare abstract class XFPropGradientStopBase extends XFProp {
    static $t: Type;
    private d;
    constructor(a: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    abstract c(a: Workbook): WorkbookColorInfo;
    get e(): number;
}
/**
 * @hidden
 */
export declare class XFPropGradientStop extends XFPropGradientStopBase {
    static $t: Type;
    private f;
    constructor(a: WorkbookColorInfo, b: number);
    c(a: Workbook): WorkbookColorInfo;
}
/**
 * @hidden
 */
export declare class XFPropHorizontalAlignment extends XFProp {
    static $t: Type;
    private c;
    constructor(a: HorizontalCellAlignment);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): HorizontalCellAlignment;
}
/**
 * @hidden
 */
export declare class XFPropNumberFormat extends XFProp {
    static $t: Type;
    private e;
    private c;
    constructor(a: number, b: string);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get f(): number;
    get d(): string;
}
/**
 * @hidden
 */
export declare class XFPropNumberFormatId extends XFProp {
    static $t: Type;
    private c;
    constructor(a: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): number;
}
/**
 * @hidden
 */
export declare class XFPropTextIndentationLevel extends XFProp {
    static $t: Type;
    private c;
    constructor(a: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): number;
}
/**
 * @hidden
 */
export declare class XFPropTextIndentationLevelRelative extends XFProp {
    static $t: Type;
    private c;
    constructor(a: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): number;
}
/**
 * @hidden
 */
export declare class XFPropTextRotation extends XFProp {
    static $t: Type;
    private c;
    constructor(a: number);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): number;
}
/**
 * @hidden
 */
export declare class XFPropVerticalAlignment extends XFProp {
    static $t: Type;
    private c;
    constructor(a: VerticalCellAlignment);
    b(a: Workbook, b: WorksheetCellFormatData): void;
    protected get_a(): XFPropType;
    get a(): XFPropType;
    get d(): VerticalCellAlignment;
}
/**
 * @hidden
 */
export declare class FtLbsData extends Base {
    static $t: Type;
    f: number;
    d: ObjFmla;
    g: number;
    j: number;
    h: number;
    i: number;
    c: LbsDropData;
    b: string[];
    a: boolean[];
    constructor();
    get e(): ObjFmla;
}
/**
 * @hidden
 */
export declare class FtMacro extends Base {
    static $t: Type;
    b: ObjFmla;
    constructor();
    a(): Formula;
    get c(): ObjFmla;
}
/**
 * @hidden
 */
export declare class FtPictFmla extends Base {
    static $t: Type;
    b: ObjFmla;
    g: number;
    f: number;
    d: PictFmlaKey;
    constructor();
    a(): Formula;
    get c(): ObjFmla;
    get e(): PictFmlaKey;
}
/**
 * @hidden
 */
export declare class FtRboData extends Base {
    static $t: Type;
    d: number;
    a: WorksheetShape;
    c: boolean;
    constructor();
    get e(): number;
    get b(): WorksheetShape;
    set b(a: WorksheetShape);
}
/**
 * @hidden
 */
export declare class Obj extends Base {
    static $t: Type;
    d: FtCmo;
    h: FtGmo;
    c: FtCf;
    p: FtPioGrbit;
    a: FtCbls;
    r: FtRbo;
    u: FtSbs;
    m: FtNts;
    k: FtMacro;
    n: FtPictFmla;
    v: ObjLinkFmla;
    b: FtCblsData;
    s: FtRboData;
    f: FtEdoData;
    i: FtLbsData;
    g: FtGboData;
    constructor(a: number);
    constructor(a: number, b: WorksheetShape);
    constructor(a: number, ..._rest: any[]);
    get e(): FtCmo;
    get w(): ObjLinkFmla;
    get j(): FtLbsData;
    get l(): FtMacro;
    get q(): FtPioGrbit;
    get o(): FtPictFmla;
    get t(): FtRboData;
}
/**
 * @hidden
 */
export declare class ObjectParsedFormula extends Base {
    static $t: Type;
    c: number;
    b: Rgce;
    constructor();
    a(): Formula;
}
/**
 * @hidden
 */
export declare class ObjFmla extends Base {
    static $t: Type;
    b: ObjectParsedFormula;
    d: PictFmlaEmbedInfo;
    constructor();
    a(): Formula;
    f(a: Sheet, b: (arg1: Sheet, arg2: Formula) => void): void;
    get e(): PictFmlaEmbedInfo;
    get c(): ObjectParsedFormula;
}
/**
 * @hidden
 */
export declare class ObjLinkFmla extends Base {
    static $t: Type;
    a: ObjFmla;
    constructor();
    get b(): ObjFmla;
}
/**
 * @hidden
 */
export declare class PictFmlaKey extends Base {
    static $t: Type;
    a: number[];
    b: ObjFmla;
    d: ObjFmla;
    constructor();
    get c(): ObjFmla;
    get e(): ObjFmla;
}
/**
 * @hidden
 */
export declare class Rgce extends Base {
    static $t: Type;
    a: Formula;
    constructor();
    get b(): Formula;
}
/**
 * @hidden
 */
export declare class ValueFormatter_ValueFormatterSectionInfo extends Base implements IValueFormatterSectionInfo {
    static $t: Type;
    private a;
    constructor(a: any);
    get color(): string;
    get fractionDigitCount(): number;
    get hasAnyDateParts(): boolean;
    get hasAnyTimeParts(): boolean;
    get hasParentheses(): boolean;
    get hasVerbatimString(): boolean;
    get isDateSection(): boolean;
    get isNumberSection(): boolean;
    get percentCount(): number;
    private get b();
    get showsGroupSeparators(): boolean;
}
/**
 * @hidden
 */
export declare class CalcArgumentHelper extends Base {
    static $t: Type;
    private static a;
    static c(a: ExcelCalcValue, b: CalcArgumentSource, c: CalcArgumentFlags, d: (arg1: number) => void): ExcelCalcValue;
    private static b;
    static e(a: IList$1<ExcelCalcValue>, b: CalcArgumentFlags, c: (arg1: number) => void): ExcelCalcValue;
    static d(a: ExcelCalcNumberStack, b: number, c: CalcArgumentFlags, d: (arg1: number) => void): ExcelCalcValue;
}
/**
 * @hidden
 */
export declare class CalcFunctionUtilities extends Base {
    static $t: Type;
    static readonly w: number;
    static h(a: ExcelCalcNumberStack, b: boolean, c: (arg1: number) => ExcelCalcValue): ExcelCalcValue;
    static j(a: ExcelCalcNumberStack, b: boolean, c: (arg1: number, arg2: number) => ExcelCalcValue): ExcelCalcValue;
    static i(a: ExcelCalcNumberStack, b: boolean, c: (arg1: number, arg2: number, arg3: number) => ExcelCalcValue): ExcelCalcValue;
    private static n;
    static p(a: number): List$1<ExcelCalcValue>;
    static ad(a: List$1<ExcelCalcValue>): void;
    private static m;
    static o(a: number): List$1<number>;
    static ac(a: List$1<number>): void;
    static e(a: IList$1<ExcelCalcValue>, b: CalcArgumentFlags, c: (arg1: List$1<number>) => ExcelCalcValue): ExcelCalcValue;
    static d(a: ExcelCalcNumberStack, b: number, c: CalcArgumentFlags, d: (arg1: List$1<number>) => ExcelCalcValue): ExcelCalcValue;
    static f(a: ExcelCalcNumberStack, b: number, c: CalcArgumentFlags, d: (arg1: number) => void): ExcelCalcValue;
    static g(a: IList$1<ExcelCalcValue>, b: CalcArgumentFlags, c: (arg1: number) => void): ExcelCalcValue;
    static l(a: IList$1<ExcelCalcValue>, b: CalcArgumentFlags): ExcelCalcValue;
    static k(a: ExcelCalcNumberStack, b: number, c: CalcArgumentFlags): ExcelCalcValue;
    static c(a: ExcelCalcNumberStack, b: boolean, c: boolean, d: boolean): CalcArgumentFlags;
    static b(a: ExcelCalcNumberStack, b: boolean, c: boolean, d: boolean): CalcArgumentFlags;
    private static a;
    static q(a: List$1<number>): number;
    static r(a: List$1<number>): number;
    static s(a: List$1<number>, b: number): number;
    static t(a: number, b: number): number;
    static u(a: number, b: number, c: number): number;
    static v(a: List$1<number>): number;
    static x(a: number): number;
    static y(a: number, b: number, c: boolean): number;
    static z(a: List$1<number>): number;
    static ab(a: List$1<number>, b: boolean): number;
}
/**
 * @hidden
 */
export declare class CustomExcelCalcFunction extends ExcelCalcFunction {
    static $t: Type;
    private readonly _an;
    private readonly _am;
    private readonly _al;
    private readonly _ak;
    constructor(a: string, b: number, c: number, d: (arg1: ExcelCalcNumberStack, arg2: number) => ExcelCalcValue);
    protected get_name(): string;
    get name(): string;
    protected get_minArgs(): number;
    get minArgs(): number;
    protected get_maxArgs(): number;
    get maxArgs(): number;
    protected evaluate(a: ExcelCalcNumberStack, b: number): ExcelCalcValue;
}
