/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Type, markType, ValueType, markStruct, IDisposable_$type, Stream, toNullable, String_$type, fromEnum, typeCast, typeCastObjTo$t, Boolean_$type, Number_$type, toEnum, getBoxIfEnum, enumGetBox, EnumUtil, typeGetValue } from "igniteui-react-core";
import { IPackagePart_$type } from "./IPackagePart";
import { ST_ConformanceClass_$type } from "./ST_ConformanceClass";
import { Stack$1 } from "igniteui-react-core";
import { IPackage_$type } from "./IPackage";
import { WorkItem } from "./WorkItem";
import { HashSet$1 } from "igniteui-react-core";
import { Dictionary$2 } from "igniteui-react-core";
import { OfficeDocumentManager_PartRelationshipCounter } from "./OfficeDocumentManager_PartRelationshipCounter";
import { InvalidPackage } from "./InvalidPackage";
import { WorkItemExtensions } from "./WorkItemExtensions";
import { Uri } from "igniteui-react-core";
import { UriUtilities } from "./UriUtilities";
import { Tuple$2 } from "igniteui-react-core";
import { Async } from "./Async";
import { DocCoreUtils } from "./DocCoreUtils";
import { IPackageRelationship_$type } from "./IPackageRelationship";
import { PackageUtilities } from "./PackageUtilities";
import { IInvalidPackageRelationshipTarget_$type } from "./IInvalidPackageRelationshipTarget";
import { Tuple } from "igniteui-react-core";
import { IPackagePartEx_$type } from "./IPackagePartEx";
import { StringUtilities } from "./StringUtilities";
import { IOPath } from "igniteui-react-core";
import { OverrideContentTypePart } from "./OverrideContentTypePart";
import { List$1 } from "igniteui-react-core";
import { RoundTripControlData } from "./RoundTripControlData";
import { nullableEquals, nullableNotEquals } from "igniteui-react-core";
import { stringEmpty, stringIsNullOrEmpty, stringJoin1, stringToString$1, stringIsNullOrWhiteSpace } from "igniteui-react-core";
import { CultureInfo } from "igniteui-react-core";
import { Enumerable } from "igniteui-react-core";
import { XmlReadManager_AlternateContentChoiceContext } from "./XmlReadManager_AlternateContentChoiceContext";
import { XmlReader } from "igniteui-react-core";
import { ContextStack } from "./ContextStack";
import { arrayCopy2 } from "igniteui-react-core";
import { stringSplit, trimStart, trimEnd } from "igniteui-react-core";
import { XmlWriter } from "igniteui-react-core";
import { StringBuilder } from "igniteui-react-core";
import { ImageData } from "./ImageData";
import { ImageFormat } from "./ImageFormat";
import { XmlTextReader } from "igniteui-react-core";
import { Encoding } from "igniteui-react-core";
import { XmlTextWriter } from "igniteui-react-core";
import { NotImplementedException } from "igniteui-react-core";
import { BinaryData } from "./BinaryData";
import { RoundTripPartData } from "./RoundTripPartData";
import { EqualityComparer$1 } from "igniteui-react-core";
import { ST_FillMethod_$type } from "./ST_FillMethod";
import { ST_OnOff } from "./ST_OnOff";
import { tryParseBool } from "igniteui-react-core";
import { parseInt8_1, parseNumber, numberToString, parseInt32_1, tryParseInt32_2, parseInt64_1, parseInt16_1, parseUInt8_1, parseUInt32_1, parseUInt64_1, parseUInt16_1, intSToU } from "igniteui-react-core";
import { ST_Angle } from "./ST_Angle";
import { ST_FixedPercentage } from "./ST_FixedPercentage";
import { ST_LineEndType_$type } from "./ST_LineEndType";
import { ST_LineEndWidth_$type } from "./ST_LineEndWidth";
import { ST_LineEndLength_$type } from "./ST_LineEndLength";
import { ST_DrawingElementId } from "./ST_DrawingElementId";
import { ST_Percentage } from "./ST_Percentage";
import { ST_Coordinate } from "./ST_Coordinate";
import { ST_PositiveFixedAngle } from "./ST_PositiveFixedAngle";
import { ST_PositiveFixedPercentage } from "./ST_PositiveFixedPercentage";
import { ST_PositivePercentage } from "./ST_PositivePercentage";
import { ST_PositiveCoordinate } from "./ST_PositiveCoordinate";
import { ST_Panose } from "./ST_Panose";
import { ST_BlipCompression_$type } from "./ST_BlipCompression";
import { ST_TextVertOverflowType_$type } from "./ST_TextVertOverflowType";
import { ST_TextHorzOverflowType_$type } from "./ST_TextHorzOverflowType";
import { ST_TextVerticalType_$type } from "./ST_TextVerticalType";
import { ST_TextWrappingType_$type } from "./ST_TextWrappingType";
import { ST_Coordinate32 } from "./ST_Coordinate32";
import { ST_TextAnchoringType_$type } from "./ST_TextAnchoringType";
import { ST_FontCollectionIndex_$type } from "./ST_FontCollectionIndex";
import { ST_LineWidth } from "./ST_LineWidth";
import { ST_LineCap_$type } from "./ST_LineCap";
import { ST_CompoundLine_$type } from "./ST_CompoundLine";
import { ST_PenAlignment_$type } from "./ST_PenAlignment";
import { ST_TextMargin } from "./ST_TextMargin";
import { ST_TextIndentLevelType } from "./ST_TextIndentLevelType";
import { ST_TextIndent } from "./ST_TextIndent";
import { ST_TextAlignType_$type } from "./ST_TextAlignType";
import { ST_TextFontAlignType_$type } from "./ST_TextFontAlignType";
import { ST_PresetColorVal_$type } from "./ST_PresetColorVal";
import { ST_ShapeType_$type } from "./ST_ShapeType";
import { ST_TextFontSize } from "./ST_TextFontSize";
import { ST_TextUnderlineType_$type } from "./ST_TextUnderlineType";
import { ST_TextStrikeType_$type } from "./ST_TextStrikeType";
import { ST_TextCapsType_$type } from "./ST_TextCapsType";
import { ST_TextPoint } from "./ST_TextPoint";
import { ST_SchemeColorVal_$type } from "./ST_SchemeColorVal";
import { ST_HexColorRGB } from "./ST_HexColorRGB";
import { ST_SystemColorVal_$type } from "./ST_SystemColorVal";
import { ST_BlackWhiteMode_$type } from "./ST_BlackWhiteMode";
import { ST_VectorBaseType_$type } from "./ST_VectorBaseType";
import { IVariantValueContainer_$type } from "./IVariantValueContainer";
import { OfficeDocumentDocPropsVTypes_VariantPlaceholder } from "./OfficeDocumentDocPropsVTypes_VariantPlaceholder";
import { CT_Vector } from "./CT_Vector";
import { ST_Ext_$type } from "./ST_Ext";
import { ST_TrueFalse } from "./ST_TrueFalse";
import { ST_FillType_$type } from "./ST_FillType";
import { ST_ImageAspect_$type } from "./ST_ImageAspect";
import { ST_ConnectType_$type } from "./ST_ConnectType";
import { ST_ShadowType_$type } from "./ST_ShadowType";
import { ST_HrAlign_$type } from "./ST_HrAlign";
import { ST_InsetMode_$type } from "./ST_InsetMode";
import { ST_ConnectorType_$type } from "./ST_ConnectorType";
import { ST_BWMode_$type } from "./ST_BWMode";
import { ST_TrueFalseBlank } from "./ST_TrueFalseBlank";
import { ST_StrokeLineStyle_$type } from "./ST_StrokeLineStyle";
import { ST_StrokeJoinStyle_$type } from "./ST_StrokeJoinStyle";
import { ST_StrokeEndCap_$type } from "./ST_StrokeEndCap";
import { ST_StrokeArrowType_$type } from "./ST_StrokeArrowType";
import { ST_StrokeArrowWidth_$type } from "./ST_StrokeArrowWidth";
import { ST_StrokeArrowLength_$type } from "./ST_StrokeArrowLength";
/**
 * @hidden
 */
export let AlternateContentChoice = /*@__PURE__*/ (() => {
    class AlternateContentChoice extends Base {
        constructor(a, ..._rest) {
            super();
            this.a = null;
            this.b = null;
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        let d = _rest[1];
                        let e = [[c], d];
                        {
                            let g = e[0];
                            let h = e[1];
                            this.a = h;
                            this.b = g;
                        }
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        let d = _rest[1];
                        this.a = d;
                        this.b = c;
                    }
                    break;
            }
        }
    }
    AlternateContentChoice.$t = /*@__PURE__*/ markType(AlternateContentChoice, 'AlternateContentChoice');
    return AlternateContentChoice;
})();
/**
 * @hidden
 */
export let AttributeValue = /*@__PURE__*/ (() => {
    class AttributeValue extends ValueType {
        constructor(a, ..._rest) {
            super();
            this.a = new QualifiedNameInfo();
            this.d = null;
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0: break;
                case 1:
                    {
                        let c = _rest[0];
                        let d = _rest[1];
                        let e = _rest[2];
                        let f = _rest[3];
                        this.a = new QualifiedNameInfo(1, c, d, e);
                        this.d = f;
                    }
                    break;
                case 2:
                    {
                        let c = _rest[0];
                        let d = _rest[1];
                        this.a = c;
                        this.d = d;
                    }
                    break;
            }
        }
        toString() {
            return this.a.toString() + "=\"" + this.d + "\"";
        }
        e(a, b, c, d) {
            this.a.i(a, b, c);
            this.d = d;
        }
        get b() {
            return this.a.c;
        }
        get c() {
            if (this.a.g == "http://www.w3.org/2000/xmlns/") {
                if (this.a.f == "xmlns" || this.a.h == "xmlns") {
                    return true;
                }
            }
            return false;
        }
    }
    AttributeValue.$t = /*@__PURE__*/ markStruct(AttributeValue, 'AttributeValue');
    return AttributeValue;
})();
/**
 * @hidden
 */
export let ElementLoadCallbacks = /*@__PURE__*/ (() => {
    class ElementLoadCallbacks extends ValueType {
        constructor(a, ..._rest) {
            super();
            this.b = null;
            this.a = null;
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0: break;
                case 1:
                    {
                        let c = _rest[0];
                        let d = _rest[1];
                        this.b = c;
                        this.a = d;
                    }
                    break;
            }
        }
        get c() {
            return this.b == null && this.a == null;
        }
    }
    ElementLoadCallbacks.$t = /*@__PURE__*/ markStruct(ElementLoadCallbacks, 'ElementLoadCallbacks');
    return ElementLoadCallbacks;
})();
/**
 * @hidden
 */
export let OfficeDocumentManager = /*@__PURE__*/ (() => {
    class OfficeDocumentManager extends Base {
        constructor(a, b, c, d) {
            super();
            this._c = null;
            this._ap = toNullable(ST_ConformanceClass_$type, null);
            this._ab = false;
            this._aj = null;
            this._al = null;
            this._ag = null;
            this._am = null;
            this._aq = null;
            this._ah = null;
            this._ai = null;
            this._y = null;
            this._a = null;
            this._ao = null;
            this._h = null;
            this._i = null;
            this._m = null;
            this._ax = null;
            this._av = null;
            this._aw = null;
            this._af = false;
            this._aj = new HashSet$1(String_$type, 0);
            this._al = new Stack$1(IPackagePart_$type);
            this._ag = new Dictionary$2(String_$type, Base.$, 0);
            this._am = new Stack$1(OfficeDocumentManager_PartRelationshipCounter.$);
            this._am.h(new OfficeDocumentManager_PartRelationshipCounter());
            this._aq = {};
            this._ah = new Dictionary$2(String_$type, PartManagerBase.$, 0);
            this._ai = new Dictionary$2(String_$type, PartManagerBase.$, 0);
            this._ap = d;
            this._ab = c;
            this._ao = b;
            if (a != null && this._ao != null) {
                this._a = new InvalidPackage();
                let e = WorkItemExtensions.f(IPackage_$type, a._open$i(this._ao, this._ab ? 3 : 2), (f) => {
                    this._a = WorkItemExtensions.m(IPackage_$type, f);
                    return null;
                });
                this._m = e;
            }
            else {
                this._m = WorkItem.g(Base.$, null);
            }
        }
        dispose() {
            this.disposeCore(true);
        }
        _a0(a, b) {
            return this._a1(a, b.o(this._z));
        }
        _a1(a, b) {
            return this._a2(a, b, 0);
        }
        _az(a, b) {
            return this._a2(a, b, 1);
        }
        _ay(a, b) {
            let c;
            if (((() => { let d = UriUtilities.a(a, c); c = d.p1; return d.ret; })())) {
                return this._az(c, b);
            }
            return this._a2(null, b, 1, a);
        }
        _j(a, b = null, c = null) {
            let d = a.n(this._v);
            if (a.g) {
                d = this._a6(d, a.h == false);
            }
            return this._k(a, d, b, c);
        }
        _k(a, b, c = null, d = null) {
            let e = UriUtilities.b(b);
            let f;
            if (d != null && this._ae(d)) {
                f = d;
                this._be(e, a.o(this._z), 0, f, null);
            }
            else {
                f = this._a2(e, a.o(this._z), 0);
            }
            let g = this._c;
            return WorkItemExtensions.g(Tuple$2.$.specialize(Uri.$, String_$type), Async.h(() => {
                if (g != null) {
                    this._al.h(g);
                }
                let h = this._a.createPart(e, a.m);
                this._c = h;
                this._am.h(new OfficeDocumentManager_PartRelationshipCounter());
                return WorkItemExtensions.a(Async.o(Stream.$, h.getStream(2, 2), (i) => {
                    let j = a.e(this, i);
                    return j.b(c);
                }), () => {
                    this._am.e();
                    this._ag.addItem(b, c);
                });
            }, () => {
                if (g != null) {
                    this._al.e();
                }
                this._c = g;
            }), () => Tuple.a(Uri.$, String_$type, e, f));
        }
        _l(a, b, c = null, d = null) {
            if (b == null) {
                return null;
            }
            let e = this._w(a);
            if (e == null) {
                return null;
            }
            return this._k(e, b, c, d);
        }
        _a5() {
            if (this._ao == null) {
                return null;
            }
            return DocCoreUtils.z(this._ao);
        }
        _u(a) {
            return (this._aq[a] || null);
        }
        _e(a) {
            return this._b.getPart(a);
        }
        _ar(a) {
            return this._at(a.uri.toString());
        }
        _as(a) {
            let b = PackageUtilities.ak(a).originalString;
            return this._at(b);
        }
        _bd(a) {
            for (let b of fromEnum(this._ag)) {
                if (Base.equalsStatic(b.value, a)) {
                    return UriUtilities.b(b.key);
                }
            }
            return null;
        }
        _au(a) {
            let b = this._g(a);
            if (b == null) {
                return null;
            }
            if (b.targetMode == 1) {
                if (typeCast(IInvalidPackageRelationshipTarget_$type, b) !== null) {
                    return b.targetString;
                }
                return b.targetUri;
            }
            return this._as(b);
        }
        _bc($tData, a) {
            let b = a.o(this._z);
            for (let c of fromEnum(this._ak())) {
                if (c.relationshipType == b) {
                    let d = this._au(c.id);
                    if (d != null) {
                        return Tuple.a(String_$type, $tData, c.id, typeCastObjTo$t($tData, d));
                    }
                    break;
                }
            }
            return null;
        }
        _g(a) {
            return this._c != null ? this._c.getRelationship(a) : this._a.getRelationship(a);
        }
        _f(a) {
            for (let b of fromEnum(this._ak())) {
                if (this._as(b) == a) {
                    return b;
                }
            }
            return null;
        }
        _a7(a, b) {
            let c = a;
            let d = c == 0 ? 1 : 0;
            for (let e of fromEnum(this._ai)) {
                let f = e.value.o(d);
                let g = e.value.o(c);
                if (f == b || b == g) {
                    return g;
                }
            }
            return null;
        }
        _bh() {
            this._bk(XmlNamespace.ao);
            this._bk(VmlNamespace.ao);
            this._bk(CoreProperties.ao);
            this._bk(DcDcmiType.ao);
            this._bk(DcElements.ao);
            this._bk(DcTerms.ao);
            this._bk(Drawing2010Main.ao);
            this._bk(Drawing2010Slicer.ao);
            this._bk(DrawingMLChart.ao);
            this._bk(DrawingMLChart2014.ao);
            this._bk(DrawingMLChartEx2015_9_8.ao);
            this._bk(DrawingMLChartEx2015_10_21.ao);
            this._bk(DrawingMLChartEx2016_5_10.ao);
            this._bk(DrawingMLMain.ao);
            this._bk(EmptyNamespace.ao);
            this._bk(MarkupCompatibility2006.ao);
            this._bk(OfficeDocumentDocPropsVTypes.ao);
            this._bk(OfficeDocumentExtendedProperties.ao);
            this._bk(OfficeDocumentRelationships.ao);
            this._bk(OfficeNamespace.ao);
            this._bk(XmlSchemaInstance.ao);
            this._bk(IGOfficeExtensions.ao);
            let a = this._t;
            if (a != null) {
                this._bk(a);
            }
            if (nullableEquals(this._ap, null)) {
                this._ap = toNullable(ST_ConformanceClass_$type, this._aa());
            }
        }
        _ad(a) {
            return (this._aq[a] != null);
        }
        _n() {
            return WorkItemExtensions.c(this._m, () => {
                this._bh();
                return this._o();
            });
        }
        _bj() {
        }
        _bb(a) {
            if (a == null || a.length == 0) {
                if (this._aw != null) {
                    return this._aw;
                }
            }
            else if (Base.equalsStatic(a, this._ax)) {
                return this._av;
            }
            else {
                this._ax = a;
            }
            let b = this._u(a);
            if (b != null) {
                a = b.s(1);
            }
            if (a == null || a.length == 0) {
                this._aw = a;
            }
            else {
                this._av = a;
            }
            return a;
        }
        _r() {
            this._bh();
            return WorkItemExtensions.c(WorkItemExtensions.c(WorkItemExtensions.c(this._m, () => this._s()), () => Async.g(this._h != null, () => this._j(Office2007ExtensibilityPartManager.a5))), () => Async.g(this._i != null, () => this._j(Office2010ExtensibilityPartManager.a5)));
        }
        _bn(a) {
            this._ap = toNullable(ST_ConformanceClass_$type, a);
        }
        disposeCore(a) {
            if (this._a != null) {
                this._a.dispose();
                this._a = null;
            }
        }
        _o() {
            return WorkItemExtensions.f(Boolean_$type, this._q(null, null, this._a.getRelationships(), false), (a) => {
                let b = WorkItemExtensions.m(Boolean_$type, a);
                return Async.g((this._y != null && this._af == false), () => {
                    let c = this._a6(this._y.n(this._v), void 0, true);
                    let d = null;
                    return Async.g((this._aj.contains(c) == false && ((() => { let e = Uri.tryCreate(c, 2, d); d = e.p2; return e.ret; })()) && this._a.partExists(d)), () => this._p(this._a.getPart(d)));
                });
            });
        }
        _bi(a) {
            this._bj();
        }
        _bk(a) {
            this._aq[a.s(1)] = a;
            this._aq[a.s(0)] = a;
        }
        _bl(a, b = true) {
            if (b) {
                this._ah.item(a.m, a);
            }
            this._ai.item(a.o(this._z), a);
            if (a.m == "image/jpeg") {
                this._ah.item("image/jpg", a);
            }
            let c = typeCast(ThemePartManager.$, a);
            if (c != null) {
                this._y = c;
            }
        }
        _a2(a, b, c, d = null) {
            let e;
            let f = this._am.d();
            e = OfficeDocumentManager._a3(f.b);
            this._be(a, b, c, e, d);
            return e;
        }
        _be(a, b, c, d, e) {
            this._am.d().c();
            let f;
            if (c == 0) {
                if (this._c == null) {
                    let g = new Uri(1, "/".toString(), 0);
                    f = PackageUtilities.ai(g, a);
                }
                else {
                    f = PackageUtilities.ai(this._c.uri, a);
                }
            }
            else {
                if (a == null && e != null) {
                    let h = typeCast(IPackagePartEx_$type, this._c);
                    if (h != null) {
                        h.createExternalRelationship(e, b, d);
                        return;
                    }
                }
                f = a;
            }
            if (this._c == null) {
                this._a.createRelationship(f, c, b, d);
            }
            else {
                this._c.createRelationship(f, c, b, d);
            }
        }
        static _a3(a) {
            return "rId" + (a + 1).toString();
        }
        _ak() {
            if (this._c != null) {
                return this._c.getRelationships();
            }
            return this._a.getRelationships();
        }
        _a4() {
            switch (this._z) {
                case 0: return OfficeDocumentManager._a9;
                case 1: return OfficeDocumentManager._a8;
                default: return OfficeDocumentManager._a9;
            }
        }
        _a6(a, b = false, c = false) {
            let d = new HashSet$1(String_$type, 2, StringUtilities.f);
            if (c == false && b) {
                for (let e of fromEnum(this._a.getParts())) {
                    let f = e.uri.toString();
                    let g = IOPath.getExtension(f);
                    let h = f.substr(0, f.length - g.length);
                    d.add_1(h);
                }
            }
            let i = IOPath.getExtension(a);
            let j = a.substr(0, a.length - i.length);
            let k = 1;
            while (true) {
                if (b) {
                    let l = j + k;
                    if (c || d.contains(l) == false) {
                        l += i;
                        return l;
                    }
                }
                else {
                    let m = j + k + i;
                    if (c || this._a.partExists(UriUtilities.b(m)) == false) {
                        return m;
                    }
                }
                k++;
            }
        }
        _at(a) {
            let b;
            let c = this._ag.tryGetValue(a, b);
            b = c.p1;
            return b;
        }
        _w(a) {
            let b;
            let c = this._ah.tryGetValue(a, b);
            b = c.p1;
            return b;
        }
        _x(a) {
            let b;
            if (((() => { let c = this._ai.tryGetValue(a, b); b = c.p1; return c.ret; })()) == false) {
                let c = "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet";
                let d = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet";
                let e = "http://purl.oclc.org/ooxml/officeDocument/relationships/drawing";
                let f = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing";
                switch (a) {
                    case c:
                        let g = this._ai.tryGetValue(d, b);
                        b = g.p1;
                        break;
                    case e:
                        let h = this._ai.tryGetValue(f, b);
                        b = h.p1;
                        break;
                }
            }
            return b;
        }
        _ae(a) {
            for (let b of fromEnum(this._ak())) {
                if (b.id == a) {
                    return false;
                }
            }
            return true;
        }
        _p(a, b = null) {
            if (b == null) {
                b = this._w(a.contentType);
            }
            let c = a.getRelationships();
            let d = a.uri.toString();
            if (this._aj.add_1(d) == false) {
                return null;
            }
            let e = null;
            let f = null;
            return WorkItemExtensions.f(Boolean_$type, this._q(a, b, c, false), (g) => {
                let h = WorkItemExtensions.m(Boolean_$type, g);
                return WorkItemExtensions.a(WorkItemExtensions.c(Async.g((b != null), () => {
                    let i = this._c;
                    return Async.h(() => {
                        this._c = a;
                        return Async.o(Stream.$, a.getStream(3, 1), (j) => {
                            f = b.e(this, j);
                            return WorkItemExtensions.e(Base.$, f.a(), (k) => e = WorkItemExtensions.m(Base.$, k));
                        });
                    }, () => this._c = i);
                }, () => {
                    this._bi(a);
                    return null;
                }), () => {
                    if (e != null) {
                        this._ag.item(d, e);
                    }
                    return Async.g(h, () => this._q(a, b, c, true));
                }), () => {
                    if (f != null) {
                        f.q();
                    }
                });
            });
        }
        _q(a, b, c, d) {
            let e = false;
            return WorkItemExtensions.g(Boolean_$type, Async.h(() => {
                if (a != null) {
                    this._al.h(a);
                }
                let f = this._bm(b, c);
                c = f.p1;
                return Async.d(IPackageRelationship_$type, c, (g) => {
                    if (g.relationshipType == this._a4()) {
                        return null;
                    }
                    switch (g.targetMode) {
                        case 0:
                            {
                                if (b != null) {
                                    let h = this._x(g.relationshipType);
                                    let i = h != null && b.i(h);
                                    if (d != i) {
                                        e = true;
                                        return null;
                                    }
                                }
                                if (g.targetUri != null && g.targetUri.originalString == "NULL") {
                                    return null;
                                }
                                let j = PackageUtilities.ak(g);
                                let k = this._a.getPart(j);
                                let l = null;
                                if (b != null) {
                                    l = b.f(k, g);
                                }
                                if (l == null && k != null && k.contentType == "application/xml") {
                                    let m = this._x(g.relationshipType);
                                    if (m != null && m.m != k.contentType) {
                                        k = new OverrideContentTypePart(k, m.m);
                                    }
                                    l = m;
                                }
                                return this._p(k, l);
                            }
                        case 1: break;
                        default: break;
                    }
                    return null;
                });
            }, () => {
                if (a != null) {
                    this._al.e();
                }
            }), () => e);
        }
        _bm(a, b) {
            if (a == null) {
                return {
                    p1: b
                };
            }
            let c = a.j();
            if (c == null) {
                return {
                    p1: b
                };
            }
            let d = new Dictionary$2(String_$type, Number_$type, 0);
            for (let e of fromEnum(c)) {
                d.addItem(e.key.o(this._z), e.value);
            }
            let f = new List$1(IPackageRelationship_$type, 1, b);
            f.aa((g, h) => {
                let i;
                let j = ((() => { let k = d.tryGetValue(g.relationshipType, i); i = k.p1; return k.ret; })());
                let k;
                let l = ((() => { let m = d.tryGetValue(h.relationshipType, k); k = m.p1; return m.ret; })());
                if (j == false && l == false) {
                    return 0;
                }
                else if (j && l == false) {
                    return -1;
                }
                else if (j == false && l) {
                    return 1;
                }
                return Base.compareSimple(i, k);
            });
            b = f;
            return {
                p1: b
            };
        }
        get _d() {
            return this._c;
        }
        get _z() {
            return this._ap.getValueOrDefault1(0);
        }
        get _ac() {
            return this._ab;
        }
        get _an() {
            return this._al;
        }
        get _b() {
            return this._a;
        }
    }
    OfficeDocumentManager.$t = /*@__PURE__*/ markType(OfficeDocumentManager, 'OfficeDocumentManager', Base.$, [IDisposable_$type]);
    OfficeDocumentManager._a9 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink";
    OfficeDocumentManager._a8 = "http://purl.oclc.org/ooxml/officeDocument/relationships/hyperlink";
    return OfficeDocumentManager;
})();
/**
 * @hidden
 */
export let QualifiedNameInfo = /*@__PURE__*/ (() => {
    class QualifiedNameInfo extends ValueType {
        constructor(a, ..._rest) {
            super();
            this.h = null;
            this.g = null;
            this.f = null;
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0: break;
                case 1:
                    {
                        let c = _rest[0];
                        let d = _rest[1];
                        let e = _rest[2];
                        if (c == stringEmpty()) {
                            c = null;
                        }
                        this.h = c;
                        this.g = d;
                        this.f = e;
                    }
                    break;
            }
        }
        toString() {
            if (this.h != null) {
                return this.h + ":" + this.f;
            }
            return this.f;
        }
        static d(a, b) {
            if (stringIsNullOrEmpty(a)) {
                return b;
            }
            let c;
            if (a.charAt(a.length - 1) != "/") {
                a += "/";
            }
            c = a + b;
            return c;
        }
        e(a) {
            if (this.g == null) {
                return this.f;
            }
            if (a == null) {
                return QualifiedNameInfo.d(this.g, this.f);
            }
            return QualifiedNameInfo.d(a._bb(this.g), this.f);
        }
        i(a, b, c) {
            if (a == stringEmpty()) {
                a = null;
            }
            this.h = a;
            this.g = b;
            this.f = c;
        }
        b(a) {
            if (this.g == null) {
                return this;
            }
            if (a == null) {
                return this;
            }
            return new QualifiedNameInfo(1, this.h, a._bb(this.g), this.f);
        }
        get c() {
            return this.f == null;
        }
    }
    QualifiedNameInfo.$t = /*@__PURE__*/ markStruct(QualifiedNameInfo, 'QualifiedNameInfo');
    QualifiedNameInfo.a = /*@__PURE__*/ new QualifiedNameInfo(0);
    return QualifiedNameInfo;
})();
/**
 * @hidden
 */
export let UnknownElementCache = /*@__PURE__*/ (() => {
    class UnknownElementCache extends Base {
        constructor(a, b) {
            super();
            this.h = null;
            this.i = null;
            this.a = new QualifiedNameInfo();
            this.m = null;
            this.o = null;
            this.a = a;
            this.o = b;
        }
        l(a, b) {
            for (let c of fromEnum(this.j)) {
                if (c.a.e(b) == a) {
                    return toNullable(AttributeValue.$, c);
                }
            }
            return toNullable(AttributeValue.$, null);
        }
        c(a, b) {
            return Enumerable.ag(UnknownElementCache.$, this.k, (c) => c.b.e(b) == a);
        }
        f(a, b) {
            return Enumerable.u(UnknownElementCache.$, this.k, (c) => c.b.e(b) == a);
        }
        *_g(a, b) {
            for (let c of fromEnum(this.k)) {
                if (c.b.e(b) == a) {
                    yield c;
                }
                for (let d of fromEnum(c.g(a, b))) {
                    yield d;
                }
            }
        }
        g(a, b) {
            return toEnum(() => this._g(a, b));
        }
        get j() {
            if (this.h == null) {
                this.h = new List$1(AttributeValue.$, 0);
            }
            return this.h;
        }
        get d() {
            return this.h != null && this.h.count != 0;
        }
        get k() {
            if (this.i == null) {
                this.i = new List$1(UnknownElementCache.$, 0);
            }
            return this.i;
        }
        get e() {
            return this.i != null && this.i.count != 0;
        }
        get b() {
            return this.a;
        }
        get n() {
            return this.m;
        }
        set n(a) {
            this.m = a;
        }
        get p() {
            return this.o;
        }
        set p(a) {
            this.o = a;
        }
    }
    UnknownElementCache.$t = /*@__PURE__*/ markType(UnknownElementCache, 'UnknownElementCache');
    return UnknownElementCache;
})();
/**
 * @hidden
 */
export let UnknownStructure = /*@__PURE__*/ (() => {
    class UnknownStructure extends Base {
        constructor(a) {
            super();
            this.a = null;
            this.a = a;
        }
        get b() {
            return this.a;
        }
    }
    UnknownStructure.$t = /*@__PURE__*/ markType(UnknownStructure, 'UnknownStructure');
    return UnknownStructure;
})();
/**
 * @hidden
 */
export let XmlReadManager = /*@__PURE__*/ (() => {
    class XmlReadManager extends Base {
        constructor(a, b) {
            super();
            this.u = null;
            this.ab = 0;
            this.k = new QualifiedNameInfo();
            this.ad = null;
            this.v = null;
            this.z = 0;
            this.m = null;
            this.b = null;
            this.i = null;
            this.j = null;
            this.ao = null;
            this.aa = 0;
            this.w = new Stack$1(XmlReadManager_LoadChildContext.$);
            this.x = new Stack$1(XmlReadManager_LoadFastContext.$);
            this.a = ([]);
            this.y = 0;
            this.v = new Stack$1(XmlReadManager_AlternateContentChoiceContext.$);
            this.u = new List$1(AttributeValue.$, 0);
            this.z = -1;
            this.b = new Array(16);
            this.i = a.d;
            this.j = a;
            this.ao = b;
        }
        q(a) {
            for (let b = 0; b <= this.z; b++) {
                if (this.b[b].a(a)) {
                    return true;
                }
            }
            return false;
        }
        r(a) {
            if (this.w.f > 0) {
                let b = this.w.d();
                if (a == b.b.e(this.i)) {
                    return true;
                }
            }
            return false;
        }
        d() {
            this.aa = 0;
            return this.f(this.w.f);
        }
        f(a, b = 0, c = 0, d = false, e = false) {
            let f = new XmlReadManager_LoadChildContext();
            if (d) {
                f = this.w.e();
            }
            else {
                f = new XmlReadManager_LoadChildContext();
                f.h = b;
                f.c = c;
            }
            let g = null;
            while (true) {
                if (e == true) {
                    e = false;
                }
                else {
                    if (this.ao.a7 == 15) {
                        if (this.w.f == a) {
                            break;
                        }
                        f = this.w.e();
                        e = true;
                        continue;
                    }
                    f.b = this.l();
                    if (f.b.c) {
                        if (this.w.f == a) {
                            break;
                        }
                        f = this.w.e();
                        e = true;
                        continue;
                    }
                    this.al();
                    f.f = true;
                    f.g = true;
                    f.e = false;
                    g = f.b.e(this.i);
                    let h = null;
                    switch (g) {
                        case MarkupCompatibility2006.aq: return WorkItemExtensions.c(this.c(f.b, f.h), () => {
                            if (f.g && this.ao.t() == false) {
                                if (this.w.f == a) {
                                    return null;
                                }
                                f = this.w.e();
                                e = true;
                            }
                            else {
                                if (f.f) {
                                    f.h++;
                                }
                                this.ak();
                            }
                            this.w.h(f);
                            return WorkItem.d(() => this.f(a, f.h, f.c, true, e), 2);
                        });
                        case MarkupCompatibility2006.ar:
                            h = this.g(f.b, f.h, f.c);
                            break;
                        case MarkupCompatibility2006.as:
                            h = this.h(f.b, f.h, f.c);
                            break;
                        default:
                            f.e = true;
                            break;
                    }
                    if (h != null) {
                        return WorkItemExtensions.f(Boolean_$type, h, (i) => {
                            if (WorkItemExtensions.m(Boolean_$type, i) == false) {
                                f.f = false;
                                f.g = false;
                            }
                            else {
                                f.c = 2;
                            }
                            if (f.g && this.ao.t() == false) {
                                if (this.w.f == a) {
                                    return null;
                                }
                                f = this.w.e();
                                e = true;
                            }
                            else {
                                if (f.f) {
                                    f.h++;
                                }
                                this.ak();
                            }
                            this.w.h(f);
                            return WorkItem.d(() => this.f(a, f.h, f.c, true, e), 2);
                        });
                    }
                    if (f.e) {
                        let i = false;
                        f.a = this.j.x(g);
                        if (f.a.c) {
                            if (this.t(f.b, f.h)) {
                                f.g = false;
                                i = true;
                            }
                        }
                        if (!i) {
                            let j = this.ao.i;
                            this.am(f.b, false);
                            f.d = j;
                            if (f.a.b != null) {
                                this.k = f.b;
                                this.ab = f.h;
                                f.a.b(this.j);
                            }
                            if (f.d == false) {
                                if (this.j.ai(f.b.e(this.i))) {
                                    if (this.b[this.z].b) {
                                        return WorkItemExtensions.c(WorkItemExtensions.a(this.e(this.x.f), () => {
                                        }), () => {
                                            this.w.h(f);
                                            return WorkItem.d(() => this.f(a, f.h, f.c, true, true), 2);
                                        });
                                    }
                                    else {
                                        this.w.h(f);
                                        f = new XmlReadManager_LoadChildContext();
                                        f.h = 0;
                                        f.c = 0;
                                        continue;
                                    }
                                }
                                else {
                                    while (this.ao.a7 != 15) {
                                        this.ao.a2();
                                    }
                                }
                            }
                        }
                    }
                }
                if (f.e) {
                    if (f.a.a != null) {
                        this.k = f.b;
                        this.ab = f.h;
                        f.a.a(this.j);
                    }
                }
                if (f.g && this.ao.t() == false) {
                    if (this.w.f == a) {
                        break;
                    }
                    f = this.w.e();
                    e = true;
                    continue;
                }
                if (f.f) {
                    f.h++;
                }
                this.ak();
                this.aa++;
                if (1000 < this.aa) {
                    this.aa = 0;
                    this.w.h(f);
                    return WorkItem.d(() => this.f(a, f.h, f.c, true, e), 2);
                }
            }
            return null;
        }
        e(a, b = false, c = false) {
            let d = b ? this.x.e() : new XmlReadManager_LoadFastContext();
            let e = null;
            while (true) {
                if (c == false) {
                    if (this.ao.a7 == 15) {
                        if (this.x.f == a) {
                            break;
                        }
                        d = this.x.e();
                        c = true;
                        continue;
                    }
                    d.b = this.l();
                    if (d.b.c) {
                        if (this.x.f == a) {
                            break;
                        }
                        d = this.x.e();
                        c = true;
                        continue;
                    }
                    this.al();
                    e = d.b.e(this.i);
                }
                if (c == false && e == MarkupCompatibility2006.aq) {
                    return WorkItemExtensions.c(this.c(d.b, 0), () => {
                        if (this.ao.t() == false) {
                            if (this.x.f == a) {
                                return null;
                            }
                            d = this.x.e();
                            c = true;
                        }
                        else {
                            d.c++;
                            this.ak();
                        }
                        this.x.h(d);
                        return WorkItem.d(() => this.e(a, true, c), 2);
                    });
                }
                else {
                    if (c) {
                        c = false;
                    }
                    else {
                        d.a = this.j.x(e);
                        let f = this.ao.i;
                        this.am(d.b, false);
                        if (d.a.b != null) {
                            this.k = d.b;
                            this.ab = d.c;
                            d.a.b(this.j);
                        }
                        if (f == false) {
                            this.x.h(d);
                            d = new XmlReadManager_LoadFastContext();
                            continue;
                        }
                    }
                    if (d.a.a != null) {
                        this.k = d.b;
                        this.ab = d.c;
                        d.a.a(this.j);
                    }
                }
                if (this.ao.t() == false) {
                    if (this.x.f == a) {
                        break;
                    }
                    d = this.x.e();
                    c = true;
                    continue;
                }
                d.c++;
                this.ak();
                if (1000 < ++this.aa) {
                    this.aa = 0;
                    this.x.h(d);
                    return WorkItem.d(() => this.e(a, true, c), 2);
                }
            }
            return null;
        }
        ae(a) {
            return this.ao.ah(a);
        }
        aj() {
            if (this.v.f == 0) {
                return;
            }
            this.v.d().a = true;
        }
        an() {
            this.b[this.z].b = true;
        }
        ah(a, ...b) {
            for (let c = 0; c < b.length; c++) {
                let d = this.ae(b[c]);
                if (d != null) {
                    a.add_1(d);
                }
            }
        }
        c(a, b) {
            let c = this.ao.i;
            this.am(a, false);
            this.k = a;
            this.ab = b;
            if (c == false) {
                return this.f(this.w.f, b, 1);
            }
            return null;
        }
        o(a, b) {
            b = this.ao.i;
            this.am(a, true, true);
            let c = new UnknownElementCache(a, this.ad);
            if (this.u.count != 0) {
                c.j.o(this.u);
            }
            return {
                ret: c,
                p1: b
            };
        }
        p(a, b) {
            this.al();
            let c;
            let d = ((() => { let e = this.o(a, c); c = e.p1; return e.ret; })());
            let e = this.j.w(a);
            if (e.b != null) {
                this.k = a;
                this.ab = b;
                this.m = d;
                e.b(this.j);
                this.m = null;
            }
            if (c == false) {
                if (this.j.ai(a.e(this.i))) {
                    this.ai(d);
                }
                else {
                    while (this.ao.a7 != 15) {
                        this.ao.a2();
                    }
                }
            }
            if (e.a != null) {
                this.k = a;
                this.ab = b;
                this.m = d;
                e.a(this.j);
                this.m = null;
            }
            this.j.av(d);
            this.ak();
            return d;
        }
        ai(a) {
            let b = 0;
            while (this.ao.a7 != 15) {
                let c = this.l();
                if (c.c) {
                    break;
                }
                a.k.add(this.p(c, b));
                if (this.ao.t() == false) {
                    break;
                }
                b++;
            }
        }
        t(a, b) {
            let c = a.e(this.i);
            let d = this.j.z(c);
            let t1 = d;
            L0: while (true) {
                switch (t1) {
                    case 0:
                        this.ao.a2();
                        return true;
                    case 1:
                        {
                            let e = this.ao.ap();
                            this.j.ax(c, e);
                            return true;
                        }
                    case 2:
                        {
                            let f = this.p(a, b);
                            let g = new UnknownStructure(f);
                            this.j.aw(g);
                            this.ao.t();
                            return true;
                        }
                    case 3: return false;
                    default:
                        t1 = 0;
                        continue L0;
                }
                break;
            }
        }
        l() {
            switch (this.ao.a7) {
                case 1: return new QualifiedNameInfo(1, this.ao.ak, this.ao.aj, this.ao.ag);
                case 2: break;
                case 15:
                case 14:
                case 3:
                case 0: break;
                case 17:
                case 13:
                case 8:
                    {
                        do {
                            this.ao.t();
                        } while (this.ao.a7 == 13 || this.ao.a7 == 17 || this.ao.a7 == 8);
                        return this.l();
                    }
                default: break;
            }
            return QualifiedNameInfo.a;
        }
        ak() {
            this.j.s.j(this.b[this.z].e, this.b[this.z].f);
            this.b[this.z] = (null);
            this.z--;
        }
        al() {
            this.z++;
            while (this.b.length <= this.z) {
                let a = new Array(this.b.length * 2);
                arrayCopy2(this.b, a, this.b.length);
                this.b = a;
            }
            this.b[this.z] = new XmlReadManager_ElementContext(1, this);
        }
        am(a, b, c = false) {
            this.y = 0;
            this.u.clear();
            this.ad = null;
            let d = this.ao.i;
            if (this.ao.r()) {
                do {
                    let e = this.ao.aj;
                    if (b == false && e == "http://www.w3.org/2000/xmlns/") {
                        if (this.ao.ag == "xmlns" || this.ao.ak == "xmlns") {
                            continue;
                        }
                    }
                    let f = new AttributeValue();
                    if (c) {
                        f = new AttributeValue(1, this.ao.ak, e, this.ao.ag, this.ao.ar);
                    }
                    else if (this.y < this.a.length) {
                        f = (this.a[this.y++]);
                        f.e(this.ao.ak, e, this.ao.ag, this.ao.ar);
                    }
                    else {
                        f = new AttributeValue(1, this.ao.ak, e, this.ao.ag, this.ao.ar);
                        this.a.push(f);
                        this.y++;
                    }
                    if (f.a.f == "Ignorable" && f.a.e(this.i) == MarkupCompatibility2006.at) {
                        this.ah(this.b[this.z].d, ...stringSplit(f.d, [' '], 1));
                        continue;
                    }
                    this.u.add(f);
                } while (this.ao.s());
                this.ao.q();
            }
            if (d == false && this.ao.t()) {
                if (this.ao.a7 == 13 && a.f == "t" && a.e(this.i) == DrawingMLMain.jb) {
                    this.ad = this.ao.ar;
                }
                else {
                    while (this.ao.a7 == 13) {
                        this.ao.t();
                    }
                    if (this.ao.a7 == 14 || this.ao.a7 == 3) {
                        this.ad = this.ao.ar;
                        this.ao.t();
                    }
                }
            }
        }
        ag(a) {
            let b = a.indexOf(':');
            if (b < 0) {
                return a;
            }
            let c = a.substr(0, b);
            let d = a.substr(b + 1);
            let e = this.ae(c);
            let f = new QualifiedNameInfo(1, c, e, d);
            return f.e(this.i);
        }
        g(a, b, c) {
            if (c != 1) {
                this.ao.a2();
                return WorkItem.g(Boolean_$type, false);
            }
            let d = this.ao.i;
            this.am(a, false);
            this.k = a;
            this.ab = b;
            let e;
            let f = MarkupCompatibility2006.ax(this.j, e);
            e = f.p1;
            if (this.j.ah(e) == false) {
                while (this.ao.a7 == 1) {
                    this.ao.a2();
                    if (this.ao.a7 == 13) {
                        this.ao.a2();
                    }
                }
                if (this.ao.t() == false) {
                }
                return WorkItem.g(Boolean_$type, false);
            }
            let g = true;
            return WorkItemExtensions.g(Boolean_$type, Async.g(d == false, () => {
                this.v.h(new XmlReadManager_AlternateContentChoiceContext());
                let h = this.f(this.w.f);
                let i = this.v.e();
                if (i.a) {
                    if (this.ao.t() == false) {
                    }
                    g = false;
                }
                return h;
            }), () => g);
        }
        h(a, b, c) {
            if (c != 1) {
                this.ao.a2();
                return WorkItem.g(Boolean_$type, false);
            }
            let d = this.ao.i;
            this.am(a, false);
            this.k = a;
            this.ab = b;
            return WorkItemExtensions.g(Boolean_$type, Async.g(d == false, () => this.f(this.w.f)), () => true);
        }
        get n() {
            return this.m;
        }
        get s() {
            return this.v.f != 0;
        }
        get af() {
            return this.ao.aj;
        }
    }
    XmlReadManager.$t = /*@__PURE__*/ markType(XmlReadManager, 'XmlReadManager');
    return XmlReadManager;
})();
/**
 * @hidden
 */
export let XmlReadManager_ElementContext = /*@__PURE__*/ (() => {
    class XmlReadManager_ElementContext extends ValueType {
        constructor(a, ..._rest) {
            super();
            this.e = 0;
            this.f = null;
            this.c = null;
            this.b = false;
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0: break;
                case 1:
                    {
                        let c = _rest[0];
                        this.e = c.j.s.e;
                        this.f = c.j.s.f;
                        this.b = false;
                        this.c = null;
                    }
                    break;
            }
        }
        a(a) {
            return this.c != null && this.c.contains(a);
        }
        get d() {
            if (this.c == null) {
                this.c = new HashSet$1(String_$type, 0);
            }
            return this.c;
        }
    }
    XmlReadManager_ElementContext.$t = /*@__PURE__*/ markStruct(XmlReadManager_ElementContext, 'XmlReadManager_ElementContext');
    return XmlReadManager_ElementContext;
})();
/**
 * @hidden
 */
export let XmlReadManager_LoadChildContext = /*@__PURE__*/ (() => {
    class XmlReadManager_LoadChildContext extends ValueType {
        constructor() {
            super();
            this.h = 0;
            this.c = 0;
            this.b = new QualifiedNameInfo();
            this.a = new ElementLoadCallbacks();
            this.g = false;
            this.f = false;
            this.e = false;
            this.d = false;
        }
    }
    XmlReadManager_LoadChildContext.$t = /*@__PURE__*/ markStruct(XmlReadManager_LoadChildContext, 'XmlReadManager_LoadChildContext');
    return XmlReadManager_LoadChildContext;
})();
/**
 * @hidden
 */
export let XmlReadManager_LoadFastContext = /*@__PURE__*/ (() => {
    class XmlReadManager_LoadFastContext extends ValueType {
        constructor() {
            super();
            this.c = 0;
            this.b = new QualifiedNameInfo();
            this.a = new ElementLoadCallbacks();
        }
    }
    XmlReadManager_LoadFastContext.$t = /*@__PURE__*/ markStruct(XmlReadManager_LoadFastContext, 'XmlReadManager_LoadFastContext');
    return XmlReadManager_LoadFastContext;
})();
/**
 * @hidden
 */
export let XmlWriteManager = /*@__PURE__*/ (() => {
    class XmlWriteManager extends Base {
        constructor(a, b) {
            super();
            this.a = null;
            this.c = null;
            this.b = null;
            this.w = null;
            this.c = new List$1(String_$type, 0);
            this.a = a.d;
            this.b = a;
            this.w = b;
        }
        d(a) {
            return this.w.a(a.s(this.a._z));
        }
        e(a, b, c, d) {
            let e = a.lastIndexOf("/");
            if (e < 0) {
                c = a;
                d = "";
                b = stringEmpty();
                return {
                    p1: b,
                    p2: c,
                    p3: d
                };
            }
            c = a.substr(e + 1);
            d = a.substr(0, e);
            if (this.a._z != 1) {
                let f = this.a._u(d);
                if (f != null) {
                    d = f.s(this.a._z);
                }
            }
            b = this.w.a(d);
            if (stringIsNullOrEmpty(b)) {
                let g = d + "/";
                b = this.w.a(g);
                if (stringIsNullOrEmpty(b) == false) {
                    d = g;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d
            };
        }
        f() {
            if (this.c.count == 0) {
                return;
            }
            this.l(MarkupCompatibility2006.ao);
            this.h(MarkupCompatibility2006.at, stringJoin1(String_$type, " ", this.c));
            this.c.clear();
        }
        g(a, b = null, c = true) {
            if (a != null) {
                let d = new HashSet$1(XmlNamespaceDefinitionBase.$, 0);
                for (let e of fromEnum(a)) {
                    for (let f of fromEnum(Enumerable.u(XmlNamespaceDefinitionBase.$, e.b, (g) => this.d(g) == null))) {
                        d.add_1(f);
                    }
                }
                MarkupCompatibility2006.az(this.b);
                for (let g of fromEnum(d)) {
                    this.l(g);
                }
                for (let h of fromEnum(a)) {
                    MarkupCompatibility2006.a0(this.b, h.b);
                    h.a();
                    this.k();
                }
            }
            if (b != null) {
                MarkupCompatibility2006.a2(this.b);
                b();
                this.k();
            }
            if (c) {
                this.k();
            }
        }
        h(a, b) {
            if (b == null) {
                return;
            }
            let c;
            let d;
            let e;
            let f = this.e(a, c, d, e);
            c = f.p1;
            d = f.p2;
            e = f.p3;
            this.i(c, d, e, b);
        }
        i(a, b, c, d) {
            this.w.j(a, b, c, d);
        }
        j(a, b) {
            this.w.h(a, b);
        }
        k() {
            this.f();
            this.w.v();
        }
        o(a) {
            this.p(a, null);
        }
        p(a, b) {
            let c;
            let d;
            let e;
            let f = this.e(a, c, d, e);
            c = f.p1;
            d = f.p2;
            e = f.p3;
            this.q(c != null ? c : b, d, e);
        }
        q(a, b, c) {
            this.f();
            this.w.ao(a, b, c);
        }
        r(a) {
            this.w.am(a);
        }
        l(a, b = false) {
            this.m(a.t, a.s(this.a._z), b);
        }
        m(a, b, c = false) {
            let d = b;
            if (this.a._z != 1) {
                let e = this.a._u(b);
                if (e != null) {
                    d = e.s(this.a._z);
                }
            }
            this.w.j("xmlns", a, "http://www.w3.org/2000/xmlns/", d);
            if (c) {
                this.c.add(a);
            }
        }
        n(a) {
            this.f();
            this.w.ah(a);
        }
        t(a) {
            this.f();
            let b = new Stack$1(UnknownElementCache.$);
            this.s(a.b, b);
        }
        s(a, b) {
            let c = this.b.y(a, b);
            let t1 = c;
            L0: while (true) {
                switch (t1) {
                    case 0:
                        {
                            let d = a.b.b(this.a);
                            this.q(d.h, d.f, d.g);
                            if (a.d) {
                                for (let e of fromEnum(a.j)) {
                                    let f = e.a.b(this.a);
                                    this.i(f.h, f.f, f.g, e.d);
                                }
                            }
                            if (a.p != null) {
                                this.u(a.p);
                            }
                        }
                        t1 = 1;
                        continue L0;
                    case 1:
                        {
                            if (a.e) {
                                b.h(a);
                                for (let g of fromEnum(a.k)) {
                                    this.s(g, b);
                                }
                                b.e();
                            }
                            this.k();
                        }
                        break;
                    case 2: break;
                    default:
                        t1 = 0;
                        continue L0;
                }
                break;
            }
        }
        u(a) {
            this.f();
            this.w.ap(a);
        }
        v(a, b, c) {
            this.f();
            let d = new StringBuilder(2, "version=\"" + a + "\"");
            if (b.length > 0) {
                d.l(" encoding=\"");
                d.l(b);
                d.l("\"");
            }
            if (c.length > 0) {
                d.l(" standalone=\"");
                d.l(c);
                d.l("\"");
            }
            let e = d.toString();
            this.w.ad("xml", e);
        }
    }
    XmlWriteManager.$t = /*@__PURE__*/ markType(XmlWriteManager, 'XmlWriteManager');
    return XmlWriteManager;
})();
/**
 * @hidden
 */
export let PartManagerBase = /*@__PURE__*/ (() => {
    class PartManagerBase extends Base {
        constructor() {
            super();
            this.c = null;
            this.k = null;
        }
        e(a, b) {
            let c = this.memberwiseClone();
            c.k = b;
            c.c = a;
            c.p();
            return c;
        }
        j() {
            return null;
        }
        f(a, b) {
            return null;
        }
        p() {
        }
        q() {
        }
        i(a) {
            return false;
        }
        get d() {
            return this.c;
        }
        get_h() {
            return true;
        }
        get h() {
            return this.get_h();
        }
        get l() {
            return this.k;
        }
        set l(a) {
            this.k = a;
        }
    }
    PartManagerBase.$t = /*@__PURE__*/ markType(PartManagerBase, 'PartManagerBase');
    return PartManagerBase;
})();
/**
 * @hidden
 */
export let ImagePartManagerBase = /*@__PURE__*/ (() => {
    class ImagePartManagerBase extends PartManagerBase {
        n(a) {
            switch (a) {
                case 0: return this.s;
                case 1: return this.u;
                case 2: return this.t;
                default: return null;
            }
        }
        o(a) {
            return ImagePartManagerBase.v(a);
        }
        get_g() {
            return true;
        }
        get g() {
            return this.get_g();
        }
        a() {
            return WorkItem.g(Base.$, new ImageData(1, this.r(this.d._d.uri.toString()), this.l));
        }
        get_h() {
            return false;
        }
        b(a) {
            let b = typeCast(ImageData.$, a);
            if (b != null) {
                b.f(this.l);
            }
            return null;
        }
        static v(a) {
            switch (a) {
                case 0: return ImagePartManagerBase.x;
                case 1: return ImagePartManagerBase.w;
                default: return ImagePartManagerBase.x;
            }
        }
    }
    ImagePartManagerBase.$t = /*@__PURE__*/ markType(ImagePartManagerBase, 'ImagePartManagerBase', PartManagerBase.$);
    ImagePartManagerBase.x = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image";
    ImagePartManagerBase.w = "http://purl.oclc.org/ooxml/officeDocument/relationships/image";
    return ImagePartManagerBase;
})();
/**
 * @hidden
 */
export let XmlPartManagerBase = /*@__PURE__*/ (() => {
    class XmlPartManagerBase extends PartManagerBase {
        constructor() {
            super();
            this.r = null;
            this.am = null;
            this.al = 0;
            this.aa = null;
            this.ac = null;
            this.v = new ElementLoadCallbacks(0);
            this.an = null;
            this.ae = false;
            this.am = {};
        }
        p() {
            super.p();
            let a = this.am;
            this.am = {};
            for (var p in a) {
                if (a.hasOwnProperty(p)) {
                    this.am[p] = a[p];
                }
            }
            ;
        }
        a() {
            return Async.i(Base.$, () => {
                this.r = new ContextStack();
                return this.t();
            }, () => {
                this.r = null;
                this.aa = null;
            });
        }
        b(a) {
            this.r = new ContextStack();
            if (a != null) {
                this.r.k(a);
            }
            return Async.n(XmlWriter.$, this.a2(), (b) => {
                this.ac = new XmlWriteManager(this, b);
                if (this.aj) {
                    this.ac.v("1.0", "UTF-8", "yes");
                }
                return this.u(a);
            });
        }
        at() {
            this.al++;
        }
        au() {
            this.al--;
            if (this.al == 0) {
                this.ae = false;
            }
        }
        as(a) {
        }
        w(a) {
            return this.x(a.e(this.d));
        }
        x(a) {
            return (this.am[a] || this.v);
        }
        z(a) {
            this.d._bj();
            return 0;
        }
        av(a) {
        }
        aw(a) {
        }
        ax(a, b) {
        }
        ay(a, b, c = true) {
            switch (a) {
                case MarkupCompatibility2006.aq:
                case MarkupCompatibility2006.ar:
                case MarkupCompatibility2006.as: return;
            }
            let d = (this.am[a]);
            let e = (d != null);
            let f = e ? new ElementLoadCallbacks(1, d.b, b) : new ElementLoadCallbacks(1, null, b);
            this.am[a] = f;
        }
        static ag(a, b) {
            if (a == null || b == null) {
                return false;
            }
            return a == b;
        }
        ao(a) {
            let b = this.ab.u;
            let c = null;
            for (let d of fromEnum(b)) {
                if (d.a.e(this.d) == a) {
                    c = d.d;
                }
                else {
                }
            }
            return c;
        }
        az(a, b, c = true) {
            switch (a) {
                case MarkupCompatibility2006.aq:
                case MarkupCompatibility2006.ar:
                case MarkupCompatibility2006.as: return;
            }
            let d = (this.am[a]);
            let e = (d != null);
            let f = e ? new ElementLoadCallbacks(1, b, d.a) : new ElementLoadCallbacks(1, b, null);
            this.am[a] = f;
        }
        ah(a) {
            if (stringIsNullOrEmpty(a)) {
                return true;
            }
            let b = a.split(' ');
            for (let d = 0; d < b.length; d++) {
                let c = b[d];
                let e = this.aa.ae(c);
                if (stringIsNullOrEmpty(e)) {
                    continue;
                }
                if (this.d._ad(e) == false) {
                    return false;
                }
            }
            return true;
        }
        ai(a) {
            return this.s.c == false;
        }
        y(a, b) {
            return 0;
        }
        a0(a) {
            let b = this.aa.k.e(this.d);
        }
        a1() {
            return new XmlTextReader(1, this.l);
        }
        a2() {
            return new XmlTextWriter(0, this.l, Encoding.uTF8);
        }
        t() {
            return WorkItemExtensions.g(Base.$, Async.n(XmlReader.$, this.a1(), (a) => Async.g(a.t(), () => {
                this.aa = new XmlReadManager(this, a);
                return this.aa.d();
            })), () => this.an);
        }
        get s() {
            return this.r;
        }
        get af() {
            return this.al != 0;
        }
        get_aj() {
            return true;
        }
        get aj() {
            return this.get_aj();
        }
        get ab() {
            return this.aa;
        }
        get ad() {
            return this.ac;
        }
    }
    XmlPartManagerBase.$t = /*@__PURE__*/ markType(XmlPartManagerBase, 'XmlPartManagerBase', PartManagerBase.$);
    return XmlPartManagerBase;
})();
/**
 * @hidden
 */
export let OfficeExtensibilityPartManagerBase = /*@__PURE__*/ (() => {
    class OfficeExtensibilityPartManagerBase extends XmlPartManagerBase {
        get_m() {
            return "application/xml";
        }
        get m() {
            return this.get_m();
        }
        get_g() {
            return false;
        }
        get g() {
            return this.get_g();
        }
        f(a, b) {
            let c = PackageUtilities.ak(b);
            return new RoundTripDataPartManager(a.contentType, c.toString(), b.relationshipType, this.d);
        }
        a() {
            let a = RoundTripDataPartManager.r(this.d, this.l, this.m);
            this.a3 = a;
            return WorkItem.g(Base.$, a);
        }
        b(a) {
            let b = this.a3;
            if (b == null) {
                return null;
            }
            return RoundTripDataPartManager.s(b, this.d, this.l, true);
        }
        u(a) {
            throw new NotImplementedException(0);
        }
    }
    OfficeExtensibilityPartManagerBase.$t = /*@__PURE__*/ markType(OfficeExtensibilityPartManagerBase, 'OfficeExtensibilityPartManagerBase', XmlPartManagerBase.$);
    return OfficeExtensibilityPartManagerBase;
})();
/**
 * @hidden
 */
export let Office2007ExtensibilityPartManager = /*@__PURE__*/ (() => {
    class Office2007ExtensibilityPartManager extends OfficeExtensibilityPartManagerBase {
        constructor() {
            super();
        }
        get_a3() {
            return this.d._h;
        }
        set_a3(a) {
            this.d._h = a;
        }
        get a3() {
            return this.get_a3();
        }
        set a3(a) {
            this.set_a3(a);
        }
        n(a) {
            return "/customUI/customUI.xml";
        }
        o(a) {
            switch (a) {
                case 0:
                case 1: return Office2007ExtensibilityPartManager.a7;
                default: return Office2007ExtensibilityPartManager.a7;
            }
        }
    }
    Office2007ExtensibilityPartManager.$t = /*@__PURE__*/ markType(Office2007ExtensibilityPartManager, 'Office2007ExtensibilityPartManager', OfficeExtensibilityPartManagerBase.$);
    Office2007ExtensibilityPartManager.a7 = "http://schemas.microsoft.com/office/2006/relationships/ui/extensibility";
    Office2007ExtensibilityPartManager.a5 = /*@__PURE__*/ new Office2007ExtensibilityPartManager();
    return Office2007ExtensibilityPartManager;
})();
/**
 * @hidden
 */
export let Office2010ExtensibilityPartManager = /*@__PURE__*/ (() => {
    class Office2010ExtensibilityPartManager extends OfficeExtensibilityPartManagerBase {
        constructor() {
            super();
        }
        get_a3() {
            return this.d._i;
        }
        set_a3(a) {
            this.d._i = a;
        }
        get a3() {
            return this.get_a3();
        }
        set a3(a) {
            this.set_a3(a);
        }
        n(a) {
            return "/customUI/customUI14.xml";
        }
        o(a) {
            switch (a) {
                case 0:
                case 1: return Office2010ExtensibilityPartManager.a7;
                default: return Office2010ExtensibilityPartManager.a7;
            }
        }
    }
    Office2010ExtensibilityPartManager.$t = /*@__PURE__*/ markType(Office2010ExtensibilityPartManager, 'Office2010ExtensibilityPartManager', OfficeExtensibilityPartManagerBase.$);
    Office2010ExtensibilityPartManager.a7 = "http://schemas.microsoft.com/office/2007/relationships/ui/extensibility";
    Office2010ExtensibilityPartManager.a5 = /*@__PURE__*/ new Office2010ExtensibilityPartManager();
    return Office2010ExtensibilityPartManager;
})();
/**
 * @hidden
 */
export let JpegPartManager = /*@__PURE__*/ (() => {
    class JpegPartManager extends ImagePartManagerBase {
        constructor() {
            super();
        }
        get_s() {
            return "/xl/media/image.jpeg";
        }
        get s() {
            return this.get_s();
        }
        get_t() {
            return "/ppt/media/image.jpeg";
        }
        get t() {
            return this.get_t();
        }
        get_u() {
            return "/word/media/image.jpeg";
        }
        get u() {
            return this.get_u();
        }
        get_m() {
            return "image/jpeg";
        }
        get m() {
            return this.get_m();
        }
        r(a) {
            return ImageFormat.f;
        }
    }
    JpegPartManager.$t = /*@__PURE__*/ markType(JpegPartManager, 'JpegPartManager', ImagePartManagerBase.$);
    JpegPartManager.y = /*@__PURE__*/ new JpegPartManager();
    return JpegPartManager;
})();
/**
 * @hidden
 */
export let RoundTripDataPartManager = /*@__PURE__*/ (() => {
    class RoundTripDataPartManager extends PartManagerBase {
        constructor(a, b, c, d) {
            super();
            this.u = null;
            this.v = null;
            this.w = null;
            this.t = null;
            this.u = a;
            this.v = b;
            this.w = c;
            this.t = d;
        }
        a() {
            return WorkItem.g(Base.$, new BinaryData(DocCoreUtils.c(this.l)));
        }
        b(a) {
            let b = typeCast(BinaryData.$, a);
            if (b == null) {
                return null;
            }
            this.l.write(b.a, 0, b.a.length);
            return null;
        }
        n(a) {
            return this.v;
        }
        o(a) {
            return this.t._a7(a, this.w);
        }
        get_m() {
            return this.u;
        }
        get m() {
            return this.get_m();
        }
        get_g() {
            return false;
        }
        get g() {
            return this.get_g();
        }
        static r(a, b, c) {
            let d = new RoundTripControlData(c, a._d.uri.toString(), DocCoreUtils.c(b));
            for (let e of fromEnum(a._d.getRelationships())) {
                if (e.targetMode != 0) {
                    continue;
                }
                let f = typeCast(BinaryData.$, a._as(e));
                if (f == null) {
                    continue;
                }
                let g = PackageUtilities.ak(e);
                let h = a._e(g);
                let i = PackageUtilities.ak(e).toString();
                d.c.add(((() => {
                    let $ret = new RoundTripPartData();
                    $ret.b = h.contentType;
                    $ret.d = e.id;
                    $ret.a = f;
                    $ret.e = e.relationshipType;
                    $ret.c = g.toString();
                    return $ret;
                })()));
            }
            return d;
        }
        static s(a, b, c, d = false) {
            return WorkItemExtensions.a(Async.d(RoundTripPartData.$, a.c, (e) => {
                if (d) {
                    let f = (((g) => g != null ? g : e.e)(b._a7(b._z, e.e)));
                    let g = new RoundTripDataPartManager(e.b, e.c, f, b);
                    return b._j(g, e.a, e.d);
                }
                return WorkItemExtensions.e(Tuple$2.$.specialize(Uri.$, String_$type), b._l(e.b, e.c, e.a, e.d), (h) => {
                });
            }), () => c.write(a.a, 0, a.a.length));
        }
    }
    RoundTripDataPartManager.$t = /*@__PURE__*/ markType(RoundTripDataPartManager, 'RoundTripDataPartManager', PartManagerBase.$);
    return RoundTripDataPartManager;
})();
/**
 * @hidden
 */
export let ThemePartManager = /*@__PURE__*/ (() => {
    class ThemePartManager extends XmlPartManagerBase {
        constructor(a) {
            super();
            this.a3 = false;
            this.a3 = a;
        }
        get_m() {
            return ThemePartManager.a7;
        }
        get m() {
            return this.get_m();
        }
        n(a) {
            if (this.a3) {
                switch (a) {
                    case 0: return "/theme/theme/theme.xml";
                    case 1: return "/theme/theme/theme.xml";
                    default: return null;
                }
            }
            else {
                switch (a) {
                    case 0: return "/xl/theme/theme.xml";
                    case 1: return "/word/theme/theme.xml";
                    default: return null;
                }
            }
        }
        o(a) {
            switch (a) {
                case 0: return ThemePartManager.a9;
                case 1: return ThemePartManager.a8;
                default: return ThemePartManager.a9;
            }
        }
        get_g() {
            return true;
        }
        get g() {
            return this.get_g();
        }
        a() {
            this.d._af = true;
            return super.a();
        }
    }
    ThemePartManager.$t = /*@__PURE__*/ markType(ThemePartManager, 'ThemePartManager', XmlPartManagerBase.$);
    ThemePartManager.a7 = "application/vnd.openxmlformats-officedocument.theme+xml";
    ThemePartManager.a9 = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme";
    ThemePartManager.a8 = "http://purl.oclc.org/ooxml/officeDocument/relationships/theme";
    return ThemePartManager;
})();
/**
 * @hidden
 */
export let XmlNamespaceDefinitionBase = /*@__PURE__*/ (() => {
    class XmlNamespaceDefinitionBase extends Base {
        static z(a, b) {
        }
        static y(a) {
            for (let b of fromEnum(a.ab.u)) {
                switch (b.a.e(a.d)) {
                    default: break;
                }
            }
        }
        static q($t, a, b, c) {
            if (c == false && EqualityComparer$1.defaultEqualityComparerValue($t).equalsC(a, b)) {
                return null;
            }
            return XmlNamespaceDefinitionBase.p($t, a);
        }
        static p($t, value_) {
            let a = $t;
            if (a == ST_FillMethod_$type && Base.equalsStatic(getBoxIfEnum($t, value_), enumGetBox(ST_FillMethod_$type, 4))) {
                return "linear sigma";
            }
            let b = stringToString$1($t, value_);
            if (b.charAt(0) == '_') {
                return b.substr(1);
            }
            return b;
        }
        static r(a) {
            let b = a.lastIndexOf('/');
            if (b < 0) {
                return a;
            }
            return a.substr(b + 1);
        }
        static b($t, a, b = Type.createInstance($t)) {
            if (stringIsNullOrEmpty(a)) {
                return b;
            }
            let c = false;
            switch (a) {
                case "continue":
                case "decimal":
                case "default":
                case "double":
                case "fixed":
                case "long":
                case "short":
                case "base":
                    c = true;
                    break;
                case "linear sigma":
                    a = EnumUtil.getName(ST_FillMethod_$type, 4);
                    break;
                default:
                    if ('0'.charCodeAt(0) <= a.charAt(0).charCodeAt(0) && a.charAt(0).charCodeAt(0) <= '9'.charCodeAt(0)) {
                        c = true;
                    }
                    break;
            }
            let d;
            if (c == false && ((() => { let e = EnumUtil.tryParse$1($t, a, false, d); d = e.p2; return e.ret; })())) {
                return d;
            }
            if (((() => { let e = EnumUtil.tryParse$1($t, "_" + a, false, d); d = e.p2; return e.ret; })())) {
                return d;
            }
            return b;
        }
        static c($t, a, b, c) {
            if (stringIsNullOrEmpty(a.d)) {
                return b;
            }
            return c(a.d);
        }
        static g($t, a, b) {
            let c = new List$1($t, 0);
            let d = -1;
            for (let e = 0; e < a.length; e++) {
                switch (a.charAt(e)) {
                    case ' ':
                    case '\t':
                    case '\r':
                    case '\n':
                        if (d != -1) {
                            c.add(b(a.substr(d, e - d)));
                            d = -1;
                        }
                        break;
                    default:
                        if (d == -1) {
                            d = e;
                        }
                        break;
                }
            }
            if (d != -1) {
                c.add(b(a.substr(d)));
            }
            return c;
        }
        static e(a, b) {
            let c;
            if (((() => { let d = tryParseBool(a.ab.ad, c); c = d.p1; return d.ret; })()) == false) {
                c = ST_OnOff.e(a.ab.ad);
            }
            return c;
        }
        static aa(a, b, c, d) {
            a.ad.p(b, c);
            a.ad.u(d.toString().toLowerCase());
        }
        static n(a, b) {
            return parseInt8_1(a.ab.ad, CultureInfo.invariantCulture);
        }
        static ab(a, b, c, d) {
            a.ad.p(b, c);
            a.ad.u(d.toString());
        }
        static h(a, b) {
            let c = a.ao(XmlSchemaInstance.ar);
            let d = c == null ? null : a.ab.ag(c);
            return PackageUtilities.i(a.ab.ad);
        }
        static ac(a, b, c, d) {
            a.ad.p(b, c);
            let e = new QualifiedNameInfo(1, DcTerms.ao.t, DcTerms.ao.s(a.d._z), XmlNamespaceDefinitionBase.r("http://purl.org/dc/terms/W3CDTF"));
            a.ad.h(XmlSchemaInstance.ar, e.toString());
            a.ad.u(PackageUtilities.k(d));
        }
        static i(a, b) {
            return parseNumber(a.ab.ad, CultureInfo.invariantCulture);
        }
        static ad(a, b, c, d) {
            a.ad.p(b, c);
            a.ad.u(numberToString(d, CultureInfo.invariantCulture));
        }
        static j(a, b) {
            return parseNumber(a.ab.ad, CultureInfo.invariantCulture);
        }
        static ae(a, b, c, d) {
            a.ad.p(b, c);
            a.ad.u(numberToString(d, CultureInfo.invariantCulture));
        }
        static o(a, b) {
            return parseNumber(a.ab.ad, CultureInfo.invariantCulture);
        }
        static af(a, b, c, d) {
            a.ad.p(b, c);
            a.ad.u(numberToString(d, CultureInfo.invariantCulture));
        }
        static l(a, b, c = true) {
            let d = a.ab.ad;
            if (c) {
                return parseInt32_1(d, CultureInfo.invariantCulture);
            }
            let e;
            let f = tryParseInt32_2(d, 7, CultureInfo.invariantCulture, e);
            e = f.p3;
            return e;
        }
        static ag(a, b, c, d) {
            a.ad.p(b, c);
            a.ad.u(d.toString());
        }
        static m(a, b) {
            return parseInt64_1(a.ab.ad, CultureInfo.invariantCulture);
        }
        static ah(a, b, c, d) {
            a.ad.p(b, c);
            a.ad.u(d.toString());
        }
        static k(a, b) {
            return parseInt16_1(a.ab.ad, CultureInfo.invariantCulture);
        }
        static ai(a, b, c, d) {
            a.ad.p(b, c);
            a.ad.u(d.toString());
        }
        static d(a) {
            switch (a) {
                case ' ':
                case '\r':
                case '\n':
                case '\t': return true;
                default: return false;
            }
        }
        static u(a, b, c = 0) {
            let d = a.ao(XmlNamespace.as);
            if (d == "preserve") {
                c = 6;
            }
            let e = a.ab.ad;
            if (e != null) {
                if ((c & 2) == 0) {
                    e = trimStart(e, ...XmlNamespaceDefinitionBase.a);
                }
                if ((c & 4) == 0 && stringIsNullOrWhiteSpace(e) == false) {
                    e = trimEnd(e, ...XmlNamespaceDefinitionBase.a);
                }
            }
            return e;
        }
        static aj(a, b, c, d, e = null, f = 0) {
            a.ad.p(b, c);
            if (f != 6) {
                if (stringIsNullOrEmpty(d) == false) {
                    if ((XmlNamespaceDefinitionBase.d(d.charAt(0)) && (f & 2) == 0) || (XmlNamespaceDefinitionBase.d(d.charAt(d.length - 1)) && (f & 4) == 0)) {
                        XmlNamespace.at(a.ad);
                    }
                }
            }
            if (e != null) {
                e();
            }
            a.ad.u(d);
        }
        static f(a, b) {
            return parseUInt8_1(a.ab.ad, CultureInfo.invariantCulture);
        }
        static ak(a, b, c, d) {
            a.ad.p(b, c);
            a.ad.u(d.toString());
        }
        static w(a, b) {
            return parseUInt32_1(a.ab.ad, CultureInfo.invariantCulture);
        }
        static al(a, b, c, d) {
            a.ad.p(b, c);
            a.ad.u(d.toString());
        }
        static x(a, b) {
            return parseUInt64_1(a.ab.ad, CultureInfo.invariantCulture);
        }
        static am(a, b, c, d) {
            a.ad.p(b, c);
            a.ad.u(d.toString());
        }
        static v(a, b) {
            return parseUInt16_1(a.ab.ad, CultureInfo.invariantCulture);
        }
        static an(a, b, c, d) {
            a.ad.p(b, c);
            a.ad.u(d.toString());
        }
    }
    XmlNamespaceDefinitionBase.$t = /*@__PURE__*/ markType(XmlNamespaceDefinitionBase, 'XmlNamespaceDefinitionBase');
    XmlNamespaceDefinitionBase.a = [' ', '\r', '\n', '\t'];
    return XmlNamespaceDefinitionBase;
})();
/**
 * @hidden
 */
export let CoreProperties = /*@__PURE__*/ (() => {
    class CoreProperties extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0:
                case 1: return CoreProperties.av;
                default: return CoreProperties.av;
            }
        }
        get_t() {
            return "cp";
        }
        get t() {
            return this.get_t();
        }
        static ay(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, CoreProperties.aq, 6);
            return {
                p1: b
            };
        }
        static a5(a, b) {
            XmlNamespaceDefinitionBase.aj(a, CoreProperties.aq, "cp", b, void 0, 6);
        }
        static az(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, CoreProperties.ar, 6);
            return {
                p1: b
            };
        }
        static a6(a, b) {
            XmlNamespaceDefinitionBase.aj(a, CoreProperties.ar, "cp", b, void 0, 6);
        }
        static a0(a) {
        }
        static a7(a) {
            a.ad.p(CoreProperties.as, "cp");
            let b = a.d._z;
            a.ad.l(CoreProperties.ao);
            a.ad.l(DcElements.ao);
            a.ad.l(DcTerms.ao);
            a.ad.l(DcDcmiType.ao);
            a.ad.l(XmlSchemaInstance.ao);
        }
        static a1(a, b, c) {
            b = a.ao(XmlNamespace.aq);
            c = a.ab.ad;
            return {
                p1: b,
                p2: c
            };
        }
        static a8(a, b, c) {
            a.ad.p(CoreProperties.at, "cp");
            let d;
            d = b;
            a.ad.h(XmlNamespace.aq, d);
            a.ad.u(c);
        }
        static a2(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, CoreProperties.au);
            return {
                p1: b
            };
        }
        static a9(a, b) {
            XmlNamespaceDefinitionBase.aj(a, CoreProperties.au, "cp", b);
        }
        static a3(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, CoreProperties.aw);
            return {
                p1: b
            };
        }
        static ba(a, b) {
            XmlNamespaceDefinitionBase.aj(a, CoreProperties.aw, "cp", b);
        }
        static a4(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, CoreProperties.ax);
            return {
                p1: b
            };
        }
        static bb(a, b) {
            XmlNamespaceDefinitionBase.aj(a, CoreProperties.ax, "cp", b);
        }
    }
    CoreProperties.$t = /*@__PURE__*/ markType(CoreProperties, 'CoreProperties', XmlNamespaceDefinitionBase.$);
    CoreProperties.av = "http://schemas.openxmlformats.org/package/2006/metadata/core-properties";
    CoreProperties.aq = CoreProperties.av + "/category";
    CoreProperties.ar = CoreProperties.av + "/contentStatus";
    CoreProperties.as = CoreProperties.av + "/coreProperties";
    CoreProperties.at = CoreProperties.av + "/keywords";
    CoreProperties.au = CoreProperties.av + "/lastModifiedBy";
    CoreProperties.aw = CoreProperties.av + "/revision";
    CoreProperties.ax = CoreProperties.av + "/version";
    CoreProperties.ao = /*@__PURE__*/ new CoreProperties();
    return CoreProperties;
})();
/**
 * @hidden
 */
export let DcDcmiType = /*@__PURE__*/ (() => {
    class DcDcmiType extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0:
                case 1: return "http://purl.org/dc/dcmitype/";
                default: return "http://purl.org/dc/dcmitype/";
            }
        }
        get_t() {
            return "dcmitype";
        }
        get t() {
            return this.get_t();
        }
    }
    DcDcmiType.$t = /*@__PURE__*/ markType(DcDcmiType, 'DcDcmiType', XmlNamespaceDefinitionBase.$);
    DcDcmiType.ao = /*@__PURE__*/ new DcDcmiType();
    return DcDcmiType;
})();
/**
 * @hidden
 */
export let DcElements = /*@__PURE__*/ (() => {
    class DcElements extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0:
                case 1: return "http://purl.org/dc/elements/1.1/";
                default: return "http://purl.org/dc/elements/1.1/";
            }
        }
        get_t() {
            return "dc";
        }
        get t() {
            return this.get_t();
        }
        static av(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, "http://purl.org/dc/elements/1.1/creator");
            return {
                p1: b
            };
        }
        static az(a, b) {
            XmlNamespaceDefinitionBase.aj(a, "http://purl.org/dc/elements/1.1/creator", "dc", b);
        }
        static aw(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, DcElements.ar, 6);
            return {
                p1: b
            };
        }
        static a0(a, b) {
            XmlNamespaceDefinitionBase.aj(a, DcElements.ar, "dc", b, void 0, 6);
        }
        static ax(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, "http://purl.org/dc/elements/1.1/subject", 6);
            return {
                p1: b
            };
        }
        static a1(a, b) {
            XmlNamespaceDefinitionBase.aj(a, "http://purl.org/dc/elements/1.1/subject", "dc", b, void 0, 6);
        }
        static ay(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, "http://purl.org/dc/elements/1.1/title", 6);
            return {
                p1: b
            };
        }
        static a2(a, b) {
            XmlNamespaceDefinitionBase.aj(a, "http://purl.org/dc/elements/1.1/title", "dc", b, void 0, 6);
        }
    }
    DcElements.$t = /*@__PURE__*/ markType(DcElements, 'DcElements', XmlNamespaceDefinitionBase.$);
    DcElements.ar = "http://purl.org/dc/elements/1.1/" + "description";
    DcElements.ao = /*@__PURE__*/ new DcElements();
    return DcElements;
})();
/**
 * @hidden
 */
export let DcTerms = /*@__PURE__*/ (() => {
    class DcTerms extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0:
                case 1: return "http://purl.org/dc/terms/";
                default: return "http://purl.org/dc/terms/";
            }
        }
        get_t() {
            return "dcterms";
        }
        get t() {
            return this.get_t();
        }
        static au(a, b) {
            b = XmlNamespaceDefinitionBase.h(a, "http://purl.org/dc/terms/created");
            return {
                p1: b
            };
        }
        static aw(a, b) {
            XmlNamespaceDefinitionBase.ac(a, "http://purl.org/dc/terms/created", "dcterms", b);
        }
        static av(a, b) {
            b = XmlNamespaceDefinitionBase.h(a, "http://purl.org/dc/terms/modified");
            return {
                p1: b
            };
        }
        static ax(a, b) {
            XmlNamespaceDefinitionBase.ac(a, "http://purl.org/dc/terms/modified", "dcterms", b);
        }
    }
    DcTerms.$t = /*@__PURE__*/ markType(DcTerms, 'DcTerms', XmlNamespaceDefinitionBase.$);
    DcTerms.ao = /*@__PURE__*/ new DcTerms();
    return DcTerms;
})();
/**
 * @hidden
 */
export let Drawing2010Main = /*@__PURE__*/ (() => {
    class Drawing2010Main extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0:
                case 1: return Drawing2010Main.aq;
                default: return Drawing2010Main.aq;
            }
        }
        get_t() {
            return "a14";
        }
        get t() {
            return this.get_t();
        }
    }
    Drawing2010Main.$t = /*@__PURE__*/ markType(Drawing2010Main, 'Drawing2010Main', XmlNamespaceDefinitionBase.$);
    Drawing2010Main.aq = "http://schemas.microsoft.com/office/drawing/2010/main";
    Drawing2010Main.ao = /*@__PURE__*/ new Drawing2010Main();
    return Drawing2010Main;
})();
/**
 * @hidden
 */
export let Drawing2010Slicer = /*@__PURE__*/ (() => {
    class Drawing2010Slicer extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0:
                case 1: return Drawing2010Slicer.as;
                default: return Drawing2010Slicer.as;
            }
        }
        get_t() {
            return "sle";
        }
        get t() {
            return this.get_t();
        }
        static au(a, b) {
            b = a.ao("name");
            return {
                p1: b
            };
        }
        static av(a, b) {
            a.ad.p(Drawing2010Slicer.at, "sle");
            let c;
            c = b;
            a.ad.h("name", c);
        }
    }
    Drawing2010Slicer.$t = /*@__PURE__*/ markType(Drawing2010Slicer, 'Drawing2010Slicer', XmlNamespaceDefinitionBase.$);
    Drawing2010Slicer.as = "http://schemas.microsoft.com/office/drawing/2010/slicer";
    Drawing2010Slicer.at = Drawing2010Slicer.as + "/slicer";
    Drawing2010Slicer.ao = /*@__PURE__*/ new Drawing2010Slicer();
    return Drawing2010Slicer;
})();
/**
 * @hidden
 */
export let DrawingMLChart = /*@__PURE__*/ (() => {
    class DrawingMLChart extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0: return DrawingMLChart.dy;
                case 1: return DrawingMLChart.dx;
                default: return DrawingMLChart.dy;
            }
        }
        get_t() {
            return "c";
        }
        get t() {
            return this.get_t();
        }
        static gy(a, b) {
            b = a.ao(OfficeDocumentRelationships.as);
            return {
                p1: b
            };
        }
        static gz(a, b = null) {
            a.ad.p(DrawingMLChart.bf, "c");
            a.ad.l(DrawingMLChart.ao);
            a.ad.l(OfficeDocumentRelationships.ao);
            let c;
            c = b;
            a.ad.h(OfficeDocumentRelationships.as, c);
        }
    }
    DrawingMLChart.$t = /*@__PURE__*/ markType(DrawingMLChart, 'DrawingMLChart', XmlNamespaceDefinitionBase.$);
    DrawingMLChart.dy = "http://schemas.openxmlformats.org/drawingml/2006/chart";
    DrawingMLChart.dx = "http://purl.oclc.org/ooxml/drawingml/chart";
    DrawingMLChart.aq = DrawingMLChart.dx + "/applyToEnd";
    DrawingMLChart.ar = DrawingMLChart.dx + "/applyToFront";
    DrawingMLChart.as = DrawingMLChart.dx + "/applyToSides";
    DrawingMLChart.at = DrawingMLChart.dx + "/area3DChart";
    DrawingMLChart.au = DrawingMLChart.dx + "/areaChart";
    DrawingMLChart.av = DrawingMLChart.dx + "/auto";
    DrawingMLChart.aw = DrawingMLChart.dx + "/autoTitleDeleted";
    DrawingMLChart.ax = DrawingMLChart.dx + "/autoUpdate";
    DrawingMLChart.ay = DrawingMLChart.dx + "/axId";
    DrawingMLChart.az = DrawingMLChart.dx + "/axPos";
    DrawingMLChart.a0 = DrawingMLChart.dx + "/backWall";
    DrawingMLChart.a1 = DrawingMLChart.dx + "/backward";
    DrawingMLChart.a2 = DrawingMLChart.dx + "/bandFmt";
    DrawingMLChart.a3 = DrawingMLChart.dx + "/bandFmts";
    DrawingMLChart.a4 = DrawingMLChart.dx + "/bar3DChart";
    DrawingMLChart.a5 = DrawingMLChart.dx + "/barChart";
    DrawingMLChart.a6 = DrawingMLChart.dx + "/barDir";
    DrawingMLChart.a7 = DrawingMLChart.dx + "/baseTimeUnit";
    DrawingMLChart.a8 = DrawingMLChart.dx + "/bubble3D";
    DrawingMLChart.a9 = DrawingMLChart.dx + "/bubbleChart";
    DrawingMLChart.ba = DrawingMLChart.dx + "/bubbleScale";
    DrawingMLChart.bb = DrawingMLChart.dx + "/bubbleSize";
    DrawingMLChart.bc = DrawingMLChart.dx + "/builtInUnit";
    DrawingMLChart.bd = DrawingMLChart.dx + "/cat";
    DrawingMLChart.be = DrawingMLChart.dx + "/catAx";
    DrawingMLChart.bf = DrawingMLChart.dx + "/chart";
    DrawingMLChart.bg = DrawingMLChart.dx + "/chartObject";
    DrawingMLChart.bh = DrawingMLChart.dx + "/chartSpace";
    DrawingMLChart.bi = DrawingMLChart.dx + "/clrMapOvr";
    DrawingMLChart.bj = DrawingMLChart.dx + "/crossAx";
    DrawingMLChart.bk = DrawingMLChart.dx + "/crossBetween";
    DrawingMLChart.bl = DrawingMLChart.dx + "/crosses";
    DrawingMLChart.bm = DrawingMLChart.dx + "/crossesAt";
    DrawingMLChart.bn = DrawingMLChart.dx + "/custSplit";
    DrawingMLChart.bo = DrawingMLChart.dx + "/custUnit";
    DrawingMLChart.bp = DrawingMLChart.dx + "/data";
    DrawingMLChart.bq = DrawingMLChart.dx + "/date1904";
    DrawingMLChart.br = DrawingMLChart.dx + "/dateAx";
    DrawingMLChart.bs = DrawingMLChart.dx + "/delete";
    DrawingMLChart.bt = DrawingMLChart.dx + "/depthPercent";
    DrawingMLChart.bu = DrawingMLChart.dx + "/dispBlanksAs";
    DrawingMLChart.bv = DrawingMLChart.dx + "/dispEq";
    DrawingMLChart.bw = DrawingMLChart.dx + "/dispRSqr";
    DrawingMLChart.bx = DrawingMLChart.dx + "/dispUnits";
    DrawingMLChart.by = DrawingMLChart.dx + "/dispUnitsLbl";
    DrawingMLChart.bz = DrawingMLChart.dx + "/dLbl";
    DrawingMLChart.b0 = DrawingMLChart.dx + "/dLblPos";
    DrawingMLChart.b1 = DrawingMLChart.dx + "/dLbls";
    DrawingMLChart.b2 = DrawingMLChart.dx + "/doughnutChart";
    DrawingMLChart.b3 = DrawingMLChart.dx + "/downBars";
    DrawingMLChart.b4 = DrawingMLChart.dx + "/dPt";
    DrawingMLChart.b5 = DrawingMLChart.dx + "/dropLines";
    DrawingMLChart.b6 = DrawingMLChart.dx + "/dTable";
    DrawingMLChart.b7 = DrawingMLChart.dx + "/errBars";
    DrawingMLChart.b8 = DrawingMLChart.dx + "/errBarType";
    DrawingMLChart.b9 = DrawingMLChart.dx + "/errDir";
    DrawingMLChart.ca = DrawingMLChart.dx + "/errValType";
    DrawingMLChart.cb = DrawingMLChart.dx + "/evenFooter";
    DrawingMLChart.cc = DrawingMLChart.dx + "/evenHeader";
    DrawingMLChart.cd = DrawingMLChart.dx + "/explosion";
    DrawingMLChart.ce = DrawingMLChart.dx + "/ext";
    DrawingMLChart.cf = DrawingMLChart.dx + "/externalData";
    DrawingMLChart.cg = DrawingMLChart.dx + "/extLst";
    DrawingMLChart.ch = DrawingMLChart.dx + "/f";
    DrawingMLChart.ci = DrawingMLChart.dx + "/firstFooter";
    DrawingMLChart.cj = DrawingMLChart.dx + "/firstHeader";
    DrawingMLChart.ck = DrawingMLChart.dx + "/firstSliceAng";
    DrawingMLChart.cl = DrawingMLChart.dx + "/floor";
    DrawingMLChart.cm = DrawingMLChart.dx + "/fmtId";
    DrawingMLChart.cn = DrawingMLChart.dx + "/formatCode";
    DrawingMLChart.co = DrawingMLChart.dx + "/formatting";
    DrawingMLChart.cp = DrawingMLChart.dx + "/forward";
    DrawingMLChart.cq = DrawingMLChart.dx + "/gapDepth";
    DrawingMLChart.cr = DrawingMLChart.dx + "/gapWidth";
    DrawingMLChart.cs = DrawingMLChart.dx + "/grouping";
    DrawingMLChart.ct = DrawingMLChart.dx + "/h";
    DrawingMLChart.cu = DrawingMLChart.dx + "/headerFooter";
    DrawingMLChart.cv = DrawingMLChart.dx + "/hiLowLines";
    DrawingMLChart.cw = DrawingMLChart.dx + "/hMode";
    DrawingMLChart.cx = DrawingMLChart.dx + "/holeSize";
    DrawingMLChart.cy = DrawingMLChart.dx + "/hPercent";
    DrawingMLChart.cz = DrawingMLChart.dx + "/idx";
    DrawingMLChart.c0 = DrawingMLChart.dx + "/intercept";
    DrawingMLChart.c1 = DrawingMLChart.dx + "/invertIfNegative";
    DrawingMLChart.c2 = DrawingMLChart.dx + "/lang";
    DrawingMLChart.c3 = DrawingMLChart.dx + "/layout";
    DrawingMLChart.c4 = DrawingMLChart.dx + "/layoutTarget";
    DrawingMLChart.c5 = DrawingMLChart.dx + "/lblAlgn";
    DrawingMLChart.c6 = DrawingMLChart.dx + "/lblOffset";
    DrawingMLChart.c7 = DrawingMLChart.dx + "/leaderLines";
    DrawingMLChart.c8 = DrawingMLChart.dx + "/legacyDrawingHF";
    DrawingMLChart.c9 = DrawingMLChart.dx + "/legend";
    DrawingMLChart.da = DrawingMLChart.dx + "/legendEntry";
    DrawingMLChart.db = DrawingMLChart.dx + "/legendPos";
    DrawingMLChart.dc = DrawingMLChart.dx + "/line3DChart";
    DrawingMLChart.dd = DrawingMLChart.dx + "/lineChart";
    DrawingMLChart.de = DrawingMLChart.dx + "/logBase";
    DrawingMLChart.df = DrawingMLChart.dx + "/lvl";
    DrawingMLChart.dg = DrawingMLChart.dx + "/majorGridlines";
    DrawingMLChart.dh = DrawingMLChart.dx + "/majorTickMark";
    DrawingMLChart.di = DrawingMLChart.dx + "/majorTimeUnit";
    DrawingMLChart.dj = DrawingMLChart.dx + "/majorUnit";
    DrawingMLChart.dk = DrawingMLChart.dx + "/manualLayout";
    DrawingMLChart.dl = DrawingMLChart.dx + "/marker";
    DrawingMLChart.dm = DrawingMLChart.dx + "/max";
    DrawingMLChart.dn = DrawingMLChart.dx + "/min";
    DrawingMLChart.dp = DrawingMLChart.dx + "/minorGridlines";
    DrawingMLChart.dq = DrawingMLChart.dx + "/minorTickMark";
    DrawingMLChart.dr = DrawingMLChart.dx + "/minorTimeUnit";
    DrawingMLChart.ds = DrawingMLChart.dx + "/minorUnit";
    DrawingMLChart.dt = DrawingMLChart.dx + "/minus";
    DrawingMLChart.du = DrawingMLChart.dx + "/multiLvlStrCache";
    DrawingMLChart.dv = DrawingMLChart.dx + "/multiLvlStrRef";
    DrawingMLChart.dw = DrawingMLChart.dx + "/name";
    DrawingMLChart.dz = DrawingMLChart.dx + "/noEndCap";
    DrawingMLChart.d0 = DrawingMLChart.dx + "/noMultiLvlLbl";
    DrawingMLChart.d1 = DrawingMLChart.dx + "/numCache";
    DrawingMLChart.d2 = DrawingMLChart.dx + "/numFmt";
    DrawingMLChart.d3 = DrawingMLChart.dx + "/numLit";
    DrawingMLChart.d4 = DrawingMLChart.dx + "/numRef";
    DrawingMLChart.d5 = DrawingMLChart.dx + "/oddFooter";
    DrawingMLChart.d6 = DrawingMLChart.dx + "/oddHeader";
    DrawingMLChart.d7 = DrawingMLChart.dx + "/ofPieChart";
    DrawingMLChart.d8 = DrawingMLChart.dx + "/ofPieType";
    DrawingMLChart.d9 = DrawingMLChart.dx + "/order";
    DrawingMLChart.ea = DrawingMLChart.dx + "/orientation";
    DrawingMLChart.eb = DrawingMLChart.dx + "/overlap";
    DrawingMLChart.ec = DrawingMLChart.dx + "/overlay";
    DrawingMLChart.ed = DrawingMLChart.dx + "/pageMargins";
    DrawingMLChart.ee = DrawingMLChart.dx + "/pageSetup";
    DrawingMLChart.ef = DrawingMLChart.dx + "/period";
    DrawingMLChart.eg = DrawingMLChart.dx + "/perspective";
    DrawingMLChart.eh = DrawingMLChart.dx + "/pictureFormat";
    DrawingMLChart.ei = DrawingMLChart.dx + "/pictureOptions";
    DrawingMLChart.ej = DrawingMLChart.dx + "/pictureStackUnit";
    DrawingMLChart.ek = DrawingMLChart.dx + "/pie3DChart";
    DrawingMLChart.el = DrawingMLChart.dx + "/pieChart";
    DrawingMLChart.em = DrawingMLChart.dx + "/pivotFmt";
    DrawingMLChart.en = DrawingMLChart.dx + "/pivotFmts";
    DrawingMLChart.eo = DrawingMLChart.dx + "/pivotSource";
    DrawingMLChart.ep = DrawingMLChart.dx + "/plotArea";
    DrawingMLChart.eq = DrawingMLChart.dx + "/plotVisOnly";
    DrawingMLChart.er = DrawingMLChart.dx + "/plus";
    DrawingMLChart.es = DrawingMLChart.dx + "/printSettings";
    DrawingMLChart.et = DrawingMLChart.dx + "/protection";
    DrawingMLChart.eu = DrawingMLChart.dx + "/pt";
    DrawingMLChart.ev = DrawingMLChart.dx + "/ptCount";
    DrawingMLChart.ew = DrawingMLChart.dx + "/radarChart";
    DrawingMLChart.ex = DrawingMLChart.dx + "/radarStyle";
    DrawingMLChart.ey = DrawingMLChart.dx + "/rAngAx";
    DrawingMLChart.ez = DrawingMLChart.dx + "/rich";
    DrawingMLChart.e0 = DrawingMLChart.dx + "/rotX";
    DrawingMLChart.e1 = DrawingMLChart.dx + "/rotY";
    DrawingMLChart.e2 = DrawingMLChart.dx + "/roundedCorners";
    DrawingMLChart.e3 = DrawingMLChart.dx + "/scaling";
    DrawingMLChart.e4 = DrawingMLChart.dx + "/scatterChart";
    DrawingMLChart.e5 = DrawingMLChart.dx + "/scatterStyle";
    DrawingMLChart.e6 = DrawingMLChart.dx + "/secondPiePt";
    DrawingMLChart.e7 = DrawingMLChart.dx + "/secondPieSize";
    DrawingMLChart.e8 = DrawingMLChart.dx + "/selection";
    DrawingMLChart.e9 = DrawingMLChart.dx + "/separator";
    DrawingMLChart.fa = DrawingMLChart.dx + "/ser";
    DrawingMLChart.fb = DrawingMLChart.dx + "/serAx";
    DrawingMLChart.fc = DrawingMLChart.dx + "/serLines";
    DrawingMLChart.fd = DrawingMLChart.dx + "/shape";
    DrawingMLChart.fe = DrawingMLChart.dx + "/showBubbleSize";
    DrawingMLChart.ff = DrawingMLChart.dx + "/showCatName";
    DrawingMLChart.fg = DrawingMLChart.dx + "/showDLblsOverMax";
    DrawingMLChart.fh = DrawingMLChart.dx + "/showHorzBorder";
    DrawingMLChart.fi = DrawingMLChart.dx + "/showKeys";
    DrawingMLChart.fj = DrawingMLChart.dx + "/showLeaderLines";
    DrawingMLChart.fk = DrawingMLChart.dx + "/showLegendKey";
    DrawingMLChart.fl = DrawingMLChart.dx + "/showNegBubbles";
    DrawingMLChart.fm = DrawingMLChart.dx + "/showOutline";
    DrawingMLChart.fn = DrawingMLChart.dx + "/showPercent";
    DrawingMLChart.fo = DrawingMLChart.dx + "/showSerName";
    DrawingMLChart.fp = DrawingMLChart.dx + "/showVal";
    DrawingMLChart.fq = DrawingMLChart.dx + "/showVertBorder";
    DrawingMLChart.fr = DrawingMLChart.dx + "/sideWall";
    DrawingMLChart.fs = DrawingMLChart.dx + "/size";
    DrawingMLChart.ft = DrawingMLChart.dx + "/sizeRepresents";
    DrawingMLChart.fu = DrawingMLChart.dx + "/smooth";
    DrawingMLChart.fv = DrawingMLChart.dx + "/splitPos";
    DrawingMLChart.fw = DrawingMLChart.dx + "/splitType";
    DrawingMLChart.fx = DrawingMLChart.dx + "/spPr";
    DrawingMLChart.fy = DrawingMLChart.dx + "/stockChart";
    DrawingMLChart.fz = DrawingMLChart.dx + "/strCache";
    DrawingMLChart.f0 = DrawingMLChart.dx + "/strLit";
    DrawingMLChart.f1 = DrawingMLChart.dx + "/strRef";
    DrawingMLChart.f2 = DrawingMLChart.dx + "/style";
    DrawingMLChart.f3 = DrawingMLChart.dx + "/surface3DChart";
    DrawingMLChart.f4 = DrawingMLChart.dx + "/surfaceChart";
    DrawingMLChart.f5 = DrawingMLChart.dx + "/symbol";
    DrawingMLChart.f6 = DrawingMLChart.dx + "/thickness";
    DrawingMLChart.f7 = DrawingMLChart.dx + "/tickLblPos";
    DrawingMLChart.f8 = DrawingMLChart.dx + "/tickLblSkip";
    DrawingMLChart.f9 = DrawingMLChart.dx + "/tickMarkSkip";
    DrawingMLChart.ga = DrawingMLChart.dx + "/title";
    DrawingMLChart.gb = DrawingMLChart.dx + "/trendline";
    DrawingMLChart.gc = DrawingMLChart.dx + "/trendlineLbl";
    DrawingMLChart.gd = DrawingMLChart.dx + "/trendlineType";
    DrawingMLChart.ge = DrawingMLChart.dx + "/tx";
    DrawingMLChart.gf = DrawingMLChart.dx + "/txPr";
    DrawingMLChart.gg = DrawingMLChart.dx + "/upBars";
    DrawingMLChart.gh = DrawingMLChart.dx + "/upDownBars";
    DrawingMLChart.gi = DrawingMLChart.dx + "/userInterface";
    DrawingMLChart.gj = DrawingMLChart.dx + "/userShapes";
    DrawingMLChart.gk = DrawingMLChart.dx + "/v";
    DrawingMLChart.gl = DrawingMLChart.dx + "/val";
    DrawingMLChart.gm = DrawingMLChart.dx + "/valAx";
    DrawingMLChart.gn = DrawingMLChart.dx + "/varyColors";
    DrawingMLChart.go = DrawingMLChart.dx + "/view3D";
    DrawingMLChart.gp = DrawingMLChart.dx + "/w";
    DrawingMLChart.gq = DrawingMLChart.dx + "/wireframe";
    DrawingMLChart.gr = DrawingMLChart.dx + "/wMode";
    DrawingMLChart.gs = DrawingMLChart.dx + "/x";
    DrawingMLChart.gt = DrawingMLChart.dx + "/xMode";
    DrawingMLChart.gu = DrawingMLChart.dx + "/xVal";
    DrawingMLChart.gv = DrawingMLChart.dx + "/y";
    DrawingMLChart.gw = DrawingMLChart.dx + "/yMode";
    DrawingMLChart.gx = DrawingMLChart.dx + "/yVal";
    DrawingMLChart.ao = /*@__PURE__*/ new DrawingMLChart();
    return DrawingMLChart;
})();
/**
 * @hidden
 */
export let DrawingMLChart2014 = /*@__PURE__*/ (() => {
    class DrawingMLChart2014 extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0: return DrawingMLChart2014.at;
                case 1: return DrawingMLChart2014.as;
                default: return DrawingMLChart2014.at;
            }
        }
        get_t() {
            return "cx";
        }
        get t() {
            return this.get_t();
        }
        static au(a, b) {
            b = a.ao(OfficeDocumentRelationships.as);
            return {
                p1: b
            };
        }
        static av(a, b = null) {
            a.ad.p(DrawingMLChart2014.aq, "cx");
            a.ad.l(DrawingMLChart2014.ao);
            a.ad.l(OfficeDocumentRelationships.ao);
            let c;
            c = b;
            a.ad.h(OfficeDocumentRelationships.as, c);
        }
    }
    DrawingMLChart2014.$t = /*@__PURE__*/ markType(DrawingMLChart2014, 'DrawingMLChart2014', XmlNamespaceDefinitionBase.$);
    DrawingMLChart2014.at = "http://schemas.microsoft.com/office/drawing/2014/chartex";
    DrawingMLChart2014.as = DrawingMLChart2014.at;
    DrawingMLChart2014.ar = DrawingMLChart2014.at;
    DrawingMLChart2014.aq = DrawingMLChart2014.at + "/chart";
    DrawingMLChart2014.ao = /*@__PURE__*/ new DrawingMLChart2014();
    return DrawingMLChart2014;
})();
/**
 * @hidden
 */
export let DrawingMLChartEx2015_9_8 = /*@__PURE__*/ (() => {
    class DrawingMLChartEx2015_9_8 extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0: return DrawingMLChartEx2015_9_8.as;
                case 1: return DrawingMLChartEx2015_9_8.ar;
                default: return DrawingMLChartEx2015_9_8.as;
            }
        }
        get_t() {
            return "cx1";
        }
        get t() {
            return this.get_t();
        }
    }
    DrawingMLChartEx2015_9_8.$t = /*@__PURE__*/ markType(DrawingMLChartEx2015_9_8, 'DrawingMLChartEx2015_9_8', XmlNamespaceDefinitionBase.$);
    DrawingMLChartEx2015_9_8.as = "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex";
    DrawingMLChartEx2015_9_8.ar = "http://purl.oclc.org/ooxml/drawing/2015/9/8/chartex";
    DrawingMLChartEx2015_9_8.aq = DrawingMLChartEx2015_9_8.as;
    DrawingMLChartEx2015_9_8.ao = /*@__PURE__*/ new DrawingMLChartEx2015_9_8();
    return DrawingMLChartEx2015_9_8;
})();
/**
 * @hidden
 */
export let DrawingMLChartEx2015_10_21 = /*@__PURE__*/ (() => {
    class DrawingMLChartEx2015_10_21 extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0: return DrawingMLChartEx2015_10_21.as;
                case 1: return DrawingMLChartEx2015_10_21.ar;
                default: return DrawingMLChartEx2015_10_21.as;
            }
        }
        get_t() {
            return "cx2";
        }
        get t() {
            return this.get_t();
        }
    }
    DrawingMLChartEx2015_10_21.$t = /*@__PURE__*/ markType(DrawingMLChartEx2015_10_21, 'DrawingMLChartEx2015_10_21', XmlNamespaceDefinitionBase.$);
    DrawingMLChartEx2015_10_21.as = "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex";
    DrawingMLChartEx2015_10_21.ar = "http://purl.oclc.org/ooxml/drawing/2015/10/21/chartex";
    DrawingMLChartEx2015_10_21.aq = DrawingMLChartEx2015_10_21.as;
    DrawingMLChartEx2015_10_21.ao = /*@__PURE__*/ new DrawingMLChartEx2015_10_21();
    return DrawingMLChartEx2015_10_21;
})();
/**
 * @hidden
 */
export let DrawingMLChartEx2016_5_10 = /*@__PURE__*/ (() => {
    class DrawingMLChartEx2016_5_10 extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0: return DrawingMLChartEx2016_5_10.as;
                case 1: return DrawingMLChartEx2016_5_10.ar;
                default: return DrawingMLChartEx2016_5_10.as;
            }
        }
        get_t() {
            return "cx4";
        }
        get t() {
            return this.get_t();
        }
    }
    DrawingMLChartEx2016_5_10.$t = /*@__PURE__*/ markType(DrawingMLChartEx2016_5_10, 'DrawingMLChartEx2016_5_10', XmlNamespaceDefinitionBase.$);
    DrawingMLChartEx2016_5_10.as = "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex";
    DrawingMLChartEx2016_5_10.ar = "http://purl.oclc.org/ooxml/drawing/2016/5/10/chartex";
    DrawingMLChartEx2016_5_10.aq = DrawingMLChartEx2016_5_10.as;
    DrawingMLChartEx2016_5_10.ao = /*@__PURE__*/ new DrawingMLChartEx2016_5_10();
    return DrawingMLChartEx2016_5_10;
})();
/**
 * @hidden
 */
export let DrawingMLMain = /*@__PURE__*/ (() => {
    class DrawingMLMain extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0: return DrawingMLMain.gq;
                case 1: return DrawingMLMain.gp;
                default: return DrawingMLMain.gq;
            }
        }
        get_t() {
            return "a";
        }
        get t() {
            return this.get_t();
        }
        static kw(a, b, c) {
            let d = a.ao("val");
            if (d == null) {
                c = ST_Angle.a(0);
            }
            else {
                c = ST_Angle.b(d);
            }
            return {
                p2: c
            };
        }
        static nx(a, b, c) {
            a.ad.p(b, "a");
            let d;
            d = c.toString();
            a.ad.h("val", d);
        }
        static kx(a, b) {
        }
        static ny(a, b) {
            a.ad.p(b, "a");
        }
        static ky(a, b, c) {
            let d = a.ao("val");
            if (d == null) {
                c = new ST_FixedPercentage();
            }
            else {
                c = ST_FixedPercentage.c(d, a.d._z);
            }
            return {
                p2: c
            };
        }
        static nz(a, b, c) {
            a.ad.p(b, "a");
            let d;
            d = c.s(a.d._z);
            a.ad.h("val", d);
        }
        static kz(a, b, c, d, e) {
            c = toNullable(ST_LineEndType_$type, null);
            d = toNullable(ST_LineEndWidth_$type, null);
            e = toNullable(ST_LineEndLength_$type, null);
            for (let f of fromEnum(a.ab.u)) {
                switch (f.a.e(a.d)) {
                    case "type":
                        c = toNullable(ST_LineEndType_$type, XmlNamespaceDefinitionBase.b(ST_LineEndType_$type, f.d));
                        break;
                    case "w":
                        d = toNullable(ST_LineEndWidth_$type, XmlNamespaceDefinitionBase.b(ST_LineEndWidth_$type, f.d));
                        break;
                    case "len":
                        e = toNullable(ST_LineEndLength_$type, XmlNamespaceDefinitionBase.b(ST_LineEndLength_$type, f.d));
                        break;
                    default: break;
                }
            }
            return {
                p2: c,
                p3: d,
                p4: e
            };
        }
        static n0(a, b, c, d, e) {
            a.ad.p(b, "a");
            let f;
            if (nullableNotEquals(c, null)) {
                f = XmlNamespaceDefinitionBase.p(ST_LineEndType_$type, c.value);
                a.ad.h("type", f);
            }
            if (nullableNotEquals(d, null)) {
                f = XmlNamespaceDefinitionBase.p(ST_LineEndWidth_$type, d.value);
                a.ad.h("w", f);
            }
            if (nullableNotEquals(e, null)) {
                f = XmlNamespaceDefinitionBase.p(ST_LineEndLength_$type, e.value);
                a.ad.h("len", f);
            }
        }
        static k0(a, b, c, d, e, f, g) {
            c = new ST_DrawingElementId();
            d = null;
            e = null;
            f = false;
            g = null;
            for (let h of fromEnum(a.ab.u)) {
                switch (h.a.e(a.d)) {
                    case "id":
                        c = ST_DrawingElementId.c(h.d);
                        break;
                    case "name":
                        d = h.d;
                        break;
                    case "descr":
                        e = h.d;
                        break;
                    case "hidden":
                        f = ST_OnOff.e(h.d);
                        break;
                    case "title":
                        g = h.d;
                        break;
                    default: break;
                }
            }
            return {
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g
            };
        }
        static n1(a, b, c, d, e, f, g) {
            a.ad.p(b, "a");
            let h;
            h = c.toString();
            a.ad.h("id", h);
            h = d;
            a.ad.h("name", h);
            h = e;
            a.ad.h("descr", h);
            if (f != false) {
                h = ST_OnOff.g(f);
                a.ad.h("hidden", h);
            }
            h = g;
            a.ad.h("title", h);
        }
        static k1(a, b, c) {
            let d = a.ao("val");
            if (d == null) {
                c = new ST_Percentage();
            }
            else {
                c = ST_Percentage.d(d, a.d._z);
            }
            return {
                p2: c
            };
        }
        static n2(a, b, c) {
            a.ad.p(b, "a");
            let d;
            d = c.r(a.d._z);
            a.ad.h("val", d);
        }
        static k2(a, b, c, d) {
            c = new ST_Coordinate();
            d = new ST_Coordinate();
            for (let e of fromEnum(a.ab.u)) {
                switch (e.a.e(a.d)) {
                    case "x":
                        c = ST_Coordinate.h(e.d);
                        break;
                    case "y":
                        d = ST_Coordinate.h(e.d);
                        break;
                    default: break;
                }
            }
            return {
                p2: c,
                p3: d
            };
        }
        static n3(a, b, c, d) {
            a.ad.p(b, "a");
            let e;
            e = c.toString();
            a.ad.h("x", e);
            e = d.toString();
            a.ad.h("y", e);
        }
        static k3(a, b, c) {
            let d = a.ao("val");
            if (d == null) {
                c = ST_PositiveFixedAngle.e(ST_Angle.a(0));
            }
            else {
                c = ST_PositiveFixedAngle.g(d);
            }
            return {
                p2: c
            };
        }
        static n4(a, b, c) {
            a.ad.p(b, "a");
            let d;
            d = c.toString();
            a.ad.h("val", d);
        }
        static k4(a, b, c) {
            let d = a.ao("val");
            if (d == null) {
                c = new ST_PositiveFixedPercentage();
            }
            else {
                c = ST_PositiveFixedPercentage.f(d, a.d._z);
            }
            return {
                p2: c
            };
        }
        static n5(a, b, c) {
            a.ad.p(b, "a");
            let d;
            d = c.u(a.d._z);
            a.ad.h("val", d);
        }
        static k5(a, b, c) {
            let d = a.ao("val");
            if (d == null) {
                c = new ST_PositivePercentage();
            }
            else {
                c = ST_PositivePercentage.f(d, a.d._z);
            }
            return {
                p2: c
            };
        }
        static n6(a, b, c) {
            a.ad.p(b, "a");
            let d;
            d = c.s(a.d._z);
            a.ad.h("val", d);
        }
        static k6(a, b, c, d) {
            c = new ST_PositiveCoordinate();
            d = new ST_PositiveCoordinate();
            for (let e of fromEnum(a.ab.u)) {
                switch (e.a.e(a.d)) {
                    case "cx":
                        c = ST_PositiveCoordinate.c(e.d);
                        break;
                    case "cy":
                        d = ST_PositiveCoordinate.c(e.d);
                        break;
                    default: break;
                }
            }
            return {
                p2: c,
                p3: d
            };
        }
        static n7(a, b, c, d) {
            a.ad.p(b, "a");
            let e;
            e = c.toString();
            a.ad.h("cx", e);
            e = d.toString();
            a.ad.h("cy", e);
        }
        static k7(a, b, c, d, e, f) {
            c = ST_Percentage.b(0);
            d = ST_Percentage.b(0);
            e = ST_Percentage.b(0);
            f = ST_Percentage.b(0);
            let g = a.d._z;
            for (let h of fromEnum(a.ab.u)) {
                switch (h.a.e(a.d)) {
                    case "l":
                        c = ST_Percentage.d(h.d, g);
                        break;
                    case "t":
                        d = ST_Percentage.d(h.d, g);
                        break;
                    case "r":
                        e = ST_Percentage.d(h.d, g);
                        break;
                    case "b":
                        f = ST_Percentage.d(h.d, g);
                        break;
                    default: break;
                }
            }
            return {
                p2: c,
                p3: d,
                p4: e,
                p5: f
            };
        }
        static n8(a, b, c, d, e, f) {
            a.ad.p(b, "a");
            let g;
            let h = a.d._z;
            if (ST_Percentage.g(c, ST_Percentage.b(0))) {
                g = c.r(h);
                a.ad.h("l", g);
            }
            if (ST_Percentage.g(d, ST_Percentage.b(0))) {
                g = d.r(h);
                a.ad.h("t", g);
            }
            if (ST_Percentage.g(e, ST_Percentage.b(0))) {
                g = e.r(h);
                a.ad.h("r", g);
            }
            if (ST_Percentage.g(f, ST_Percentage.b(0))) {
                g = f.r(h);
                a.ad.h("b", g);
            }
        }
        static k8(a, b, c) {
            let d = a.ao("idx");
            if (d == null) {
                c = 0;
            }
            else {
                c = parseUInt32_1(d, CultureInfo.invariantCulture);
            }
            return {
                p2: c
            };
        }
        static n9(a, b, c) {
            a.ad.p(b, "a");
            let d;
            d = c.toString();
            a.ad.h("idx", d);
        }
        static k9(a, b, c, d, e, f, g = true) {
            c = null;
            d = null;
            e = toNullable(Number_$type, null);
            f = toNullable(Number_$type, null);
            let h = 1;
            for (let i of fromEnum(a.ab.u)) {
                switch (i.a.e(a.d)) {
                    case "typeface":
                        c = i.d;
                        break;
                    case "panose":
                        d = ST_Panose.b(i.d);
                        break;
                    case "pitchFamily":
                        e = toNullable(Number_$type, parseInt8_1(i.d, CultureInfo.invariantCulture));
                        break;
                    case "charset":
                        f = toNullable(Number_$type, parseInt8_1(i.d, CultureInfo.invariantCulture));
                        break;
                    default: break;
                }
            }
            if (g && f.hasValue == false) {
                f = toNullable(Number_$type, h);
            }
            return {
                p2: c,
                p3: d,
                p4: e,
                p5: f
            };
        }
        static oa(a, b, c, d, e, f) {
            a.ad.p(b, "a");
            let g;
            g = c != null ? c : "";
            a.ad.h("typeface", g);
            if (d != null) {
                g = d.toString();
                a.ad.h("panose", g);
            }
            if (nullableNotEquals(e, null)) {
                g = e.value.toString();
                a.ad.h("pitchFamily", g);
            }
            if (f != 1) {
                g = f.toString();
                a.ad.h("charset", g);
            }
        }
        static kb(a) {
        }
        static nc(a) {
            DrawingMLMain.ny(a, DrawingMLMain.ar);
        }
        static kc(a) {
        }
        static nd(a) {
            DrawingMLMain.ny(a, DrawingMLMain.as);
        }
        static kd(a) {
        }
        static ne(a) {
            DrawingMLMain.ny(a, DrawingMLMain.at);
        }
        static ke(a) {
        }
        static nf(a) {
            DrawingMLMain.ny(a, DrawingMLMain.au);
        }
        static kf(a) {
        }
        static ng(a) {
            DrawingMLMain.ny(a, DrawingMLMain.av);
        }
        static kg(a) {
        }
        static nh(a) {
            DrawingMLMain.ny(a, DrawingMLMain.aw);
        }
        static kh(a, b) {
            let c = DrawingMLMain.k4(a, DrawingMLMain.a2, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static ni(a, b) {
            DrawingMLMain.n5(a, DrawingMLMain.a2, b);
        }
        static ki(a, b) {
            let c = DrawingMLMain.k5(a, DrawingMLMain.a7, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static nj(a, b) {
            DrawingMLMain.n6(a, DrawingMLMain.a7, b);
        }
        static kj(a, b) {
            let c = DrawingMLMain.ky(a, DrawingMLMain.a9, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static nk(a, b) {
            DrawingMLMain.nz(a, DrawingMLMain.a9, b);
        }
        static kk(a) {
        }
        static nl(a) {
            a.ad.p(DrawingMLMain.bh, "a");
        }
        static kl(a, b, c, d, e = true) {
            b = null;
            c = null;
            if (e) {
                d = toNullable(ST_BlipCompression_$type, 0);
            }
            else {
                d = toNullable(ST_BlipCompression_$type, null);
            }
            for (let f of fromEnum(a.ab.u)) {
                switch (f.a.e(a.d)) {
                    case OfficeDocumentRelationships.aq:
                        b = f.d;
                        break;
                    case OfficeDocumentRelationships.at:
                        c = f.d;
                        break;
                    case "cstate":
                        d = toNullable(ST_BlipCompression_$type, XmlNamespaceDefinitionBase.b(ST_BlipCompression_$type, f.d, 0));
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d
            };
        }
        static nm(a, b, c, d) {
            a.ad.p(DrawingMLMain.bt, "a");
            let e;
            e = b;
            a.ad.h(OfficeDocumentRelationships.aq, e);
            e = c;
            a.ad.h(OfficeDocumentRelationships.at, e);
            if (d.hasValue && d.value != 0) {
                e = XmlNamespaceDefinitionBase.p(ST_BlipCompression_$type, d.value);
                a.ad.h("cstate", e);
            }
        }
        static km(a, b, c) {
            b = toNullable(Number_$type, null);
            c = toNullable(Boolean_$type, null);
            for (let d of fromEnum(a.ab.u)) {
                switch (d.a.e(a.d)) {
                    case "dpi":
                        b = toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                        break;
                    case "rotWithShape":
                        c = toNullable(Boolean_$type, ST_OnOff.e(d.d));
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c
            };
        }
        static nn(a, b = toNullable(Number_$type, null), c = toNullable(Boolean_$type, null)) {
            a.ad.p(DrawingMLMain.bu, "a");
            let d;
            if (nullableNotEquals(b, null)) {
                d = b.value.toString();
                a.ad.h("dpi", d);
            }
            if (nullableNotEquals(c, null)) {
                d = ST_OnOff.g(c.value);
                a.ad.h("rotWithShape", d);
            }
        }
        static kn(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.bv, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static no(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.bv, b);
        }
        static ko(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.bw, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static np(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.bw, b);
        }
        static kp(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.bx, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static nq(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.bx, b);
        }
        static kq(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {
            b = toNullable(Number_$type, null);
            c = toNullable(Boolean_$type, null);
            d = toNullable(ST_TextVertOverflowType_$type, null);
            e = toNullable(ST_TextHorzOverflowType_$type, null);
            f = toNullable(ST_TextVerticalType_$type, null);
            g = toNullable(ST_TextWrappingType_$type, null);
            h = toNullable(ST_Coordinate32.$, null);
            i = toNullable(ST_Coordinate32.$, null);
            j = toNullable(ST_Coordinate32.$, null);
            k = toNullable(ST_Coordinate32.$, null);
            l = toNullable(Number_$type, null);
            m = toNullable(Number_$type, null);
            n = toNullable(Boolean_$type, null);
            o = toNullable(Boolean_$type, null);
            p = toNullable(ST_TextAnchoringType_$type, null);
            q = toNullable(Boolean_$type, null);
            r = toNullable(Boolean_$type, null);
            s = false;
            t = toNullable(Boolean_$type, null);
            for (let u of fromEnum(a.ab.u)) {
                switch (u.a.e(a.d)) {
                    case "rot":
                        b = toNullable(Number_$type, parseInt32_1(u.d, CultureInfo.invariantCulture));
                        break;
                    case "spcFirstLastPara":
                        c = toNullable(Boolean_$type, ST_OnOff.e(u.d));
                        break;
                    case "vertOverflow":
                        d = toNullable(ST_TextVertOverflowType_$type, XmlNamespaceDefinitionBase.b(ST_TextVertOverflowType_$type, u.d));
                        break;
                    case "horzOverflow":
                        e = toNullable(ST_TextHorzOverflowType_$type, XmlNamespaceDefinitionBase.b(ST_TextHorzOverflowType_$type, u.d));
                        break;
                    case "vert":
                        f = toNullable(ST_TextVerticalType_$type, XmlNamespaceDefinitionBase.b(ST_TextVerticalType_$type, u.d));
                        break;
                    case "wrap":
                        g = toNullable(ST_TextWrappingType_$type, XmlNamespaceDefinitionBase.b(ST_TextWrappingType_$type, u.d));
                        break;
                    case "lIns":
                        h = toNullable(ST_Coordinate32.$, ST_Coordinate32.g(u.d));
                        break;
                    case "tIns":
                        i = toNullable(ST_Coordinate32.$, ST_Coordinate32.g(u.d));
                        break;
                    case "rIns":
                        j = toNullable(ST_Coordinate32.$, ST_Coordinate32.g(u.d));
                        break;
                    case "bIns":
                        k = toNullable(ST_Coordinate32.$, ST_Coordinate32.g(u.d));
                        break;
                    case "numCol":
                        l = toNullable(Number_$type, parseInt32_1(u.d, CultureInfo.invariantCulture));
                        break;
                    case "spcCol":
                        m = toNullable(Number_$type, parseInt32_1(u.d, CultureInfo.invariantCulture));
                        break;
                    case "rtlCol":
                        n = toNullable(Boolean_$type, ST_OnOff.e(u.d));
                        break;
                    case "fromWordArt":
                        o = toNullable(Boolean_$type, ST_OnOff.e(u.d));
                        break;
                    case "anchor":
                        p = toNullable(ST_TextAnchoringType_$type, XmlNamespaceDefinitionBase.b(ST_TextAnchoringType_$type, u.d));
                        break;
                    case "anchorCtr":
                        q = toNullable(Boolean_$type, ST_OnOff.e(u.d));
                        break;
                    case "forceAA":
                        r = toNullable(Boolean_$type, ST_OnOff.e(u.d));
                        break;
                    case "upright":
                        s = ST_OnOff.e(u.d);
                        break;
                    case "compatLnSpc":
                        t = toNullable(Boolean_$type, ST_OnOff.e(u.d));
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i,
                p9: j,
                p10: k,
                p11: l,
                p12: m,
                p13: n,
                p14: o,
                p15: p,
                p16: q,
                p17: r,
                p18: s,
                p19: t
            };
        }
        static nr(a, b = toNullable(Number_$type, null), c = toNullable(Boolean_$type, null), d = toNullable(ST_TextVertOverflowType_$type, null), e = toNullable(ST_TextHorzOverflowType_$type, null), f = toNullable(ST_TextVerticalType_$type, null), g = toNullable(ST_TextWrappingType_$type, null), h = toNullable(ST_Coordinate32.$, null), i = toNullable(ST_Coordinate32.$, null), j = toNullable(ST_Coordinate32.$, null), k = toNullable(ST_Coordinate32.$, null), l = toNullable(Number_$type, null), m = toNullable(Number_$type, null), n = toNullable(Boolean_$type, null), o = toNullable(Boolean_$type, null), p = toNullable(ST_TextAnchoringType_$type, null), q = toNullable(Boolean_$type, null), r = toNullable(Boolean_$type, null), s = false, t = toNullable(Boolean_$type, null)) {
            a.ad.p(DrawingMLMain.b0, "a");
            let u;
            if (nullableNotEquals(b, null)) {
                u = b.value.toString();
                a.ad.h("rot", u);
            }
            if (nullableNotEquals(c, null)) {
                u = ST_OnOff.g(c.value);
                a.ad.h("spcFirstLastPara", u);
            }
            if (nullableNotEquals(d, null)) {
                u = XmlNamespaceDefinitionBase.p(ST_TextVertOverflowType_$type, d.value);
                a.ad.h("vertOverflow", u);
            }
            if (nullableNotEquals(e, null)) {
                u = XmlNamespaceDefinitionBase.p(ST_TextHorzOverflowType_$type, e.value);
                a.ad.h("horzOverflow", u);
            }
            if (nullableNotEquals(f, null)) {
                u = XmlNamespaceDefinitionBase.p(ST_TextVerticalType_$type, f.value);
                a.ad.h("vert", u);
            }
            if (nullableNotEquals(g, null)) {
                u = XmlNamespaceDefinitionBase.p(ST_TextWrappingType_$type, g.value);
                a.ad.h("wrap", u);
            }
            if (nullableNotEquals(h, null)) {
                u = h.value.toString();
                a.ad.h("lIns", u);
            }
            if (nullableNotEquals(i, null)) {
                u = i.value.toString();
                a.ad.h("tIns", u);
            }
            if (nullableNotEquals(j, null)) {
                u = j.value.toString();
                a.ad.h("rIns", u);
            }
            if (nullableNotEquals(k, null)) {
                u = k.value.toString();
                a.ad.h("bIns", u);
            }
            if (nullableNotEquals(l, null)) {
                u = l.value.toString();
                a.ad.h("numCol", u);
            }
            if (nullableNotEquals(m, null)) {
                u = m.value.toString();
                a.ad.h("spcCol", u);
            }
            if (nullableNotEquals(n, null)) {
                u = ST_OnOff.g(n.value);
                a.ad.h("rtlCol", u);
            }
            if (nullableNotEquals(o, null)) {
                u = ST_OnOff.g(o.value);
                a.ad.h("fromWordArt", u);
            }
            if (nullableNotEquals(p, null)) {
                u = XmlNamespaceDefinitionBase.p(ST_TextAnchoringType_$type, p.value);
                a.ad.h("anchor", u);
            }
            if (nullableNotEquals(q, null)) {
                u = ST_OnOff.g(q.value);
                a.ad.h("anchorCtr", u);
            }
            if (nullableNotEquals(r, null)) {
                u = ST_OnOff.g(r.value);
                a.ad.h("forceAA", u);
            }
            if (s != false) {
                u = ST_OnOff.g(s);
                a.ad.h("upright", u);
            }
            if (nullableNotEquals(t, null)) {
                u = ST_OnOff.g(t.value);
                a.ad.h("compatLnSpc", u);
            }
        }
        static kr(a, b, c) {
            let d = DrawingMLMain.k6(a, DrawingMLMain.ch, b, c);
            b = d.p2;
            c = d.p3;
            return {
                p1: b,
                p2: c
            };
        }
        static ns(a, b, c) {
            DrawingMLMain.n7(a, DrawingMLMain.ch, b, c);
        }
        static ks(a, b, c) {
            let d = DrawingMLMain.k2(a, DrawingMLMain.ci, b, c);
            b = d.p2;
            c = d.p3;
            return {
                p1: b,
                p2: c
            };
        }
        static nt(a, b, c) {
            DrawingMLMain.n3(a, DrawingMLMain.ci, b, c);
        }
        static kt(a, b) {
            b = a.ao("name");
            return {
                p1: b
            };
        }
        static nu(a, b) {
            a.ad.p(DrawingMLMain.cn, "a");
            let c;
            c = b;
            a.ad.h("name", c);
        }
        static ku(a) {
        }
        static nv(a) {
            a.ad.p(DrawingMLMain.cq, "a");
        }
        static kv(a, b, c, d, e, f = true) {
            let g = DrawingMLMain.k9(a, DrawingMLMain.cu, b, c, d, e);
            b = g.p2;
            c = g.p3;
            d = g.p4;
            e = g.p5;
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e
            };
        }
        static nw(a, b, c = null, d = toNullable(Number_$type, null), e = 1) {
            DrawingMLMain.oa(a, DrawingMLMain.cu, b, c, d, e);
        }
        static la(a, b) {
            let c = a.ao("name");
            if (c == null) {
                b = "";
            }
            else {
                b = c;
            }
            return {
                p1: b
            };
        }
        static ob(a, b = "") {
            a.ad.p(DrawingMLMain.cx, "a");
            let c;
            if (b != "") {
                c = b;
                a.ad.h("name", c);
            }
        }
        static lb(a) {
        }
        static oc(a) {
            a.ad.p(DrawingMLMain.cy, "a");
        }
        static lc(a) {
        }
        static od(a) {
            DrawingMLMain.ny(a, DrawingMLMain.da);
        }
        static ld(a) {
        }
        static oe(a) {
            DrawingMLMain.ny(a, DrawingMLMain.db);
        }
        static le(a, b, c, d, e) {
            let f = toNullable(Number_$type, null);
            let g = DrawingMLMain.k9(a, DrawingMLMain.df, b, c, d, f);
            b = g.p2;
            c = g.p3;
            d = g.p4;
            f = g.p5;
            e = f.hasValue ? f.value : 1;
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e
            };
        }
        static of(a, b, c = null, d = toNullable(Number_$type, null), e = 1) {
            DrawingMLMain.oa(a, DrawingMLMain.df, b, c, d, e);
        }
        static lf(a, b) {
            let c = DrawingMLMain.k8(a, DrawingMLMain.dk, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static og(a, b) {
            DrawingMLMain.n9(a, DrawingMLMain.dk, b);
        }
        static lg(a, b, c) {
            let d = DrawingMLMain.k6(a, DrawingMLMain.dr, b, c);
            b = d.p2;
            c = d.p3;
            return {
                p1: b,
                p2: c
            };
        }
        static oh(a, b, c) {
            DrawingMLMain.n7(a, DrawingMLMain.dr, b, c);
        }
        static lh(a) {
        }
        static oi(a) {
            a.ad.p(DrawingMLMain.ds, "a");
        }
        static li(a) {
        }
        static oj(a) {
            a.ad.p(DrawingMLMain.dt, "a");
        }
        static lj(a) {
        }
        static ok(a) {
            a.ad.p(DrawingMLMain.du, "a");
        }
        static lk(a, b, c, d, e) {
            let f = DrawingMLMain.k7(a, DrawingMLMain.dz, b, c, d, e);
            b = f.p2;
            c = f.p3;
            d = f.p4;
            e = f.p5;
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e
            };
        }
        static ol(a, b, c, d, e) {
            DrawingMLMain.n8(a, DrawingMLMain.dz, b, c, d, e);
        }
        static ll(a, b) {
            let c = DrawingMLMain.k8(a, DrawingMLMain.d0, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static om(a, b) {
            DrawingMLMain.n9(a, DrawingMLMain.d0, b);
        }
        static lm(a) {
        }
        static on(a) {
            DrawingMLMain.ny(a, DrawingMLMain.d9);
        }
        static ln(a, b, c) {
            b = null;
            c = null;
            for (let d of fromEnum(a.ab.u)) {
                switch (d.a.e(a.d)) {
                    case "script":
                        b = d.d;
                        break;
                    case "typeface":
                        c = d.d;
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c
            };
        }
        static oo(a, b, c) {
            a.ad.p(DrawingMLMain.ea, "a");
            let d;
            d = b;
            a.ad.h("script", d);
            d = c;
            a.ad.h("typeface", d);
        }
        static lo(a, b) {
            b = 0;
            let c = a.ao("idx");
            if (c != null) {
                b = XmlNamespaceDefinitionBase.b(ST_FontCollectionIndex_$type, c, b);
            }
            return {
                p1: b
            };
        }
        static op(a, b) {
            a.ad.p(DrawingMLMain.ec, "a");
            let c;
            c = XmlNamespaceDefinitionBase.p(ST_FontCollectionIndex_$type, b);
            a.ad.h("idx", c);
        }
        static lp(a, b) {
            b = a.ao("name");
            return {
                p1: b
            };
        }
        static oq(a, b) {
            a.ad.p(DrawingMLMain.ed, "a");
            let c;
            c = b;
            a.ad.h("name", c);
        }
        static lq(a, b, c) {
            b = null;
            c = null;
            for (let d of fromEnum(a.ab.u)) {
                switch (d.a.e(a.d)) {
                    case "name":
                        b = d.d;
                        break;
                    case "fmla":
                        c = d.d;
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c
            };
        }
        static or(a, b, c) {
            a.ad.p(DrawingMLMain.eh, "a");
            let d;
            d = b;
            a.ad.h("name", d);
            d = c;
            a.ad.h("fmla", d);
        }
        static lr(a, b) {
            b = a.ao("uri");
            return {
                p1: b
            };
        }
        static os(a, b) {
            a.ad.p(DrawingMLMain.em, "a");
            let c;
            c = b;
            a.ad.h("uri", c);
        }
        static ls(a) {
        }
        static ot(a) {
            a.ad.p(DrawingMLMain.el, "a");
        }
        static lt(a, b, c, d, e, f, g) {
            b = false;
            c = false;
            d = false;
            e = false;
            f = false;
            g = false;
            for (let h of fromEnum(a.ab.u)) {
                switch (h.a.e(a.d)) {
                    case "noGrp":
                        b = ST_OnOff.e(h.d);
                        break;
                    case "noDrilldown":
                        c = ST_OnOff.e(h.d);
                        break;
                    case "noSelect":
                        d = ST_OnOff.e(h.d);
                        break;
                    case "noChangeAspect":
                        e = ST_OnOff.e(h.d);
                        break;
                    case "noMove":
                        f = ST_OnOff.e(h.d);
                        break;
                    case "noResize":
                        g = ST_OnOff.e(h.d);
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g
            };
        }
        static ou(a, b = false, c = false, d = false, e = false, f = false, g = false) {
            a.ad.p(DrawingMLMain.en, "a");
            let h;
            if (b != false) {
                h = ST_OnOff.g(b);
                a.ad.h("noGrp", h);
            }
            if (c != false) {
                h = ST_OnOff.g(c);
                a.ad.h("noDrilldown", h);
            }
            if (d != false) {
                h = ST_OnOff.g(d);
                a.ad.h("noSelect", h);
            }
            if (e != false) {
                h = ST_OnOff.g(e);
                a.ad.h("noChangeAspect", h);
            }
            if (f != false) {
                h = ST_OnOff.g(f);
                a.ad.h("noMove", h);
            }
            if (g != false) {
                h = ST_OnOff.g(g);
                a.ad.h("noResize", h);
            }
        }
        static lu(a) {
        }
        static ov(a) {
            a.ad.p(DrawingMLMain.eo, "a");
        }
        static lv(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.eq, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static ow(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.eq, b);
        }
        static lw(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.er, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static ox(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.er, b);
        }
        static lx(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.es, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static oy(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.es, b);
        }
        static ly(a) {
        }
        static oz(a) {
            a.ad.p(DrawingMLMain.et, "a");
        }
        static lz(a, b, c, d) {
            let e = DrawingMLMain.kz(a, DrawingMLMain.ex, b, c, d);
            b = e.p2;
            c = e.p3;
            d = e.p4;
            return {
                p1: b,
                p2: c,
                p3: d
            };
        }
        static o0(a, b, c, d) {
            DrawingMLMain.n0(a, DrawingMLMain.ex, b, c, d);
        }
        static l0(a, b, c, d, e, f, g, h, i) {
            b = null;
            c = "";
            d = "";
            e = "";
            f = "";
            g = true;
            h = false;
            i = false;
            for (let j of fromEnum(a.ab.u)) {
                switch (j.a.e(a.d)) {
                    case OfficeDocumentRelationships.as:
                        b = j.d;
                        break;
                    case "invalidUrl":
                        c = j.d;
                        break;
                    case "action":
                        d = j.d;
                        break;
                    case "tgtFrame":
                        e = j.d;
                        break;
                    case "tooltip":
                        f = j.d;
                        break;
                    case "history":
                        g = ST_OnOff.e(j.d);
                        break;
                    case "highlightClick":
                        h = ST_OnOff.e(j.d);
                        break;
                    case "endSnd":
                        i = ST_OnOff.e(j.d);
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i
            };
        }
        static o1(a, b = null, c = "", d = "", e = "", f = "", g = true, h = false, i = false) {
            a.ad.p(DrawingMLMain.e3, "a");
            let j;
            j = b;
            a.ad.h(OfficeDocumentRelationships.as, j);
            j = c;
            a.ad.h("invalidUrl", j);
            j = d;
            a.ad.h("action", j);
            j = e;
            a.ad.h("tgtFrame", j);
            j = f;
            a.ad.h("tooltip", j);
            if (g != true) {
                j = ST_OnOff.g(g);
                a.ad.h("history", j);
            }
            if (h != false) {
                j = ST_OnOff.g(h);
                a.ad.h("highlightClick", j);
            }
            if (i != false) {
                j = ST_OnOff.g(i);
                a.ad.h("endSnd", j);
            }
        }
        static l1(a) {
        }
        static o2(a) {
            DrawingMLMain.ny(a, DrawingMLMain.e2);
        }
        static l2(a, b) {
            let c = DrawingMLMain.k3(a, DrawingMLMain.e9, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static o3(a, b) {
            DrawingMLMain.n4(a, DrawingMLMain.e9, b);
        }
        static l3(a, b) {
            let c = DrawingMLMain.k5(a, DrawingMLMain.fa, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static o4(a, b) {
            DrawingMLMain.n6(a, DrawingMLMain.fa, b);
        }
        static l4(a, b) {
            let c = DrawingMLMain.kw(a, DrawingMLMain.fb, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static o5(a, b) {
            DrawingMLMain.nx(a, DrawingMLMain.fb, b);
        }
        static l5(a) {
        }
        static o6(a) {
            a.ad.p(DrawingMLMain.fh, "a");
        }
        static l6(a, b, c, d, e) {
            let f = toNullable(Number_$type, null);
            let g = DrawingMLMain.k9(a, DrawingMLMain.fr, b, c, d, f);
            b = g.p2;
            c = g.p3;
            d = g.p4;
            f = g.p5;
            e = f.hasValue ? f.value : 1;
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e
            };
        }
        static o7(a, b, c = null, d = toNullable(Number_$type, null), e = 1) {
            DrawingMLMain.oa(a, DrawingMLMain.fr, b, c, d, e);
        }
        static l7(a, b, c, d, e) {
            b = toNullable(ST_LineWidth.$, null);
            c = toNullable(ST_LineCap_$type, null);
            d = toNullable(ST_CompoundLine_$type, null);
            e = toNullable(ST_PenAlignment_$type, null);
            for (let f of fromEnum(a.ab.u)) {
                switch (f.a.e(a.d)) {
                    case "w":
                        b = toNullable(ST_LineWidth.$, ST_LineWidth.f(f.d));
                        break;
                    case "cap":
                        c = toNullable(ST_LineCap_$type, XmlNamespaceDefinitionBase.b(ST_LineCap_$type, f.d));
                        break;
                    case "cmpd":
                        d = toNullable(ST_CompoundLine_$type, XmlNamespaceDefinitionBase.b(ST_CompoundLine_$type, f.d));
                        break;
                    case "algn":
                        e = toNullable(ST_PenAlignment_$type, XmlNamespaceDefinitionBase.b(ST_PenAlignment_$type, f.d));
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e
            };
        }
        static o8(a, b, c, d, e) {
            a.ad.p(DrawingMLMain.fx, "a");
            let f;
            if (ST_LineWidth.j(b, toNullable(ST_LineWidth.$, null))) {
                f = b.toString();
                a.ad.h("w", f);
            }
            if (nullableNotEquals(c, null)) {
                f = XmlNamespaceDefinitionBase.p(ST_LineCap_$type, c.value);
                a.ad.h("cap", f);
            }
            if (nullableNotEquals(d, null)) {
                f = XmlNamespaceDefinitionBase.p(ST_CompoundLine_$type, d.value);
                a.ad.h("cmpd", f);
            }
            if (nullableNotEquals(e, null)) {
                f = XmlNamespaceDefinitionBase.p(ST_PenAlignment_$type, e.value);
                a.ad.h("algn", f);
            }
        }
        static l8(a, b) {
            let c = DrawingMLMain.k8(a, DrawingMLMain.fy, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static o9(a, b) {
            DrawingMLMain.n9(a, DrawingMLMain.fy, b);
        }
        static l9(a) {
        }
        static pa(a) {
            a.ad.p(DrawingMLMain.f2, "a");
        }
        static ma(a) {
        }
        static pb(a) {
            DrawingMLMain.ny(a, DrawingMLMain.f3);
        }
        static mb(a) {
        }
        static pc(a) {
            DrawingMLMain.ny(a, DrawingMLMain.f4);
        }
        static mc(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.f5, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static pd(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.f5, b);
        }
        static md(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.f6, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static pe(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.f6, b);
        }
        static me(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.f7, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static pf(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.f7, b);
        }
        static mf(a) {
        }
        static pg(a) {
            a.ad.p(DrawingMLMain.gi, "a");
        }
        static mg(a) {
        }
        static ph(a) {
            a.ad.p(DrawingMLMain.gl, "a");
        }
        static mh(a) {
        }
        static pi(a) {
            a.ad.p(DrawingMLMain.gz, "a");
        }
        static mi(a) {
        }
        static pj(a) {
            a.ad.p(DrawingMLMain.hb, "a");
        }
        static mj(a, b, c) {
            let d = DrawingMLMain.k2(a, DrawingMLMain.hc, b, c);
            b = d.p2;
            c = d.p3;
            return {
                p1: b,
                p2: c
            };
        }
        static pk(a, b, c) {
            DrawingMLMain.n3(a, DrawingMLMain.hc, b, c);
        }
        static mk(a) {
        }
        static pl(a) {
            a.ad.p(DrawingMLMain.he, "a");
        }
        static ml(a, b, c, d, e, f, g, h, i, j, k, l) {
            b = false;
            c = false;
            d = false;
            e = false;
            f = false;
            g = false;
            h = false;
            i = false;
            j = false;
            k = false;
            l = false;
            for (let m of fromEnum(a.ab.u)) {
                switch (m.a.e(a.d)) {
                    case "noGrp":
                        b = ST_OnOff.e(m.d);
                        break;
                    case "noSelect":
                        c = ST_OnOff.e(m.d);
                        break;
                    case "noRot":
                        d = ST_OnOff.e(m.d);
                        break;
                    case "noChangeAspect":
                        e = ST_OnOff.e(m.d);
                        break;
                    case "noMove":
                        f = ST_OnOff.e(m.d);
                        break;
                    case "noResize":
                        g = ST_OnOff.e(m.d);
                        break;
                    case "noEditPoints":
                        h = ST_OnOff.e(m.d);
                        break;
                    case "noAdjustHandles":
                        i = ST_OnOff.e(m.d);
                        break;
                    case "noChangeArrowheads":
                        j = ST_OnOff.e(m.d);
                        break;
                    case "noChangeShapeType":
                        k = ST_OnOff.e(m.d);
                        break;
                    case "noCrop":
                        l = ST_OnOff.e(m.d);
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i,
                p9: j,
                p10: k,
                p11: l
            };
        }
        static pm(a, b = false, c = false, d = false, e = false, f = false, g = false, h = false, i = false, j = false, k = false, l = false) {
            a.ad.p(DrawingMLMain.hj, "a");
            let m;
            if (b != false) {
                m = ST_OnOff.g(b);
                a.ad.h("noGrp", m);
            }
            if (c != false) {
                m = ST_OnOff.g(c);
                a.ad.h("noSelect", m);
            }
            if (d != false) {
                m = ST_OnOff.g(d);
                a.ad.h("noRot", m);
            }
            if (e != false) {
                m = ST_OnOff.g(e);
                a.ad.h("noChangeAspect", m);
            }
            if (f != false) {
                m = ST_OnOff.g(f);
                a.ad.h("noMove", m);
            }
            if (g != false) {
                m = ST_OnOff.g(g);
                a.ad.h("noResize", m);
            }
            if (h != false) {
                m = ST_OnOff.g(h);
                a.ad.h("noEditPoints", m);
            }
            if (i != false) {
                m = ST_OnOff.g(i);
                a.ad.h("noAdjustHandles", m);
            }
            if (j != false) {
                m = ST_OnOff.g(j);
                a.ad.h("noChangeArrowheads", m);
            }
            if (k != false) {
                m = ST_OnOff.g(k);
                a.ad.h("noChangeShapeType", m);
            }
            if (l != false) {
                m = ST_OnOff.g(l);
                a.ad.h("noCrop", m);
            }
        }
        static mm(a, b, c, d, e, f, g, h, i, j, k, l) {
            b = toNullable(ST_TextMargin.$, null);
            c = toNullable(ST_TextMargin.$, null);
            d = toNullable(ST_TextIndentLevelType.$, null);
            e = toNullable(ST_TextIndent.$, null);
            f = toNullable(ST_TextAlignType_$type, null);
            g = toNullable(ST_Coordinate32.$, null);
            h = toNullable(Boolean_$type, null);
            i = toNullable(Boolean_$type, null);
            j = toNullable(ST_TextFontAlignType_$type, null);
            k = toNullable(Boolean_$type, null);
            l = toNullable(Boolean_$type, null);
            for (let m of fromEnum(a.ab.u)) {
                switch (m.a.e(a.d)) {
                    case "marL":
                        b = toNullable(ST_TextMargin.$, ST_TextMargin.c(m.d));
                        break;
                    case "marR":
                        c = toNullable(ST_TextMargin.$, ST_TextMargin.c(m.d));
                        break;
                    case "lvl":
                        d = toNullable(ST_TextIndentLevelType.$, ST_TextIndentLevelType.c(m.d));
                        break;
                    case "indent":
                        e = toNullable(ST_TextIndent.$, ST_TextIndent.c(m.d));
                        break;
                    case "algn":
                        f = toNullable(ST_TextAlignType_$type, XmlNamespaceDefinitionBase.b(ST_TextAlignType_$type, m.d));
                        break;
                    case "defTabSz":
                        g = toNullable(ST_Coordinate32.$, ST_Coordinate32.g(m.d));
                        break;
                    case "rtl":
                        h = toNullable(Boolean_$type, ST_OnOff.e(m.d));
                        break;
                    case "eaLnBrk":
                        i = toNullable(Boolean_$type, ST_OnOff.e(m.d));
                        break;
                    case "fontAlgn":
                        j = toNullable(ST_TextFontAlignType_$type, XmlNamespaceDefinitionBase.b(ST_TextFontAlignType_$type, m.d));
                        break;
                    case "latinLnBrk":
                        k = toNullable(Boolean_$type, ST_OnOff.e(m.d));
                        break;
                    case "hangingPunct":
                        l = toNullable(Boolean_$type, ST_OnOff.e(m.d));
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i,
                p9: j,
                p10: k,
                p11: l
            };
        }
        static pn(a, b = toNullable(ST_TextMargin.$, null), c = toNullable(ST_TextMargin.$, null), d = toNullable(ST_TextIndentLevelType.$, null), e = toNullable(ST_TextIndent.$, null), f = toNullable(ST_TextAlignType_$type, null), g = toNullable(ST_Coordinate32.$, null), h = toNullable(Boolean_$type, null), i = toNullable(Boolean_$type, null), j = toNullable(ST_TextFontAlignType_$type, null), k = toNullable(Boolean_$type, null), l = toNullable(Boolean_$type, null)) {
            a.ad.p(DrawingMLMain.hm, "a");
            let m;
            if (nullableNotEquals(b, null)) {
                m = b.value.toString();
                a.ad.h("marL", m);
            }
            if (nullableNotEquals(c, null)) {
                m = c.value.toString();
                a.ad.h("marR", m);
            }
            if (nullableNotEquals(d, null)) {
                m = d.value.toString();
                a.ad.h("lvl", m);
            }
            if (nullableNotEquals(e, null)) {
                m = e.value.toString();
                a.ad.h("indent", m);
            }
            if (nullableNotEquals(f, null)) {
                m = XmlNamespaceDefinitionBase.p(ST_TextAlignType_$type, f.value);
                a.ad.h("algn", m);
            }
            if (nullableNotEquals(g, null)) {
                m = g.value.toString();
                a.ad.h("defTabSz", m);
            }
            if (nullableNotEquals(h, null)) {
                m = ST_OnOff.g(h.value);
                a.ad.h("rtl", m);
            }
            if (nullableNotEquals(i, null)) {
                m = ST_OnOff.g(i.value);
                a.ad.h("eaLnBrk", m);
            }
            if (nullableNotEquals(j, null)) {
                m = XmlNamespaceDefinitionBase.p(ST_TextFontAlignType_$type, j.value);
                a.ad.h("fontAlgn", m);
            }
            if (nullableNotEquals(k, null)) {
                m = ST_OnOff.g(k.value);
                a.ad.h("latinLnBrk", m);
            }
            if (nullableNotEquals(l, null)) {
                m = ST_OnOff.g(l.value);
                a.ad.h("hangingPunct", m);
            }
        }
        static mn(a, b) {
            b = 7;
            let c = a.ao("val");
            if (c != null) {
                b = XmlNamespaceDefinitionBase.b(ST_PresetColorVal_$type, c, b);
            }
            return {
                p1: b
            };
        }
        static po(a, b) {
            a.ad.p(DrawingMLMain.ho, "a");
            let c;
            c = XmlNamespaceDefinitionBase.p(ST_PresetColorVal_$type, b);
            a.ad.h("val", c);
        }
        static mo(a, b) {
            let c = a.ao("prst");
            b = 0;
            if (c != null) {
                b = XmlNamespaceDefinitionBase.b(ST_ShapeType_$type, c, b);
            }
            return {
                p1: b
            };
        }
        static pp(a, b) {
            a.ad.p(DrawingMLMain.hq, "a");
            let c;
            c = XmlNamespaceDefinitionBase.p(ST_ShapeType_$type, b);
            a.ad.h("prst", c);
        }
        static mp(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.hy, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static pq(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.hy, b);
        }
        static mq(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.hz, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static pr(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.hz, b);
        }
        static mr(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.h0, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static ps(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.h0, b);
        }
        static ms(a) {
        }
        static pt(a) {
            a.ad.p(DrawingMLMain.hv, "a");
        }
        static mt(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = DrawingMLMain.h8, v = true) {
            b = toNullable(Boolean_$type, null);
            c = null;
            d = null;
            e = toNullable(ST_TextFontSize.$, null);
            f = toNullable(Boolean_$type, null);
            g = toNullable(Boolean_$type, null);
            h = toNullable(ST_TextUnderlineType_$type, null);
            i = toNullable(ST_TextStrikeType_$type, null);
            j = toNullable(Number_$type, null);
            k = toNullable(ST_TextCapsType_$type, null);
            l = toNullable(ST_TextPoint.$, null);
            m = toNullable(Boolean_$type, null);
            n = toNullable(ST_Percentage.$, null);
            o = toNullable(Boolean_$type, null);
            p = toNullable(Boolean_$type, null);
            q = toNullable(Boolean_$type, null);
            r = toNullable(Boolean_$type, null);
            s = toNullable(Number_$type, null);
            let w = true;
            let x = false;
            let y = true;
            let z = 0;
            t = null;
            for (let aa of fromEnum(a.ab.u)) {
                switch (aa.a.e(a.d)) {
                    case "kumimoji":
                        b = toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                        break;
                    case "lang":
                        c = aa.d;
                        break;
                    case "altLang":
                        d = aa.d;
                        break;
                    case "sz":
                        e = toNullable(ST_TextFontSize.$, ST_TextFontSize.c(aa.d));
                        break;
                    case "b":
                        f = toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                        break;
                    case "i":
                        g = toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                        break;
                    case "u":
                        h = toNullable(ST_TextUnderlineType_$type, XmlNamespaceDefinitionBase.b(ST_TextUnderlineType_$type, aa.d));
                        break;
                    case "strike":
                        i = toNullable(ST_TextStrikeType_$type, XmlNamespaceDefinitionBase.b(ST_TextStrikeType_$type, aa.d));
                        break;
                    case "kern":
                        j = toNullable(Number_$type, parseInt32_1(aa.d, CultureInfo.invariantCulture));
                        break;
                    case "cap":
                        k = toNullable(ST_TextCapsType_$type, XmlNamespaceDefinitionBase.b(ST_TextCapsType_$type, aa.d));
                        break;
                    case "spc":
                        l = toNullable(ST_TextPoint.$, ST_TextPoint.a(aa.d));
                        break;
                    case "normalizeH":
                        m = toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                        break;
                    case "baseline":
                        n = toNullable(ST_Percentage.$, ST_Percentage.d(aa.d, a.d._z));
                        break;
                    case "noProof":
                        o = toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                        break;
                    case "dirty":
                        p = toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                        break;
                    case "err":
                        q = toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                        break;
                    case "smtClean":
                        r = toNullable(Boolean_$type, ST_OnOff.e(aa.d));
                        break;
                    case "smtId":
                        s = toNullable(Number_$type, parseUInt32_1(aa.d, CultureInfo.invariantCulture));
                        break;
                    case "bmk":
                        t = aa.d;
                        break;
                    default: break;
                }
                if (v) {
                    if (p.hasValue == false) {
                        p = toNullable(Boolean_$type, w);
                    }
                    if (q.hasValue == false) {
                        q = toNullable(Boolean_$type, x);
                    }
                    if (r.hasValue == false) {
                        r = toNullable(Boolean_$type, y);
                    }
                    if (s.hasValue == false) {
                        s = toNullable(Number_$type, z);
                    }
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i,
                p9: j,
                p10: k,
                p11: l,
                p12: m,
                p13: n,
                p14: o,
                p15: p,
                p16: q,
                p17: r,
                p18: s,
                p19: t
            };
        }
        static pu(a, b = toNullable(Boolean_$type, null), c = null, d = null, e = toNullable(ST_TextFontSize.$, null), f = toNullable(Boolean_$type, null), g = toNullable(Boolean_$type, null), h = toNullable(ST_TextUnderlineType_$type, null), i = toNullable(ST_TextStrikeType_$type, null), j = toNullable(Number_$type, null), k = toNullable(ST_TextCapsType_$type, null), l = toNullable(ST_TextPoint.$, null), m = toNullable(Boolean_$type, null), n = toNullable(ST_Percentage.$, null), o = toNullable(Boolean_$type, null), p = toNullable(Boolean_$type, true), q = toNullable(Boolean_$type, false), r = toNullable(Boolean_$type, true), s = toNullable(Number_$type, 0), t = null) {
            a.ad.p(DrawingMLMain.h8, "a");
            let u;
            if (nullableNotEquals(b, null)) {
                u = ST_OnOff.g(b.value);
                a.ad.h("kumimoji", u);
            }
            u = c;
            a.ad.h("lang", u);
            u = d;
            a.ad.h("altLang", u);
            if (nullableNotEquals(e, null)) {
                u = e.value.toString();
                a.ad.h("sz", u);
            }
            if (nullableNotEquals(f, null)) {
                u = ST_OnOff.g(f.value);
                a.ad.h("b", u);
            }
            if (nullableNotEquals(g, null)) {
                u = ST_OnOff.g(g.value);
                a.ad.h("i", u);
            }
            if (nullableNotEquals(h, null)) {
                u = XmlNamespaceDefinitionBase.p(ST_TextUnderlineType_$type, h.value);
                a.ad.h("u", u);
            }
            if (nullableNotEquals(i, null)) {
                u = XmlNamespaceDefinitionBase.p(ST_TextStrikeType_$type, i.value);
                a.ad.h("strike", u);
            }
            if (nullableNotEquals(j, null)) {
                u = j.value.toString();
                a.ad.h("kern", u);
            }
            if (nullableNotEquals(k, null)) {
                u = XmlNamespaceDefinitionBase.p(ST_TextCapsType_$type, k.value);
                a.ad.h("cap", u);
            }
            if (nullableNotEquals(l, null)) {
                u = l.value.toString();
                a.ad.h("spc", u);
            }
            if (nullableNotEquals(m, null)) {
                u = ST_OnOff.g(m.value);
                a.ad.h("normalizeH", u);
            }
            if (ST_Percentage.h(n, toNullable(ST_Percentage.$, null))) {
                u = n.value.r(a.d._z);
                a.ad.h("baseline", u);
            }
            if (nullableNotEquals(o, null)) {
                u = ST_OnOff.g(o.value);
                a.ad.h("noProof", u);
            }
            if (p.hasValue && nullableNotEquals(p, true)) {
                u = ST_OnOff.g(p.value);
                a.ad.h("dirty", u);
            }
            if (q.hasValue && nullableNotEquals(q, false)) {
                u = ST_OnOff.g(q.value);
                a.ad.h("err", u);
            }
            if (r.hasValue && nullableNotEquals(r, true)) {
                u = ST_OnOff.g(r.value);
                a.ad.h("smtClean", u);
            }
            if (s.hasValue && nullableNotEquals(s, 0)) {
                u = s.value.toString();
                a.ad.h("smtId", u);
            }
            u = t;
            a.ad.h("bmk", u);
        }
        static mu(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.ib, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static pv(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.ib, b);
        }
        static mv(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.ic, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static pw(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.ic, b);
        }
        static mw(a, b) {
            let c = DrawingMLMain.k1(a, DrawingMLMain.id, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static px(a, b) {
            DrawingMLMain.n2(a, DrawingMLMain.id, b);
        }
        static mx(a, b) {
            let c = a.ao("val");
            if (c == null) {
                b = 0;
            }
            else {
                b = XmlNamespaceDefinitionBase.b(ST_SchemeColorVal_$type, c, 0);
            }
            return {
                p1: b
            };
        }
        static py(a, b) {
            a.ad.p(DrawingMLMain.ig, "a");
            let c;
            c = XmlNamespaceDefinitionBase.p(ST_SchemeColorVal_$type, b);
            a.ad.h("val", c);
        }
        static my(a, b) {
            let c = DrawingMLMain.k4(a, DrawingMLMain.ij, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static pz(a, b) {
            DrawingMLMain.n5(a, DrawingMLMain.ij, b);
        }
        static mz(a) {
        }
        static p0(a) {
            a.ad.p(DrawingMLMain.ip, "a");
        }
        static m0(a, b, c, d, e, f, g, h, i, j, k, l) {
            b = false;
            c = false;
            d = false;
            e = false;
            f = false;
            g = false;
            h = false;
            i = false;
            j = false;
            k = false;
            l = false;
            for (let m of fromEnum(a.ab.u)) {
                switch (m.a.e(a.d)) {
                    case "noGrp":
                        b = ST_OnOff.e(m.d);
                        break;
                    case "noSelect":
                        c = ST_OnOff.e(m.d);
                        break;
                    case "noRot":
                        d = ST_OnOff.e(m.d);
                        break;
                    case "noChangeAspect":
                        e = ST_OnOff.e(m.d);
                        break;
                    case "noMove":
                        f = ST_OnOff.e(m.d);
                        break;
                    case "noResize":
                        g = ST_OnOff.e(m.d);
                        break;
                    case "noEditPoints":
                        h = ST_OnOff.e(m.d);
                        break;
                    case "noAdjustHandles":
                        i = ST_OnOff.e(m.d);
                        break;
                    case "noChangeArrowheads":
                        j = ST_OnOff.e(m.d);
                        break;
                    case "noChangeShapeType":
                        k = ST_OnOff.e(m.d);
                        break;
                    case "noTextEdit":
                        l = ST_OnOff.e(m.d);
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i,
                p9: j,
                p10: k,
                p11: l
            };
        }
        static p1(a, b = false, c = false, d = false, e = false, f = false, g = false, h = false, i = false, j = false, k = false, l = false) {
            a.ad.p(DrawingMLMain.iz, "a");
            let m;
            if (b != false) {
                m = ST_OnOff.g(b);
                a.ad.h("noGrp", m);
            }
            if (c != false) {
                m = ST_OnOff.g(c);
                a.ad.h("noSelect", m);
            }
            if (d != false) {
                m = ST_OnOff.g(d);
                a.ad.h("noRot", m);
            }
            if (e != false) {
                m = ST_OnOff.g(e);
                a.ad.h("noChangeAspect", m);
            }
            if (f != false) {
                m = ST_OnOff.g(f);
                a.ad.h("noMove", m);
            }
            if (g != false) {
                m = ST_OnOff.g(g);
                a.ad.h("noResize", m);
            }
            if (h != false) {
                m = ST_OnOff.g(h);
                a.ad.h("noEditPoints", m);
            }
            if (i != false) {
                m = ST_OnOff.g(i);
                a.ad.h("noAdjustHandles", m);
            }
            if (j != false) {
                m = ST_OnOff.g(j);
                a.ad.h("noChangeArrowheads", m);
            }
            if (k != false) {
                m = ST_OnOff.g(k);
                a.ad.h("noChangeShapeType", m);
            }
            if (l != false) {
                m = ST_OnOff.g(l);
                a.ad.h("noTextEdit", m);
            }
        }
        static m1(a, b, c, d, e) {
            let f = DrawingMLMain.k7(a, DrawingMLMain.i0, b, c, d, e);
            b = f.p2;
            c = f.p3;
            d = f.p4;
            e = f.p5;
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e
            };
        }
        static p2(a, b, c, d, e) {
            DrawingMLMain.n8(a, DrawingMLMain.i0, b, c, d, e);
        }
        static m2(a, b) {
            let c = a.ao("val");
            if (c == null) {
                b = ST_HexColorRGB.a;
            }
            else {
                b = ST_HexColorRGB.d(c);
            }
            return {
                p1: b
            };
        }
        static p3(a, b) {
            a.ad.p(DrawingMLMain.i1, "a");
            let c;
            c = b.toString();
            a.ad.h("val", c);
        }
        static m3(a) {
        }
        static p4(a) {
            a.ad.p(DrawingMLMain.i3, "a");
        }
        static m4(a, b, c) {
            b = 0;
            c = ST_HexColorRGB.a;
            for (let d of fromEnum(a.ab.u)) {
                switch (d.a.e(a.d)) {
                    case "val":
                        b = XmlNamespaceDefinitionBase.b(ST_SystemColorVal_$type, d.d, b);
                        break;
                    case "lastClr":
                        c = ST_HexColorRGB.d(d.d);
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c
            };
        }
        static p5(a, b, c) {
            a.ad.p(DrawingMLMain.i9, "a");
            let d;
            d = XmlNamespaceDefinitionBase.p(ST_SystemColorVal_$type, b);
            a.ad.h("val", d);
            d = c.toString();
            a.ad.h("lastClr", d);
        }
        static m5(a, b, c, d) {
            let e = DrawingMLMain.kz(a, DrawingMLMain.jf, b, c, d);
            b = e.p2;
            c = e.p3;
            d = e.p4;
            return {
                p1: b,
                p2: c,
                p3: d
            };
        }
        static p6(a, b, c, d) {
            DrawingMLMain.n0(a, DrawingMLMain.jf, b, c, d);
        }
        static m6(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, DrawingMLMain.jb, 6);
            return {
                p1: b
            };
        }
        static p7(a, b) {
            XmlNamespaceDefinitionBase.aj(a, DrawingMLMain.jb, "a", b, void 0, 6);
        }
        static m7(a, b) {
            b = a.ao("name");
            return {
                p1: b
            };
        }
        static p8(a, b) {
            a.ad.p(DrawingMLMain.jh, "a");
            let c;
            c = b;
            a.ad.h("name", c);
            a.ad.l(IGOfficeExtensions.ao, true);
        }
        static m8(a) {
        }
        static p9(a) {
            a.ad.p(DrawingMLMain.ji, "a");
        }
        static m9(a) {
        }
        static qa(a) {
            a.ad.p(DrawingMLMain.jj, "a");
        }
        static na(a, b) {
            let c = DrawingMLMain.k4(a, DrawingMLMain.jn, b);
            b = c.p2;
            return {
                p1: b
            };
        }
        static qb(a, b) {
            DrawingMLMain.n5(a, DrawingMLMain.jn, b);
        }
        static nb(a, b, c, d) {
            b = ST_Angle.a(0);
            c = false;
            d = false;
            for (let e of fromEnum(a.ab.u)) {
                switch (e.a.e(a.d)) {
                    case "rot":
                        b = ST_Angle.b(e.d);
                        break;
                    case "flipH":
                        c = ST_OnOff.e(e.d);
                        break;
                    case "flipV":
                        d = ST_OnOff.e(e.d);
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d
            };
        }
        static qc(a, b = new ST_Angle(), c = false, d = false) {
            a.ad.p(DrawingMLMain.j9, "a");
            let e;
            if (b.n() != 0) {
                e = b.toString();
                a.ad.h("rot", e);
            }
            if (c != false) {
                e = ST_OnOff.g(c);
                a.ad.h("flipH", e);
            }
            if (d != false) {
                e = ST_OnOff.g(d);
                a.ad.h("flipV", e);
            }
        }
    }
    DrawingMLMain.$t = /*@__PURE__*/ markType(DrawingMLMain, 'DrawingMLMain', XmlNamespaceDefinitionBase.$);
    DrawingMLMain.gq = "http://schemas.openxmlformats.org/drawingml/2006/main";
    DrawingMLMain.gp = "http://purl.oclc.org/ooxml/drawingml/main";
    DrawingMLMain.ar = DrawingMLMain.gp + "/accent1";
    DrawingMLMain.as = DrawingMLMain.gp + "/accent2";
    DrawingMLMain.at = DrawingMLMain.gp + "/accent3";
    DrawingMLMain.au = DrawingMLMain.gp + "/accent4";
    DrawingMLMain.av = DrawingMLMain.gp + "/accent5";
    DrawingMLMain.aw = DrawingMLMain.gp + "/accent6";
    DrawingMLMain.az = DrawingMLMain.gp + "/ahPolar";
    DrawingMLMain.a0 = DrawingMLMain.gp + "/ahXY";
    DrawingMLMain.a2 = DrawingMLMain.gp + "/alpha";
    DrawingMLMain.a7 = DrawingMLMain.gp + "/alphaMod";
    DrawingMLMain.a9 = DrawingMLMain.gp + "/alphaOff";
    DrawingMLMain.bg = DrawingMLMain.gp + "/arcTo";
    DrawingMLMain.bh = DrawingMLMain.gp + "/avLst";
    DrawingMLMain.bt = DrawingMLMain.gp + "/blip";
    DrawingMLMain.bu = DrawingMLMain.gp + "/blipFill";
    DrawingMLMain.bv = DrawingMLMain.gp + "/blue";
    DrawingMLMain.bw = DrawingMLMain.gp + "/blueMod";
    DrawingMLMain.bx = DrawingMLMain.gp + "/blueOff";
    DrawingMLMain.b0 = DrawingMLMain.gp + "/bodyPr";
    DrawingMLMain.ch = DrawingMLMain.gp + "/chExt";
    DrawingMLMain.ci = DrawingMLMain.gp + "/chOff";
    DrawingMLMain.cj = DrawingMLMain.gp + "/close";
    DrawingMLMain.cn = DrawingMLMain.gp + "/clrScheme";
    DrawingMLMain.cq = DrawingMLMain.gp + "/comp";
    DrawingMLMain.cu = DrawingMLMain.gp + "/cs";
    DrawingMLMain.cw = DrawingMLMain.gp + "/cubicBezTo";
    DrawingMLMain.cx = DrawingMLMain.gp + "/custClr";
    DrawingMLMain.cy = DrawingMLMain.gp + "/custClrLst";
    DrawingMLMain.c0 = DrawingMLMain.gp + "/custGeom";
    DrawingMLMain.da = DrawingMLMain.gp + "/dk1";
    DrawingMLMain.db = DrawingMLMain.gp + "/dk2";
    DrawingMLMain.df = DrawingMLMain.gp + "/ea";
    DrawingMLMain.dk = DrawingMLMain.gp + "/effectRef";
    DrawingMLMain.dr = DrawingMLMain.gp + "/ext";
    DrawingMLMain.ds = DrawingMLMain.gp + "/extLst";
    DrawingMLMain.dt = DrawingMLMain.gp + "/extraClrScheme";
    DrawingMLMain.du = DrawingMLMain.gp + "/extraClrSchemeLst";
    DrawingMLMain.dz = DrawingMLMain.gp + "/fillRect";
    DrawingMLMain.d0 = DrawingMLMain.gp + "/fillRef";
    DrawingMLMain.d8 = DrawingMLMain.gp + "/fmtScheme";
    DrawingMLMain.d9 = DrawingMLMain.gp + "/folHlink";
    DrawingMLMain.ea = DrawingMLMain.gp + "/font";
    DrawingMLMain.ec = DrawingMLMain.gp + "/fontRef";
    DrawingMLMain.ed = DrawingMLMain.gp + "/fontScheme";
    DrawingMLMain.eh = DrawingMLMain.gp + "/gd";
    DrawingMLMain.el = DrawingMLMain.gp + "/graphic";
    DrawingMLMain.em = DrawingMLMain.gp + "/graphicData";
    DrawingMLMain.en = DrawingMLMain.gp + "/graphicFrameLocks";
    DrawingMLMain.eo = DrawingMLMain.gp + "/gray";
    DrawingMLMain.eq = DrawingMLMain.gp + "/green";
    DrawingMLMain.er = DrawingMLMain.gp + "/greenMod";
    DrawingMLMain.es = DrawingMLMain.gp + "/greenOff";
    DrawingMLMain.et = DrawingMLMain.gp + "/grpFill";
    DrawingMLMain.ex = DrawingMLMain.gp + "/headEnd";
    DrawingMLMain.e2 = DrawingMLMain.gp + "/hlink";
    DrawingMLMain.e3 = DrawingMLMain.gp + "/hlinkClick";
    DrawingMLMain.e9 = DrawingMLMain.gp + "/hue";
    DrawingMLMain.fa = DrawingMLMain.gp + "/hueMod";
    DrawingMLMain.fb = DrawingMLMain.gp + "/hueOff";
    DrawingMLMain.fh = DrawingMLMain.gp + "/inv";
    DrawingMLMain.fr = DrawingMLMain.gp + "/latin";
    DrawingMLMain.fx = DrawingMLMain.gp + "/ln";
    DrawingMLMain.fy = DrawingMLMain.gp + "/lnRef";
    DrawingMLMain.f1 = DrawingMLMain.gp + "/lnTo";
    DrawingMLMain.f2 = DrawingMLMain.gp + "/lstStyle";
    DrawingMLMain.f3 = DrawingMLMain.gp + "/lt1";
    DrawingMLMain.f4 = DrawingMLMain.gp + "/lt2";
    DrawingMLMain.f5 = DrawingMLMain.gp + "/lum";
    DrawingMLMain.f6 = DrawingMLMain.gp + "/lumMod";
    DrawingMLMain.f7 = DrawingMLMain.gp + "/lumOff";
    DrawingMLMain.gi = DrawingMLMain.gp + "/majorFont";
    DrawingMLMain.gl = DrawingMLMain.gp + "/minorFont";
    DrawingMLMain.gn = DrawingMLMain.gp + "/moveTo";
    DrawingMLMain.gz = DrawingMLMain.gp + "/noFill";
    DrawingMLMain.hb = DrawingMLMain.gp + "/objectDefaults";
    DrawingMLMain.hc = DrawingMLMain.gp + "/off";
    DrawingMLMain.he = DrawingMLMain.gp + "/p";
    DrawingMLMain.hj = DrawingMLMain.gp + "/picLocks";
    DrawingMLMain.hm = DrawingMLMain.gp + "/pPr";
    DrawingMLMain.ho = DrawingMLMain.gp + "/prstClr";
    DrawingMLMain.hq = DrawingMLMain.gp + "/prstGeom";
    DrawingMLMain.ht = DrawingMLMain.gp + "/pt";
    DrawingMLMain.hu = DrawingMLMain.gp + "/quadBezTo";
    DrawingMLMain.hv = DrawingMLMain.gp + "/r";
    DrawingMLMain.hy = DrawingMLMain.gp + "/red";
    DrawingMLMain.hz = DrawingMLMain.gp + "/redMod";
    DrawingMLMain.h0 = DrawingMLMain.gp + "/redOff";
    DrawingMLMain.h8 = DrawingMLMain.gp + "/rPr";
    DrawingMLMain.ib = DrawingMLMain.gp + "/sat";
    DrawingMLMain.ic = DrawingMLMain.gp + "/satMod";
    DrawingMLMain.id = DrawingMLMain.gp + "/satOff";
    DrawingMLMain.ig = DrawingMLMain.gp + "/schemeClr";
    DrawingMLMain.ij = DrawingMLMain.gp + "/shade";
    DrawingMLMain.ip = DrawingMLMain.gp + "/solidFill";
    DrawingMLMain.iz = DrawingMLMain.gp + "/spLocks";
    DrawingMLMain.i0 = DrawingMLMain.gp + "/srcRect";
    DrawingMLMain.i1 = DrawingMLMain.gp + "/srgbClr";
    DrawingMLMain.i3 = DrawingMLMain.gp + "/stretch";
    DrawingMLMain.i9 = DrawingMLMain.gp + "/sysClr";
    DrawingMLMain.jb = DrawingMLMain.gp + "/t";
    DrawingMLMain.jf = DrawingMLMain.gp + "/tailEnd";
    DrawingMLMain.jh = DrawingMLMain.gp + "/theme";
    DrawingMLMain.ji = DrawingMLMain.gp + "/themeElements";
    DrawingMLMain.jj = DrawingMLMain.gp + "/themeManager";
    DrawingMLMain.jn = DrawingMLMain.gp + "/tint";
    DrawingMLMain.j9 = DrawingMLMain.gp + "/xfrm";
    DrawingMLMain.gs = DrawingMLMain.gp + "/noAutofit";
    DrawingMLMain.g6 = DrawingMLMain.gp + "/normAutofit";
    DrawingMLMain.hs = DrawingMLMain.gp + "/prstTxWarp";
    DrawingMLMain.ie = DrawingMLMain.gp + "/scene3d";
    DrawingMLMain.iq = DrawingMLMain.gp + "/sp3d";
    DrawingMLMain.ir = DrawingMLMain.gp + "/spAutoFit";
    DrawingMLMain.bj = DrawingMLMain.gp + "/backdrop";
    DrawingMLMain.bm = DrawingMLMain.gp + "/bevelB";
    DrawingMLMain.bn = DrawingMLMain.gp + "/bevelT";
    DrawingMLMain.ce = DrawingMLMain.gp + "/camera";
    DrawingMLMain.fu = DrawingMLMain.gp + "/lightRig";
    DrawingMLMain.hd = DrawingMLMain.gp + "/outerShdw";
    DrawingMLMain.bd = DrawingMLMain.gp + "/anchor";
    DrawingMLMain.g4 = DrawingMLMain.gp + "/norm";
    DrawingMLMain.jz = DrawingMLMain.gp + "/up";
    DrawingMLMain.h4 = DrawingMLMain.gp + "/rot";
    DrawingMLMain.ct = DrawingMLMain.gp + "/contourClr";
    DrawingMLMain.dv = DrawingMLMain.gp + "/extrusionClr";
    DrawingMLMain.e8 = DrawingMLMain.gp + "/hslClr";
    DrawingMLMain.ih = DrawingMLMain.gp + "/scrgbClr";
    DrawingMLMain.eg = DrawingMLMain.gp + "/gamma";
    DrawingMLMain.fj = DrawingMLMain.gp + "/invGamma";
    DrawingMLMain.di = DrawingMLMain.gp + "/effectDag";
    DrawingMLMain.dj = DrawingMLMain.gp + "/effectLst";
    DrawingMLMain.ek = DrawingMLMain.gp + "/gradFill";
    DrawingMLMain.ez = DrawingMLMain.gp + "/highlight";
    DrawingMLMain.e4 = DrawingMLMain.gp + "/hlinkMouseOver";
    DrawingMLMain.hi = DrawingMLMain.gp + "/pattFill";
    DrawingMLMain.i8 = DrawingMLMain.gp + "/sym";
    DrawingMLMain.jv = DrawingMLMain.gp + "/uFill";
    DrawingMLMain.jw = DrawingMLMain.gp + "/uFillTx";
    DrawingMLMain.jx = DrawingMLMain.gp + "/uLn";
    DrawingMLMain.jy = DrawingMLMain.gp + "/uLnTx";
    DrawingMLMain.a3 = DrawingMLMain.gp + "/alphaBiLevel";
    DrawingMLMain.a4 = DrawingMLMain.gp + "/alphaCeiling";
    DrawingMLMain.a5 = DrawingMLMain.gp + "/alphaFloor";
    DrawingMLMain.a6 = DrawingMLMain.gp + "/alphaInv";
    DrawingMLMain.a8 = DrawingMLMain.gp + "/alphaModFix";
    DrawingMLMain.bb = DrawingMLMain.gp + "/alphaRepl";
    DrawingMLMain.ba = DrawingMLMain.gp + "/alphaOutset";
    DrawingMLMain.bs = DrawingMLMain.gp + "/blend";
    DrawingMLMain.jk = DrawingMLMain.gp + "/tile";
    DrawingMLMain.bq = DrawingMLMain.gp + "/biLevel";
    DrawingMLMain.by = DrawingMLMain.gp + "/blur";
    DrawingMLMain.ck = DrawingMLMain.gp + "/clrChange";
    DrawingMLMain.cm = DrawingMLMain.gp + "/clrRepl";
    DrawingMLMain.de = DrawingMLMain.gp + "/duotone";
    DrawingMLMain.dh = DrawingMLMain.gp + "/effect";
    DrawingMLMain.dx = DrawingMLMain.gp + "/fill";
    DrawingMLMain.dy = DrawingMLMain.gp + "/fillOverlay";
    DrawingMLMain.ep = DrawingMLMain.gp + "/grayscl";
    DrawingMLMain.e7 = DrawingMLMain.gp + "/hsl";
    DrawingMLMain.cl = DrawingMLMain.gp + "/clrFrom";
    DrawingMLMain.co = DrawingMLMain.gp + "/clrTo";
    DrawingMLMain.ej = DrawingMLMain.gp + "/glow";
    DrawingMLMain.fg = DrawingMLMain.gp + "/innerShdw";
    DrawingMLMain.hr = DrawingMLMain.gp + "/prstShdw";
    DrawingMLMain.h1 = DrawingMLMain.gp + "/reflection";
    DrawingMLMain.io = DrawingMLMain.gp + "/softEdge";
    DrawingMLMain.ev = DrawingMLMain.gp + "/gsLst";
    DrawingMLMain.fv = DrawingMLMain.gp + "/lin";
    DrawingMLMain.hg = DrawingMLMain.gp + "/path";
    DrawingMLMain.jl = DrawingMLMain.gp + "/tileRect";
    DrawingMLMain.eu = DrawingMLMain.gp + "/gs";
    DrawingMLMain.im = DrawingMLMain.gp + "/snd";
    DrawingMLMain.bl = DrawingMLMain.gp + "/bevel";
    DrawingMLMain.cz = DrawingMLMain.gp + "/custDash";
    DrawingMLMain.hp = DrawingMLMain.gp + "/prstDash";
    DrawingMLMain.gm = DrawingMLMain.gp + "/miter";
    DrawingMLMain.h7 = DrawingMLMain.gp + "/round";
    DrawingMLMain.dd = DrawingMLMain.gp + "/ds";
    DrawingMLMain.bo = DrawingMLMain.gp + "/bgClr";
    DrawingMLMain.dw = DrawingMLMain.gp + "/fgClr";
    DrawingMLMain.ay = DrawingMLMain.gp + "/ahLst";
    DrawingMLMain.c3 = DrawingMLMain.gp + "/cxnLst";
    DrawingMLMain.ei = DrawingMLMain.gp + "/gdLst";
    DrawingMLMain.hh = DrawingMLMain.gp + "/pathLst";
    DrawingMLMain.hx = DrawingMLMain.gp + "/rect";
    DrawingMLMain.c2 = DrawingMLMain.gp + "/cxn";
    DrawingMLMain.hl = DrawingMLMain.gp + "/pos";
    DrawingMLMain.d3 = DrawingMLMain.gp + "/flatTx";
    DrawingMLMain.bp = DrawingMLMain.gp + "/bgFillStyleLst";
    DrawingMLMain.dm = DrawingMLMain.gp + "/effectStyleLst";
    DrawingMLMain.d1 = DrawingMLMain.gp + "/fillStyleLst";
    DrawingMLMain.f0 = DrawingMLMain.gp + "/lnStyleLst";
    DrawingMLMain.cs = DrawingMLMain.gp + "/cont";
    DrawingMLMain.d2 = DrawingMLMain.gp + "/fillToRect";
    DrawingMLMain.dl = DrawingMLMain.gp + "/effectStyle";
    DrawingMLMain.h2 = DrawingMLMain.gp + "/relOff";
    DrawingMLMain.c5 = DrawingMLMain.gp + "/defPPr";
    DrawingMLMain.f9 = DrawingMLMain.gp + "/lvl1pPr";
    DrawingMLMain.ga = DrawingMLMain.gp + "/lvl2pPr";
    DrawingMLMain.gb = DrawingMLMain.gp + "/lvl3pPr";
    DrawingMLMain.gc = DrawingMLMain.gp + "/lvl4pPr";
    DrawingMLMain.gd = DrawingMLMain.gp + "/lvl5pPr";
    DrawingMLMain.ge = DrawingMLMain.gp + "/lvl6pPr";
    DrawingMLMain.gf = DrawingMLMain.gp + "/lvl7pPr";
    DrawingMLMain.gg = DrawingMLMain.gp + "/lvl8pPr";
    DrawingMLMain.gh = DrawingMLMain.gp + "/lvl9pPr";
    DrawingMLMain.fz = DrawingMLMain.gp + "/lnSpc";
    DrawingMLMain.it = DrawingMLMain.gp + "/spcAft";
    DrawingMLMain.iu = DrawingMLMain.gp + "/spcBef";
    DrawingMLMain.ix = DrawingMLMain.gp + "/spcPct";
    DrawingMLMain.iy = DrawingMLMain.gp + "/spcPts";
    DrawingMLMain.b5 = DrawingMLMain.gp + "/buClr";
    DrawingMLMain.b6 = DrawingMLMain.gp + "/buClrTx";
    DrawingMLMain.b7 = DrawingMLMain.gp + "/buFont";
    DrawingMLMain.b8 = DrawingMLMain.gp + "/buFontTx";
    DrawingMLMain.ca = DrawingMLMain.gp + "/buSzPct";
    DrawingMLMain.cb = DrawingMLMain.gp + "/buSzPts";
    DrawingMLMain.cc = DrawingMLMain.gp + "/buSzTx";
    DrawingMLMain.b2 = DrawingMLMain.gp + "/buAutoNum";
    DrawingMLMain.b9 = DrawingMLMain.gp + "/buNone";
    DrawingMLMain.b3 = DrawingMLMain.gp + "/buBlip";
    DrawingMLMain.b4 = DrawingMLMain.gp + "/buChar";
    DrawingMLMain.c6 = DrawingMLMain.gp + "/defRPr";
    DrawingMLMain.jd = DrawingMLMain.gp + "/tab";
    DrawingMLMain.b1 = DrawingMLMain.gp + "/br";
    DrawingMLMain.d4 = DrawingMLMain.gp + "/fld";
    DrawingMLMain.dn = DrawingMLMain.gp + "/endParaRPr";
    DrawingMLMain.je = DrawingMLMain.gp + "/tabLst";
    DrawingMLMain.ao = /*@__PURE__*/ new DrawingMLMain();
    return DrawingMLMain;
})();
/**
 * @hidden
 */
export let DrawingNamespaceDefinitionBase = /*@__PURE__*/ (() => {
    class DrawingNamespaceDefinitionBase extends XmlNamespaceDefinitionBase {
        constructor(a, b) {
            super();
            this.ao = null;
            this.aq = null;
            this.ar = null;
            this.as = null;
            this.at = null;
            this.au = null;
            this.av = null;
            this.aw = null;
            this.ax = null;
            this.az = null;
            this.a4 = null;
            this.a5 = null;
            this.a6 = null;
            this.a7 = null;
            this.bo = null;
            this.bp = null;
            this.bq = null;
            this.br = null;
            this.bs = null;
            this.bt = null;
            this.bx = null;
            this.by = null;
            this.bz = null;
            this.b0 = null;
            this.b2 = null;
            this.b4 = null;
            this.bb = null;
            this.bc = null;
            this.bb = a;
            this.bc = b;
            this.ao = a + "/blipFill";
            this.aq = a + "/cNvCxnSpPr";
            this.ar = a + "/cNvGraphicFramePr";
            this.as = a + "/cNvGrpSpPr";
            this.at = a + "/cNvPicPr";
            this.au = a + "/cNvPr";
            this.av = a + "/cNvSpPr";
            this.aw = a + "/cxnSp";
            this.ax = a + "/cxnSpLocks";
            this.az = a + "/endCxn";
            this.a4 = a + "/graphicFrame";
            this.a5 = a + "/grpSp";
            this.a6 = a + "/grpSpLocks";
            this.a7 = a + "/grpSpPr";
            this.bo = a + "/nvCxnSpPr";
            this.bp = a + "/nvGraphicFramePr";
            this.bq = a + "/nvGrpSpPr";
            this.br = a + "/nvPicPr";
            this.bs = a + "/nvSpPr";
            this.bt = a + "/pic";
            this.bx = a + "/sp";
            this.by = a + "/spPr";
            this.bz = a + "/stCxn";
            this.b0 = a + "/style";
            this.b2 = a + "/txBody";
            this.b4 = a + "/xfrm";
        }
        s(a) {
            switch (a) {
                case 0: return this.bc;
                case 1: return this.bb;
                default: return this.bc;
            }
        }
        cc(a, b, c, d) {
            c = 0;
            d = 0;
            for (let e of fromEnum(a.ab.u)) {
                switch (e.a.e(a.d)) {
                    case "id":
                        c = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                        break;
                    case "idx":
                        d = parseUInt32_1(e.d, CultureInfo.invariantCulture);
                        break;
                    default: break;
                }
            }
            return {
                p2: c,
                p3: d
            };
        }
        c3(a, b, c = 0, d = 0) {
            a.ad.p(b, this.t);
            let e;
            if (c != 0) {
                e = c.toString();
                a.ad.h("id", e);
            }
            if (d != 0) {
                e = d.toString();
                a.ad.h("idx", e);
            }
        }
        static db(a, b) {
            if (stringIsNullOrEmpty(b)) {
                return;
            }
            DrawingNamespaceDefinitionBase.db(a, b);
        }
        b5(a, b, c) {
            b = toNullable(Number_$type, null);
            c = toNullable(Boolean_$type, null);
            for (let d of fromEnum(a.ab.u)) {
                switch (d.a.e(a.d)) {
                    case "dpi":
                        b = toNullable(Number_$type, parseUInt32_1(d.d, CultureInfo.invariantCulture));
                        break;
                    case "rotWithShape":
                        c = toNullable(Boolean_$type, ST_OnOff.e(d.d));
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c
            };
        }
        cw(a, b, c) {
            a.ad.p(this.ao, this.t);
            let d;
            if (nullableNotEquals(b, null)) {
                d = b.value.toString();
                a.ad.h("dpi", d);
            }
            if (nullableNotEquals(c, null)) {
                d = ST_OnOff.g(c.value);
                a.ad.h("rotWithShape", d);
            }
        }
        b6(a) {
        }
        cx(a) {
            a.ad.p(this.aq, this.t);
        }
        b7(a) {
        }
        cy(a) {
            a.ad.p(this.ar, this.t);
        }
        b8(a) {
        }
        cz(a) {
            a.ad.p(this.as, this.t);
        }
        b9(a, b) {
            let c = a.ao("preferRelativeResize");
            if (c == null) {
                b = true;
            }
            else {
                b = ST_OnOff.e(c);
            }
            return {
                p1: b
            };
        }
        c0(a, b = true) {
            a.ad.p(this.at, this.t);
            let c;
            if (b != true) {
                c = ST_OnOff.g(b);
                a.ad.h("preferRelativeResize", c);
            }
        }
        ca(a, b, c, d, e, f) {
            let g = DrawingMLMain.k0(a, this.au, b, c, d, e, f);
            b = g.p2;
            c = g.p3;
            d = g.p4;
            e = g.p5;
            f = g.p6;
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f
            };
        }
        c1(a, b, c, d = null, e = false, f = null) {
            DrawingMLMain.n1(a, this.au, b, c, d, e, f);
        }
        cb(a, b) {
            let c = a.ao("txBox");
            if (c == null) {
                b = false;
            }
            else {
                b = ST_OnOff.e(c);
            }
            return {
                p1: b
            };
        }
        c2(a, b = false) {
            a.ad.p(this.av, this.t);
            let c;
            if (b != false) {
                c = ST_OnOff.g(b);
                a.ad.h("txBox", c);
            }
        }
        cd(a, b, c) {
            b = null;
            c = false;
            for (let d of fromEnum(a.ab.u)) {
                switch (d.a.e(a.d)) {
                    case "macro":
                        b = d.d;
                        break;
                    case "fPublished":
                        c = ST_OnOff.e(d.d);
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c
            };
        }
        c4(a, b = null, c = false) {
            a.ad.p(this.aw, this.t);
            let d;
            d = b;
            DrawingNamespaceDefinitionBase.db(a, d);
            if (c != false) {
                d = ST_OnOff.g(c);
                a.ad.h("fPublished", d);
            }
        }
        ce(a, b, c, d, e, f, g, h, i, j, k) {
            b = false;
            c = false;
            d = false;
            e = false;
            f = false;
            g = false;
            h = false;
            i = false;
            j = false;
            k = false;
            for (let l of fromEnum(a.ab.u)) {
                switch (l.a.e(a.d)) {
                    case "noGrp":
                        b = ST_OnOff.e(l.d);
                        break;
                    case "noSelect":
                        c = ST_OnOff.e(l.d);
                        break;
                    case "noRot":
                        d = ST_OnOff.e(l.d);
                        break;
                    case "noChangeAspect":
                        e = ST_OnOff.e(l.d);
                        break;
                    case "noMove":
                        f = ST_OnOff.e(l.d);
                        break;
                    case "noResize":
                        g = ST_OnOff.e(l.d);
                        break;
                    case "noEditPoints":
                        h = ST_OnOff.e(l.d);
                        break;
                    case "noAdjustHandles":
                        i = ST_OnOff.e(l.d);
                        break;
                    case "noChangeArrowheads":
                        j = ST_OnOff.e(l.d);
                        break;
                    case "noChangeShapeType":
                        k = ST_OnOff.e(l.d);
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i,
                p9: j,
                p10: k
            };
        }
        c5(a, b = false, c = false, d = false, e = false, f = false, g = false, h = false, i = false, j = false, k = false) {
            a.ad.p(this.ax, this.t);
            let l;
            if (b != false) {
                l = ST_OnOff.g(b);
                a.ad.h("noGrp", l);
            }
            if (c != false) {
                l = ST_OnOff.g(c);
                a.ad.h("noSelect", l);
            }
            if (d != false) {
                l = ST_OnOff.g(d);
                a.ad.h("noRot", l);
            }
            if (e != false) {
                l = ST_OnOff.g(e);
                a.ad.h("noChangeAspect", l);
            }
            if (f != false) {
                l = ST_OnOff.g(f);
                a.ad.h("noMove", l);
            }
            if (g != false) {
                l = ST_OnOff.g(g);
                a.ad.h("noResize", l);
            }
            if (h != false) {
                l = ST_OnOff.g(h);
                a.ad.h("noEditPoints", l);
            }
            if (i != false) {
                l = ST_OnOff.g(i);
                a.ad.h("noAdjustHandles", l);
            }
            if (j != false) {
                l = ST_OnOff.g(j);
                a.ad.h("noChangeArrowheads", l);
            }
            if (k != false) {
                l = ST_OnOff.g(k);
                a.ad.h("noChangeShapeType", l);
            }
        }
        cf(a, b, c) {
            let d = this.cc(a, this.az, b, c);
            b = d.p2;
            c = d.p3;
            return {
                p1: b,
                p2: c
            };
        }
        c6(a, b = 0, c = 0) {
            this.c3(a, this.az, b, c);
        }
        cg(a, b, c) {
            b = null;
            c = false;
            for (let d of fromEnum(a.ab.u)) {
                switch (d.a.e(a.d)) {
                    case "macro":
                        b = d.d;
                        break;
                    case "fPublished":
                        c = ST_OnOff.e(d.d);
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c
            };
        }
        c7(a, b = null, c = false) {
            a.ad.p(this.a4, this.t);
            let d;
            d = b;
            DrawingNamespaceDefinitionBase.db(a, d);
            if (c != false) {
                d = ST_OnOff.g(c);
                a.ad.h("fPublished", d);
            }
        }
        ch(a) {
        }
        c8(a) {
            a.ad.p(this.a5, this.t);
        }
        ci(a, b, c, d, e, f, g, h) {
            b = false;
            c = false;
            d = false;
            e = false;
            f = false;
            g = false;
            h = false;
            for (let i of fromEnum(a.ab.u)) {
                switch (i.a.e(a.d)) {
                    case "noGrp":
                        b = ST_OnOff.e(i.d);
                        break;
                    case "noUngrp":
                        c = ST_OnOff.e(i.d);
                        break;
                    case "noSelect":
                        d = ST_OnOff.e(i.d);
                        break;
                    case "noRot":
                        e = ST_OnOff.e(i.d);
                        break;
                    case "noChangeAspect":
                        f = ST_OnOff.e(i.d);
                        break;
                    case "noMove":
                        g = ST_OnOff.e(i.d);
                        break;
                    case "noResize":
                        h = ST_OnOff.e(i.d);
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h
            };
        }
        c9(a, b = false, c = false, d = false, e = false, f = false, g = false, h = false) {
            a.ad.p(this.a6, this.t);
            let i;
            if (b != false) {
                i = ST_OnOff.g(b);
                a.ad.h("noGrp", i);
            }
            if (c != false) {
                i = ST_OnOff.g(c);
                a.ad.h("noUngrp", i);
            }
            if (d != false) {
                i = ST_OnOff.g(d);
                a.ad.h("noSelect", i);
            }
            if (e != false) {
                i = ST_OnOff.g(e);
                a.ad.h("noRot", i);
            }
            if (f != false) {
                i = ST_OnOff.g(f);
                a.ad.h("noChangeAspect", i);
            }
            if (g != false) {
                i = ST_OnOff.g(g);
                a.ad.h("noMove", i);
            }
            if (h != false) {
                i = ST_OnOff.g(h);
                a.ad.h("noResize", i);
            }
        }
        cj(a, b) {
            let c = a.ao("bwMode");
            if (c == null) {
                b = toNullable(ST_BlackWhiteMode_$type, null);
            }
            else {
                b = toNullable(ST_BlackWhiteMode_$type, XmlNamespaceDefinitionBase.b(ST_BlackWhiteMode_$type, c));
            }
            return {
                p1: b
            };
        }
        da(a, b = toNullable(ST_BlackWhiteMode_$type, null)) {
            a.ad.p(this.a7, this.t);
            let c;
            if (nullableNotEquals(b, null)) {
                c = XmlNamespaceDefinitionBase.p(ST_BlackWhiteMode_$type, b.value);
                a.ad.h("bwMode", c);
            }
        }
        ck(a) {
        }
        dc(a) {
            a.ad.p(this.bo, this.t);
        }
        cl(a) {
        }
        dd(a) {
            a.ad.p(this.bp, this.t);
        }
        cm(a) {
        }
        de(a) {
            a.ad.p(this.bq, this.t);
        }
        cn(a) {
        }
        df(a) {
            a.ad.p(this.br, this.t);
        }
        co(a) {
        }
        dg(a) {
            a.ad.p(this.bs, this.t);
        }
        cp(a, b, c) {
            b = "";
            c = false;
            for (let d of fromEnum(a.ab.u)) {
                switch (d.a.e(a.d)) {
                    case "macro":
                        b = d.d;
                        break;
                    case "fPublished":
                        c = ST_OnOff.e(d.d);
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c
            };
        }
        dh(a, b = "", c = false) {
            a.ad.p(this.bt, this.t);
            let d;
            d = b;
            DrawingNamespaceDefinitionBase.db(a, d);
            if (c != false) {
                d = ST_OnOff.g(c);
                a.ad.h("fPublished", d);
            }
        }
        cq(a, b, c, d, e) {
            b = null;
            c = null;
            d = true;
            e = false;
            for (let f of fromEnum(a.ab.u)) {
                switch (f.a.e(a.d)) {
                    case "macro":
                        b = f.d;
                        break;
                    case "textlink":
                        c = f.d;
                        break;
                    case "fLocksText":
                        d = ST_OnOff.e(f.d);
                        break;
                    case "fPublished":
                        e = ST_OnOff.e(f.d);
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e
            };
        }
        di(a, b = null, c = null, d = true, e = false) {
            a.ad.p(this.bx, this.t);
            let f;
            f = b;
            DrawingNamespaceDefinitionBase.db(a, f);
            f = c;
            a.ad.h("textlink", f);
            if (d != true) {
                f = ST_OnOff.g(d);
                a.ad.h("fLocksText", f);
            }
            if (e != false) {
                f = ST_OnOff.g(e);
                a.ad.h("fPublished", f);
            }
        }
        cr(a, b) {
            let c = a.ao("bwMode");
            if (c == null) {
                b = toNullable(ST_BlackWhiteMode_$type, null);
            }
            else {
                b = toNullable(ST_BlackWhiteMode_$type, XmlNamespaceDefinitionBase.b(ST_BlackWhiteMode_$type, c));
            }
            return {
                p1: b
            };
        }
        dj(a, b = toNullable(ST_BlackWhiteMode_$type, null)) {
            a.ad.p(this.by, this.t);
            let c;
            if (nullableNotEquals(b, null)) {
                c = XmlNamespaceDefinitionBase.p(ST_BlackWhiteMode_$type, b.value);
                a.ad.h("bwMode", c);
            }
        }
        cs(a, b, c) {
            let d = this.cc(a, this.bz, b, c);
            b = d.p2;
            c = d.p3;
            return {
                p1: b,
                p2: c
            };
        }
        dk(a, b = 0, c = 0) {
            this.c3(a, this.bz, b, c);
        }
        ct(a) {
        }
        dl(a) {
            a.ad.p(this.b0, this.t);
        }
        cu(a) {
        }
        dm(a) {
            a.ad.p(this.b2, this.t);
        }
        cv(a, b, c, d) {
            b = ST_Angle.a(0);
            c = false;
            d = false;
            for (let e of fromEnum(a.ab.u)) {
                switch (e.a.e(a.d)) {
                    case "rot":
                        b = ST_Angle.b(e.d);
                        break;
                    case "flipH":
                        c = ST_OnOff.e(e.d);
                        break;
                    case "flipV":
                        d = ST_OnOff.e(e.d);
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d
            };
        }
        dn(a, b = new ST_Angle(), c = false, d = false) {
            a.ad.p(this.b4, this.t);
            let e;
            if (b.n() != 0) {
                e = b.toString();
                a.ad.h("rot", e);
            }
            if (c != false) {
                e = ST_OnOff.g(c);
                a.ad.h("flipH", e);
            }
            if (d != false) {
                e = ST_OnOff.g(d);
                a.ad.h("flipV", e);
            }
        }
    }
    DrawingNamespaceDefinitionBase.$t = /*@__PURE__*/ markType(DrawingNamespaceDefinitionBase, 'DrawingNamespaceDefinitionBase', XmlNamespaceDefinitionBase.$);
    return DrawingNamespaceDefinitionBase;
})();
/**
 * @hidden
 */
export let EmptyNamespace = /*@__PURE__*/ (() => {
    class EmptyNamespace extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            return stringEmpty();
        }
        get_t() {
            return stringEmpty();
        }
        get t() {
            return this.get_t();
        }
        static aq(a) {
        }
        static ar(a, b = toNullable(Number_$type, null), c = toNullable(Number_$type, null)) {
            a.ad.o("xml");
            let d = a.d._z;
            a.ad.l(VmlNamespace.ao);
            a.ad.l(OfficeNamespace.ao);
        }
    }
    EmptyNamespace.$t = /*@__PURE__*/ markType(EmptyNamespace, 'EmptyNamespace', XmlNamespaceDefinitionBase.$);
    EmptyNamespace.ao = /*@__PURE__*/ new EmptyNamespace();
    return EmptyNamespace;
})();
/**
 * @hidden
 */
export let IGOfficeExtensions = /*@__PURE__*/ (() => {
    class IGOfficeExtensions extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            return IGOfficeExtensions.as;
        }
        get_t() {
            return "ig";
        }
        get t() {
            return this.get_t();
        }
    }
    IGOfficeExtensions.$t = /*@__PURE__*/ markType(IGOfficeExtensions, 'IGOfficeExtensions', XmlNamespaceDefinitionBase.$);
    IGOfficeExtensions.as = "http://schemas.infragistics.com/officeExtensions";
    IGOfficeExtensions.aq = IGOfficeExtensions.as + "/isSupported";
    IGOfficeExtensions.ar = IGOfficeExtensions.as + "/listId";
    IGOfficeExtensions.at = IGOfficeExtensions.as + "/nodeId";
    IGOfficeExtensions.au = IGOfficeExtensions.as + "/unclosedParagraph";
    IGOfficeExtensions.ao = /*@__PURE__*/ new IGOfficeExtensions();
    return IGOfficeExtensions;
})();
/**
 * @hidden
 */
export let MarkupCompatibility2006 = /*@__PURE__*/ (() => {
    class MarkupCompatibility2006 extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            return MarkupCompatibility2006.au;
        }
        get_t() {
            return "mc";
        }
        get t() {
            return this.get_t();
        }
        static aw(a) {
        }
        static az(a) {
            a.ad.p(MarkupCompatibility2006.aq, "mc");
        }
        static ax(a, b) {
            b = a.ao("Requires");
            return {
                p1: b
            };
        }
        static a0(a, b) {
            MarkupCompatibility2006.a1(a, stringJoin1(String_$type, " ", Enumerable.o(XmlNamespaceDefinitionBase.$, String_$type, b, (c) => c.t)));
        }
        static a1(a, b) {
            a.ad.p(MarkupCompatibility2006.ar, "mc");
            let c;
            c = b;
            a.ad.h("Requires", c);
        }
        static ay(a) {
        }
        static a2(a) {
            a.ad.p(MarkupCompatibility2006.as, "mc");
        }
    }
    MarkupCompatibility2006.$t = /*@__PURE__*/ markType(MarkupCompatibility2006, 'MarkupCompatibility2006', XmlNamespaceDefinitionBase.$);
    MarkupCompatibility2006.au = "http://schemas.openxmlformats.org/markup-compatibility/2006";
    MarkupCompatibility2006.aq = MarkupCompatibility2006.au + "/AlternateContent";
    MarkupCompatibility2006.ar = MarkupCompatibility2006.au + "/Choice";
    MarkupCompatibility2006.as = MarkupCompatibility2006.au + "/Fallback";
    MarkupCompatibility2006.at = MarkupCompatibility2006.au + "/Ignorable";
    MarkupCompatibility2006.ao = /*@__PURE__*/ new MarkupCompatibility2006();
    return MarkupCompatibility2006;
})();
/**
 * @hidden
 */
export let OfficeDocumentDocPropsVTypes = /*@__PURE__*/ (() => {
    class OfficeDocumentDocPropsVTypes extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0: return OfficeDocumentDocPropsVTypes.a2;
                case 1: return OfficeDocumentDocPropsVTypes.a1;
                default: return OfficeDocumentDocPropsVTypes.a2;
            }
        }
        get_t() {
            return "vt";
        }
        get t() {
            return this.get_t();
        }
        static bu(a, b) {
            b = XmlNamespaceDefinitionBase.i(a, OfficeDocumentDocPropsVTypes.au);
            return {
                p1: b
            };
        }
        static cg(a, b) {
            XmlNamespaceDefinitionBase.ad(a, OfficeDocumentDocPropsVTypes.au, "vt", b);
        }
        static bv(a, b) {
            b = XmlNamespaceDefinitionBase.i(a, OfficeDocumentDocPropsVTypes.ap);
            return {
                p1: b
            };
        }
        static ch(a, b) {
            XmlNamespaceDefinitionBase.ad(a, OfficeDocumentDocPropsVTypes.ap, "vt", b);
        }
        static bw(a, b) {
            b = XmlNamespaceDefinitionBase.n(a, OfficeDocumentDocPropsVTypes.av);
            return {
                p1: b
            };
        }
        static ci(a, b) {
            XmlNamespaceDefinitionBase.ab(a, OfficeDocumentDocPropsVTypes.av, "vt", b);
        }
        static bx(a, b) {
            b = XmlNamespaceDefinitionBase.k(a, OfficeDocumentDocPropsVTypes.aw);
            return {
                p1: b
            };
        }
        static cj(a, b) {
            XmlNamespaceDefinitionBase.ai(a, OfficeDocumentDocPropsVTypes.aw, "vt", b);
        }
        static by(a, b) {
            b = XmlNamespaceDefinitionBase.l(a, OfficeDocumentDocPropsVTypes.ax);
            return {
                p1: b
            };
        }
        static ck(a, b) {
            XmlNamespaceDefinitionBase.ag(a, OfficeDocumentDocPropsVTypes.ax, "vt", b);
        }
        static bz(a, b) {
            b = XmlNamespaceDefinitionBase.m(a, OfficeDocumentDocPropsVTypes.ay);
            return {
                p1: b
            };
        }
        static cl(a, b) {
            XmlNamespaceDefinitionBase.ah(a, OfficeDocumentDocPropsVTypes.ay, "vt", b);
        }
        static b0(a, b) {
            b = XmlNamespaceDefinitionBase.l(a, OfficeDocumentDocPropsVTypes.aq);
            return {
                p1: b
            };
        }
        static cm(a, b) {
            XmlNamespaceDefinitionBase.ag(a, OfficeDocumentDocPropsVTypes.aq, "vt", b);
        }
        static b1(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, OfficeDocumentDocPropsVTypes.az);
            return {
                p1: b
            };
        }
        static cn(a, b) {
            XmlNamespaceDefinitionBase.aj(a, OfficeDocumentDocPropsVTypes.az, "vt", b);
        }
        static b2(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, OfficeDocumentDocPropsVTypes.a0);
            return {
                p1: b
            };
        }
        static co(a, b) {
            XmlNamespaceDefinitionBase.aj(a, OfficeDocumentDocPropsVTypes.a0, "vt", b);
        }
        static b3(a, b) {
            b = XmlNamespaceDefinitionBase.o(a, OfficeDocumentDocPropsVTypes.a3);
            return {
                p1: b
            };
        }
        static cp(a, b) {
            XmlNamespaceDefinitionBase.af(a, OfficeDocumentDocPropsVTypes.a3, "vt", b);
        }
        static b4(a, b) {
            b = XmlNamespaceDefinitionBase.j(a, OfficeDocumentDocPropsVTypes.a4);
            return {
                p1: b
            };
        }
        static cq(a, b) {
            XmlNamespaceDefinitionBase.ae(a, OfficeDocumentDocPropsVTypes.a4, "vt", b);
        }
        static b5(a, b) {
            b = XmlNamespaceDefinitionBase.f(a, OfficeDocumentDocPropsVTypes.a6);
            return {
                p1: b
            };
        }
        static cr(a, b) {
            XmlNamespaceDefinitionBase.ak(a, OfficeDocumentDocPropsVTypes.a6, "vt", b);
        }
        static b6(a, b) {
            b = XmlNamespaceDefinitionBase.v(a, OfficeDocumentDocPropsVTypes.a7);
            return {
                p1: b
            };
        }
        static cs(a, b) {
            XmlNamespaceDefinitionBase.an(a, OfficeDocumentDocPropsVTypes.a7, "vt", b);
        }
        static b7(a, b) {
            b = XmlNamespaceDefinitionBase.w(a, OfficeDocumentDocPropsVTypes.a8);
            return {
                p1: b
            };
        }
        static ct(a, b) {
            XmlNamespaceDefinitionBase.al(a, OfficeDocumentDocPropsVTypes.a8, "vt", b);
        }
        static b8(a, b) {
            b = XmlNamespaceDefinitionBase.x(a, OfficeDocumentDocPropsVTypes.a9);
            return {
                p1: b
            };
        }
        static cu(a, b) {
            XmlNamespaceDefinitionBase.am(a, OfficeDocumentDocPropsVTypes.a9, "vt", b);
        }
        static b9(a, b) {
            b = XmlNamespaceDefinitionBase.w(a, OfficeDocumentDocPropsVTypes.a8);
            return {
                p1: b
            };
        }
        static cv(a, b) {
            XmlNamespaceDefinitionBase.al(a, OfficeDocumentDocPropsVTypes.a8, "vt", b);
        }
        static ca(a) {
        }
        static cw(a) {
            a.ad.p(OfficeDocumentDocPropsVTypes.ba, "vt");
        }
        static cb(a, b, c) {
            b = 0;
            c = 0;
            for (let d of fromEnum(a.ab.u)) {
                switch (d.a.e(a.d)) {
                    case "baseType":
                        b = XmlNamespaceDefinitionBase.b(ST_VectorBaseType_$type, d.d, b);
                        break;
                    case "size":
                        c = parseUInt32_1(d.d, CultureInfo.invariantCulture);
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c
            };
        }
        static cx(a, b, c) {
            a.ad.p(OfficeDocumentDocPropsVTypes.bb, "vt");
            let d;
            d = XmlNamespaceDefinitionBase.p(ST_VectorBaseType_$type, b);
            a.ad.h("baseType", d);
            d = c.toString();
            a.ad.h("size", d);
        }
        static bc(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.bv(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static bd(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.bv(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static be(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.bw(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static bf(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.bx(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static bg(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.by(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static bh(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.bz(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static bi(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.b0(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static bj(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.b1(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static bk(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.b2(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static bl(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.b3(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static bm(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.b4(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static bn(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.b5(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static bo(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.b6(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static bp(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.b7(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static bq(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.b8(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static br(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c;
            let d = OfficeDocumentDocPropsVTypes.b9(a, c);
            c = d.p1;
            b.setValue(c, a.ab.ab);
        }
        static bs(a) {
            let b = a.s.a(IVariantValueContainer_$type);
            if (b == null) {
                return;
            }
            let c = new OfficeDocumentDocPropsVTypes_VariantPlaceholder(b, a.ab.ab);
            a.s.k(c);
        }
        static bt(a) {
            let b;
            let c;
            let d = OfficeDocumentDocPropsVTypes.cb(a, b, c);
            b = d.p1;
            c = d.p2;
            let e = new CT_Vector(0, c, b);
            a.s.k(e);
        }
        static cc(a) {
            a.az(OfficeDocumentDocPropsVTypes.au, OfficeDocumentDocPropsVTypes.bc);
            a.az(OfficeDocumentDocPropsVTypes.ap, OfficeDocumentDocPropsVTypes.bd);
            a.az(OfficeDocumentDocPropsVTypes.av, OfficeDocumentDocPropsVTypes.be);
            a.az(OfficeDocumentDocPropsVTypes.aw, OfficeDocumentDocPropsVTypes.bf);
            a.az(OfficeDocumentDocPropsVTypes.ax, OfficeDocumentDocPropsVTypes.bg);
            a.az(OfficeDocumentDocPropsVTypes.ay, OfficeDocumentDocPropsVTypes.bh);
            a.az(OfficeDocumentDocPropsVTypes.aq, OfficeDocumentDocPropsVTypes.bi);
            a.az(OfficeDocumentDocPropsVTypes.az, OfficeDocumentDocPropsVTypes.bj);
            a.az(OfficeDocumentDocPropsVTypes.a0, OfficeDocumentDocPropsVTypes.bk);
            a.az(OfficeDocumentDocPropsVTypes.a3, OfficeDocumentDocPropsVTypes.bl);
            a.az(OfficeDocumentDocPropsVTypes.a4, OfficeDocumentDocPropsVTypes.bm);
            a.az(OfficeDocumentDocPropsVTypes.a6, OfficeDocumentDocPropsVTypes.bn);
            a.az(OfficeDocumentDocPropsVTypes.a7, OfficeDocumentDocPropsVTypes.bo);
            a.az(OfficeDocumentDocPropsVTypes.a8, OfficeDocumentDocPropsVTypes.bp);
            a.az(OfficeDocumentDocPropsVTypes.a9, OfficeDocumentDocPropsVTypes.bq);
            a.az(OfficeDocumentDocPropsVTypes.as, OfficeDocumentDocPropsVTypes.br);
            a.az(OfficeDocumentDocPropsVTypes.ba, OfficeDocumentDocPropsVTypes.bs);
            a.az(OfficeDocumentDocPropsVTypes.bb, OfficeDocumentDocPropsVTypes.bt);
        }
        static cd(a, b) {
            let c = typeCast(String_$type, b);
            if (c != null) {
                OfficeDocumentDocPropsVTypes.cn(a, c);
            }
            else if (typeof b === 'number') {
                OfficeDocumentDocPropsVTypes.ck(a, typeGetValue(b));
            }
            else if (typeof b === 'number') {
                OfficeDocumentDocPropsVTypes.ci(a, typeGetValue(b));
            }
            else if (typeof b === 'number') {
                OfficeDocumentDocPropsVTypes.cj(a, typeGetValue(b));
            }
            else if (typeof b === 'number') {
                OfficeDocumentDocPropsVTypes.cl(a, typeGetValue(b));
            }
            else if (typeof b === 'number') {
                OfficeDocumentDocPropsVTypes.cr(a, typeGetValue(b));
            }
            else if (typeof b === 'number') {
                OfficeDocumentDocPropsVTypes.cs(a, typeGetValue(b));
            }
            else if (typeof b === 'number') {
                OfficeDocumentDocPropsVTypes.ct(a, typeGetValue(b));
            }
            else if (typeof b === 'number') {
                OfficeDocumentDocPropsVTypes.cu(a, typeGetValue(b));
            }
            else if (typeof b === 'number') {
                OfficeDocumentDocPropsVTypes.cp(a, b);
            }
            else if (typeof b === 'number') {
                OfficeDocumentDocPropsVTypes.cq(a, b);
            }
            else if (typeof b === 'number') {
                OfficeDocumentDocPropsVTypes.ch(a, b);
            }
            else {
                return;
            }
            a.ad.k();
        }
        static ce(a, b) {
            OfficeDocumentDocPropsVTypes.cw(a);
            OfficeDocumentDocPropsVTypes.cd(a, b);
            a.ad.k();
        }
        static cf(a, b) {
            OfficeDocumentDocPropsVTypes.cx(a, b.b, intSToU(b.a.length));
            if (b.b == 0) {
                DocCoreUtils.ao(Base.$, b.a, (c) => OfficeDocumentDocPropsVTypes.ce(a, c));
            }
            else {
                DocCoreUtils.ao(Base.$, b.a, (c) => OfficeDocumentDocPropsVTypes.cd(a, c));
            }
            a.ad.k();
        }
    }
    OfficeDocumentDocPropsVTypes.$t = /*@__PURE__*/ markType(OfficeDocumentDocPropsVTypes, 'OfficeDocumentDocPropsVTypes', XmlNamespaceDefinitionBase.$);
    OfficeDocumentDocPropsVTypes.a2 = "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes";
    OfficeDocumentDocPropsVTypes.a1 = "http://purl.oclc.org/ooxml/officeDocument/docPropsVTypes";
    OfficeDocumentDocPropsVTypes.au = OfficeDocumentDocPropsVTypes.a1 + "/cy";
    OfficeDocumentDocPropsVTypes.ap = OfficeDocumentDocPropsVTypes.a1 + "/decimal";
    OfficeDocumentDocPropsVTypes.av = OfficeDocumentDocPropsVTypes.a1 + "/i1";
    OfficeDocumentDocPropsVTypes.aw = OfficeDocumentDocPropsVTypes.a1 + "/i2";
    OfficeDocumentDocPropsVTypes.ax = OfficeDocumentDocPropsVTypes.a1 + "/i4";
    OfficeDocumentDocPropsVTypes.ay = OfficeDocumentDocPropsVTypes.a1 + "/i8";
    OfficeDocumentDocPropsVTypes.aq = OfficeDocumentDocPropsVTypes.a1 + "/int";
    OfficeDocumentDocPropsVTypes.a3 = OfficeDocumentDocPropsVTypes.a1 + "/r4";
    OfficeDocumentDocPropsVTypes.a4 = OfficeDocumentDocPropsVTypes.a1 + "/r8";
    OfficeDocumentDocPropsVTypes.a6 = OfficeDocumentDocPropsVTypes.a1 + "/ui1";
    OfficeDocumentDocPropsVTypes.a7 = OfficeDocumentDocPropsVTypes.a1 + "/ui2";
    OfficeDocumentDocPropsVTypes.a8 = OfficeDocumentDocPropsVTypes.a1 + "/ui4";
    OfficeDocumentDocPropsVTypes.a9 = OfficeDocumentDocPropsVTypes.a1 + "/ui8";
    OfficeDocumentDocPropsVTypes.as = OfficeDocumentDocPropsVTypes.a1 + "/uint";
    OfficeDocumentDocPropsVTypes.az = OfficeDocumentDocPropsVTypes.a1 + "/lpstr";
    OfficeDocumentDocPropsVTypes.a0 = OfficeDocumentDocPropsVTypes.a1 + "/lpwstr";
    OfficeDocumentDocPropsVTypes.ba = OfficeDocumentDocPropsVTypes.a1 + "/variant";
    OfficeDocumentDocPropsVTypes.bb = OfficeDocumentDocPropsVTypes.a1 + "/vector";
    OfficeDocumentDocPropsVTypes.ao = /*@__PURE__*/ new OfficeDocumentDocPropsVTypes();
    return OfficeDocumentDocPropsVTypes;
})();
/**
 * @hidden
 */
export let OfficeDocumentExtendedProperties = /*@__PURE__*/ (() => {
    class OfficeDocumentExtendedProperties extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0: return OfficeDocumentExtendedProperties.a5;
                case 1: return OfficeDocumentExtendedProperties.a4;
                default: return OfficeDocumentExtendedProperties.a5;
            }
        }
        get_t() {
            return null;
        }
        get t() {
            return this.get_t();
        }
        static bi(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, OfficeDocumentExtendedProperties.aq);
            return {
                p1: b
            };
        }
        static b9(a, b) {
            XmlNamespaceDefinitionBase.aj(a, OfficeDocumentExtendedProperties.aq, null, b);
        }
        static bj(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, OfficeDocumentExtendedProperties.ar);
            return {
                p1: b
            };
        }
        static ca(a, b) {
            XmlNamespaceDefinitionBase.aj(a, OfficeDocumentExtendedProperties.ar, null, b);
        }
        static bk(a, b) {
            b = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.as);
            return {
                p1: b
            };
        }
        static cb(a, b) {
            XmlNamespaceDefinitionBase.ag(a, OfficeDocumentExtendedProperties.as, null, b);
        }
        static bl(a, b) {
            b = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.at);
            return {
                p1: b
            };
        }
        static cc(a, b) {
            XmlNamespaceDefinitionBase.ag(a, OfficeDocumentExtendedProperties.at, null, b);
        }
        static bm(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, OfficeDocumentExtendedProperties.au);
            return {
                p1: b
            };
        }
        static cd(a, b) {
            XmlNamespaceDefinitionBase.aj(a, OfficeDocumentExtendedProperties.au, null, b);
        }
        static bn(a, b) {
            b = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.av);
            return {
                p1: b
            };
        }
        static ce(a, b) {
            XmlNamespaceDefinitionBase.ag(a, OfficeDocumentExtendedProperties.av, null, b);
        }
        static bo(a) {
        }
        static cf(a) {
            a.ad.p(OfficeDocumentExtendedProperties.aw, null);
        }
        static bp(a, b) {
            b = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.ax);
            return {
                p1: b
            };
        }
        static cg(a, b) {
            XmlNamespaceDefinitionBase.ag(a, OfficeDocumentExtendedProperties.ax, null, b);
        }
        static bq(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, OfficeDocumentExtendedProperties.ay);
            return {
                p1: b
            };
        }
        static ch(a, b) {
            XmlNamespaceDefinitionBase.aj(a, OfficeDocumentExtendedProperties.ay, null, b);
        }
        static br(a, b) {
            b = XmlNamespaceDefinitionBase.e(a, OfficeDocumentExtendedProperties.az);
            return {
                p1: b
            };
        }
        static ci(a, b) {
            XmlNamespaceDefinitionBase.aa(a, OfficeDocumentExtendedProperties.az, null, b);
        }
        static bs(a, b) {
            b = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.a0);
            return {
                p1: b
            };
        }
        static cj(a, b) {
            XmlNamespaceDefinitionBase.ag(a, OfficeDocumentExtendedProperties.a0, null, b);
        }
        static bt(a, b) {
            b = XmlNamespaceDefinitionBase.e(a, OfficeDocumentExtendedProperties.a1);
            return {
                p1: b
            };
        }
        static ck(a, b) {
            XmlNamespaceDefinitionBase.aa(a, OfficeDocumentExtendedProperties.a1, null, b);
        }
        static bu(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, OfficeDocumentExtendedProperties.a2);
            return {
                p1: b
            };
        }
        static cl(a, b) {
            XmlNamespaceDefinitionBase.aj(a, OfficeDocumentExtendedProperties.a2, null, b);
        }
        static bv(a, b) {
            b = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.a3);
            return {
                p1: b
            };
        }
        static cm(a, b) {
            XmlNamespaceDefinitionBase.ag(a, OfficeDocumentExtendedProperties.a3, null, b);
        }
        static bw(a, b) {
            b = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.a6);
            return {
                p1: b
            };
        }
        static cn(a, b) {
            XmlNamespaceDefinitionBase.ag(a, OfficeDocumentExtendedProperties.a6, null, b);
        }
        static bx(a, b) {
            b = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.a7);
            return {
                p1: b
            };
        }
        static co(a, b) {
            XmlNamespaceDefinitionBase.ag(a, OfficeDocumentExtendedProperties.a7, null, b);
        }
        static by(a, b) {
            b = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.a8);
            return {
                p1: b
            };
        }
        static cp(a, b) {
            XmlNamespaceDefinitionBase.ag(a, OfficeDocumentExtendedProperties.a8, null, b);
        }
        static bz(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, OfficeDocumentExtendedProperties.a9);
            return {
                p1: b
            };
        }
        static cq(a, b) {
            XmlNamespaceDefinitionBase.aj(a, OfficeDocumentExtendedProperties.a9, null, b);
        }
        static b0(a) {
        }
        static cr(a) {
            a.ad.p(OfficeDocumentExtendedProperties.ba, null);
            let b = a.d._z;
            a.ad.l(OfficeDocumentExtendedProperties.ao);
            a.ad.l(OfficeDocumentDocPropsVTypes.ao);
        }
        static b1(a, b) {
            b = XmlNamespaceDefinitionBase.e(a, OfficeDocumentExtendedProperties.bb);
            return {
                p1: b
            };
        }
        static cs(a, b) {
            XmlNamespaceDefinitionBase.aa(a, OfficeDocumentExtendedProperties.bb, null, b);
        }
        static b2(a, b) {
            b = XmlNamespaceDefinitionBase.e(a, OfficeDocumentExtendedProperties.bc);
            return {
                p1: b
            };
        }
        static ct(a, b) {
            XmlNamespaceDefinitionBase.aa(a, OfficeDocumentExtendedProperties.bc, null, b);
        }
        static b3(a, b) {
            b = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.bd);
            return {
                p1: b
            };
        }
        static b8(a, b) {
            XmlNamespaceDefinitionBase.ag(a, OfficeDocumentExtendedProperties.bd, null, b);
        }
        static b4(a, b) {
            b = XmlNamespaceDefinitionBase.u(a, OfficeDocumentExtendedProperties.be);
            return {
                p1: b
            };
        }
        static cu(a, b) {
            XmlNamespaceDefinitionBase.aj(a, OfficeDocumentExtendedProperties.be, null, b);
        }
        static b5(a) {
        }
        static cv(a) {
            a.ad.p(OfficeDocumentExtendedProperties.bf, null);
        }
        static b6(a, b) {
            b = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.bg);
            return {
                p1: b
            };
        }
        static cw(a, b) {
            XmlNamespaceDefinitionBase.ag(a, OfficeDocumentExtendedProperties.bg, null, b);
        }
        static b7(a, b) {
            b = XmlNamespaceDefinitionBase.l(a, OfficeDocumentExtendedProperties.bh);
            return {
                p1: b
            };
        }
        static cx(a, b) {
            XmlNamespaceDefinitionBase.ag(a, OfficeDocumentExtendedProperties.bh, null, b);
        }
    }
    OfficeDocumentExtendedProperties.$t = /*@__PURE__*/ markType(OfficeDocumentExtendedProperties, 'OfficeDocumentExtendedProperties', XmlNamespaceDefinitionBase.$);
    OfficeDocumentExtendedProperties.a5 = "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties";
    OfficeDocumentExtendedProperties.a4 = "http://purl.oclc.org/ooxml/officeDocument/extendedProperties";
    OfficeDocumentExtendedProperties.aq = OfficeDocumentExtendedProperties.a4 + "/Application";
    OfficeDocumentExtendedProperties.ar = OfficeDocumentExtendedProperties.a4 + "/AppVersion";
    OfficeDocumentExtendedProperties.as = OfficeDocumentExtendedProperties.a4 + "/Characters";
    OfficeDocumentExtendedProperties.at = OfficeDocumentExtendedProperties.a4 + "/CharactersWithSpaces";
    OfficeDocumentExtendedProperties.au = OfficeDocumentExtendedProperties.a4 + "/Company";
    OfficeDocumentExtendedProperties.av = OfficeDocumentExtendedProperties.a4 + "/DocSecurity";
    OfficeDocumentExtendedProperties.aw = OfficeDocumentExtendedProperties.a4 + "/HeadingPairs";
    OfficeDocumentExtendedProperties.ax = OfficeDocumentExtendedProperties.a4 + "/HiddenSlides";
    OfficeDocumentExtendedProperties.ay = OfficeDocumentExtendedProperties.a4 + "/HyperlinkBase";
    OfficeDocumentExtendedProperties.az = OfficeDocumentExtendedProperties.a4 + "/HyperlinksChanged";
    OfficeDocumentExtendedProperties.a0 = OfficeDocumentExtendedProperties.a4 + "/Lines";
    OfficeDocumentExtendedProperties.a1 = OfficeDocumentExtendedProperties.a4 + "/LinksUpToDate";
    OfficeDocumentExtendedProperties.a2 = OfficeDocumentExtendedProperties.a4 + "/Manager";
    OfficeDocumentExtendedProperties.a3 = OfficeDocumentExtendedProperties.a4 + "/MMClips";
    OfficeDocumentExtendedProperties.a6 = OfficeDocumentExtendedProperties.a4 + "/Notes";
    OfficeDocumentExtendedProperties.a7 = OfficeDocumentExtendedProperties.a4 + "/Pages";
    OfficeDocumentExtendedProperties.a8 = OfficeDocumentExtendedProperties.a4 + "/Paragraphs";
    OfficeDocumentExtendedProperties.ba = OfficeDocumentExtendedProperties.a4 + "/Properties";
    OfficeDocumentExtendedProperties.a9 = OfficeDocumentExtendedProperties.a4 + "/PresentationFormat";
    OfficeDocumentExtendedProperties.bb = OfficeDocumentExtendedProperties.a4 + "/ScaleCrop";
    OfficeDocumentExtendedProperties.bc = OfficeDocumentExtendedProperties.a4 + "/SharedDoc";
    OfficeDocumentExtendedProperties.bd = OfficeDocumentExtendedProperties.a4 + "/Slides";
    OfficeDocumentExtendedProperties.be = OfficeDocumentExtendedProperties.a4 + "/Template";
    OfficeDocumentExtendedProperties.bf = OfficeDocumentExtendedProperties.a4 + "/TitlesOfParts";
    OfficeDocumentExtendedProperties.bg = OfficeDocumentExtendedProperties.a4 + "/TotalTime";
    OfficeDocumentExtendedProperties.bh = OfficeDocumentExtendedProperties.a4 + "/Words";
    OfficeDocumentExtendedProperties.ao = /*@__PURE__*/ new OfficeDocumentExtendedProperties();
    return OfficeDocumentExtendedProperties;
})();
/**
 * @hidden
 */
export let OfficeDocumentRelationships = /*@__PURE__*/ (() => {
    class OfficeDocumentRelationships extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0: return OfficeDocumentRelationships.av;
                case 1: return OfficeDocumentRelationships.au;
                default: return OfficeDocumentRelationships.av;
            }
        }
        get_t() {
            return "r";
        }
        get t() {
            return this.get_t();
        }
    }
    OfficeDocumentRelationships.$t = /*@__PURE__*/ markType(OfficeDocumentRelationships, 'OfficeDocumentRelationships', XmlNamespaceDefinitionBase.$);
    OfficeDocumentRelationships.av = "http://schemas.openxmlformats.org/officeDocument/2006/relationships";
    OfficeDocumentRelationships.au = "http://purl.oclc.org/ooxml/officeDocument/relationships";
    OfficeDocumentRelationships.aq = OfficeDocumentRelationships.au + "/embed";
    OfficeDocumentRelationships.ar = OfficeDocumentRelationships.au + "/href";
    OfficeDocumentRelationships.as = OfficeDocumentRelationships.au + "/id";
    OfficeDocumentRelationships.at = OfficeDocumentRelationships.au + "/link";
    OfficeDocumentRelationships.aw = OfficeDocumentRelationships.au + "/pict";
    OfficeDocumentRelationships.ao = /*@__PURE__*/ new OfficeDocumentRelationships();
    return OfficeDocumentRelationships;
})();
/**
 * @hidden
 */
export let OfficeNamespace = /*@__PURE__*/ (() => {
    class OfficeNamespace extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0:
                case 1: return "urn:schemas-microsoft-com:office:office";
                default: return "urn:schemas-microsoft-com:office:office";
            }
        }
        get_t() {
            return "o";
        }
        get t() {
            return this.get_t();
        }
        static ci(a, b, c) {
            b = toNullable(ST_Ext_$type, null);
            c = null;
            for (let d of fromEnum(a.ab.u)) {
                switch (d.a.e(a.d)) {
                    case "urn:schemas-microsoft-com:vml/ext":
                        b = toNullable(ST_Ext_$type, XmlNamespaceDefinitionBase.b(ST_Ext_$type, d.d));
                        break;
                    case "data":
                        c = d.d;
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c
            };
        }
        static cl(a, b = toNullable(ST_Ext_$type, null), c = null) {
            a.ad.p(OfficeNamespace.bs, "o");
            let d;
            if (nullableNotEquals(b, null)) {
                d = XmlNamespaceDefinitionBase.p(ST_Ext_$type, b.value);
                a.ad.h("urn:schemas-microsoft-com:vml/ext", d);
            }
            d = c;
            a.ad.h("data", d);
        }
        static cj(a, b, c, d, e, f, g, h, i, j, k, l, m) {
            b = toNullable(ST_Ext_$type, null);
            c = toNullable(Boolean_$type, null);
            d = toNullable(Boolean_$type, null);
            e = toNullable(Boolean_$type, null);
            f = toNullable(Boolean_$type, null);
            g = toNullable(Boolean_$type, null);
            h = toNullable(Boolean_$type, null);
            i = toNullable(Boolean_$type, null);
            j = toNullable(Boolean_$type, null);
            k = toNullable(Boolean_$type, null);
            l = toNullable(Boolean_$type, null);
            m = toNullable(Boolean_$type, null);
            for (let n of fromEnum(a.ab.u)) {
                switch (n.a.e(a.d)) {
                    case "urn:schemas-microsoft-com:vml/ext":
                        b = toNullable(ST_Ext_$type, XmlNamespaceDefinitionBase.b(ST_Ext_$type, n.d));
                        break;
                    case "position":
                        c = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                        break;
                    case "selection":
                        d = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                        break;
                    case "grouping":
                        e = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                        break;
                    case "ungrouping":
                        f = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                        break;
                    case "rotation":
                        g = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                        break;
                    case "cropping":
                        h = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                        break;
                    case "verticies":
                        i = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                        break;
                    case "adjusthandles":
                        j = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                        break;
                    case "text":
                        k = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                        break;
                    case "aspectratio":
                        l = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                        break;
                    case "shapetype":
                        m = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(n.d)));
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i,
                p9: j,
                p10: k,
                p11: l,
                p12: m
            };
        }
        static cm(a, b = toNullable(ST_Ext_$type, null), c = toNullable(Boolean_$type, null), d = toNullable(Boolean_$type, null), e = toNullable(Boolean_$type, null), f = toNullable(Boolean_$type, null), g = toNullable(Boolean_$type, null), h = toNullable(Boolean_$type, null), i = toNullable(Boolean_$type, null), j = toNullable(Boolean_$type, null), k = toNullable(Boolean_$type, null), l = toNullable(Boolean_$type, null), m = toNullable(Boolean_$type, null)) {
            a.ad.p(OfficeNamespace.ap, "o");
            let n;
            if (nullableNotEquals(b, null)) {
                n = XmlNamespaceDefinitionBase.p(ST_Ext_$type, b.value);
                a.ad.h("urn:schemas-microsoft-com:vml/ext", n);
            }
            if (nullableNotEquals(c, null)) {
                n = ST_TrueFalse.k(ST_TrueFalse.b(c.value));
                a.ad.h("position", n);
            }
            if (nullableNotEquals(d, null)) {
                n = ST_TrueFalse.k(ST_TrueFalse.b(d.value));
                a.ad.h("selection", n);
            }
            if (nullableNotEquals(e, null)) {
                n = ST_TrueFalse.k(ST_TrueFalse.b(e.value));
                a.ad.h("grouping", n);
            }
            if (nullableNotEquals(f, null)) {
                n = ST_TrueFalse.k(ST_TrueFalse.b(f.value));
                a.ad.h("ungrouping", n);
            }
            if (nullableNotEquals(g, null)) {
                n = ST_TrueFalse.k(ST_TrueFalse.b(g.value));
                a.ad.h("rotation", n);
            }
            if (nullableNotEquals(h, null)) {
                n = ST_TrueFalse.k(ST_TrueFalse.b(h.value));
                a.ad.h("cropping", n);
            }
            if (nullableNotEquals(i, null)) {
                n = ST_TrueFalse.k(ST_TrueFalse.b(i.value));
                a.ad.h("verticies", n);
            }
            if (nullableNotEquals(j, null)) {
                n = ST_TrueFalse.k(ST_TrueFalse.b(j.value));
                a.ad.h("adjusthandles", n);
            }
            if (nullableNotEquals(k, null)) {
                n = ST_TrueFalse.k(ST_TrueFalse.b(k.value));
                a.ad.h("text", n);
            }
            if (nullableNotEquals(l, null)) {
                n = ST_TrueFalse.k(ST_TrueFalse.b(l.value));
                a.ad.h("aspectratio", n);
            }
            if (nullableNotEquals(m, null)) {
                n = ST_TrueFalse.k(ST_TrueFalse.b(m.value));
                a.ad.h("shapetype", n);
            }
        }
        static ck(a, b) {
            let c = a.ao("urn:schemas-microsoft-com:vml/ext");
            if (c == null) {
                b = toNullable(ST_Ext_$type, null);
            }
            else {
                b = toNullable(ST_Ext_$type, XmlNamespaceDefinitionBase.b(ST_Ext_$type, c));
            }
            return {
                p1: b
            };
        }
        static cn(a, b = toNullable(ST_Ext_$type, null)) {
            a.ad.p(OfficeNamespace.b7, "o");
            let c;
            if (nullableNotEquals(b, null)) {
                c = XmlNamespaceDefinitionBase.p(ST_Ext_$type, b.value);
                a.ad.h("urn:schemas-microsoft-com:vml/ext", c);
            }
        }
    }
    OfficeNamespace.$t = /*@__PURE__*/ markType(OfficeNamespace, 'OfficeNamespace', XmlNamespaceDefinitionBase.$);
    OfficeNamespace.bs = "urn:schemas-microsoft-com:office:office" + "/idmap";
    OfficeNamespace.ap = "urn:schemas-microsoft-com:office:office" + "/lock";
    OfficeNamespace.b7 = "urn:schemas-microsoft-com:office:office" + "/shapelayout";
    OfficeNamespace.as = "urn:schemas-microsoft-com:office:office" + "/allowincell";
    OfficeNamespace.au = "urn:schemas-microsoft-com:office:office" + "/althref";
    OfficeNamespace.at = "urn:schemas-microsoft-com:office:office" + "/allowoverlap";
    OfficeNamespace.a2 = "urn:schemas-microsoft-com:office:office" + "/bwmode";
    OfficeNamespace.a3 = "urn:schemas-microsoft-com:office:office" + "/bwnormal";
    OfficeNamespace.a4 = "urn:schemas-microsoft-com:office:office" + "/bwpure";
    OfficeNamespace.aw = "urn:schemas-microsoft-com:office:office" + "/borderbottomcolor";
    OfficeNamespace.ax = "urn:schemas-microsoft-com:office:office" + "/borderleftcolor";
    OfficeNamespace.ay = "urn:schemas-microsoft-com:office:office" + "/borderrightcolor";
    OfficeNamespace.az = "urn:schemas-microsoft-com:office:office" + "/bordertopcolor";
    OfficeNamespace.a0 = "urn:schemas-microsoft-com:office:office" + "/bullet";
    OfficeNamespace.a1 = "urn:schemas-microsoft-com:office:office" + "/button";
    OfficeNamespace.a5 = "urn:schemas-microsoft-com:office:office" + "/clip";
    OfficeNamespace.a6 = "urn:schemas-microsoft-com:office:office" + "/cliptowrap";
    OfficeNamespace.a7 = "urn:schemas-microsoft-com:office:office" + "/connectangles";
    OfficeNamespace.a8 = "urn:schemas-microsoft-com:office:office" + "/connectlocs";
    OfficeNamespace.a9 = "urn:schemas-microsoft-com:office:office" + "/connectortype";
    OfficeNamespace.ba = "urn:schemas-microsoft-com:office:office" + "/connecttype";
    OfficeNamespace.bd = "urn:schemas-microsoft-com:office:office" + "/detectmouseclick";
    OfficeNamespace.be = "urn:schemas-microsoft-com:office:office" + "/dgmlayout";
    OfficeNamespace.bf = "urn:schemas-microsoft-com:office:office" + "/dgmlayoutmru";
    OfficeNamespace.bg = "urn:schemas-microsoft-com:office:office" + "/dgmnodekind";
    OfficeNamespace.bh = "urn:schemas-microsoft-com:office:office" + "/doubleclicknotify";
    OfficeNamespace.bi = "urn:schemas-microsoft-com:office:office" + "/extrusionok";
    OfficeNamespace.bj = "urn:schemas-microsoft-com:office:office" + "/forcedash";
    OfficeNamespace.bk = "urn:schemas-microsoft-com:office:office" + "/gfxdata";
    OfficeNamespace.bm = "urn:schemas-microsoft-com:office:office" + "/hr";
    OfficeNamespace.bn = "urn:schemas-microsoft-com:office:office" + "/hralign";
    OfficeNamespace.bo = "urn:schemas-microsoft-com:office:office" + "/href";
    OfficeNamespace.bp = "urn:schemas-microsoft-com:office:office" + "/hrnoshade";
    OfficeNamespace.bq = "urn:schemas-microsoft-com:office:office" + "/hrpct";
    OfficeNamespace.br = "urn:schemas-microsoft-com:office:office" + "/hrstd";
    OfficeNamespace.bt = "urn:schemas-microsoft-com:office:office" + "/insetmode";
    OfficeNamespace.bu = "urn:schemas-microsoft-com:office:office" + "/movie";
    OfficeNamespace.bw = "urn:schemas-microsoft-com:office:office" + "/ole";
    OfficeNamespace.bx = "urn:schemas-microsoft-com:office:office" + "/oleicon";
    OfficeNamespace.by = "urn:schemas-microsoft-com:office:office" + "/oleid";
    OfficeNamespace.bz = "urn:schemas-microsoft-com:office:office" + "/oned";
    OfficeNamespace.b0 = "urn:schemas-microsoft-com:office:office" + "/opacity2";
    OfficeNamespace.b2 = "urn:schemas-microsoft-com:office:office" + "/preferrelative";
    OfficeNamespace.b3 = "urn:schemas-microsoft-com:office:office" + "/regroupid";
    OfficeNamespace.b4 = "urn:schemas-microsoft-com:office:office" + "/relid";
    OfficeNamespace.b9 = "urn:schemas-microsoft-com:office:office" + "/singleclick";
    OfficeNamespace.ca = "urn:schemas-microsoft-com:office:office" + "/spid";
    OfficeNamespace.cb = "urn:schemas-microsoft-com:office:office" + "/spt";
    OfficeNamespace.cd = "urn:schemas-microsoft-com:office:office" + "/title";
    OfficeNamespace.cf = "urn:schemas-microsoft-com:office:office" + "/userdrawn";
    OfficeNamespace.cg = "urn:schemas-microsoft-com:office:office" + "/userhidden";
    OfficeNamespace.ao = /*@__PURE__*/ new OfficeNamespace();
    return OfficeNamespace;
})();
/**
 * @hidden
 */
export let VmlNamespace = /*@__PURE__*/ (() => {
    class VmlNamespace extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0:
                case 1: return "urn:schemas-microsoft-com:vml";
                default: return "urn:schemas-microsoft-com:vml";
            }
        }
        get_t() {
            return "v";
        }
        get t() {
            return this.get_t();
        }
        static dp(a, b, c) {
            b = toNullable(Number_$type, null);
            c = toNullable(Number_$type, null);
            for (let d of fromEnum(a.ab.u)) {
                switch (d.a.e(a.d)) {
                    case "startAngle":
                        b = toNullable(Number_$type, parseNumber(d.d, CultureInfo.invariantCulture));
                        break;
                    case "endAngle":
                        c = toNullable(Number_$type, parseNumber(d.d, CultureInfo.invariantCulture));
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c
            };
        }
        static dy(a, b = toNullable(Number_$type, null), c = toNullable(Number_$type, null)) {
            a.ad.p("urn:schemas-microsoft-com:vml/arc", "v");
            let d;
            if (nullableNotEquals(b, null)) {
                d = numberToString(b.value, CultureInfo.invariantCulture);
                a.ad.h("startAngle", d);
            }
            if (nullableNotEquals(c, null)) {
                d = numberToString(c.value, CultureInfo.invariantCulture);
                a.ad.h("endAngle", d);
            }
        }
        static dq(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab) {
            b = null;
            c = toNullable(ST_FillType_$type, null);
            d = toNullable(Boolean_$type, null);
            e = null;
            f = null;
            g = null;
            h = null;
            i = null;
            j = null;
            k = null;
            l = null;
            m = null;
            n = toNullable(ST_ImageAspect_$type, null);
            o = null;
            p = toNullable(Number_$type, null);
            q = toNullable(Boolean_$type, null);
            r = null;
            s = null;
            t = null;
            u = toNullable(ST_FillMethod_$type, null);
            v = toNullable(Boolean_$type, null);
            w = null;
            x = null;
            y = toNullable(Boolean_$type, null);
            z = toNullable(Boolean_$type, null);
            aa = null;
            ab = null;
            for (let ac of fromEnum(a.ab.u)) {
                switch (ac.a.e(a.d)) {
                    case "id":
                        b = ac.d;
                        break;
                    case "type":
                        c = toNullable(ST_FillType_$type, XmlNamespaceDefinitionBase.b(ST_FillType_$type, ac.d));
                        break;
                    case "on":
                        d = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ac.d)));
                        break;
                    case "color":
                        e = ac.d;
                        break;
                    case "opacity":
                        f = ac.d;
                        break;
                    case "color2":
                        g = ac.d;
                        break;
                    case "src":
                        h = ac.d;
                        break;
                    case OfficeNamespace.bo:
                        i = ac.d;
                        break;
                    case OfficeNamespace.au:
                        j = ac.d;
                        break;
                    case "size":
                        k = ac.d;
                        break;
                    case "origin":
                        l = ac.d;
                        break;
                    case "position":
                        m = ac.d;
                        break;
                    case "aspect":
                        n = toNullable(ST_ImageAspect_$type, XmlNamespaceDefinitionBase.b(ST_ImageAspect_$type, ac.d));
                        break;
                    case "colors":
                        o = ac.d;
                        break;
                    case "angle":
                        p = toNullable(Number_$type, parseNumber(ac.d, CultureInfo.invariantCulture));
                        break;
                    case "alignshape":
                        q = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ac.d)));
                        break;
                    case "focus":
                        r = ac.d;
                        break;
                    case "focussize":
                        s = ac.d;
                        break;
                    case "focusposition":
                        t = ac.d;
                        break;
                    case "method":
                        u = toNullable(ST_FillMethod_$type, XmlNamespaceDefinitionBase.b(ST_FillMethod_$type, ac.d));
                        break;
                    case OfficeNamespace.bd:
                        v = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ac.d)));
                        break;
                    case OfficeNamespace.cd:
                        w = ac.d;
                        break;
                    case OfficeNamespace.b0:
                        x = ac.d;
                        break;
                    case "recolor":
                        y = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ac.d)));
                        break;
                    case "rotate":
                        z = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ac.d)));
                        break;
                    case OfficeDocumentRelationships.as:
                        aa = ac.d;
                        break;
                    case OfficeNamespace.b4:
                        ab = ac.d;
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i,
                p9: j,
                p10: k,
                p11: l,
                p12: m,
                p13: n,
                p14: o,
                p15: p,
                p16: q,
                p17: r,
                p18: s,
                p19: t,
                p20: u,
                p21: v,
                p22: w,
                p23: x,
                p24: y,
                p25: z,
                p26: aa,
                p27: ab
            };
        }
        static dz(a, b = null, c = toNullable(ST_FillType_$type, null), d = toNullable(Boolean_$type, null), e = null, f = null, g = null, h = null, i = null, j = null, k = null, l = null, m = null, n = toNullable(ST_ImageAspect_$type, null), o = null, p = toNullable(Number_$type, null), q = toNullable(Boolean_$type, null), r = null, s = null, t = null, u = toNullable(ST_FillMethod_$type, null), v = toNullable(Boolean_$type, null), w = null, x = null, y = toNullable(Boolean_$type, null), z = toNullable(Boolean_$type, null), aa = null, ab = null) {
            a.ad.p("urn:schemas-microsoft-com:vml/fill", "v");
            let ac;
            ac = b;
            a.ad.h("id", ac);
            if (nullableNotEquals(c, null)) {
                ac = XmlNamespaceDefinitionBase.p(ST_FillType_$type, c.value);
                a.ad.h("type", ac);
            }
            if (nullableNotEquals(d, null)) {
                ac = ST_TrueFalse.k(ST_TrueFalse.b(d.value));
                a.ad.h("on", ac);
            }
            ac = e;
            a.ad.h("color", ac);
            ac = f;
            a.ad.h("opacity", ac);
            ac = g;
            a.ad.h("color2", ac);
            ac = h;
            a.ad.h("src", ac);
            ac = i;
            a.ad.h(OfficeNamespace.bo, ac);
            ac = j;
            a.ad.h(OfficeNamespace.au, ac);
            ac = k;
            a.ad.h("size", ac);
            ac = l;
            a.ad.h("origin", ac);
            ac = m;
            a.ad.h("position", ac);
            if (nullableNotEquals(n, null)) {
                ac = XmlNamespaceDefinitionBase.p(ST_ImageAspect_$type, n.value);
                a.ad.h("aspect", ac);
            }
            ac = o;
            a.ad.h("colors", ac);
            if (nullableNotEquals(p, null)) {
                ac = numberToString(p.value, CultureInfo.invariantCulture);
                a.ad.h("angle", ac);
            }
            if (nullableNotEquals(q, null)) {
                ac = ST_TrueFalse.k(ST_TrueFalse.b(q.value));
                a.ad.h("alignshape", ac);
            }
            ac = r;
            a.ad.h("focus", ac);
            ac = s;
            a.ad.h("focussize", ac);
            ac = t;
            a.ad.h("focusposition", ac);
            if (nullableNotEquals(u, null)) {
                ac = XmlNamespaceDefinitionBase.p(ST_FillMethod_$type, u.value);
                a.ad.h("method", ac);
            }
            if (nullableNotEquals(v, null)) {
                ac = ST_TrueFalse.k(ST_TrueFalse.b(v.value));
                a.ad.h(OfficeNamespace.bd, ac);
            }
            ac = w;
            a.ad.h(OfficeNamespace.cd, ac);
            ac = x;
            a.ad.h(OfficeNamespace.b0, ac);
            if (nullableNotEquals(y, null)) {
                ac = ST_TrueFalse.k(ST_TrueFalse.b(y.value));
                a.ad.h("recolor", ac);
            }
            if (nullableNotEquals(z, null)) {
                ac = ST_TrueFalse.k(ST_TrueFalse.b(z.value));
                a.ad.h("rotate", ac);
            }
            ac = aa;
            a.ad.h(OfficeDocumentRelationships.as, ac);
            ac = ab;
            a.ad.h(OfficeNamespace.b4, ac);
        }
        static dr(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y) {
            b = null;
            c = null;
            d = null;
            e = null;
            f = null;
            g = null;
            h = null;
            i = null;
            j = null;
            k = toNullable(Boolean_$type, null);
            l = toNullable(Boolean_$type, null);
            m = null;
            n = null;
            o = null;
            p = null;
            q = null;
            r = null;
            s = toNullable(Number_$type, null);
            t = toNullable(Boolean_$type, null);
            u = toNullable(Number_$type, null);
            v = null;
            w = null;
            x = null;
            y = null;
            for (let z of fromEnum(a.ab.u)) {
                switch (z.a.e(a.d)) {
                    case "id":
                        b = z.d;
                        break;
                    case "src":
                        c = z.d;
                        break;
                    case "cropleft":
                        d = z.d;
                        break;
                    case "croptop":
                        e = z.d;
                        break;
                    case "cropright":
                        f = z.d;
                        break;
                    case "cropbottom":
                        g = z.d;
                        break;
                    case "gain":
                        h = z.d;
                        break;
                    case "blacklevel":
                        i = z.d;
                        break;
                    case "gamma":
                        j = z.d;
                        break;
                    case "grayscale":
                        k = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(z.d)));
                        break;
                    case "bilevel":
                        l = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(z.d)));
                        break;
                    case "chromakey":
                        m = z.d;
                        break;
                    case "embosscolor":
                        n = z.d;
                        break;
                    case "recolortarget":
                        o = z.d;
                        break;
                    case OfficeNamespace.bo:
                        p = z.d;
                        break;
                    case OfficeNamespace.au:
                        q = z.d;
                        break;
                    case OfficeNamespace.cd:
                        r = z.d;
                        break;
                    case OfficeNamespace.by:
                        s = toNullable(Number_$type, parseNumber(z.d, CultureInfo.invariantCulture));
                        break;
                    case OfficeNamespace.bd:
                        t = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(z.d)));
                        break;
                    case OfficeNamespace.bu:
                        u = toNullable(Number_$type, parseNumber(z.d, CultureInfo.invariantCulture));
                        break;
                    case OfficeNamespace.b4:
                        v = z.d;
                        break;
                    case OfficeDocumentRelationships.as:
                        w = z.d;
                        break;
                    case OfficeDocumentRelationships.aw:
                        x = z.d;
                        break;
                    case OfficeDocumentRelationships.ar:
                        y = z.d;
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i,
                p9: j,
                p10: k,
                p11: l,
                p12: m,
                p13: n,
                p14: o,
                p15: p,
                p16: q,
                p17: r,
                p18: s,
                p19: t,
                p20: u,
                p21: v,
                p22: w,
                p23: x,
                p24: y
            };
        }
        static d0(a, b = null, c = null, d = null, e = null, f = null, g = null, h = null, i = null, j = null, k = toNullable(Boolean_$type, null), l = toNullable(Boolean_$type, null), m = null, n = null, o = null, p = null, q = null, r = null, s = toNullable(Number_$type, null), t = toNullable(Boolean_$type, null), u = toNullable(Number_$type, null), v = null, w = null, x = null, y = null) {
            a.ad.p("urn:schemas-microsoft-com:vml/imagedata", "v");
            let z;
            z = b;
            a.ad.h("id", z);
            z = c;
            a.ad.h("src", z);
            z = d;
            a.ad.h("cropleft", z);
            z = e;
            a.ad.h("croptop", z);
            z = f;
            a.ad.h("cropright", z);
            z = g;
            a.ad.h("cropbottom", z);
            z = h;
            a.ad.h("gain", z);
            z = i;
            a.ad.h("blacklevel", z);
            z = j;
            a.ad.h("gamma", z);
            if (nullableNotEquals(k, null)) {
                z = ST_TrueFalse.k(ST_TrueFalse.b(k.value));
                a.ad.h("grayscale", z);
            }
            if (nullableNotEquals(l, null)) {
                z = ST_TrueFalse.k(ST_TrueFalse.b(l.value));
                a.ad.h("bilevel", z);
            }
            z = m;
            a.ad.h("chromakey", z);
            z = n;
            a.ad.h("embosscolor", z);
            z = o;
            a.ad.h("recolortarget", z);
            z = p;
            a.ad.h(OfficeNamespace.bo, z);
            z = q;
            a.ad.h(OfficeNamespace.au, z);
            z = r;
            a.ad.h(OfficeNamespace.cd, z);
            if (nullableNotEquals(s, null)) {
                z = numberToString(s.value, CultureInfo.invariantCulture);
                a.ad.h(OfficeNamespace.by, z);
            }
            if (nullableNotEquals(t, null)) {
                z = ST_TrueFalse.k(ST_TrueFalse.b(t.value));
                a.ad.h(OfficeNamespace.bd, z);
            }
            if (nullableNotEquals(u, null)) {
                z = numberToString(u.value, CultureInfo.invariantCulture);
                a.ad.h(OfficeNamespace.bu, z);
            }
            z = v;
            a.ad.h(OfficeNamespace.b4, z);
            z = w;
            a.ad.h(OfficeDocumentRelationships.as, z);
            z = x;
            a.ad.h(OfficeDocumentRelationships.aw, z);
            z = y;
            a.ad.h(OfficeDocumentRelationships.ar, z);
        }
        static ds(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {
            b = null;
            c = null;
            d = null;
            e = null;
            f = toNullable(Boolean_$type, null);
            g = toNullable(Boolean_$type, null);
            h = toNullable(Boolean_$type, null);
            i = toNullable(Boolean_$type, null);
            j = toNullable(Boolean_$type, null);
            k = toNullable(Boolean_$type, null);
            l = toNullable(Boolean_$type, null);
            m = toNullable(ST_ConnectType_$type, null);
            n = null;
            o = null;
            p = toNullable(Boolean_$type, null);
            for (let q of fromEnum(a.ab.u)) {
                switch (q.a.e(a.d)) {
                    case "id":
                        b = q.d;
                        break;
                    case "v":
                        c = q.d;
                        break;
                    case "limo":
                        d = q.d;
                        break;
                    case "textboxrect":
                        e = q.d;
                        break;
                    case "fillok":
                        f = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                        break;
                    case "strokeok":
                        g = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                        break;
                    case "shadowok":
                        h = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                        break;
                    case "arrowok":
                        i = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                        break;
                    case "gradientshapeok":
                        j = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                        break;
                    case "textpathok":
                        k = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                        break;
                    case "insetpenok":
                        l = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                        break;
                    case OfficeNamespace.ba:
                        m = toNullable(ST_ConnectType_$type, XmlNamespaceDefinitionBase.b(ST_ConnectType_$type, q.d));
                        break;
                    case OfficeNamespace.a8:
                        n = q.d;
                        break;
                    case OfficeNamespace.a7:
                        o = q.d;
                        break;
                    case OfficeNamespace.bi:
                        p = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(q.d)));
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i,
                p9: j,
                p10: k,
                p11: l,
                p12: m,
                p13: n,
                p14: o,
                p15: p
            };
        }
        static d1(a, b = null, c = null, d = null, e = null, f = toNullable(Boolean_$type, null), g = toNullable(Boolean_$type, null), h = toNullable(Boolean_$type, null), i = toNullable(Boolean_$type, null), j = toNullable(Boolean_$type, null), k = toNullable(Boolean_$type, null), l = toNullable(Boolean_$type, null), m = toNullable(ST_ConnectType_$type, null), n = null, o = null, p = toNullable(Boolean_$type, null)) {
            a.ad.p("urn:schemas-microsoft-com:vml/path", "v");
            let q;
            q = b;
            a.ad.h("id", q);
            q = c;
            a.ad.h("v", q);
            q = d;
            a.ad.h("limo", q);
            q = e;
            a.ad.h("textboxrect", q);
            if (nullableNotEquals(f, null)) {
                q = ST_TrueFalse.k(ST_TrueFalse.b(f.value));
                a.ad.h("fillok", q);
            }
            if (nullableNotEquals(g, null)) {
                q = ST_TrueFalse.k(ST_TrueFalse.b(g.value));
                a.ad.h("strokeok", q);
            }
            if (nullableNotEquals(h, null)) {
                q = ST_TrueFalse.k(ST_TrueFalse.b(h.value));
                a.ad.h("shadowok", q);
            }
            if (nullableNotEquals(i, null)) {
                q = ST_TrueFalse.k(ST_TrueFalse.b(i.value));
                a.ad.h("arrowok", q);
            }
            if (nullableNotEquals(j, null)) {
                q = ST_TrueFalse.k(ST_TrueFalse.b(j.value));
                a.ad.h("gradientshapeok", q);
            }
            if (nullableNotEquals(k, null)) {
                q = ST_TrueFalse.k(ST_TrueFalse.b(k.value));
                a.ad.h("textpathok", q);
            }
            if (nullableNotEquals(l, null)) {
                q = ST_TrueFalse.k(ST_TrueFalse.b(l.value));
                a.ad.h("insetpenok", q);
            }
            if (nullableNotEquals(m, null)) {
                q = XmlNamespaceDefinitionBase.p(ST_ConnectType_$type, m.value);
                a.ad.h(OfficeNamespace.ba, q);
            }
            q = n;
            a.ad.h(OfficeNamespace.a8, q);
            q = o;
            a.ad.h(OfficeNamespace.a7, q);
            if (nullableNotEquals(p, null)) {
                q = ST_TrueFalse.k(ST_TrueFalse.b(p.value));
                a.ad.h(OfficeNamespace.bi, q);
            }
        }
        static dt(a, b, c, d, e, f, g, h, i, j, k, l) {
            b = null;
            c = toNullable(Boolean_$type, null);
            d = toNullable(ST_ShadowType_$type, null);
            e = toNullable(Boolean_$type, null);
            f = null;
            g = null;
            h = null;
            i = null;
            j = null;
            k = null;
            l = null;
            for (let m of fromEnum(a.ab.u)) {
                switch (m.a.e(a.d)) {
                    case "id":
                        b = m.d;
                        break;
                    case "on":
                        c = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(m.d)));
                        break;
                    case "type":
                        d = toNullable(ST_ShadowType_$type, XmlNamespaceDefinitionBase.b(ST_ShadowType_$type, m.d));
                        break;
                    case "obscured":
                        e = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(m.d)));
                        break;
                    case "color":
                        f = m.d;
                        break;
                    case "opacity":
                        g = m.d;
                        break;
                    case "offset":
                        h = m.d;
                        break;
                    case "color2":
                        i = m.d;
                        break;
                    case "offset2":
                        j = m.d;
                        break;
                    case "origin":
                        k = m.d;
                        break;
                    case "matrix":
                        l = m.d;
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i,
                p9: j,
                p10: k,
                p11: l
            };
        }
        static d2(a, b = null, c = toNullable(Boolean_$type, null), d = toNullable(ST_ShadowType_$type, null), e = toNullable(Boolean_$type, null), f = null, g = null, h = null, i = null, j = null, k = null, l = null) {
            a.ad.p("urn:schemas-microsoft-com:vml/shadow", "v");
            let m;
            m = b;
            a.ad.h("id", m);
            if (nullableNotEquals(c, null)) {
                m = ST_TrueFalse.k(ST_TrueFalse.b(c.value));
                a.ad.h("on", m);
            }
            if (nullableNotEquals(d, null)) {
                m = XmlNamespaceDefinitionBase.p(ST_ShadowType_$type, d.value);
                a.ad.h("type", m);
            }
            if (nullableNotEquals(e, null)) {
                m = ST_TrueFalse.k(ST_TrueFalse.b(e.value));
                a.ad.h("obscured", m);
            }
            m = f;
            a.ad.h("color", m);
            m = g;
            a.ad.h("opacity", m);
            m = h;
            a.ad.h("offset", m);
            m = i;
            a.ad.h("color2", m);
            m = j;
            a.ad.h("offset2", m);
            m = k;
            a.ad.h("origin", m);
            m = l;
            a.ad.h("matrix", m);
        }
        static du(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, an, ao, ap, aq, ar, as, at, au, av, aw, ax, ay, az, a0, a1, a2, a3, a4, a5, a6) {
            b = null;
            c = null;
            d = null;
            e = null;
            f = null;
            g = null;
            h = null;
            i = null;
            j = null;
            k = null;
            l = toNullable(Boolean_$type, null);
            m = null;
            n = toNullable(Boolean_$type, null);
            o = null;
            p = toNullable(Boolean_$type, null);
            q = toNullable(Boolean_$type, null);
            r = toNullable(Boolean_$type, null);
            s = toNullable(Boolean_$type, null);
            t = toNullable(Boolean_$type, null);
            u = toNullable(Boolean_$type, null);
            v = toNullable(Boolean_$type, null);
            w = toNullable(Number_$type, null);
            x = toNullable(ST_HrAlign_$type, null);
            y = toNullable(Boolean_$type, null);
            z = toNullable(Boolean_$type, null);
            aa = toNullable(Boolean_$type, null);
            ab = null;
            ac = null;
            ad = null;
            ae = null;
            af = null;
            ag = null;
            ah = null;
            ai = toNullable(ST_InsetMode_$type, null);
            aj = null;
            ak = toNullable(Boolean_$type, null);
            al = null;
            am = null;
            an = toNullable(Boolean_$type, null);
            ao = null;
            ap = null;
            aq = toNullable(Boolean_$type, null);
            ar = toNullable(Number_$type, null);
            as = toNullable(ST_ConnectorType_$type, null);
            at = toNullable(ST_BWMode_$type, null);
            au = toNullable(ST_BWMode_$type, null);
            av = toNullable(ST_BWMode_$type, null);
            aw = toNullable(Boolean_$type, null);
            ax = toNullable(Boolean_$type, null);
            ay = toNullable(Boolean_$type, null);
            az = toNullable(Boolean_$type, null);
            a0 = toNullable(Boolean_$type, null);
            a1 = toNullable(Boolean_$type, null);
            a2 = null;
            a3 = null;
            a4 = null;
            a5 = null;
            a6 = null;
            for (let a7 of fromEnum(a.ab.u)) {
                switch (a7.a.e(a.d)) {
                    case "id":
                        b = a7.d;
                        break;
                    case "style":
                        c = a7.d;
                        break;
                    case "href":
                        d = a7.d;
                        break;
                    case "target":
                        e = a7.d;
                        break;
                    case "class":
                        f = a7.d;
                        break;
                    case "title":
                        g = a7.d;
                        break;
                    case "alt":
                        h = a7.d;
                        break;
                    case "coordsize":
                        i = a7.d;
                        break;
                    case "coordorigin":
                        j = a7.d;
                        break;
                    case "wrapcoords":
                        k = a7.d;
                        break;
                    case "print":
                        l = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.ca:
                        m = a7.d;
                        break;
                    case OfficeNamespace.bz:
                        n = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.b3:
                        o = a7.d;
                        break;
                    case OfficeNamespace.bh:
                        p = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.a1:
                        q = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.cg:
                        r = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.a0:
                        s = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.bm:
                        t = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.br:
                        u = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.bp:
                        v = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.bq:
                        w = toNullable(Number_$type, parseNumber(a7.d, CultureInfo.invariantCulture));
                        break;
                    case OfficeNamespace.bn:
                        x = toNullable(ST_HrAlign_$type, XmlNamespaceDefinitionBase.b(ST_HrAlign_$type, a7.d));
                        break;
                    case OfficeNamespace.as:
                        y = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.at:
                        z = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.cf:
                        aa = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case "bordertopcolor":
                        ab = a7.d;
                        break;
                    case "borderleftcolor":
                        ac = a7.d;
                        break;
                    case "borderbottomcolor":
                        ad = a7.d;
                        break;
                    case "borderrightcolor":
                        ae = a7.d;
                        break;
                    case OfficeNamespace.be:
                        af = a7.d;
                        break;
                    case OfficeNamespace.bg:
                        ag = a7.d;
                        break;
                    case OfficeNamespace.bf:
                        ah = a7.d;
                        break;
                    case OfficeNamespace.bt:
                        ai = toNullable(ST_InsetMode_$type, XmlNamespaceDefinitionBase.b(ST_InsetMode_$type, a7.d));
                        break;
                    case "chromakey":
                        aj = a7.d;
                        break;
                    case "filled":
                        ak = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case "fillcolor":
                        al = a7.d;
                        break;
                    case "opacity":
                        am = a7.d;
                        break;
                    case "stroked":
                        an = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case "strokecolor":
                        ao = a7.d;
                        break;
                    case "strokeweight":
                        ap = a7.d;
                        break;
                    case "insetpen":
                        aq = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.cb:
                        ar = toNullable(Number_$type, parseNumber(a7.d, CultureInfo.invariantCulture));
                        break;
                    case OfficeNamespace.a9:
                        as = toNullable(ST_ConnectorType_$type, XmlNamespaceDefinitionBase.b(ST_ConnectorType_$type, a7.d));
                        break;
                    case "bwmode":
                        at = toNullable(ST_BWMode_$type, XmlNamespaceDefinitionBase.b(ST_BWMode_$type, a7.d));
                        break;
                    case "bwpure":
                        au = toNullable(ST_BWMode_$type, XmlNamespaceDefinitionBase.b(ST_BWMode_$type, a7.d));
                        break;
                    case "bwnormal":
                        av = toNullable(ST_BWMode_$type, XmlNamespaceDefinitionBase.b(ST_BWMode_$type, a7.d));
                        break;
                    case OfficeNamespace.bj:
                        aw = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.bx:
                        ax = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.bw:
                        ay = toNullable(Boolean_$type, ST_TrueFalseBlank.d(a7.d));
                        break;
                    case OfficeNamespace.b2:
                        az = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.a6:
                        a0 = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case OfficeNamespace.a5:
                        a1 = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a7.d)));
                        break;
                    case "type":
                        a2 = a7.d;
                        break;
                    case "adj":
                        a3 = a7.d;
                        break;
                    case "path":
                        a4 = a7.d;
                        break;
                    case "gfxdata":
                        a5 = a7.d;
                        break;
                    case "equationxml":
                        a6 = a7.d;
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i,
                p9: j,
                p10: k,
                p11: l,
                p12: m,
                p13: n,
                p14: o,
                p15: p,
                p16: q,
                p17: r,
                p18: s,
                p19: t,
                p20: u,
                p21: v,
                p22: w,
                p23: x,
                p24: y,
                p25: z,
                p26: aa,
                p27: ab,
                p28: ac,
                p29: ad,
                p30: ae,
                p31: af,
                p32: ag,
                p33: ah,
                p34: ai,
                p35: aj,
                p36: ak,
                p37: al,
                p38: am,
                p39: an,
                p40: ao,
                p41: ap,
                p42: aq,
                p43: ar,
                p44: as,
                p45: at,
                p46: au,
                p47: av,
                p48: aw,
                p49: ax,
                p50: ay,
                p51: az,
                p52: a0,
                p53: a1,
                p54: a2,
                p55: a3,
                p56: a4,
                p57: a5,
                p58: a6
            };
        }
        static d3(a, b = null, c = null, d = null, e = null, f = null, g = null, h = null, i = null, j = null, k = null, l = toNullable(Boolean_$type, null), m = null, n = toNullable(Boolean_$type, null), o = null, p = toNullable(Boolean_$type, null), q = toNullable(Boolean_$type, null), r = toNullable(Boolean_$type, null), s = toNullable(Boolean_$type, null), t = toNullable(Boolean_$type, null), u = toNullable(Boolean_$type, null), v = toNullable(Boolean_$type, null), w = toNullable(Number_$type, null), x = toNullable(ST_HrAlign_$type, null), y = toNullable(Boolean_$type, null), z = toNullable(Boolean_$type, null), aa = toNullable(Boolean_$type, null), ab = null, ac = null, ad = null, ae = null, af = null, ag = null, ah = null, ai = toNullable(ST_InsetMode_$type, null), aj = null, ak = toNullable(Boolean_$type, null), al = null, am = null, an = toNullable(Boolean_$type, null), ao = null, ap = null, aq = toNullable(Boolean_$type, null), ar = toNullable(Number_$type, null), as = toNullable(ST_ConnectorType_$type, null), at = toNullable(ST_BWMode_$type, null), au = toNullable(ST_BWMode_$type, null), av = toNullable(ST_BWMode_$type, null), aw = toNullable(Boolean_$type, null), ax = toNullable(Boolean_$type, null), ay = toNullable(Boolean_$type, null), az = toNullable(Boolean_$type, null), a0 = toNullable(Boolean_$type, null), a1 = toNullable(Boolean_$type, null), a2 = null, a3 = null, a4 = null, a5 = null, a6 = null) {
            a.ad.p("urn:schemas-microsoft-com:vml/shape", "v");
            let a7;
            a7 = b;
            a.ad.h("id", a7);
            a7 = c;
            a.ad.h("style", a7);
            a7 = d;
            a.ad.h("href", a7);
            a7 = e;
            a.ad.h("target", a7);
            a7 = f;
            a.ad.h("class", a7);
            a7 = g;
            a.ad.h("title", a7);
            a7 = h;
            a.ad.h("alt", a7);
            a7 = i;
            a.ad.h("coordsize", a7);
            a7 = j;
            a.ad.h("coordorigin", a7);
            a7 = k;
            a.ad.h("wrapcoords", a7);
            if (nullableNotEquals(l, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(l.value));
                a.ad.h("print", a7);
            }
            a7 = m;
            a.ad.h(OfficeNamespace.ca, a7);
            if (nullableNotEquals(n, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(n.value));
                a.ad.h(OfficeNamespace.bz, a7);
            }
            a7 = o;
            a.ad.h(OfficeNamespace.b3, a7);
            if (nullableNotEquals(p, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(p.value));
                a.ad.h(OfficeNamespace.bh, a7);
            }
            if (nullableNotEquals(q, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(q.value));
                a.ad.h(OfficeNamespace.a1, a7);
            }
            if (nullableNotEquals(r, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(r.value));
                a.ad.h(OfficeNamespace.cg, a7);
            }
            if (nullableNotEquals(s, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(s.value));
                a.ad.h(OfficeNamespace.a0, a7);
            }
            if (nullableNotEquals(t, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(t.value));
                a.ad.h(OfficeNamespace.bm, a7);
            }
            if (nullableNotEquals(u, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(u.value));
                a.ad.h(OfficeNamespace.br, a7);
            }
            if (nullableNotEquals(v, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(v.value));
                a.ad.h(OfficeNamespace.bp, a7);
            }
            if (nullableNotEquals(w, null)) {
                a7 = numberToString(w.value, CultureInfo.invariantCulture);
                a.ad.h(OfficeNamespace.bq, a7);
            }
            if (nullableNotEquals(x, null)) {
                a7 = XmlNamespaceDefinitionBase.p(ST_HrAlign_$type, x.value);
                a.ad.h(OfficeNamespace.bn, a7);
            }
            if (nullableNotEquals(y, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(y.value));
                a.ad.h(OfficeNamespace.as, a7);
            }
            if (nullableNotEquals(z, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(z.value));
                a.ad.h(OfficeNamespace.at, a7);
            }
            if (nullableNotEquals(aa, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(aa.value));
                a.ad.h(OfficeNamespace.cf, a7);
            }
            a7 = ab;
            a.ad.h("bordertopcolor", a7);
            a7 = ac;
            a.ad.h("borderleftcolor", a7);
            a7 = ad;
            a.ad.h("borderbottomcolor", a7);
            a7 = ae;
            a.ad.h("borderrightcolor", a7);
            a7 = af;
            a.ad.h(OfficeNamespace.be, a7);
            a7 = ag;
            a.ad.h(OfficeNamespace.bg, a7);
            a7 = ah;
            a.ad.h(OfficeNamespace.bf, a7);
            if (nullableNotEquals(ai, null)) {
                a7 = XmlNamespaceDefinitionBase.p(ST_InsetMode_$type, ai.value);
                a.ad.h(OfficeNamespace.bt, a7);
            }
            a7 = aj;
            a.ad.h("chromakey", a7);
            if (nullableNotEquals(ak, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(ak.value));
                a.ad.h("filled", a7);
            }
            a7 = al;
            a.ad.h("fillcolor", a7);
            a7 = am;
            a.ad.h("opacity", a7);
            if (nullableNotEquals(an, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(an.value));
                a.ad.h("stroked", a7);
            }
            a7 = ao;
            a.ad.h("strokecolor", a7);
            a7 = ap;
            a.ad.h("strokeweight", a7);
            if (nullableNotEquals(aq, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(aq.value));
                a.ad.h("insetpen", a7);
            }
            if (nullableNotEquals(ar, null)) {
                a7 = numberToString(ar.value, CultureInfo.invariantCulture);
                a.ad.h(OfficeNamespace.cb, a7);
            }
            if (nullableNotEquals(as, null)) {
                a7 = XmlNamespaceDefinitionBase.p(ST_ConnectorType_$type, as.value);
                a.ad.h(OfficeNamespace.a9, a7);
            }
            if (nullableNotEquals(at, null)) {
                a7 = XmlNamespaceDefinitionBase.p(ST_BWMode_$type, at.value);
                a.ad.h("bwmode", a7);
            }
            if (nullableNotEquals(au, null)) {
                a7 = XmlNamespaceDefinitionBase.p(ST_BWMode_$type, au.value);
                a.ad.h("bwpure", a7);
            }
            if (nullableNotEquals(av, null)) {
                a7 = XmlNamespaceDefinitionBase.p(ST_BWMode_$type, av.value);
                a.ad.h("bwnormal", a7);
            }
            if (nullableNotEquals(aw, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(aw.value));
                a.ad.h(OfficeNamespace.bj, a7);
            }
            if (nullableNotEquals(ax, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(ax.value));
                a.ad.h(OfficeNamespace.bx, a7);
            }
            if (nullableNotEquals(ay, null)) {
                a7 = ST_TrueFalseBlank.f(ay.value);
                a.ad.h(OfficeNamespace.bw, a7);
            }
            if (nullableNotEquals(az, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(az.value));
                a.ad.h(OfficeNamespace.b2, a7);
            }
            if (nullableNotEquals(a0, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(a0.value));
                a.ad.h(OfficeNamespace.a6, a7);
            }
            if (nullableNotEquals(a1, null)) {
                a7 = ST_TrueFalse.k(ST_TrueFalse.b(a1.value));
                a.ad.h(OfficeNamespace.a5, a7);
            }
            a7 = a2;
            a.ad.h("type", a7);
            a7 = a3;
            a.ad.h("adj", a7);
            a7 = a4;
            a.ad.h("path", a7);
            a7 = a5;
            a.ad.h("gfxdata", a7);
            a7 = a6;
            a.ad.h("equationxml", a7);
        }
        static dv(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, an, ao, ap, aq, ar, as, at, au, av, aw, ax, ay, az, a0, a1, a2, a3, a4) {
            b = null;
            c = null;
            d = null;
            e = null;
            f = null;
            g = null;
            h = null;
            i = null;
            j = null;
            k = null;
            l = toNullable(Boolean_$type, null);
            m = null;
            n = toNullable(Boolean_$type, null);
            o = null;
            p = toNullable(Boolean_$type, null);
            q = toNullable(Boolean_$type, null);
            r = toNullable(Boolean_$type, null);
            s = toNullable(Boolean_$type, null);
            t = toNullable(Boolean_$type, null);
            u = toNullable(Boolean_$type, null);
            v = toNullable(Boolean_$type, null);
            w = toNullable(Number_$type, null);
            x = toNullable(ST_HrAlign_$type, null);
            y = toNullable(Boolean_$type, null);
            z = toNullable(Boolean_$type, null);
            aa = toNullable(Boolean_$type, null);
            ab = null;
            ac = null;
            ad = null;
            ae = null;
            af = null;
            ag = null;
            ah = null;
            ai = toNullable(ST_InsetMode_$type, null);
            aj = null;
            ak = toNullable(Boolean_$type, null);
            al = null;
            am = null;
            an = toNullable(Boolean_$type, null);
            ao = null;
            ap = null;
            aq = toNullable(Boolean_$type, null);
            ar = toNullable(Number_$type, null);
            as = toNullable(ST_ConnectorType_$type, null);
            at = toNullable(ST_BWMode_$type, null);
            au = toNullable(ST_BWMode_$type, null);
            av = toNullable(ST_BWMode_$type, null);
            aw = toNullable(Boolean_$type, null);
            ax = toNullable(Boolean_$type, null);
            ay = toNullable(Boolean_$type, null);
            az = toNullable(Boolean_$type, null);
            a0 = toNullable(Boolean_$type, null);
            a1 = toNullable(Boolean_$type, null);
            a2 = null;
            a3 = null;
            a4 = null;
            for (let a5 of fromEnum(a.ab.u)) {
                switch (a5.a.e(a.d)) {
                    case "id":
                        b = a5.d;
                        break;
                    case "style":
                        c = a5.d;
                        break;
                    case "href":
                        d = a5.d;
                        break;
                    case "target":
                        e = a5.d;
                        break;
                    case "class":
                        f = a5.d;
                        break;
                    case "title":
                        g = a5.d;
                        break;
                    case "alt":
                        h = a5.d;
                        break;
                    case "coordsize":
                        i = a5.d;
                        break;
                    case "coordorigin":
                        j = a5.d;
                        break;
                    case "wrapcoords":
                        k = a5.d;
                        break;
                    case "print":
                        l = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.ca:
                        m = a5.d;
                        break;
                    case OfficeNamespace.bz:
                        n = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.b3:
                        o = a5.d;
                        break;
                    case OfficeNamespace.bh:
                        p = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.a1:
                        q = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.cg:
                        r = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.a0:
                        s = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.bm:
                        t = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.br:
                        u = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.bp:
                        v = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.bq:
                        w = toNullable(Number_$type, parseNumber(a5.d, CultureInfo.invariantCulture));
                        break;
                    case OfficeNamespace.bn:
                        x = toNullable(ST_HrAlign_$type, XmlNamespaceDefinitionBase.b(ST_HrAlign_$type, a5.d));
                        break;
                    case OfficeNamespace.as:
                        y = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.at:
                        z = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.cf:
                        aa = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case "bordertopcolor":
                        ab = a5.d;
                        break;
                    case "borderleftcolor":
                        ac = a5.d;
                        break;
                    case "borderbottomcolor":
                        ad = a5.d;
                        break;
                    case "borderrightcolor":
                        ae = a5.d;
                        break;
                    case OfficeNamespace.be:
                        af = a5.d;
                        break;
                    case OfficeNamespace.bg:
                        ag = a5.d;
                        break;
                    case OfficeNamespace.bf:
                        ah = a5.d;
                        break;
                    case OfficeNamespace.bt:
                        ai = toNullable(ST_InsetMode_$type, XmlNamespaceDefinitionBase.b(ST_InsetMode_$type, a5.d));
                        break;
                    case "chromakey":
                        aj = a5.d;
                        break;
                    case "filled":
                        ak = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case "fillcolor":
                        al = a5.d;
                        break;
                    case "opacity":
                        am = a5.d;
                        break;
                    case "stroked":
                        an = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case "strokecolor":
                        ao = a5.d;
                        break;
                    case "strokeweight":
                        ap = a5.d;
                        break;
                    case "insetpen":
                        aq = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.cb:
                        ar = toNullable(Number_$type, parseNumber(a5.d, CultureInfo.invariantCulture));
                        break;
                    case OfficeNamespace.a9:
                        as = toNullable(ST_ConnectorType_$type, XmlNamespaceDefinitionBase.b(ST_ConnectorType_$type, a5.d));
                        break;
                    case "bwmode":
                        at = toNullable(ST_BWMode_$type, XmlNamespaceDefinitionBase.b(ST_BWMode_$type, a5.d));
                        break;
                    case "bwpure":
                        au = toNullable(ST_BWMode_$type, XmlNamespaceDefinitionBase.b(ST_BWMode_$type, a5.d));
                        break;
                    case "bwnormal":
                        av = toNullable(ST_BWMode_$type, XmlNamespaceDefinitionBase.b(ST_BWMode_$type, a5.d));
                        break;
                    case OfficeNamespace.bj:
                        aw = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.bx:
                        ax = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.bw:
                        ay = toNullable(Boolean_$type, ST_TrueFalseBlank.d(a5.d));
                        break;
                    case OfficeNamespace.b2:
                        az = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.a6:
                        a0 = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case OfficeNamespace.a5:
                        a1 = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(a5.d)));
                        break;
                    case "adj":
                        a2 = a5.d;
                        break;
                    case "path":
                        a3 = a5.d;
                        break;
                    case "master":
                        a4 = a5.d;
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i,
                p9: j,
                p10: k,
                p11: l,
                p12: m,
                p13: n,
                p14: o,
                p15: p,
                p16: q,
                p17: r,
                p18: s,
                p19: t,
                p20: u,
                p21: v,
                p22: w,
                p23: x,
                p24: y,
                p25: z,
                p26: aa,
                p27: ab,
                p28: ac,
                p29: ad,
                p30: ae,
                p31: af,
                p32: ag,
                p33: ah,
                p34: ai,
                p35: aj,
                p36: ak,
                p37: al,
                p38: am,
                p39: an,
                p40: ao,
                p41: ap,
                p42: aq,
                p43: ar,
                p44: as,
                p45: at,
                p46: au,
                p47: av,
                p48: aw,
                p49: ax,
                p50: ay,
                p51: az,
                p52: a0,
                p53: a1,
                p54: a2,
                p55: a3,
                p56: a4
            };
        }
        static d4(a, b = null, c = null, d = null, e = null, f = null, g = null, h = null, i = null, j = null, k = null, l = toNullable(Boolean_$type, null), m = null, n = toNullable(Boolean_$type, null), o = null, p = toNullable(Boolean_$type, null), q = toNullable(Boolean_$type, null), r = toNullable(Boolean_$type, null), s = toNullable(Boolean_$type, null), t = toNullable(Boolean_$type, null), u = toNullable(Boolean_$type, null), v = toNullable(Boolean_$type, null), w = toNullable(Number_$type, null), x = toNullable(ST_HrAlign_$type, null), y = toNullable(Boolean_$type, null), z = toNullable(Boolean_$type, null), aa = toNullable(Boolean_$type, null), ab = null, ac = null, ad = null, ae = null, af = null, ag = null, ah = null, ai = toNullable(ST_InsetMode_$type, null), aj = null, ak = toNullable(Boolean_$type, null), al = null, am = null, an = toNullable(Boolean_$type, null), ao = null, ap = null, aq = toNullable(Boolean_$type, null), ar = toNullable(Number_$type, null), as = toNullable(ST_ConnectorType_$type, null), at = toNullable(ST_BWMode_$type, null), au = toNullable(ST_BWMode_$type, null), av = toNullable(ST_BWMode_$type, null), aw = toNullable(Boolean_$type, null), ax = toNullable(Boolean_$type, null), ay = toNullable(Boolean_$type, null), az = toNullable(Boolean_$type, null), a0 = toNullable(Boolean_$type, null), a1 = toNullable(Boolean_$type, null), a2 = null, a3 = null, a4 = null) {
            a.ad.p("urn:schemas-microsoft-com:vml/shapetype", "v");
            let a5;
            a5 = b;
            a.ad.h("id", a5);
            a5 = c;
            a.ad.h("style", a5);
            a5 = d;
            a.ad.h("href", a5);
            a5 = e;
            a.ad.h("target", a5);
            a5 = f;
            a.ad.h("class", a5);
            a5 = g;
            a.ad.h("title", a5);
            a5 = h;
            a.ad.h("alt", a5);
            a5 = i;
            a.ad.h("coordsize", a5);
            a5 = j;
            a.ad.h("coordorigin", a5);
            a5 = k;
            a.ad.h("wrapcoords", a5);
            if (nullableNotEquals(l, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(l.value));
                a.ad.h("print", a5);
            }
            a5 = m;
            a.ad.h(OfficeNamespace.ca, a5);
            if (nullableNotEquals(n, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(n.value));
                a.ad.h(OfficeNamespace.bz, a5);
            }
            a5 = o;
            a.ad.h(OfficeNamespace.b3, a5);
            if (nullableNotEquals(p, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(p.value));
                a.ad.h(OfficeNamespace.bh, a5);
            }
            if (nullableNotEquals(q, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(q.value));
                a.ad.h(OfficeNamespace.a1, a5);
            }
            if (nullableNotEquals(r, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(r.value));
                a.ad.h(OfficeNamespace.cg, a5);
            }
            if (nullableNotEquals(s, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(s.value));
                a.ad.h(OfficeNamespace.a0, a5);
            }
            if (nullableNotEquals(t, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(t.value));
                a.ad.h(OfficeNamespace.bm, a5);
            }
            if (nullableNotEquals(u, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(u.value));
                a.ad.h(OfficeNamespace.br, a5);
            }
            if (nullableNotEquals(v, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(v.value));
                a.ad.h(OfficeNamespace.bp, a5);
            }
            if (nullableNotEquals(w, null)) {
                a5 = numberToString(w.value, CultureInfo.invariantCulture);
                a.ad.h(OfficeNamespace.bq, a5);
            }
            if (nullableNotEquals(x, null)) {
                a5 = XmlNamespaceDefinitionBase.p(ST_HrAlign_$type, x.value);
                a.ad.h(OfficeNamespace.bn, a5);
            }
            if (nullableNotEquals(y, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(y.value));
                a.ad.h(OfficeNamespace.as, a5);
            }
            if (nullableNotEquals(z, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(z.value));
                a.ad.h(OfficeNamespace.at, a5);
            }
            if (nullableNotEquals(aa, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(aa.value));
                a.ad.h(OfficeNamespace.cf, a5);
            }
            a5 = ab;
            a.ad.h("bordertopcolor", a5);
            a5 = ac;
            a.ad.h("borderleftcolor", a5);
            a5 = ad;
            a.ad.h("borderbottomcolor", a5);
            a5 = ae;
            a.ad.h("borderrightcolor", a5);
            a5 = af;
            a.ad.h(OfficeNamespace.be, a5);
            a5 = ag;
            a.ad.h(OfficeNamespace.bg, a5);
            a5 = ah;
            a.ad.h(OfficeNamespace.bf, a5);
            if (nullableNotEquals(ai, null)) {
                a5 = XmlNamespaceDefinitionBase.p(ST_InsetMode_$type, ai.value);
                a.ad.h(OfficeNamespace.bt, a5);
            }
            a5 = aj;
            a.ad.h("chromakey", a5);
            if (nullableNotEquals(ak, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(ak.value));
                a.ad.h("filled", a5);
            }
            a5 = al;
            a.ad.h("fillcolor", a5);
            a5 = am;
            a.ad.h("opacity", a5);
            if (nullableNotEquals(an, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(an.value));
                a.ad.h("stroked", a5);
            }
            a5 = ao;
            a.ad.h("strokecolor", a5);
            a5 = ap;
            a.ad.h("strokeweight", a5);
            if (nullableNotEquals(aq, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(aq.value));
                a.ad.h("insetpen", a5);
            }
            if (nullableNotEquals(ar, null)) {
                a5 = numberToString(ar.value, CultureInfo.invariantCulture);
                a.ad.h(OfficeNamespace.cb, a5);
            }
            if (nullableNotEquals(as, null)) {
                a5 = XmlNamespaceDefinitionBase.p(ST_ConnectorType_$type, as.value);
                a.ad.h(OfficeNamespace.a9, a5);
            }
            if (nullableNotEquals(at, null)) {
                a5 = XmlNamespaceDefinitionBase.p(ST_BWMode_$type, at.value);
                a.ad.h("bwmode", a5);
            }
            if (nullableNotEquals(au, null)) {
                a5 = XmlNamespaceDefinitionBase.p(ST_BWMode_$type, au.value);
                a.ad.h("bwpure", a5);
            }
            if (nullableNotEquals(av, null)) {
                a5 = XmlNamespaceDefinitionBase.p(ST_BWMode_$type, av.value);
                a.ad.h("bwnormal", a5);
            }
            if (nullableNotEquals(aw, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(aw.value));
                a.ad.h(OfficeNamespace.bj, a5);
            }
            if (nullableNotEquals(ax, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(ax.value));
                a.ad.h(OfficeNamespace.bx, a5);
            }
            if (nullableNotEquals(ay, null)) {
                a5 = ST_TrueFalseBlank.f(ay.value);
                a.ad.h(OfficeNamespace.bw, a5);
            }
            if (nullableNotEquals(az, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(az.value));
                a.ad.h(OfficeNamespace.b2, a5);
            }
            if (nullableNotEquals(a0, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(a0.value));
                a.ad.h(OfficeNamespace.a6, a5);
            }
            if (nullableNotEquals(a1, null)) {
                a5 = ST_TrueFalse.k(ST_TrueFalse.b(a1.value));
                a.ad.h(OfficeNamespace.a5, a5);
            }
            a5 = a2;
            a.ad.h("adj", a5);
            a5 = a3;
            a.ad.h("path", a5);
            a5 = a4;
            a.ad.h("master", a5);
        }
        static dw(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac, ad) {
            b = null;
            c = toNullable(Boolean_$type, null);
            d = null;
            e = null;
            f = null;
            g = toNullable(ST_StrokeLineStyle_$type, null);
            h = toNullable(Number_$type, null);
            i = toNullable(ST_StrokeJoinStyle_$type, null);
            j = toNullable(ST_StrokeEndCap_$type, null);
            k = null;
            l = toNullable(ST_FillType_$type, null);
            m = null;
            n = toNullable(ST_ImageAspect_$type, null);
            o = null;
            p = toNullable(Boolean_$type, null);
            q = null;
            r = toNullable(ST_StrokeArrowType_$type, null);
            s = toNullable(ST_StrokeArrowWidth_$type, null);
            t = toNullable(ST_StrokeArrowLength_$type, null);
            u = toNullable(ST_StrokeArrowType_$type, null);
            v = toNullable(ST_StrokeArrowWidth_$type, null);
            w = toNullable(ST_StrokeArrowLength_$type, null);
            x = null;
            y = null;
            z = null;
            aa = toNullable(Boolean_$type, null);
            ab = null;
            ac = toNullable(Boolean_$type, null);
            ad = null;
            for (let ae of fromEnum(a.ab.u)) {
                switch (ae.a.e(a.d)) {
                    case "id":
                        b = ae.d;
                        break;
                    case "on":
                        c = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ae.d)));
                        break;
                    case "weight":
                        d = ae.d;
                        break;
                    case "color":
                        e = ae.d;
                        break;
                    case "opacity":
                        f = ae.d;
                        break;
                    case "linestyle":
                        g = toNullable(ST_StrokeLineStyle_$type, XmlNamespaceDefinitionBase.b(ST_StrokeLineStyle_$type, ae.d));
                        break;
                    case "miterlimit":
                        h = toNullable(Number_$type, parseNumber(ae.d, CultureInfo.invariantCulture));
                        break;
                    case "joinstyle":
                        i = toNullable(ST_StrokeJoinStyle_$type, XmlNamespaceDefinitionBase.b(ST_StrokeJoinStyle_$type, ae.d));
                        break;
                    case "endcap":
                        j = toNullable(ST_StrokeEndCap_$type, XmlNamespaceDefinitionBase.b(ST_StrokeEndCap_$type, ae.d));
                        break;
                    case "dashstyle":
                        k = ae.d;
                        break;
                    case "filltype":
                        l = toNullable(ST_FillType_$type, XmlNamespaceDefinitionBase.b(ST_FillType_$type, ae.d));
                        break;
                    case "src":
                        m = ae.d;
                        break;
                    case "imageaspect":
                        n = toNullable(ST_ImageAspect_$type, XmlNamespaceDefinitionBase.b(ST_ImageAspect_$type, ae.d));
                        break;
                    case "imagesize":
                        o = ae.d;
                        break;
                    case "imagealignshape":
                        p = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ae.d)));
                        break;
                    case "color2":
                        q = ae.d;
                        break;
                    case "startarrow":
                        r = toNullable(ST_StrokeArrowType_$type, XmlNamespaceDefinitionBase.b(ST_StrokeArrowType_$type, ae.d));
                        break;
                    case "startarrowwidth":
                        s = toNullable(ST_StrokeArrowWidth_$type, XmlNamespaceDefinitionBase.b(ST_StrokeArrowWidth_$type, ae.d));
                        break;
                    case "startarrowlength":
                        t = toNullable(ST_StrokeArrowLength_$type, XmlNamespaceDefinitionBase.b(ST_StrokeArrowLength_$type, ae.d));
                        break;
                    case "endarrow":
                        u = toNullable(ST_StrokeArrowType_$type, XmlNamespaceDefinitionBase.b(ST_StrokeArrowType_$type, ae.d));
                        break;
                    case "endarrowwidth":
                        v = toNullable(ST_StrokeArrowWidth_$type, XmlNamespaceDefinitionBase.b(ST_StrokeArrowWidth_$type, ae.d));
                        break;
                    case "endarrowlength":
                        w = toNullable(ST_StrokeArrowLength_$type, XmlNamespaceDefinitionBase.b(ST_StrokeArrowLength_$type, ae.d));
                        break;
                    case OfficeNamespace.bo:
                        x = ae.d;
                        break;
                    case OfficeNamespace.au:
                        y = ae.d;
                        break;
                    case OfficeNamespace.cd:
                        z = ae.d;
                        break;
                    case OfficeNamespace.bj:
                        aa = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ae.d)));
                        break;
                    case OfficeDocumentRelationships.as:
                        ab = ae.d;
                        break;
                    case "insetpen":
                        ac = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(ae.d)));
                        break;
                    case OfficeNamespace.b4:
                        ad = ae.d;
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f,
                p6: g,
                p7: h,
                p8: i,
                p9: j,
                p10: k,
                p11: l,
                p12: m,
                p13: n,
                p14: o,
                p15: p,
                p16: q,
                p17: r,
                p18: s,
                p19: t,
                p20: u,
                p21: v,
                p22: w,
                p23: x,
                p24: y,
                p25: z,
                p26: aa,
                p27: ab,
                p28: ac,
                p29: ad
            };
        }
        static d5(a, b = null, c = toNullable(Boolean_$type, null), d = null, e = null, f = null, g = toNullable(ST_StrokeLineStyle_$type, null), h = toNullable(Number_$type, null), i = toNullable(ST_StrokeJoinStyle_$type, null), j = toNullable(ST_StrokeEndCap_$type, null), k = null, l = toNullable(ST_FillType_$type, null), m = null, n = toNullable(ST_ImageAspect_$type, null), o = null, p = toNullable(Boolean_$type, null), q = null, r = toNullable(ST_StrokeArrowType_$type, null), s = toNullable(ST_StrokeArrowWidth_$type, null), t = toNullable(ST_StrokeArrowLength_$type, null), u = toNullable(ST_StrokeArrowType_$type, null), v = toNullable(ST_StrokeArrowWidth_$type, null), w = toNullable(ST_StrokeArrowLength_$type, null), x = null, y = null, z = null, aa = toNullable(Boolean_$type, null), ab = null, ac = toNullable(Boolean_$type, null), ad = null) {
            a.ad.p("urn:schemas-microsoft-com:vml/stroke", "v");
            let ae;
            ae = b;
            a.ad.h("id", ae);
            if (nullableNotEquals(c, null)) {
                ae = ST_TrueFalse.k(ST_TrueFalse.b(c.value));
                a.ad.h("on", ae);
            }
            ae = d;
            a.ad.h("weight", ae);
            ae = e;
            a.ad.h("color", ae);
            ae = f;
            a.ad.h("opacity", ae);
            if (nullableNotEquals(g, null)) {
                ae = XmlNamespaceDefinitionBase.p(ST_StrokeLineStyle_$type, g.value);
                a.ad.h("linestyle", ae);
            }
            if (nullableNotEquals(h, null)) {
                ae = numberToString(h.value, CultureInfo.invariantCulture);
                a.ad.h("miterlimit", ae);
            }
            if (nullableNotEquals(i, null)) {
                ae = XmlNamespaceDefinitionBase.p(ST_StrokeJoinStyle_$type, i.value);
                a.ad.h("joinstyle", ae);
            }
            if (nullableNotEquals(j, null)) {
                ae = XmlNamespaceDefinitionBase.p(ST_StrokeEndCap_$type, j.value);
                a.ad.h("endcap", ae);
            }
            ae = k;
            a.ad.h("dashstyle", ae);
            if (nullableNotEquals(l, null)) {
                ae = XmlNamespaceDefinitionBase.p(ST_FillType_$type, l.value);
                a.ad.h("filltype", ae);
            }
            ae = m;
            a.ad.h("src", ae);
            if (nullableNotEquals(n, null)) {
                ae = XmlNamespaceDefinitionBase.p(ST_ImageAspect_$type, n.value);
                a.ad.h("imageaspect", ae);
            }
            ae = o;
            a.ad.h("imagesize", ae);
            if (nullableNotEquals(p, null)) {
                ae = ST_TrueFalse.k(ST_TrueFalse.b(p.value));
                a.ad.h("imagealignshape", ae);
            }
            ae = q;
            a.ad.h("color2", ae);
            if (nullableNotEquals(r, null)) {
                ae = XmlNamespaceDefinitionBase.p(ST_StrokeArrowType_$type, r.value);
                a.ad.h("startarrow", ae);
            }
            if (nullableNotEquals(s, null)) {
                ae = XmlNamespaceDefinitionBase.p(ST_StrokeArrowWidth_$type, s.value);
                a.ad.h("startarrowwidth", ae);
            }
            if (nullableNotEquals(t, null)) {
                ae = XmlNamespaceDefinitionBase.p(ST_StrokeArrowLength_$type, t.value);
                a.ad.h("startarrowlength", ae);
            }
            if (nullableNotEquals(u, null)) {
                ae = XmlNamespaceDefinitionBase.p(ST_StrokeArrowType_$type, u.value);
                a.ad.h("endarrow", ae);
            }
            if (nullableNotEquals(v, null)) {
                ae = XmlNamespaceDefinitionBase.p(ST_StrokeArrowWidth_$type, v.value);
                a.ad.h("endarrowwidth", ae);
            }
            if (nullableNotEquals(w, null)) {
                ae = XmlNamespaceDefinitionBase.p(ST_StrokeArrowLength_$type, w.value);
                a.ad.h("endarrowlength", ae);
            }
            ae = x;
            a.ad.h(OfficeNamespace.bo, ae);
            ae = y;
            a.ad.h(OfficeNamespace.au, ae);
            ae = z;
            a.ad.h(OfficeNamespace.cd, ae);
            if (nullableNotEquals(aa, null)) {
                ae = ST_TrueFalse.k(ST_TrueFalse.b(aa.value));
                a.ad.h(OfficeNamespace.bj, ae);
            }
            ae = ab;
            a.ad.h(OfficeDocumentRelationships.as, ae);
            if (nullableNotEquals(ac, null)) {
                ae = ST_TrueFalse.k(ST_TrueFalse.b(ac.value));
                a.ad.h("insetpen", ae);
            }
            ae = ad;
            a.ad.h(OfficeNamespace.b4, ae);
        }
        static dx(a, b, c, d, e, f) {
            b = null;
            c = null;
            d = null;
            e = toNullable(Boolean_$type, null);
            f = toNullable(ST_InsetMode_$type, null);
            for (let g of fromEnum(a.ab.u)) {
                switch (g.a.e(a.d)) {
                    case "id":
                        b = g.d;
                        break;
                    case "style":
                        c = g.d;
                        break;
                    case "inset":
                        d = g.d;
                        break;
                    case OfficeNamespace.b9:
                        e = toNullable(Boolean_$type, ST_TrueFalse.g(ST_TrueFalse.d(g.d)));
                        break;
                    case OfficeNamespace.bt:
                        f = toNullable(ST_InsetMode_$type, XmlNamespaceDefinitionBase.b(ST_InsetMode_$type, g.d));
                        break;
                    default: break;
                }
            }
            return {
                p1: b,
                p2: c,
                p3: d,
                p4: e,
                p5: f
            };
        }
        static d6(a, b = null, c = null, d = null, e = toNullable(Boolean_$type, null), f = toNullable(ST_InsetMode_$type, null)) {
            a.ad.p("urn:schemas-microsoft-com:vml/textbox", "v");
            let g;
            g = b;
            a.ad.h("id", g);
            g = c;
            a.ad.h("style", g);
            g = d;
            a.ad.h("inset", g);
            if (nullableNotEquals(e, null)) {
                g = ST_TrueFalse.k(ST_TrueFalse.b(e.value));
                a.ad.h(OfficeNamespace.b9, g);
            }
            if (nullableNotEquals(f, null)) {
                g = XmlNamespaceDefinitionBase.p(ST_InsetMode_$type, f.value);
                a.ad.h(OfficeNamespace.bt, g);
            }
        }
    }
    VmlNamespace.$t = /*@__PURE__*/ markType(VmlNamespace, 'VmlNamespace', XmlNamespaceDefinitionBase.$);
    VmlNamespace.ax = "urn:schemas-microsoft-com:vml" + "/background";
    VmlNamespace.ao = /*@__PURE__*/ new VmlNamespace();
    return VmlNamespace;
})();
/**
 * @hidden
 */
export let XmlNamespace = /*@__PURE__*/ (() => {
    class XmlNamespace extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0:
                case 1: return "http://www.w3.org/XML/1998/namespace";
                default: return "http://www.w3.org/XML/1998/namespace";
            }
        }
        get_t() {
            return "xml";
        }
        get t() {
            return this.get_t();
        }
        static at(a) {
            a.i("xml", "space", "http://www.w3.org/XML/1998/namespace", "preserve");
        }
    }
    XmlNamespace.$t = /*@__PURE__*/ markType(XmlNamespace, 'XmlNamespace', XmlNamespaceDefinitionBase.$);
    XmlNamespace.aq = "http://www.w3.org/XML/1998/namespace" + "/lang";
    XmlNamespace.as = "http://www.w3.org/XML/1998/namespace" + "/space";
    XmlNamespace.ao = /*@__PURE__*/ new XmlNamespace();
    return XmlNamespace;
})();
/**
 * @hidden
 */
export let XmlSchemaInstance = /*@__PURE__*/ (() => {
    class XmlSchemaInstance extends XmlNamespaceDefinitionBase {
        constructor() {
            super();
        }
        s(a) {
            switch (a) {
                case 0:
                case 1: return XmlSchemaInstance.aq;
                default: return XmlSchemaInstance.aq;
            }
        }
        get_t() {
            return "xsi";
        }
        get t() {
            return this.get_t();
        }
    }
    XmlSchemaInstance.$t = /*@__PURE__*/ markType(XmlSchemaInstance, 'XmlSchemaInstance', XmlNamespaceDefinitionBase.$);
    XmlSchemaInstance.aq = "http://www.w3.org/2001/XMLSchema-instance";
    XmlSchemaInstance.ar = XmlSchemaInstance.aq + "/type";
    XmlSchemaInstance.ao = /*@__PURE__*/ new XmlSchemaInstance();
    return XmlSchemaInstance;
})();
