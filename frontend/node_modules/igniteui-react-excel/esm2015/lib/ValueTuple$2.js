/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { ValueType, IEquatable$1_$type, toNullable, typeCast, markStruct } from "igniteui-react-core";
import { EqualityComparer$1 } from "igniteui-react-core";
/**
 * @hidden
 */
export let ValueTuple$2 = /*@__PURE__*/ (() => {
    class ValueTuple$2 extends ValueType {
        constructor($t1, $t2, a, ..._rest) {
            super();
            this.$t1 = null;
            this.$t2 = null;
            this._a = null;
            this._b = null;
            this._k = 0;
            this.$t1 = $t1;
            this.$t2 = $t2;
            this.$type = this.$type.specialize(this.$t1, this.$t2);
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0: break;
                case 1:
                    {
                        let c = _rest[0];
                        let d = _rest[1];
                        this._a = c;
                        this._b = d;
                        this._k = (this.$type.getStaticFields()._i.getHashCodeC(this._a) << 5) ^ this.$type.getStaticFields()._j.getHashCodeC(this._b);
                    }
                    break;
            }
        }
        equals(a) {
            return this.$type.getStaticFields()._i.equalsC(this._a, a._a) && this.$type.getStaticFields()._j.equalsC(this._b, a._b);
        }
        equals1(a) {
            let b = toNullable(ValueTuple$2.$.specialize(this.$t1, this.$t2), typeCast(ValueTuple$2.$.specialize(this.$t1, this.$t2), a));
            return ValueTuple$2._f(this.$t1, this.$t2, b, toNullable(ValueTuple$2.$.specialize(this.$t1, this.$t2), null)) && this.equals(b.value);
        }
        getHashCode() {
            return this._k;
        }
        static _c($t1, $t2, a, b) {
            return a.equals(b);
        }
        static _d($t1, $t2, a, b) {
            if (!a.hasValue) {
                return !b.hasValue;
            }
            else if (!b.hasValue) {
                return false;
            }
            return ValueTuple$2._c($t1, $t2, a.value, b.value);
        }
        static _e($t1, $t2, a, b) {
            return !a.equals(b);
        }
        static _f($t1, $t2, a, b) {
            if (!a.hasValue) {
                return b.hasValue;
            }
            else if (!b.hasValue) {
                return true;
            }
            return ValueTuple$2._e($t1, $t2, a.value, b.value);
        }
    }
    ValueTuple$2.$t = /*@__PURE__*/ /*@__PURE__*/ markStruct(ValueTuple$2, 'ValueTuple$2', ValueType.$, [/*@__PURE__*/ IEquatable$1_$type.specialize(-1)], function () {
        this._i = EqualityComparer$1.defaultEqualityComparerValue(arguments[0]);
        this._j = EqualityComparer$1.defaultEqualityComparerValue(arguments[1]);
    }).initSelfReferences();
    return ValueTuple$2;
})();
