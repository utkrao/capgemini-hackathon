/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { BuiltInFunctionBase } from "./BuiltInFunctionBase";
import { ExcelCalcValue } from "./ExcelCalcValue";
import { ExcelCalcErrorValue } from "./ExcelCalcErrorValue";
import { UltraCalcFunctionBinomDist } from "./UltraCalcFunctionBinomDist";
import { markType } from "igniteui-react-core";
import { truncate } from "igniteui-react-core";
/**
 * @hidden
 */
export let UltraCalcFunctionCritBinom = /*@__PURE__*/ (() => {
    class UltraCalcFunctionCritBinom extends BuiltInFunctionBase {
        evaluate(a, b) {
            let c = a.pop();
            if (c.isError) {
                return new ExcelCalcValue(c.toErrorValue());
            }
            let d = c._toDouble3();
            c = a.pop();
            if (c.isError) {
                return new ExcelCalcValue(c.toErrorValue());
            }
            let e = c._toDouble3();
            c = a.pop();
            if (c.isError) {
                return new ExcelCalcValue(c.toErrorValue());
            }
            let f = truncate(c._toDecimal2());
            if (f < 0 || e <= 0 || e >= 1 || d <= 0 || d >= 1) {
                return new ExcelCalcValue(new ExcelCalcErrorValue(4));
            }
            let g = 0;
            if (f >= 1030) {
                let h = Math.pow(10, -12);
                let i = f;
                let j = e;
                let k, l;
                if (d <= 0.5) {
                    k = Math.sqrt(Math.log(1 / (d * d)));
                    l = -k + (2.515517 + 0.802853 * k + 0.010328 * k * k) / (1 + 1.432788 * k + 0.189269 * k * k + 0.001308 * k * k * k);
                }
                else {
                    k = Math.sqrt(Math.log(1 / Math.pow(1 - d, 2)));
                    l = k - (2.515517 + 0.802853 * k + 0.010328 * k * k) / (1 + 1.432788 * k + 0.189269 * k * k + 0.001308 * k * k * k);
                }
                let m = truncate(Math.floor(i * j + l * Math.sqrt(i * j * (1 - j))));
                if (m < 0) {
                    m = 0;
                }
                else if (m > i) {
                    m = i;
                }
                let n = truncate((i * j));
                let o = 0;
                let p = 0;
                let q = 0;
                o = o + 1;
                if (n == m) {
                    p = p + 1;
                }
                if (n <= m) {
                    q = q + 1;
                }
                let r = 1;
                let s = false;
                let t = n + 1;
                while (!s && t <= i) {
                    let u = r * (i - t + 1) * j / (t * (1 - j));
                    o += u;
                    if (t == m) {
                        p += u;
                    }
                    if (t <= m) {
                        q += u;
                    }
                    if (u <= h) {
                        s = true;
                    }
                    r = u;
                    t = t + 1;
                }
                r = 1;
                s = false;
                t = n - 1;
                while (!s && t >= 0) {
                    let v = r * (t + 1) * (1 - j) / ((i - t) * j);
                    o = o + v;
                    if (t == m) {
                        p += v;
                    }
                    if (t <= m) {
                        q += v;
                    }
                    if (v <= h) {
                        s = true;
                    }
                    r = v;
                    t = t - 1;
                }
                let w = p / o;
                let x = q / o;
                let y = x - w;
                while (true) {
                    if (y < d && x >= d) {
                        g = m;
                        break;
                    }
                    if (y < d && x < d) {
                        let z = w * (i - m) * j / m / (1 - j);
                        y = x;
                        x = x + z;
                        w = z;
                        m++;
                    }
                    else if (y > d && x > d) {
                        let aa = w * m * (1 - j) / (i - m + 1) / j;
                        x = y;
                        y = y - w;
                        w = aa;
                        m--;
                    }
                    else {
                        break;
                    }
                }
            }
            else {
                let ab = 0;
                for (g = 0; g <= f; g++) {
                    ab += UltraCalcFunctionBinomDist._al(g, f, e);
                    if (ab >= d) {
                        break;
                    }
                }
            }
            return new ExcelCalcValue(g);
        }
        get_name() {
            return "critbinom";
        }
        get name() {
            return this.get_name();
        }
        get_minArgs() {
            return 3;
        }
        get minArgs() {
            return this.get_minArgs();
        }
        get_maxArgs() {
            return 3;
        }
        get maxArgs() {
            return this.get_maxArgs();
        }
    }
    UltraCalcFunctionCritBinom.$t = /*@__PURE__*/ markType(UltraCalcFunctionCritBinom, 'UltraCalcFunctionCritBinom', BuiltInFunctionBase.$);
    return UltraCalcFunctionCritBinom;
})();
