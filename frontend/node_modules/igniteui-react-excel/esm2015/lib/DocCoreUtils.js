/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, FormatException, Type, callStaticConstructors, toNullable, Number_$type, fromEnum, markType } from "igniteui-react-core";
import { NotImplementedException } from "igniteui-react-core";
import { Encoding } from "igniteui-react-core";
import { Buffer } from "igniteui-react-core";
import { BitConverter } from "igniteui-react-core";
import { Color } from "igniteui-react-core";
import { EscherSysIndex_$type } from "./EscherSysIndex";
import { Windows1252Encoding } from "./Windows1252Encoding";
import { Windows936Encoding } from "./Windows936Encoding";
import { Windows932Encoding } from "./Windows932Encoding";
import { CultureInfo } from "igniteui-react-core";
import { Localization } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { ArgumentNullException } from "igniteui-react-core";
import { MemoryStream } from "igniteui-react-core";
import { ArgumentOutOfRangeException } from "igniteui-react-core";
import { intDivide, truncate } from "igniteui-react-core";
import { nullableEquals, nullableNotEquals } from "igniteui-react-core";
import { intSToU, u32LS, u32BitwiseOr } from "igniteui-react-core";
import { arrayShallowClone } from "igniteui-react-core";
import { arrayCopy2 } from "igniteui-react-core";
import { dateParseExact } from "igniteui-react-core";
import { dateMinValue } from "igniteui-react-core";
/**
 * @hidden
 */
export let DocCoreUtils = /*@__PURE__*/ (() => {
    class DocCoreUtils extends Base {
        static staticInit() {
        }
        static a(a) {
            let b = a.length * 8;
            let c = (b % 512);
            let d = c < 448 ? 448 - c : 960 - c;
            let e = intDivide(d, 8);
            let f = new Array(a.length + e + 8);
            Buffer.c(a, 0, f, 0, a.length);
            f[a.length] = 128;
            Buffer.c(BitConverter.j(b), 0, f, a.length + e, 8);
            return f;
        }
        static n($t, a) {
            return new FormatException(1, DocCoreUtils.ab("LE_FormatException_TypeError", $t.typeName, a));
        }
        static am(a, b, c, d, e, f) {
            c = toNullable(Color.$, null);
            d = toNullable(Number_$type, null);
            e = toNullable(EscherSysIndex_$type, null);
            f = toNullable(Number_$type, null);
            if (nullableEquals(a, null)) {
                return {
                    p2: c,
                    p3: d,
                    p4: e,
                    p5: f
                };
            }
            let g = 255;
            if (nullableNotEquals(b, null)) {
                let h = DocCoreUtils.w(b.value);
                g = truncate(DocCoreUtils.x(h * 255));
            }
            let i = a.value;
            let j = (i >>> 24);
            let k = j;
            switch (k) {
                case 1:
                    f = toNullable(Number_$type, (i & 65535));
                    break;
                case 8:
                    d = toNullable(Number_$type, (i & 255));
                    break;
                case 16:
                    e = toNullable(EscherSysIndex_$type, (i & 16777215));
                    break;
                default:
                    let l = (i & 255);
                    let m = ((i & 65280) >>> 8);
                    let n = ((i & 16711680) >>> 16);
                    c = toNullable(Color.$, Color.u(g, l, m, n));
                    break;
            }
            return {
                p2: c,
                p3: d,
                p4: e,
                p5: f
            };
        }
        static w(a) {
            let b = (a >>> 16);
            let c = (a & 65535);
            return b + (c / 65536);
        }
        static an(a, b, c, d, e, f) {
            e = toNullable(Number_$type, null);
            f = toNullable(Number_$type, null);
            if (a.hasValue) {
                e = toNullable(Number_$type, intSToU(((a.value.m << 16) | (a.value.n << 8) | a.value.o)));
                let g = a.value.l;
                if (g != 255) {
                    let h = g / 255;
                    f = toNullable(Number_$type, DocCoreUtils.ai(h));
                }
                return {
                    p4: e,
                    p5: f
                };
            }
            if (nullableNotEquals(b, null)) {
                let i = u32LS(8, 24);
                e = toNullable(Number_$type, u32BitwiseOr(i, b.value));
                return {
                    p4: e,
                    p5: f
                };
            }
            if (nullableNotEquals(c, null)) {
                let j = u32LS(16, 24);
                e = toNullable(Number_$type, u32BitwiseOr(j, c.value));
                return {
                    p4: e,
                    p5: f
                };
            }
            if (nullableNotEquals(d, null)) {
                let k = u32LS(1, 24);
                e = toNullable(Number_$type, u32BitwiseOr(k, d.value));
                return {
                    p4: e,
                    p5: f
                };
            }
            return {
                p4: e,
                p5: f
            };
        }
        static ai(a) {
            let b = DocCoreUtils.l(a);
            let c = truncate(b);
            b = Math.abs(a % 1) * 65536;
            let d = truncate(DocCoreUtils.j(b));
            return intSToU((c << 16)) + d;
        }
        static ak(a, b = null) {
            if (DocCoreUtils.f) {
                return;
            }
        }
        static al(a) {
            if (DocCoreUtils.f) {
                return;
            }
        }
        static ao($t, a, b) {
            for (let c of fromEnum(a)) {
                b(c);
            }
        }
        static i(a) {
            return (a * 20) / 12700;
        }
        static af(a) {
            switch (a) {
                case 1200: return Encoding.unicode;
                case 1201: return Encoding.bigEndianUnicode;
                case 65001: return Encoding.uTF8;
                case 1252: return new Windows1252Encoding();
                case 936: return new Windows936Encoding();
                case 932: return new Windows932Encoding();
                default: return Encoding.uTF8;
            }
        }
        static r(a) {
            if (a == Encoding.unicode) {
                return 1200;
            }
            if (a == Encoding.bigEndianUnicode) {
                return 1201;
            }
            if (a == Encoding.uTF8) {
                return 65001;
            }
            return 0;
        }
        static y(a) {
            try {
                let b = a.webName;
                return b;
            }
            catch (c) {
                return DocCoreUtils.r(a).toString();
            }
        }
        static o(a) {
            return CultureInfo.currentCulture;
        }
        static s(a) {
            if ('0'.charCodeAt(0) <= a.charCodeAt(0) && a.charCodeAt(0) <= '9'.charCodeAt(0)) {
                return a.charCodeAt(0) - '0'.charCodeAt(0);
            }
            if ('a'.charCodeAt(0) <= a.charCodeAt(0) && a.charCodeAt(0) <= 'f'.charCodeAt(0)) {
                return (a.charCodeAt(0) - 'a'.charCodeAt(0)) + 10;
            }
            if ('A'.charCodeAt(0) <= a.charCodeAt(0) && a.charCodeAt(0) <= 'F'.charCodeAt(0)) {
                return (a.charCodeAt(0) - 'A'.charCodeAt(0)) + 10;
            }
            return 0;
        }
        static aa(a) {
            return Localization.getString("documentsCore", a);
        }
        static ab(a, ...b) {
            return Localization.getString("documentsCore", a, ...b);
        }
        static d(a) {
            return ('0'.charCodeAt(0) <= a.charCodeAt(0) && a.charCodeAt(0) <= '9'.charCodeAt(0)) || ('a'.charCodeAt(0) <= a.charCodeAt(0) && a.charCodeAt(0) <= 'f'.charCodeAt(0)) || ('A'.charCodeAt(0) <= a.charCodeAt(0) && a.charCodeAt(0) <= 'F'.charCodeAt(0));
        }
        static e(a) {
            return a == null;
        }
        static ap(a, b = 40, c = "Global") {
        }
        static x(a) {
            return DocCoreUtils.k(a, 0);
        }
        static j(a) {
            return DocCoreUtils.k(a, 0);
        }
        static k(a, b) {
            if (b < 0 || b > 15) {
                let c = Math.pow(10, b);
                let d = Math.sign(a);
                return DocCoreUtils.l(a * c + 0.5 * d) / c;
            }
            if (Math.abs(a) < 1E+16) {
                let e = DocCoreUtils.b[b];
                a *= e;
                let f = a % 1;
                a = DocCoreUtils.l(a);
                if (Math.abs(f) >= 0.5) {
                    a += Math.sign(f);
                }
                a /= e;
            }
            return a;
        }
        static aj(a, b) {
            return u32BitwiseOr((a >>> (32 - b)), (u32LS(a, b)));
        }
        static t(a, b) {
            return a + b - 1 - ((a - 1) % b);
        }
        static as($t, a, b) {
            let c = a.toArray();
            DocCoreUtils.aq($t, c, null, b);
            a.clear();
            a.o(c);
        }
        static aq($t, a, b, c) {
            DocCoreUtils.ar($t, a, b, c, 0, a.length - 1);
        }
        static ar($t, a, b, c, d, e) {
            if (a == null) {
                throw new ArgumentNullException(0, "arr");
            }
            if (c == null) {
                throw new ArgumentNullException(0, "comparer");
            }
            if (null == b) {
                b = arrayShallowClone(a);
            }
            else {
                arrayCopy2(a, b, a.length);
            }
            DocCoreUtils.at($t, a, b, c, d, e);
        }
        static at($t, a, b, c, d, e) {
            let f, g, h, i;
            let j = Type.getDefaultValue($t), k = Type.getDefaultValue($t);
            if (e - d < 6) {
                for (f = 1 + d; f <= e; f++) {
                    j = a[f];
                    for (g = f; g > d; g--) {
                        k = a[g - 1];
                        if (c.compare(j, k) < 0) {
                            a[g] = k;
                        }
                        else {
                            break;
                        }
                    }
                    if (f != g) {
                        a[g] = j;
                    }
                }
                return;
            }
            i = intDivide((d + e), 2);
            DocCoreUtils.at($t, b, a, c, d, i);
            DocCoreUtils.at($t, b, a, c, 1 + i, e);
            for (f = d, g = 1 + i, h = d; h <= e; h++) {
                if (f <= i) {
                    j = b[f];
                }
                if (g <= e) {
                    k = b[g];
                }
                if (g > e || f <= i && c.compare(j, k) <= 0) {
                    a[h] = j;
                    f++;
                }
                else {
                    a[h] = k;
                    g++;
                }
            }
        }
        static c(a) {
            if (a.canSeek) {
                let b = new Array(a.length);
                a.read(b, 0, b.length);
                return b;
            }
            let c = new Array(16 * 1024);
            {
                let d = new MemoryStream(0);
                try {
                    let e;
                    while ((e = a.read(c, 0, c.length)) > 0) {
                        d.write(c, 0, e);
                    }
                    return d.toArray();
                }
                finally {
                    if (d != null) {
                        d.dispose();
                    }
                }
            }
        }
        static au($t, a, b) {
            let c = a;
            a = b;
            b = c;
            return {
                p0: a,
                p1: b
            };
        }
        static p(a) {
            if (a < -32768) {
                a = a % 65536;
                if (a < -32768) {
                    a += 65536;
                }
            }
            else if (a > 32767) {
                a = a % 65536;
                if (a > 32767) {
                    a -= 65536;
                }
            }
            return a;
        }
        static l(a) {
            if (a < 0) {
                return Math.ceil(a);
            }
            return Math.floor(a);
        }
        static v(a, b, c) {
            c = null;
            return {
                ret: null,
                p2: c
            };
        }
        static g(a, b, c, d) {
            try {
                d = dateParseExact(a, b, c);
                return {
                    ret: true,
                    p3: d
                };
            }
            catch (e) {
                d = dateMinValue();
                return {
                    ret: false,
                    p3: d
                };
            }
        }
        static u(a) {
            return truncate(DocCoreUtils.j((a / 20) * 12700));
        }
        static av(a, b) {
            if (a == null) {
                throw new ArgumentNullException(0, b);
            }
        }
        static aw($t, a, b, c, d) {
            if (c <= a && a <= d) {
                return;
            }
            let e = DocCoreUtils.ab("LE_ArgumentOutOfRangeException_ValueError", $t.typeName, c, d);
            throw new ArgumentOutOfRangeException(2, b, e);
        }
        static get q() {
            throw new NotImplementedException(0);
        }
        static get ae() {
            return Encoding.defaultValue;
        }
        static z(a) {
            return null;
        }
        static ac(a, b) {
            return a.getString1(b, 0, b.length);
        }
        static ag(a, b) {
            return DocCoreUtils.af(b);
        }
        static ad(a) {
            let b = new List$1(Number_$type, 0);
            while (true) {
                let c = a.readByte();
                let d = a.readByte();
                if (c == 0 && d == 0) {
                    break;
                }
                b.add(c);
                b.add(d);
            }
            return Encoding.unicode.getString(b.toArray());
        }
        static ax(a, b) {
            a.h(Encoding.unicode.getBytes1(b));
            a.m(0);
            a.m(0);
        }
    }
    DocCoreUtils.$t = /*@__PURE__*/ markType(DocCoreUtils, 'DocCoreUtils');
    DocCoreUtils.b = [1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000, 100000000000, 1000000000000, 10000000000000, 100000000000000, 1E+15];
    DocCoreUtils.f = false;
    return DocCoreUtils;
})();
(function (v) { callStaticConstructors(); })(true);
