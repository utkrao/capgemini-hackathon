/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { BuiltInFunctionBase } from "./BuiltInFunctionBase";
import { Regex } from "igniteui-react-core";
import { toNullable, Number_$type, markType } from "igniteui-react-core";
import { ExcelCalcValue } from "./ExcelCalcValue";
import { ExcelCalcErrorValue } from "./ExcelCalcErrorValue";
import { ValueFormatter } from "./ValueFormatter";
import { StringUtilities } from "./StringUtilities";
import { dateTryParse } from "igniteui-react-core";
import { tryParseInt32_1 } from "igniteui-react-core";
import { startsWith1, stringFormat, stringFormat1 } from "igniteui-react-core";
/**
 * @hidden
 */
export let UltraCalcFunctionText = /*@__PURE__*/ (() => {
    class UltraCalcFunctionText extends BuiltInFunctionBase {
        evaluate(a, b) {
            let c = a.pop();
            let d = a.pop();
            if (d.isError) {
                return d;
            }
            if (c.isError) {
                return c;
            }
            if (c.isBoolean) {
                return new ExcelCalcValue(new ExcelCalcErrorValue(1));
            }
            let e = d.toString();
            let f = c.toString();
            let g;
            let h = ((() => { let i = d._toDouble1(g); g = i.p0; return i.ret; })());
            if (h == false && d.isString) {
                let i = this._ak(e);
                if (i.hasValue) {
                    g = i.value;
                    h = true;
                }
                else {
                    let j;
                    if (((() => { let k = dateTryParse(e, j); j = k.p1; return k.ret; })())) {
                        let k = ExcelCalcValue._dateTimeToExcelDate(d._o, j);
                        if (k.hasValue) {
                            g = k.value;
                            h = true;
                        }
                    }
                }
            }
            let l = NaN;
            if (h) {
                l = g;
            }
            let m = new ValueFormatter(0, d._o, f, a._w);
            let n;
            if (((() => { let o = m.v(l, e, n); n = o.p2; return o.ret; })()) == false) {
                return new ExcelCalcValue(new ExcelCalcErrorValue(1));
            }
            return new ExcelCalcValue(n);
        }
        get_name() {
            return "text";
        }
        get name() {
            return this.get_name();
        }
        get_minArgs() {
            return 2;
        }
        get minArgs() {
            return this.get_minArgs();
        }
        get_maxArgs() {
            return 2;
        }
        get maxArgs() {
            return this.get_maxArgs();
        }
        _ak(a) {
            let b = UltraCalcFunctionText._am.i(a);
            if (b.i == false) {
                return toNullable(Number_$type, null);
            }
            let c = 0;
            let d = 0;
            let e = 0;
            let f = 0;
            let g = b.m.item1("Hours");
            if (g.d != 0) {
                if (((() => { let h = tryParseInt32_1(g.g, c); c = h.p1; return h.ret; })()) == false) {
                }
            }
            let h = b.m.item1("Minutes");
            if (h.d != 0) {
                if (((() => { let i = tryParseInt32_1(h.g, d); d = i.p1; return i.ret; })()) == false) {
                }
            }
            let i = b.m.item1("Seconds");
            if (i.d != 0) {
                if (((() => { let j = tryParseInt32_1(i.g, e); e = j.p1; return j.ret; })()) == false) {
                }
            }
            let j = b.m.item1("Milliseconds");
            if (j.d != 0) {
                let k = j.g;
                while (k.length < 4) {
                    k += "0";
                }
                if (((() => { let l = tryParseInt32_1(k, f); f = l.p1; return l.ret; })()) == false) {
                }
            }
            let l = b.m.item1("AMPM");
            if (l.d != 0) {
                if (c >= 12) {
                    return toNullable(Number_$type, null);
                }
                if (startsWith1(l.g, "P", StringUtilities.j)) {
                    c += 12;
                }
            }
            return toNullable(Number_$type, (c / 24) + (d / 1440) + (e / 86400) + (f / 864000000));
        }
        static get _am() {
            if (UltraCalcFunctionText._al == null) {
                let a = "(?'Hours'[0-9]{1,4})\\s*";
                let b = "\\s*(?'Minutes'[0-9]?[0-9])\\s*";
                let c = "\\s*(?'Seconds'[0-9]?[0-9])\\s*";
                let d = ".\\s*(?'Milliseconds'[0-9]{0,4})[0-9]*\\s*";
                let e = "(\\s+(?'AMPM'(a|p)m?)\\s*)";
                let f = stringFormat("({0}{1})", a, e);
                let g = stringFormat1("({0}:{1}(:{2}({3})?)?{4}?)", a, b, c, d, e);
                let h = stringFormat1("({0}:{1}{2}{3}?)", b, c, d, e);
                UltraCalcFunctionText._al = new Regex(stringFormat("^({0}|{1}|{2})$", f, g, h), 8 | 1 | 32 | 512);
            }
            return UltraCalcFunctionText._al;
        }
        doesParameterAllowIntermediateResultArray(a, b) {
            return true;
        }
    }
    UltraCalcFunctionText.$t = /*@__PURE__*/ markType(UltraCalcFunctionText, 'UltraCalcFunctionText', BuiltInFunctionBase.$);
    UltraCalcFunctionText._al = null;
    return UltraCalcFunctionText;
})();
