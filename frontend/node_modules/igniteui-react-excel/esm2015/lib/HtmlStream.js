/*
*
* An XmlReader implementation for loading SGML (including HTML) converting it
* to well formed XML, by adding missing quotes, empty attribute values, ignoring
* duplicate attributes, case folding on tag names, adding missing closing tags
* based on SGML DTD information, and so on.
*
* Copyright (c) 2002 Microsoft Corporation. All rights reserved.
*
* Chris Lovett
*
*/
/* MD 2/27/13
 * This software is being re-used under the Microsoft Public License (MS-PL):
 * -----------------------------------------------------------------------------
 * This license governs use of the accompanying software. If you use the software, you accept this license. If you do not accept the
 * license, do not use the software.
 *
 * 1. Definitions
 * The terms "reproduce," "reproduction," "derivative works," and "distribution" have the same meaning here as under U.S. copyright law.
 * A "contribution" is the original software, or any additions or changes to the software. A "contributor" is any person that distributes
 * its contribution under this license. "Licensed patents" are a contributor's patent claims that read directly on its contribution.
 *
 * 2. Grant of Rights
 * (A) Copyright Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each
 *     contributor grants you a non-exclusive, worldwide, royalty-free copyright license to reproduce its contribution, prepare
 *     derivative works of its contribution, and distribute its contribution or any derivative works that you create.
 * (B) Patent Grant- Subject to the terms of this license, including the license conditions and limitations in section 3, each
 *     contributor grants you a non-exclusive, worldwide, royalty-free license under its licensed patents to make, have made, use,
 *     sell, offer for sale, import, and/or otherwise dispose of its contribution in the software or derivative works of the contribution
 *     in the software.
 *
 * 3. Conditions and Limitations
 * (A) No Trademark License- This license does not grant you rights to use any contributors' name, logo, or trademarks.
 * (B) If you bring a patent claim against any contributor over patents that you claim are infringed by the software, your patent license
 *     from such contributor to the software ends automatically.
 * (C) If you distribute any portion of the software, you must retain all copyright, patent, trademark, and attribution notices that are
 *     present in the software.
 * (D) If you distribute any portion of the software in source code form, you may do so only under this license by including a complete
 *     copy of this license with your distribution. If you distribute any portion of the software in compiled or object code form, you may
 *     only do so under a license that complies with this license.
 * (E) The software is licensed "as-is." You bear the risk of using it. The contributors give no express warranties, guarantees or conditions.
 *     You may have additional consumer rights under your local laws which this license cannot change. To the extent permitted under your
 *     local laws, the contributors exclude the implied warranties of merchantability, fitness for a particular purpose and non-infringement.
 * -----------------------------------------------------------------------------
 *
 * In addition, the public classes have been made internal and the namespace has been changed from Sgml to
 * Infragistics.Documents.Excel.Serialization.Excel2007.Sgml
 *
 * Also, I updated the code to work with Silverlight and WinRT.
 */
import { TextReader } from "igniteui-react-core";
import { Encoding } from "igniteui-react-core";
import { markType } from "igniteui-react-core";
import { MemoryStream } from "igniteui-react-core";
import { Ucs4DecoderBigEngian } from "./Ucs4DecoderBigEngian";
import { Ucs4DecoderLittleEndian } from "./Ucs4DecoderLittleEndian";
import { UnicodeEncoding } from "igniteui-react-core";
import { StringUtilitiesSgml } from "./StringUtilitiesSgml";
import { StringBuilder } from "igniteui-react-core";
import { u32LS, u32BitwiseOr } from "igniteui-react-core";
import { arrayCopy1 } from "igniteui-react-core";
import { stringCreateFromCharArraySlice } from "igniteui-react-core";
import { isLetterOrDigit } from "igniteui-react-core";
/**
 * @hidden
 */
export let HtmlStream = /*@__PURE__*/ (() => {
    class HtmlStream extends TextReader {
        constructor(a, b) {
            super();
            this._x = null;
            this._l = null;
            this._r = 0;
            this._s = 0;
            this._ah = null;
            this._ae = null;
            this._k = null;
            this._v = 0;
            this._q = 0;
            if (b == null) {
                b = Encoding.uTF8;
            }
            if (!a.canSeek) {
                a = this._w(a);
            }
            this._x = a;
            this._l = new Array(16384);
            this._s = a.read(this._l, 0, 4);
            this._k = new Array(16384);
            this._ae = ((() => { let c = HtmlStream._ad(this._l, this._r, this._s); this._r = c.p1; return c.ret; })());
            let c = this._r;
            if (this._ae == null) {
                this._ae = b.getDecoder();
                this._s += a.read(this._l, 4, 16384 - 4);
                this._aj();
                let d = this._af();
                if (d != null) {
                    this._ae = d;
                }
            }
            this._x.seek(0, 0);
            this._q = this._v = 0;
            if (c > 0) {
                a.read(this._l, 0, c);
            }
            this._r = this._s = 0;
        }
        get _ai() {
            return this._ah;
        }
        _w(a) {
            let b = 100000;
            let c = new Array(b);
            let d;
            let e = new MemoryStream(0);
            while ((d = a.read(c, 0, b)) > 0) {
                e.write(c, 0, d);
            }
            e.seek(0, 0);
            a.dispose();
            return e;
        }
        _aj() {
            if (this._q > 0) {
                if (this._q < this._v) {
                    arrayCopy1(this._k, this._q, this._k, 0, this._v - this._q);
                }
                this._v -= this._q;
                this._q = 0;
            }
            let a = this._ae.a(this._l, this._r, this._s - this._r);
            let b = this._k.length - this._v;
            if (b < a) {
                let c = new Array(this._k.length + a);
                arrayCopy1(this._k, this._q, c, 0, this._v - this._q);
                this._k = c;
            }
            this._v = this._q + this._ae.c(this._l, this._r, this._s - this._r, this._k, this._q);
            this._r = this._s;
        }
        static _ad(a, b, c) {
            if (4 <= (c - b)) {
                let d = u32BitwiseOr(u32BitwiseOr(u32BitwiseOr(u32LS(a[b + 0], 24), u32LS(a[b + 1], 16)), u32LS(a[b + 2], 8)), a[b + 3]);
                let t1 = d;
                L0: while (true) {
                    switch (t1) {
                        case 4278189823:
                            b += 4;
                            return {
                                ret: new Ucs4DecoderBigEngian(),
                                p1: b
                            };
                        case 4294901758:
                            b += 4;
                            return {
                                ret: new Ucs4DecoderLittleEndian(),
                                p1: b
                            };
                        case 1006632960:
                            t1 = 4278189823;
                            continue L0;
                        case 60:
                            t1 = 4294901758;
                            continue L0;
                    }
                    break;
                }
                d >>>= 8;
                if (d == 15711167) {
                    b += 3;
                    return {
                        ret: Encoding.uTF8.getDecoder(),
                        p1: b
                    };
                }
                d >>>= 8;
                {
                    let t1 = d;
                    L0: while (true) {
                        switch (t1) {
                            case 65279:
                                b += 2;
                                return {
                                    ret: Encoding.bigEndianUnicode.getDecoder(),
                                    p1: b
                                };
                            case 65534:
                                b += 2;
                                return {
                                    ret: new UnicodeEncoding(1, false, false).getDecoder(),
                                    p1: b
                                };
                            case 15360:
                                t1 = 65279;
                                continue L0;
                            case 60:
                                t1 = 65534;
                                continue L0;
                        }
                        break;
                    }
                }
            }
            return {
                ret: null,
                p1: b
            };
        }
        _t() {
            if (this._q < this._v) {
                return this._k[this._q++].charCodeAt(0);
            }
            return -1;
        }
        _p() {
            let a = this._t();
            if (a != -1) {
                this._q--;
            }
            return a;
        }
        _m(a) {
            let b = this._p();
            if (b != a.charAt(0).charCodeAt(0)) {
                return false;
            }
            for (let c = 0, d = a.length; b != -1 && c < d; c++) {
                b = this._t();
                let e = a.charAt(c);
                if (b != e.charCodeAt(0)) {
                    return false;
                }
            }
            return true;
        }
        _an() {
            let a = String.fromCharCode(this._p());
            while (a == ' ' || a == '\t' || a == '\r' || a == '\n') {
                let b = this._q;
                a = String.fromCharCode(this._t());
                if (a != ' ' && a != '\t' && a != '\r' && a != '\n') {
                    this._q = b;
                }
            }
        }
        _ab() {
            let a = this._p();
            if (a == '\''.charCodeAt(0) || a == '\"'.charCodeAt(0)) {
                this._t();
                let b = this._q;
                let c = this._t();
                while (c != -1 && c != a) {
                    c = this._t();
                }
                return (this._q > b) ? stringCreateFromCharArraySlice(this._k, b, this._q - b - 1) : "";
            }
            return null;
        }
        _z(a) {
            this._an();
            let b = this._ac();
            if (a == b) {
                this._an();
                if (this._m("=")) {
                    this._an();
                    return this._ab();
                }
            }
            return null;
        }
        _aa(a) {
            this._an();
            a = this._ac();
            if (a != null) {
                this._an();
                if (this._m("=")) {
                    this._an();
                    return {
                        ret: this._ab(),
                        p0: a
                    };
                }
            }
            return {
                ret: null,
                p0: a
            };
        }
        _am(a) {
            let b = this._t();
            let c = 0;
            let d = a.length;
            while (c < d && b != -1) {
                if (a.charAt(c).charCodeAt(0) == b) {
                    c++;
                    if (c == d) {
                        break;
                    }
                }
                else {
                    c = 0;
                }
                b = this._t();
            }
        }
        _af() {
            let a = null;
            if (this._m("<?xml")) {
                let b = this._z("version");
                if (b != null) {
                    let c = this._z("encoding");
                    if (c != null) {
                        try {
                            let d = Encoding.getEncoding(c);
                            if (d != null) {
                                this._ah = d;
                                return d.getDecoder();
                            }
                        }
                        catch (e) {
                        }
                    }
                    this._am(">");
                }
            }
            if (a == null) {
                return this._ag();
            }
            return null;
        }
        _ag() {
            let a = this._t();
            while (a != -1) {
                let b = String.fromCharCode(a);
                if (b == '<') {
                    let c = this._ac();
                    if (c != null && StringUtilitiesSgml.a(c, "meta")) {
                        let d = null;
                        let e = null;
                        while (true) {
                            let f = ((() => { let g = this._aa(c); c = g.p0; return g.ret; })());
                            if (c == null) {
                                break;
                            }
                            if (StringUtilitiesSgml.a(c, "http-equiv")) {
                                d = f;
                            }
                            else if (StringUtilitiesSgml.a(c, "content")) {
                                e = f;
                            }
                        }
                        if (d != null && StringUtilitiesSgml.a(d, "content-type") && e != null) {
                            let g = e.indexOf("charset");
                            if (g >= 0) {
                                g = e.indexOf("=", g);
                                if (g >= 0) {
                                    g++;
                                    let h = e.indexOf(";", g);
                                    if (h < 0) {
                                        h = e.length;
                                    }
                                    let i = e.substr(g, h - g).trim();
                                    try {
                                        let j = Encoding.getEncoding(i);
                                        this._ah = j;
                                        return j.getDecoder();
                                    }
                                    catch (k) {
                                    }
                                }
                            }
                        }
                    }
                }
                a = this._t();
            }
            return null;
        }
        _ac() {
            let a = this._p();
            if (a == -1) {
                return null;
            }
            let b = String.fromCharCode(a);
            let c = this._q;
            while (this._q < this._v - 1 && (isLetterOrDigit(b) || b == '-' || b == '_' || b == ':')) {
                b = this._k[++this._q];
            }
            if (c == this._q) {
                return null;
            }
            return stringCreateFromCharArraySlice(this._k, c, this._q - c);
        }
        _al() {
            let a = String.fromCharCode(this._p());
            while (this._q < this._v - 1 && (a == ' ' || a == '\r' || a == '\n')) {
                a = this._k[++this._q];
            }
        }
        _ak(a) {
            let b = String.fromCharCode(this._p());
            while (this._q < this._v - 1 && (b != a)) {
                b = this._k[++this._q];
            }
        }
        _y() {
            this._ak('=');
            if (this._q < this._v) {
                this._q++;
                this._al();
                if (this._q < this._v) {
                    let a = this._k[this._q];
                    this._q++;
                    let b = this._q;
                    this._ak(a);
                    if (this._q < this._v) {
                        let c = stringCreateFromCharArraySlice(this._k, b, this._q - b);
                        this._q++;
                        return c;
                    }
                }
            }
            return null;
        }
        a() {
            let a = this.b();
            if (a != -1) {
                this._q--;
            }
            return a;
        }
        b() {
            if (this._q == this._v) {
                this._s = this._x.read(this._l, 0, this._l.length);
                this._r = 0;
                if (this._s == 0) {
                    return -1;
                }
                this._aj();
            }
            if (this._q < this._v) {
                return this._k[this._q++].charCodeAt(0);
            }
            return -1;
        }
        c(a, b, c) {
            if (this._q == this._v) {
                this._s = this._x.read(this._l, 0, this._l.length);
                this._r = 0;
                if (this._s == 0) {
                    return -1;
                }
                this._aj();
            }
            if (this._q < this._v) {
                c = Math.min(this._v - this._q, c);
                arrayCopy1(this._k, this._q, a, b, c);
                this._q += c;
                return c;
            }
            return 0;
        }
        d(a, b, c) {
            return this.c(a, b, c);
        }
        _u(a, b, c) {
            let d = 0;
            let e = this._t();
            while (e != -1) {
                a[d + b] = String.fromCharCode(e);
                d++;
                if (d + b == c) {
                    break;
                }
                if (e == '\r'.charCodeAt(0)) {
                    if (this._p() == '\n'.charCodeAt(0)) {
                        e = this._t();
                        a[d + b] = String.fromCharCode(e);
                        d++;
                    }
                    break;
                }
                else if (e == '\n'.charCodeAt(0)) {
                    break;
                }
                e = this._t();
            }
            return d;
        }
        h() {
            let a = new Array(100000);
            let b = 0;
            let c = new StringBuilder(0);
            while ((b = this.c(a, 0, a.length)) > 0) {
                c.g(a, 0, b);
            }
            return c.toString();
        }
        dispose1(a) {
            if (a) {
                this._x.dispose();
            }
        }
    }
    HtmlStream.$t = /*@__PURE__*/ markType(HtmlStream, 'HtmlStream', TextReader.$);
    return HtmlStream;
})();
