/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { markEnum } from "igniteui-react-core";
/**
 * For internal use only.
 */
export var OpenPackagingNonConformanceReason = /*@__PURE__*/ (function (OpenPackagingNonConformanceReason) {
    /**
     * The IPackage.GetPart method threw an exception.
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["CouldNotGetPackagePart"] = -1] = "CouldNotGetPackagePart";
    /**
     * The IPackagePart conforms fully to the ECMA TC45 Open Packaging Conventions.
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["Conformant"] = 0] = "Conformant";
    /**
     * The package implementer shall require a part name. [M1.1]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["NameMissing"] = 1] = "NameMissing";
    /**
     * The package implementer shall require a content type and
     * the format designer shall specify the content type. [M1.2], [M1.13]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["ContentTypeMissing"] = 2] = "ContentTypeMissing";
    /**
     * A part name shall not have empty segments. [M1.3]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["SegmentEmpty"] = 3] = "SegmentEmpty";
    /**
     * A part name shall start with a forward slash (“/”) character. [M1.4]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["NameDoesNotStartWithForwardSlash"] = 4] = "NameDoesNotStartWithForwardSlash";
    /**
     * A part name shall not have a forward slash as the last character. [M1.5]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["NameEndsWithForwardSlash"] = 5] = "NameEndsWithForwardSlash";
    /**
     * A segment shall not hold any characters other than pchar characters. [M1.6]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["SegmentHasNonPCharCharacters"] = 6] = "SegmentHasNonPCharCharacters";
    /**
     * A segment shall not contain percent-encoded forward slash (“/”),
     * or backward slash (“\”) characters. [M1.7]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["SegmentHasPercentEncodedSlashCharacters"] = 7] = "SegmentHasPercentEncodedSlashCharacters";
    /**
     * A segment shall not contain percent-encoded unreserved characters. [M1.8]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["SegmentHasPercentEncodedUnreservedCharacters"] = 8] = "SegmentHasPercentEncodedUnreservedCharacters";
    /**
     * A segment shall not end with a dot (“.”) character. [M1.9]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["SegmentEndsWithDotCharacter"] = 9] = "SegmentEndsWithDotCharacter";
    /**
     * A segment shall include at least one non-dot character. [M1.10]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["SegmentMissingNonDotCharacter"] = 10] = "SegmentMissingNonDotCharacter";
    /**
     * A package implementer shall neither create nor recognize
     * a part with a part name derived from another part name by
     * appending segments to it. [M1.11]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["NameDerivesFromExistingPartName"] = 11] = "NameDerivesFromExistingPartName";
    /**
     * Part name equivalence is determined by comparing part names as
     * case-insensitive ASCII strings. Packages shall not contain equivalent
     * part names and package implementers shall neither create nor recognize
     * packages with equivalent part names. [M1.12]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["DuplicateName"] = 12] = "DuplicateName";
    /**
     * IPackage implementers shall only create and only recognize parts with a content type;
     * format designers shall specify a content type for each part included in the format.
     * Content types for package parts shall fit the definition and syntax for media types
     * as specified in RFC 2616, §3.7. [M1.13]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["ContentTypeHasInvalidSyntax"] = 13] = "ContentTypeHasInvalidSyntax";
    /**
     * Content types shall not use linear white space either between the type and subtype or
     * between an attribute and its value. Content types also shall not have leading or
     * trailing white spaces. IPackage implementers shall create only such content types
     * and shall require such content types when retrieving a part from a package;
     * format designers shall specify only such content types for inclusion in the format. [M1.14]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["ContentTypeHasInvalidWhitespace"] = 14] = "ContentTypeHasInvalidWhitespace";
    /**
     * The package implementer shall require a content type that does not include comments
     * and the format designer shall specify such a content type. [M1.15]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["ContentTypeHasComments"] = 15] = "ContentTypeHasComments";
    /**
     * IPackage implementers and format designers shall not create content types
     * with parameters for the package specific parts defined in this Open Packaging
     * specification and shall treat the presence of parameters in these content types
     * as an error. [M1.22]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["ContentTypeHasParameters"] = 16] = "ContentTypeHasParameters";
    /**
     * If the package implementer specifies a growth hint, it is set when a
     * part is created and the package implementer shall not change the growth
     * hint after the part has been created. [M1.16]
     * <p class="body">The PackageConformanceManager does not verify this convention.</p>
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["GrowthHintChanged"] = 17] = "GrowthHintChanged";
    /**
     * XML content shall be encoded using either UTF-8 or UTF-16.
     * If any part includes an encoding declaration, as defined in
     * §4.3.3 of the XML 1.0 specification, that declaration shall
     * not name any encoding other than UTF-8 or UTF-16. IPackage
     * implementers shall enforce this requirement upon creation
     * and retrieval of the XML content. [M1.17]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["XmlEncodingUnsupported"] = 18] = "XmlEncodingUnsupported";
    /**
     * XML content shall be valid against the corresponding XSD schema defined
     * in this Open Packaging specification. In particular, the XML content shall
     * not contain elements or attributes drawn from namespaces that are not explicitly
     * defined in the corresponding XSD unless the XSD allows elements or attributes drawn
     * from any namespace to be present in particular locations in the XML markup. IPackage
     * implementers  shall enforce this requirement upon creation and retrieval of the
     * XML content. [M1.20]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["XmlContentInvalidForSchema"] = 19] = "XmlContentInvalidForSchema";
    /**
     * XML content shall not contain elements or attributes drawn from “xml” or “xsi”
     * namespaces unless they are explicitly defined in the XSD schema or by other means
     * described in this Open Packaging specification. IPackage implementers shall enforce
     * this requirement upon creation and retrieval of the XML content. [M1.21]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["XmlContentDrawsOnUndefinedNamespace"] = 20] = "XmlContentDrawsOnUndefinedNamespace";
    /**
     * The Relationships part shall not have relationships to any other part. IPackage
     * implementers shall enforce this requirement upon the attempt to create such a
     * relationship and shall treat any such relationship as invalid. [M1.25]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["RelationshipTargetsOtherRelationship"] = 21] = "RelationshipTargetsOtherRelationship";
    /**
     * The package implementer shall require that every Relationship element
     * has an Id attribute, the value of which is unique within the Relationships
     * part, and that the Id type is xsd:ID, the value of which conforms to the naming
     * restrictions for xsd:IDas described in the W3C Recommendation “XML Schema Part 2:
     * Datatypes.” [M1.26]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["RelationshipIdInvalid"] = 22] = "RelationshipIdInvalid";
    /**
     * The package implementer shall require the Type attribute to be a URI
     * that defines the role of the relationship and the format designer shall
     * specify such a Type. [M1.27]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["RelationshipTypeInvalid"] = 23] = "RelationshipTypeInvalid";
    /**
     * The package implementer shall require the Target attribute to be a URI
     * reference pointing to a target resource. The URI reference shall be a URI
     * or a relative reference. [M1.28]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["RelationshipTargetInvalid"] = 24] = "RelationshipTargetInvalid";
    /**
     * When set to Internal, the Target attribute shall be a relative reference and
     * that reference is interpreted relative to the “parent” part. For package
     * relationships, the package implementer shallresolve relative references in
     * the Target attribute against the pack URI that identifies the entire package
     * resource. [M1.29]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["RelationshipTargetNotRelativeReference"] = 25] = "RelationshipTargetNotRelativeReference";
    /**
     * The package implementer shall name relationship parts according to the special
     * relationships part naming convention and require that parts with names that
     * conform to this naming convention have the content type for a Relationships
     * part. [M1.30]
     */
    OpenPackagingNonConformanceReason[OpenPackagingNonConformanceReason["RelationshipNameInvalid"] = 26] = "RelationshipNameInvalid";
    return OpenPackagingNonConformanceReason;
})({});
/**
 * @hidden
 */
export let OpenPackagingNonConformanceReason_$type = /*@__PURE__*/ markEnum('OpenPackagingNonConformanceReason', 'CouldNotGetPackagePart,-1|Conformant,0|NameMissing,1|ContentTypeMissing,2|SegmentEmpty,3|NameDoesNotStartWithForwardSlash,4|NameEndsWithForwardSlash,5|SegmentHasNonPCharCharacters,6|SegmentHasPercentEncodedSlashCharacters,7|SegmentHasPercentEncodedUnreservedCharacters,8|SegmentEndsWithDotCharacter,9|SegmentMissingNonDotCharacter,10|NameDerivesFromExistingPartName,11|DuplicateName,12|ContentTypeHasInvalidSyntax,13|ContentTypeHasInvalidWhitespace,14|ContentTypeHasComments,15|ContentTypeHasParameters,16|GrowthHintChanged,17|XmlEncodingUnsupported,18|XmlContentInvalidForSchema,19|XmlContentDrawsOnUndefinedNamespace,20|RelationshipTargetsOtherRelationship,21|RelationshipIdInvalid,22|RelationshipTypeInvalid,23|RelationshipTargetInvalid,24|RelationshipTargetNotRelativeReference,25|RelationshipNameInvalid,26');
