/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { __extends } from "tslib";
import { Base, Point_$type, typeCast, markType } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { ArcSegment } from "igniteui-react-core";
import { ViewportUtils } from "./ViewportUtils";
import { Size } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { LineGeometry } from "igniteui-react-core";
import { RangeInfo } from "./RangeInfo";
import { PolarAxisRenderingParameters } from "./PolarAxisRenderingParameters";
import { RadialAxisRenderingParameters } from "./RadialAxisRenderingParameters";
/**
 * @hidden
 */
var PolarAxisRenderingManager = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(PolarAxisRenderingManager, _super);
    function PolarAxisRenderingManager() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PolarAxisRenderingManager.prototype.p = function (a, b, c, d, e, f) {
        var g = ViewportUtils.d(a, e, f);
        var h = ViewportUtils.g(a, e, f);
        var i = ViewportUtils.c(b.x, e, f);
        var j = ViewportUtils.f(b.y, e, f);
        if (d - c < Math.PI && d - c > 0) {
            var k = { $type: Point_$type, x: ViewportUtils.c(b.x + a * Math.cos(c), e, f), y: ViewportUtils.f(b.y + a * Math.sin(c), e, f) };
            var l_1 = { $type: Point_$type, x: ViewportUtils.c(b.x + a * Math.cos(d), e, f), y: ViewportUtils.f(b.y + a * Math.sin(d), e, f) };
            var m = new PathFigure();
            m._startPoint = k;
            m._isClosed = false;
            m._segments.add(((function () {
                var $ret = new ArcSegment();
                $ret.b = false;
                $ret.e = l_1;
                $ret.f = new Size(1, g, h);
                $ret.d = 1;
                return $ret;
            })()));
            return m;
        }
        else {
            var n = new PathFigure();
            n._startPoint = { $type: Point_$type, x: i, y: j - h };
            n._isClosed = true;
            n._segments.add(((function () {
                var $ret = new ArcSegment();
                $ret.b = false;
                $ret.e = { $type: Point_$type, x: i, y: j + h };
                $ret.f = new Size(1, g, h);
                $ret.d = 1;
                return $ret;
            })()));
            n._segments.add(((function () {
                var $ret = new ArcSegment();
                $ret.b = false;
                $ret.e = { $type: Point_$type, x: i, y: j - h };
                $ret.f = new Size(1, g, h);
                $ret.d = 1;
                return $ret;
            })()));
            return n;
        }
    };
    PolarAxisRenderingManager.prototype.j = function (a, b, c, d, e, f, g, h) {
        var i = Math.min(b, c);
        var j = Math.max(b, c);
        var k = new PathGeometry();
        var l = null;
        var m = null;
        var n = null;
        var o = null;
        if (i > 0) {
            l = this.p(i, f, g, h, e, d);
            if (h - g < Math.PI && h - g > 0) {
                var p = typeCast(ArcSegment.$, l._segments._inner[0]);
                if (p != null) {
                    var q_1 = { $type: Point_$type, x: ViewportUtils.c(f.x + j * Math.cos(h), e, d), y: ViewportUtils.f(f.y + j * Math.sin(h), e, d) };
                    m = ((function () {
                        var $ret = new LineSegment(1);
                        $ret.c = q_1;
                        return $ret;
                    })());
                }
            }
        }
        if (j > 0) {
            n = this.p(j, f, g, h, e, d);
        }
        if (i > 0) {
            if (h - g < Math.PI && h - g > 0) {
                var r = n._startPoint;
                var s = typeCast(ArcSegment.$, n._segments._inner[0]);
                if (s != null) {
                    n._startPoint = s.e;
                    s.e = r;
                    s.d = 0;
                    var t_1 = { $type: Point_$type, x: ViewportUtils.c(f.x + i * Math.cos(g), e, d), y: ViewportUtils.f(f.y + i * Math.sin(g), e, d) };
                    o = ((function () {
                        var $ret = new LineSegment(1);
                        $ret.c = t_1;
                        return $ret;
                    })());
                }
            }
        }
        if (m != null && o != null) {
            l._segments.add(m);
            var u = n._segments._inner[0];
            n._segments.remove(u);
            l._segments.add(u);
            l._segments.add(o);
            l._isClosed = true;
            k.c.add(l);
        }
        else {
            if (l != null) {
                k.c.add(l);
                this.o(n);
            }
            if (n != null) {
                k.c.add(n);
            }
        }
        a.add(k);
    };
    PolarAxisRenderingManager.prototype.o = function (a) {
        if (a._segments.count > 1) {
            var b = typeCast(ArcSegment.$, a._segments._inner[0]);
            var c = typeCast(ArcSegment.$, a._segments._inner[1]);
            a._segments._inner[0] = c;
            a._segments._inner[1] = b;
            var d = c.e;
            var e = a._startPoint;
            var f = b.e;
            a._startPoint = d;
            c.e = f;
            b.e = e;
            b.d = 0;
            c.d = 0;
        }
        else {
            var g = a._startPoint;
            var h = typeCast(ArcSegment.$, a._segments._inner[0]);
            if (h != null) {
                a._startPoint = h.e;
                h.e = g;
                h.d = 0;
            }
        }
    };
    PolarAxisRenderingManager.prototype.i = function (a, b, c, d, e, f, g) {
        if (b > 0) {
            var h = new PathGeometry();
            h.c.add(this.p(b, e, f, g, d, c));
            a.add(h);
        }
    };
    PolarAxisRenderingManager.prototype.n = function (a, b, c, d, e, f, g, h) {
        var i = Math.min(b, c);
        var j = Math.max(b, c);
        var k = false;
        if (j - i > Math.PI) {
            k = true;
        }
        var l = Math.cos(i);
        var m = Math.sin(i);
        var n = h.x + l * f;
        var o = h.y + m * f;
        var p = h.x + l * g;
        var q = h.y + m * g;
        var r = Math.cos(j);
        var s = Math.sin(j);
        var t = h.x + r * f;
        var u = h.y + s * f;
        var v = h.x + r * g;
        var w = h.y + s * g;
        n = ViewportUtils.c(n, e, d);
        o = ViewportUtils.f(o, e, d);
        p = ViewportUtils.c(p, e, d);
        q = ViewportUtils.f(q, e, d);
        t = ViewportUtils.c(t, e, d);
        u = ViewportUtils.f(u, e, d);
        v = ViewportUtils.c(v, e, d);
        w = ViewportUtils.f(w, e, d);
        var x = new PathFigure();
        x._startPoint = { $type: Point_$type, x: n, y: o };
        x._isClosed = true;
        x._segments.add(((function () {
            var $ret = new LineSegment(1);
            $ret.c = { $type: Point_$type, x: p, y: q };
            return $ret;
        })()));
        x._segments.add(((function () {
            var $ret = new ArcSegment();
            $ret.e = { $type: Point_$type, x: v, y: w };
            $ret.f = new Size(1, ViewportUtils.d(g, e, d), ViewportUtils.g(g, e, d));
            $ret.d = 1;
            $ret.b = k;
            return $ret;
        })()));
        x._segments.add(((function () {
            var $ret = new LineSegment(1);
            $ret.c = { $type: Point_$type, x: t, y: u };
            return $ret;
        })()));
        x._segments.add(((function () {
            var $ret = new ArcSegment();
            $ret.e = { $type: Point_$type, x: n, y: o };
            $ret.f = new Size(1, ViewportUtils.d(f, e, d), ViewportUtils.g(f, e, d));
            $ret.d = 0;
            $ret.b = k;
            return $ret;
        })()));
        var y = new PathGeometry();
        y.c.add(x);
        a.add(y);
    };
    PolarAxisRenderingManager.prototype.m = function (a, b, c, d, e, f, g) {
        var h = new LineGeometry();
        var i = Math.cos(b);
        var j = Math.sin(b);
        var k = g.x + i * e;
        var l = g.y + j * e;
        var m = g.x + i * f;
        var n = g.y + j * f;
        k = ViewportUtils.c(k, d, c);
        l = ViewportUtils.f(l, d, c);
        m = ViewportUtils.c(m, d, c);
        n = ViewportUtils.f(n, d, c);
        h.d = { $type: Point_$type, x: k, y: l };
        h.c = { $type: Point_$type, x: m, y: n };
        a.add(h);
    };
    PolarAxisRenderingManager.prototype.a = function (a, b) {
        return a.x >= b.left && a.x <= b.right;
    };
    PolarAxisRenderingManager.prototype.b = function (a, b) {
        return a.y >= b.top && a.y <= b.bottom;
    };
    PolarAxisRenderingManager.prototype.c = function (a, b) {
        var c = Math.sqrt(Math.pow(a.x - b.left, 2) + Math.pow(a.y - b.top, 2));
        var d = Math.sqrt(Math.pow(a.x - b.right, 2) + Math.pow(a.y - b.top, 2));
        var e = Math.sqrt(Math.pow(a.x - b.right, 2) + Math.pow(a.y - b.bottom, 2));
        var f = Math.sqrt(Math.pow(a.x - b.left, 2) + Math.pow(a.y - b.bottom, 2));
        return Math.min(c, Math.min(d, Math.min(e, f)));
    };
    PolarAxisRenderingManager.prototype.d = function (a, b) {
        var c = Math.sqrt(Math.pow(a.x - b.left, 2) + Math.pow(a.y - b.top, 2));
        var d = Math.sqrt(Math.pow(a.x - b.right, 2) + Math.pow(a.y - b.top, 2));
        var e = Math.sqrt(Math.pow(a.x - b.right, 2) + Math.pow(a.y - b.bottom, 2));
        var f = Math.sqrt(Math.pow(a.x - b.left, 2) + Math.pow(a.y - b.bottom, 2));
        return Math.max(c, Math.max(d, Math.max(e, f)));
    };
    PolarAxisRenderingManager.prototype.f = function (a) {
        var b = { $type: Point_$type, x: 0.5, y: 0.5 };
        if (this.a(b, a) && this.b(b, a)) {
            return 0;
        }
        if (this.a(b, a)) {
            if (b.y < a.top) {
                return a.top - b.y;
            }
            else {
                return b.y - a.bottom;
            }
        }
        if (this.b(b, a)) {
            if (b.x < a.left) {
                return a.left - b.x;
            }
            else {
                return b.x - a.right;
            }
        }
        return this.c(b, a);
    };
    PolarAxisRenderingManager.prototype.g = function (a) {
        var b = { $type: Point_$type, x: 0.5, y: 0.5 };
        return this.d(b, a);
    };
    PolarAxisRenderingManager.prototype.e = function (a, b) {
        var c = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
        var d = Math.acos((b.x - a.x) / c);
        if ((b.y - a.y) < 0) {
            d = (2 * Math.PI) - d;
        }
        return d;
    };
    PolarAxisRenderingManager.prototype.h = function (a, b) {
        return ((a.y - 0.5) * b.x) + ((0.5 - a.x) * b.y) + ((a.x * 0.5) - (0.5 * a.y));
    };
    PolarAxisRenderingManager.prototype.l = function (a, b, c) {
        var d = { $type: Point_$type, x: 0.5, y: 0.5 };
        if (this.a(d, a) && this.b(d, a)) {
            b = 0;
            c = Math.PI * 2;
            return {
                p1: b,
                p2: c
            };
        }
        var e = this.e(d, { $type: Point_$type, x: a.left, y: a.top });
        var f = this.e(d, { $type: Point_$type, x: a.right, y: a.top });
        var g = this.e(d, { $type: Point_$type, x: a.right, y: a.bottom });
        var h = this.e(d, { $type: Point_$type, x: a.left, y: a.bottom });
        if (this.b(d, a) && a.left > d.x) {
            b = e;
            c = 2 * Math.PI + h;
            return {
                p1: b,
                p2: c
            };
        }
        b = Math.min(e, Math.min(f, Math.min(g, h)));
        c = Math.max(e, Math.max(f, Math.max(g, h)));
        return {
            p1: b,
            p2: c
        };
    };
    PolarAxisRenderingManager.prototype.k = function (a, b, c, d, e, f, g) {
        var h;
        var i;
        var j = this.l(a, h, i);
        h = j.p1;
        i = j.p2;
        var k = Math.min(h, i);
        var l = Math.max(h, i);
        if (typeCast(PolarAxisRenderingParameters.$, b) !== null) {
            b.minAngle = k;
            b.maxAngle = l;
        }
        else if (typeCast(RadialAxisRenderingParameters.$, b) !== null) {
            b.minAngle = k;
            b.maxAngle = l;
        }
        if (h == 0 && i == Math.PI * 2) {
            var m = c;
            var n = d;
            var o_1 = Math.min(m, n);
            var p_1 = Math.max(m, n);
            b.k.add(((function () {
                var $ret = new RangeInfo();
                $ret.d = o_1;
                $ret.c = p_1;
                $ret.b = g;
                return $ret;
            })()));
            return;
        }
        else {
            if (i > Math.PI * 2) {
                i = i - Math.PI * 2;
            }
            var q = f(h);
            var r = f(i);
            if (q < c || q > d) {
                q = f(h + Math.PI * 2);
            }
            if (r < c || r > d) {
                r = f(i + Math.PI * 2);
            }
            var s_1 = Math.min(q, r);
            var t_2 = Math.max(q, r);
            if ((!e && q > r) || (e && q < r)) {
                var u_1 = (d - t_2);
                var v_1 = (s_1 - c);
                b.k.add(((function () {
                    var $ret = new RangeInfo();
                    $ret.d = t_2;
                    $ret.c = d;
                    $ret.b = (u_1 / (u_1 + v_1)) * g;
                    return $ret;
                })()));
                b.k.add(((function () {
                    var $ret = new RangeInfo();
                    $ret.d = c;
                    $ret.c = s_1;
                    $ret.b = (v_1 / (u_1 + v_1)) * g;
                    return $ret;
                })()));
            }
            else {
                b.k.add(((function () {
                    var $ret = new RangeInfo();
                    $ret.d = s_1;
                    $ret.c = t_2;
                    $ret.b = g;
                    return $ret;
                })()));
            }
        }
    };
    PolarAxisRenderingManager.$t = markType(PolarAxisRenderingManager, 'PolarAxisRenderingManager');
    return PolarAxisRenderingManager;
}(Base));
export { PolarAxisRenderingManager };
