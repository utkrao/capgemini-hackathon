import { __extends } from "tslib";
import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { IgrCategoryAngleAxis } from "./igr-category-angle-axis";
import { IgrNumericRadiusAxis } from "./igr-numeric-radius-axis";
import { IgrAssigningRadialStyleEventArgs } from "./igr-assigning-radial-style-event-args";
import { IgrAssigningRadialMarkerStyleEventArgs } from "./igr-assigning-radial-marker-style-event-args";
import { IgrMarkerSeries } from "./igr-marker-series";
import { ensureBool, toPoint } from "igniteui-react-core";
/**
 * Represents the base class for all IgxDataChartComponent radial series
*/
var IgrRadialBase = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IgrRadialBase, _super);
    function IgrRadialBase(props) {
        var _this = _super.call(this, props) || this;
        _this._angleAxisName = null;
        _this._valueAxisName = null;
        _this._assigningRadialStyle = null;
        _this._assigningRadialStyle_wrapped = null;
        _this._assigningRadialMarkerStyle = null;
        _this._assigningRadialMarkerStyle_wrapped = null;
        return _this;
    }
    Object.defineProperty(IgrRadialBase.prototype, "i", {
        /**
                                     * @hidden
                                     */
        get: function () {
            return this._implementation;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrRadialBase.prototype, "isRadial", {
        /**
         * Checks if this series is a radial series
        */
        get: function () {
            return this.i.eb;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrRadialBase.prototype, "isCustomRadialStyleAllowed", {
        /**
         * Gets or sets whether this Radial series should allow custom style overrides of its individual visuals.
        */
        get: function () {
            return this.i.sb;
        },
        set: function (v) {
            this.i.sb = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrRadialBase.prototype, "isCustomRadialMarkerStyleAllowed", {
        /**
         * Gets or sets whether this Radial series should allow custom style overrides of its individual marker visuals.
        */
        get: function () {
            return this.i.sa;
        },
        set: function (v) {
            this.i.sa = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrRadialBase.prototype, "angleAxis", {
        /**
         * Gets the effective angle axis for the current series object.
        */
        get: function () {
            if (this.i.rp == null) {
                return null;
            }
            if (!this.i.rp.externalObject) {
                var e = IgrCategoryAngleAxis._createFromInternal(this.i.rp);
                if (e) {
                    e._implementation = this.i.rp;
                }
                this.i.rp.externalObject = e;
            }
            return this.i.rp.externalObject;
        },
        set: function (v) {
            if (v != null && this._stylingContainer && v._styling)
                v._styling(this._stylingContainer, this, this);
            v == null ? this.i.rp = null : this.i.rp = v.i;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrRadialBase.prototype, "angleAxisName", {
        /**
        * Gets or sets the name to use to resolve angleAxis from markup.
        */
        get: function () {
            return this._angleAxisName;
        },
        set: function (v) {
            this._angleAxisName = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrRadialBase.prototype, "valueAxis", {
        /**
         * Gets the effective value axis for the current series object.
        */
        get: function () {
            if (this.i.rw == null) {
                return null;
            }
            if (!this.i.rw.externalObject) {
                var e = IgrNumericRadiusAxis._createFromInternal(this.i.rw);
                if (e) {
                    e._implementation = this.i.rw;
                }
                this.i.rw.externalObject = e;
            }
            return this.i.rw.externalObject;
        },
        set: function (v) {
            if (v != null && this._stylingContainer && v._styling)
                v._styling(this._stylingContainer, this, this);
            v == null ? this.i.rw = null : this.i.rw = v.i;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrRadialBase.prototype, "valueAxisName", {
        /**
        * Gets or sets the name to use to resolve valueAxis from markup.
        */
        get: function () {
            return this._valueAxisName;
        },
        set: function (v) {
            this._valueAxisName = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrRadialBase.prototype, "clipSeriesToBounds", {
        /**
         * Gets or sets whether to clip the series to the bounds.
         * Setting this property to true will decrease chart performance.
        */
        get: function () {
            return this.i.r9;
        },
        set: function (v) {
            this.i.r9 = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    IgrRadialBase.prototype.bindAxes = function (axes) {
        _super.prototype.bindAxes.call(this, axes);
        for (var i = 0; i < axes.length; i++) {
            if (this.angleAxisName && this.angleAxisName.length > 0 &&
                axes[i].name == this.angleAxisName) {
                this.angleAxis = axes[i];
            }
        }
        for (var i = 0; i < axes.length; i++) {
            if (this.valueAxisName && this.valueAxisName.length > 0 &&
                axes[i].name == this.valueAxisName) {
                this.valueAxis = axes[i];
            }
        }
    };
    IgrRadialBase.prototype.findByName = function (name) {
        var baseResult = _super.prototype.findByName.call(this, name);
        if (baseResult) {
            return baseResult;
        }
        if (this.angleAxis && this.angleAxis.name && this.angleAxis.name == name) {
            return this.angleAxis;
        }
        if (this.valueAxis && this.valueAxis.name && this.valueAxis.name == name) {
            return this.valueAxis;
        }
        return null;
    };
    IgrRadialBase.prototype._styling = function (container, component, parent) {
        _super.prototype._styling.call(this, container, component, parent);
        this._inStyling = true;
        if (this.angleAxis && this.angleAxis._styling) {
            this.angleAxis._styling(container, component, this);
        }
        if (this.valueAxis && this.valueAxis._styling) {
            this.valueAxis._styling(container, component, this);
        }
        this._inStyling = false;
    };
    /**
     * Determine if object can be used as ValueAxis
    
    * @param axis  * The object to check
    */
    IgrRadialBase.prototype.canUseAsValueAxis = function (axis) {
        var iv = this.i.r8(axis);
        return (iv);
    };
    /**
     * Determine if object can be used as AngleAxis
    
    * @param axis  * The object to check
    */
    IgrRadialBase.prototype.canUseAsAngleAxis = function (axis) {
        var iv = this.i.r7(axis);
        return (iv);
    };
    /**
     * Gets the item that is the best match for the specified world coordinates.
    
    * @param world  * The world coordinates to use.
    */
    IgrRadialBase.prototype.getItem = function (world) {
        var iv = this.i.hv(toPoint(world));
        return (iv);
    };
    /**
     * Gets the angle to the provided world position from the center of the radial series.
    
    * @param world  * The world position to get the angle for
    */
    IgrRadialBase.prototype.getAngleFromWorld = function (world) {
        var iv = this.i.sg(toPoint(world));
        return (iv);
    };
    /**
     * Gets the precise item index, if possible, based on the closeness to the previous or next whole integer. If the series cannot provide this information, GetExactItemIndex will return the same integer value as GetItemIndex.
    
    * @param world  * The world position for which to return the index.
    */
    IgrRadialBase.prototype.getExactItemIndex = function (world) {
        var iv = this.i.f7(toPoint(world));
        return (iv);
    };
    /**
     * Get the index of the item near the provided world coordinates.
    
    * @param world  * The world coordinates for which to getch the item index.
    */
    IgrRadialBase.prototype.getItemIndex = function (world) {
        var iv = this.i.hf(toPoint(world));
        return (iv);
    };
    /**
     * Scrolls the specified item into the view.
    
    * @param item  * The item to scroll into view.
    */
    IgrRadialBase.prototype.scrollIntoView = function (item) {
        var iv = this.i.eo(item);
        return (iv);
    };
    /**
     * Returns the offset value for this series if grouped on a category axis.
    
    */
    IgrRadialBase.prototype.getOffsetValue = function () {
        var iv = this.i.getOffsetValue();
        return (iv);
    };
    /**
     * Returns the width of the category grouping this series is in.
    
    */
    IgrRadialBase.prototype.getCategoryWidth = function () {
        var iv = this.i.getCategoryWidth();
        return (iv);
    };
    Object.defineProperty(IgrRadialBase.prototype, "assigningRadialStyle", {
        /**
         * Event raised when Assigning Category Style
        */
        get: function () {
            return this._assigningRadialStyle;
        },
        set: function (ev) {
            var _this = this;
            if (this._assigningRadialStyle_wrapped !== null) {
                this.i.assigningRadialStyle = delegateRemove(this.i.assigningRadialStyle, this._assigningRadialStyle_wrapped);
                this._assigningRadialStyle_wrapped = null;
                this._assigningRadialStyle = null;
            }
            this._assigningRadialStyle = ev;
            this._assigningRadialStyle_wrapped = function (o, e) {
                var outerArgs = new IgrAssigningRadialStyleEventArgs();
                outerArgs._provideImplementation(e);
                if (_this.beforeAssigningRadialStyle) {
                    _this.beforeAssigningRadialStyle(_this, outerArgs);
                }
                if (_this._assigningRadialStyle) {
                    _this._assigningRadialStyle(_this, outerArgs);
                }
            };
            this.i.assigningRadialStyle = delegateCombine(this.i.assigningRadialStyle, this._assigningRadialStyle_wrapped);
            ;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrRadialBase.prototype, "assigningRadialMarkerStyle", {
        /**
         * Event raised when Assigning Radial Marker Style
        */
        get: function () {
            return this._assigningRadialMarkerStyle;
        },
        set: function (ev) {
            var _this = this;
            if (this._assigningRadialMarkerStyle_wrapped !== null) {
                this.i.assigningRadialMarkerStyle = delegateRemove(this.i.assigningRadialMarkerStyle, this._assigningRadialMarkerStyle_wrapped);
                this._assigningRadialMarkerStyle_wrapped = null;
                this._assigningRadialMarkerStyle = null;
            }
            this._assigningRadialMarkerStyle = ev;
            this._assigningRadialMarkerStyle_wrapped = function (o, e) {
                var outerArgs = new IgrAssigningRadialMarkerStyleEventArgs();
                outerArgs._provideImplementation(e);
                if (_this.beforeAssigningRadialMarkerStyle) {
                    _this.beforeAssigningRadialMarkerStyle(_this, outerArgs);
                }
                if (_this._assigningRadialMarkerStyle) {
                    _this._assigningRadialMarkerStyle(_this, outerArgs);
                }
            };
            this.i.assigningRadialMarkerStyle = delegateCombine(this.i.assigningRadialMarkerStyle, this._assigningRadialMarkerStyle_wrapped);
            ;
        },
        enumerable: false,
        configurable: true
    });
    return IgrRadialBase;
}(IgrMarkerSeries));
export { IgrRadialBase };
