/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { __extends, __values } from "tslib";
import * as React from 'react';
import { Visibility_$type } from "igniteui-react-core";
import { TransitionInSpeedType_$type } from './TransitionInSpeedType';
import { SeriesHitTestMode_$type } from './SeriesHitTestMode';
import { brushToString, stringToBrush, toPoint, fromPoint, fromRect, stringToColor, colorToString, ensureEnum, ensureBool, isValidProp, getModifiedProps, toSpinal, initializePropertiesFromCss, NamePatcher } from "igniteui-react-core";
import { IgrRenderRequestedEventArgs } from './igr-render-requested-event-args';
import { delegateCombine, delegateRemove, TypeRegistrar } from "igniteui-react-core";
import { SeriesVisibleRangeMode_$type } from './SeriesVisibleRangeMode';
import { SeriesHighlightingMode_$type } from './SeriesHighlightingMode';
import { SeriesOutlineMode_$type } from './SeriesOutlineMode';
import { LegendItemBadgeMode_$type } from "igniteui-react-core";
import { LegendItemBadgeShape_$type } from "igniteui-react-core";
//import { DataLegendSeriesContext, DataLegendSeriesContext_$type } from 'igniteui-core/DataLegendSeriesContext';
//import { DataLegendSeriesInfo, DataLegendSeriesInfo_$type } from 'igniteui-core/DataLegendSeriesInfo';
/**
 * Represents the base class for all IgxDataChartComponent series.
*/
var IgrSeries = /** @class */ /*@__PURE__*/ (function (_super) {
    __extends(IgrSeries, _super);
    function IgrSeries(props) {
        var _this = _super.call(this, props) || this;
        //set opacity(value: number) {
        //    this.i.opacity = +value;
        //}
        //get opacity(): number {
        //    return this.i.opacity;
        //}
        //set visibility(v: Visibility) {
        //    this.i.visibility = ensureEnum<Visibility>(Visibility_$type, v);
        //}
        //get visibility(): Visibility {
        //    return this.i.visibility;
        //}
        _this._chartLevelData = null;
        _this._dataSource = null;
        _this._tooltipTemplate = null;
        _this._tooltipContent = null;
        _this._tooltipContainerTemplate = null;
        _this._renderer = null;
        _this.__p = null;
        _this._hasUserValues = new Set();
        _this._stylingContainer = null;
        _this._stylingParent = null;
        _this._inStyling = false;
        _this._renderRequested = null;
        _this._renderRequested_wrapped = null;
        if (_this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(_this));
        }
        _this._implementation = _this.createImplementation();
        _this._implementation.externalObject = _this;
        _this.onImplementationCreated();
        return _this;
    }
    Object.defineProperty(IgrSeries.prototype, "i", {
        get: function () {
            return this._implementation;
        },
        enumerable: false,
        configurable: true
    });
    IgrSeries.prototype.onImplementationCreated = function () {
    };
    IgrSeries.prototype.createImplementation = function () {
        return null;
    };
    IgrSeries.prototype.componentDidMount = function () {
        var e_1, _a;
        try {
            for (var _b = __values(Object.keys(this.props)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                if (isValidProp(this, p)) {
                    {
                        this[p] = this.props[p];
                    }
                }
            }
        }
        catch (e_1_1) {
            e_1 = { error: e_1_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_1)
                    throw e_1.error;
            }
        }
    };
    Object.defineProperty(IgrSeries.prototype, "seriesInternal", {
        get: function () {
            return this.i;
        },
        enumerable: false,
        configurable: true
    });
    IgrSeries.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        var e_2, _a;
        var mod = getModifiedProps(this.props, nextProps);
        try {
            for (var _b = __values(Object.keys(mod)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                if (isValidProp(this, p)) {
                    this[p] = mod[p];
                }
            }
        }
        catch (e_2_1) {
            e_2 = { error: e_2_1 };
        }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return))
                    _a.call(_b);
            }
            finally {
                if (e_2)
                    throw e_2.error;
            }
        }
        return true;
    };
    IgrSeries.prototype.render = function () {
        return null;
    };
    Object.defineProperty(IgrSeries.prototype, "name", {
        get: function () {
            return this.i.name;
        },
        set: function (value) {
            this.i.name = value;
        },
        enumerable: false,
        configurable: true
    });
    IgrSeries.prototype.provideData = function (data) {
        this._chartLevelData = data;
        this.updateDataSource();
    };
    IgrSeries.prototype.onUpdateDataSource = function (dataSource) {
        return dataSource;
    };
    IgrSeries.prototype.updateDataSource = function () {
        if (this._dataSource == null) {
            this.i.itemsSource = this.onUpdateDataSource(this._chartLevelData);
        }
        else {
            this.i.itemsSource = this.onUpdateDataSource(this._dataSource);
        }
    };
    Object.defineProperty(IgrSeries.prototype, "dataSource", {
        get: function () {
            if (this._dataSource != null) {
                return this._dataSource;
            }
            return this.i.itemsSource;
        },
        set: function (value) {
            this._dataSource = value;
            this.updateDataSource();
            //console.log("setting axis data source: " + value)
        },
        enumerable: false,
        configurable: true
    });
    IgrSeries.prototype.bindAxes = function (axes) {
    };
    Object.defineProperty(IgrSeries.prototype, "tooltipTemplate", {
        get: function () {
            return this._tooltipTemplate;
        },
        set: function (value) {
            this._tooltipTemplate = value;
            if (value == null) {
                if (this._tooltipContent !== null) {
                    //this._tooltipContent.destroy();
                    this._tooltipContent = null;
                }
            }
            if (this._tooltipContent != null) {
                this._tooltipContent.template = this._tooltipTemplate;
            }
            else {
                if (this.owner != null) {
                    this.owner._ensureTooltipCreated(this);
                }
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "tooltipContainerTemplate", {
        get: function () {
            return this._tooltipContainerTemplate;
        },
        set: function (value) {
            this._tooltipContainerTemplate = value;
            if (this._tooltipContent != null) {
                this._tooltipContent.instance.containerTemplate = this._tooltipContainerTemplate;
            }
        },
        enumerable: false,
        configurable: true
    });
    IgrSeries.prototype._ensureTooltipCreated = function (createTooltip, createWrapper) {
        if (this._tooltipTemplate == null) {
            this.i.toolTip = null;
        }
        if (this._tooltipContent == null && this._tooltipTemplate != null) {
            var tooltip = createTooltip();
            if (tooltip == null) {
                return;
            }
            this._tooltipContent = tooltip;
            tooltip.tooltipTemplate = this._tooltipTemplate;
            this.i.toolTip = createWrapper(tooltip);
        }
    };
    IgrSeries.prototype._ensureTooltipDestroyed = function () {
        if (this._tooltipContent !== null) {
            //this._tooltipContent.destroy();
            this._tooltipContent = null;
        }
    };
    IgrSeries.prototype._provideRenderer = function (renderer) {
        this._renderer = renderer;
    };
    IgrSeries._createFromInternal = function (internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        var name = internal.$type.name;
        var externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    };
    Object.defineProperty(IgrSeries.prototype, "legend", {
        /**
         * Gets or sets the legend used for the current series.
        */
        get: function () {
            if (this.i.legend != null)
                return this.i.legend.externalObject;
        },
        set: function (v) {
            if (v != undefined && v != null)
                this.i.legend = v.i;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "dataLegendKey", {
        /**
     * Gets unique key used to identify the series in data legend
    */
        get: function () {
            return this.i.dataLegendKey;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isAnnotationLayer", {
        /**
         * Gets whether the series is an annotation layer.
        *
        * ```ts
        * let isAnnotationLayer: boolean = this.series.isAnnotationLayer;
        * ```
        */
        get: function () {
            return this.i.dc;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isAnnotationCrosshairLayer", {
        /**
         * Gets whether the series is an crosshair annotation layer.
        */
        get: function () {
            return this.i.c9;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isAnnotationCalloutLayer", {
        /**
         * Gets whether the series is an callout annotation layer.
        */
        get: function () {
            return this.i.c8;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isAnnotationHoverLayer", {
        /**
         * Gets whether the series is an annotation layer displayed only when hovering over the chart.
         * Crosshair Layer, Category Highlight Layer, Category Tooltip Layer, Item Tooltip Layer
        */
        get: function () {
            return this.i.db;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isAnnotationFinalValue", {
        /**
         * Gets whether the series is final value annotation layer.
        */
        get: function () {
            return this.i.da;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isVertical", {
        /**
         * Gets whether the current series is oriented vertically.
        *
        * ```ts
        * let isVertical: boolean = this.series.isVertical;
        * ```
        */
        get: function () {
            return this.i.isVertical;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isFragment", {
        /**
         * Gets whether the current series is a stack fragment.
        *
        * ```ts
        * let isFragment: boolean = this.series.isFragment;
        * ```
        */
        get: function () {
            return this.i.dv;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isAreaOrLine", {
        /**
         * Gets whether the current series shows an area or line shape.
        *
        * ```ts
        * let isAreaorLine: boolean = this.series.isAreaorLine;
        * ```
        */
        get: function () {
            return this.i.de;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isArea", {
        /**
         * Gets whether the current series shows an area shape.
        */
        get: function () {
            return this.i.dd;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "hasValueAxis", {
        /**
         * Gets whether the current series shows an area shape.
        */
        get: function () {
            return this.i.c6;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isValueAxisInverted", {
        /**
         * Gets whether the current series shows an area shape.
        */
        get: function () {
            return this.i.ek;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isLineOnly", {
        /**
         * Gets whether the current series shows only line shapes.
        */
        get: function () {
            return this.i.d2;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isLineContour", {
        /**
         * Gets whether the current series shows a line contour shape.
        */
        get: function () {
            return this.i.d1;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isSpline", {
        /**
         * Gets whether the current series shows a spline shape.
        */
        get: function () {
            return this.i.eh;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isColumn", {
        /**
         * Gets whether the current series shows a column shape.
        */
        get: function () {
            return this.i.di;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isBar", {
        /**
         * Gets whether the current series shows a horizontal column shape.
        */
        get: function () {
            return this.i.dg;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isWaterfall", {
        /**
         * Gets whether the current series shows a waterfall column shape.
        */
        get: function () {
            return this.i.el;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isPolyline", {
        /**
         * Gets whether the current series shows a polyline shape.
        */
        get: function () {
            return this.i.d9;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isPolygon", {
        /**
         * Gets whether the current series shows a polygon shape.
        */
        get: function () {
            return this.i.d8;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isPixel", {
        /**
         * Gets whether the current series shows pixels.
        */
        get: function () {
            return this.i.d6;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isPie", {
        /**
         * Gets whether the current series shows a pie shape.
        */
        get: function () {
            return this.i.d5;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isTile", {
        /**
         * Gets whether the current series shows a tile imagery.
        */
        get: function () {
            return this.i.ej;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isStep", {
        /**
         * Gets whether the current series shows step shapes.
        */
        get: function () {
            return this.i.ei;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isShapeControl", {
        /**
         * Gets whether the current series shows interactive shape controls.
        */
        get: function () {
            return this.i.ef;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isPolar", {
        /**
         * Gets whether the current series is a polar type series.
        *
        * ```ts
        * let isPolar: boolean = this.series.isPolar;
        * ```
        */
        get: function () {
            return this.i.d7;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isScatter", {
        /**
         * Gets whether the current series is a scatter type series.
        *
        * ```ts
        * let isScatter: boolean = this.series.isScatter;
        * ```
        */
        get: function () {
            return this.i.ed;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isRadial", {
        /**
         * Gets whether the current series is a radial type series.
        *
        * ```ts
        * let isRadial: boolean = this.series.isRadial;
        * ```
        */
        get: function () {
            return this.i.eb;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isStacked", {
        /**
         * Gets whether the current series is a stacked type series.
        *
        * ```ts
        * let isStacked: boolean = this.series.isStacked;
        * ```
        */
        get: function () {
            return this.i.isStacked;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isFinancial", {
        /**
         * Gets whether the current series is a financial type series.
        *
        * ```ts
        * let isFinancial: boolean = this.series.isFinancial;
        * ```
        */
        get: function () {
            return this.i.dq;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isRange", {
        /**
         * Gets whether the current series is a range type series.
        *
        * ```ts
        * let isRange: boolean = this.series.isRange;
        * ```
        */
        get: function () {
            return this.i.ec;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isCategory", {
        /**
         * Gets whether the current series is a category type series.
        *
        * ```ts
        * let isCategory: boolean = this.series.isCategory;
        * ```
        */
        get: function () {
            return this.i.dh;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isGeographic", {
        /**
         * Gets whether the current series is a geographic series.
        *
        * ```ts
        * let isGeographic: boolean = this.series.isGeographic;
        * ```
        */
        get: function () {
            return this.i.dw;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isShape", {
        /**
         * Gets whether the current series is a shape type series.
        */
        get: function () {
            return this.i.ee;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isValueOverlay", {
        /**
         * Gets whether the series is a value overlay.
        */
        get: function () {
            return this.i.isValueOverlay;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "hasOnlyMarkers", {
        /**
         * Gets whether the series has only marker as visuals
        */
        get: function () {
            return this.i.c4;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isFinancialSeries", {
        /**
         * Gets whether the series has financial OHLC/candlestick visuals
        */
        get: function () {
            return this.i.dt;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isFinancialOverlay", {
        /**
         * Gets whether the series is financial overlay
        */
        get: function () {
            return this.i.ds;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isFinancialIndicator", {
        /**
         * Gets whether the series is financial indicator
        */
        get: function () {
            return this.i.dr;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isFinancialWaterfall", {
        /**
         * Gets whether the series is financial waterfall
        */
        get: function () {
            return this.i.du;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isDefaultCrosshairBehaviorDisabled", {
        /**
         * Gets whether the default crosshair behavior should be disabled if this series is present.
        *
        * `isDefaultCrosshairBehaviorDisabled` defaults to true for annotation layers. When not using annotaion layers, you can show crosshairs by setting the chart's `CrosshairVisibility` to true.
        *
        * ```ts
        * let isDefaultCrosshairBehaviorDisabled: boolean = this.series.isDefaultCrosshairBehaviorDisabled;
        * ```
        */
        get: function () {
            return this.i.dk;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isDefaultTooltipBehaviorDisabled", {
        /**
         * Gets whether the default tooltip behavior should be disabled if this series is present.
        *
        * ```ts
        *  let isDefaultTooltipBehaviorDisabled: boolean = this.series.isDefaultTooltipBehaviorDisabled;
        * ```
        */
        get: function () {
            return this.i.dl;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "hasMarkers", {
        /**
         * Returns whether the current series supports visual markers.
        *
        * ```ts
        * let hasMarkers: boolean = this.series.hasMarkers;
        * ```
        */
        get: function () {
            return this.i.hasMarkers;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isIndexed", {
        /**
         * Gets if the series uses an index, which can be used to auto-assign it a color.
        *
        * ```ts
        * let isIndexed: boolean = this.series.isIndexed;
        * ```
        */
        get: function () {
            return this.i.dz;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isUsableInLegend", {
        /**
         * Gets if the series should appear in any legends.
        *
        * ```ts
        * let isUsableInLegend: boolean = this.series.isUsableInLegend;
        * ```
        */
        get: function () {
            return this.i.isUsableInLegend;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "legendItemVisibility", {
        /**
         * Gets or sets the legend item visibility for the current series object.
        *
        * The `LegendItemVisibilty` can be used to exclude only certain `IgrSeries` from the `IgrLegend`.
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     legendItemVisibility= "collapsed" />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.p7;
        },
        set: function (v) {
            this.i.p7 = ensureEnum(Visibility_$type, v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "legendItemBadgeTemplate", {
        /**
         * Gets or sets the LegendItemBadgeTemplate property.
         * The legend item badge is created according to the LegendItemBadgeTemplate on-demand by
         * the series object itself.
        */
        get: function () {
            return this.i.legendItemBadgeTemplate;
        },
        set: function (v) {
            this.i.legendItemBadgeTemplate = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualLegendItemBadgeTemplate", {
        /**
         * Gets the actual legend item badge template used by the series.
        */
        get: function () {
            return this.i.ne;
        },
        set: function (v) {
            this.i.ne = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualLegendItemBadgeOutline", {
        /**
         * Gets the effective legend badge outline for the current series.
        */
        get: function () {
            return brushToString(this.i.o5);
        },
        set: function (v) {
            this.i.o5 = stringToBrush(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualLegendItemBadgeBrush", {
        /**
         * Gets the effective legend badge fill for the current series.
        */
        get: function () {
            return brushToString(this.i.o4);
        },
        set: function (v) {
            this.i.o4 = stringToBrush(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "legendItemBadgeShape", {
        /**
         * Gets or sets the type of legend badge representing the current series in a legend.
         * This property will be ignored when the LegendItemTemplate/LegendItemBadgeTemplate property is set on the series
        */
        get: function () {
            return this.i.legendItemBadgeShape;
        },
        set: function (v) {
            this.i.legendItemBadgeShape = ensureEnum(LegendItemBadgeShape_$type, v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "legendItemBadgeMode", {
        /**
         * Gets or sets the mode of legend badge representing the current series in a legend.
         * This property will be ignored when the LegendItemTemplate/LegendItemBadgeTemplate property is set on the series
        */
        get: function () {
            return this.i.a9;
        },
        set: function (v) {
            this.i.a9 = ensureEnum(LegendItemBadgeMode_$type, v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "legendItemTemplate", {
        /**
         * Gets or sets the LegendItemTemplate property.
         * The legend item control content is created according to the LegendItemTemplate on-demand by
         * the series object itself.
        */
        get: function () {
            return this.i.legendItemTemplate;
        },
        set: function (v) {
            this.i.legendItemTemplate = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "discreteLegendItemTemplate", {
        /**
         * Gets or sets the DiscreteLegendItemTemplate property.
         * The legend item control content is created according to the DiscreteLegendItemTemplate on-demand by
         * the series object itself.
        */
        get: function () {
            return this.i.nf;
        },
        set: function (v) {
            this.i.nf = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "transitionEasingFunction", {
        /**
         * Gets or sets the easing function used to morph the current series.
        *
        * The `TransitioninDuration` and `transitionEasingFunction` can be used to play animation when data is added or removed from a `IgrSeries`. To play an initial animation see `transitionInDuration`.
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     isDropShadowEnabled=true
        *     markerType="circle"
        *    transitionEasingFunction ="cubicEase"
        *    isTransitionInEnabled= {true}  />
        *  </IgrDataChart>
        * ```
        *
        * ```ts
        * this.series.transitionEasingFunction =  EasingFunctions.cubicEase;
        * ```
        */
        get: function () {
            return this.i.cf;
        },
        set: function (v) {
            this.i.cf = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "transitionInEasingFunction", {
        /**
         * Gets or sets the EasingFunction used to morph the current series during the initial transition.
        *
        * The `transitionInEasingFunction` can be used with `IsTransitionInEnabled` to cofigure the animation when a new datasource is loaded.
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     isDropShadowEnabled=true
        *     markerType="circle"
        *    transitionInEasingFunction ="cubicEase"
        *    isTransitionInEnabled= {true}  />
        *  </IgrDataChart>
        * ```
        *
        * ```ts
        * this.series.transitionInEasingFunction =  EasingFunctions.cubicEase;
        * ```
        */
        get: function () {
            return this.i.cg;
        },
        set: function (v) {
            this.i.cg = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "transitionDuration", {
        /**
         * Gets or sets the duration of the current series's morph.
        *
        * The `transitionDuration` can be used to play animation when data is added or removed from a `IgrSeries`. To play an initial animation see `transitionInDuration`.
        *
        * ```ts
        * this.series.transitionDuration = 500;
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     isTransitionInEnabled=true
        *     transitionInSpeedType="indexScaled"
        *     transitionDuration= {500}
        *     transitionInDuration = {500} />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.ho;
        },
        set: function (v) {
            this.i.ho = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualResolution", {
        get: function () {
            return this.i.fv;
        },
        set: function (v) {
            this.i.fv = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "resolution", {
        /**
         * Gets or sets the current series object's rendering resolution.
        *
        * Setting the `resolution` on a Series to a higher value can help with performance, but it will lower the graphical fidelity of the line. As such, it can be increased up until the fidelity is unacceptable.
        *
        * ```ts
        * this.series.resolution = 1.5;
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     resolution= {1.5} />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.gv;
        },
        set: function (v) {
            this.i.gv = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "visibleRangeMarginTop", {
        /**
         * Gets or sets the top margin to use when getting a visible axis range for the series.
        */
        get: function () {
            return this.i.g6;
        },
        set: function (v) {
            this.i.g6 = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "visibleRangeMarginBottom", {
        /**
         * Gets or sets the bottom margin to use when getting a visible axis range for the series.
        */
        get: function () {
            return this.i.g3;
        },
        set: function (v) {
            this.i.g3 = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "visibleRangeMarginLeft", {
        /**
         * Gets or sets the left margin to use when getting a visible axis range for the series.
        */
        get: function () {
            return this.i.g4;
        },
        set: function (v) {
            this.i.g4 = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "visibleRangeMarginRight", {
        /**
         * Gets or sets the right margin to use when getting a visible axis range for the series.
        */
        get: function () {
            return this.i.g5;
        },
        set: function (v) {
            this.i.g5 = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "title", {
        /**
         * Gets or sets the Title property.
         * The legend item control is created according to the Title on-demand by
         * the series object itself.
        *
        * The `IgrSeries` `title` may be used in tooltips and legends.
        *
        * ```ts
        * this.series.title = "InStock Items";
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *    title="InStock Items" />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.title;
        },
        set: function (v) {
            this.i.title = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "brush", {
        /**
         * Gets or sets the brush to use for the series.
        *
        * The `brush` along with the `outline` and `Negative Brush` can be used to affect the visuals of the `IgrSeries`.
        *
        * ```ts
        * this.series.brush = "red";
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     brush="Gray"
        *     outline="Black" />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return brushToString(this.i.o7);
        },
        set: function (v) {
            this.i.o7 = stringToBrush(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualBrush", {
        /**
         * Gets the effective brush for the current series object.
        *
        * ```ts
        * let actualBrush: string = series.actualBrush;
        * ```
        */
        get: function () {
            return brushToString(this.i.o3);
        },
        set: function (v) {
            this.i.o3 = stringToBrush(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "outline", {
        /**
         * Gets or sets the brush to use for the outline of the series.
         * Some series types, such as LineSeries, do not display outlines.  Therefore, this property does not affect some charts.
        *
        * The `outline` along with the `brush` and `NegativeBrush` can be used to affect the visuals of the `IgrSeries`.
        *
        * ```ts
        * this.series.brush = "red";
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     brush="Gray"
        *     outline="Black" />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return brushToString(this.i.pc);
        },
        set: function (v) {
            this.i.pc = stringToBrush(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualOutline", {
        /**
         * Gets the effective outline for the current series object.
        *
        * ```ts
        * let actualOutline: string = series.ActualOutline;
        * ```
        */
        get: function () {
            return brushToString(this.i.o6);
        },
        set: function (v) {
            this.i.o6 = stringToBrush(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "thickness", {
        /**
         * Gets or sets the width of the current series object's line thickness.
        *
        * Depending on the `IgrSeries` type, this can be the main brush used, or just the outline. For example, when using a `IgrLineSeries` it will affect the thickness of the lines drawn, whereas when using a `IgrColumnSeries` it will affect the outer border thickness of the columns.
        *
        * ```ts
        * this.series.thickness=5;
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     thickness= {5} />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.g1;
        },
        set: function (v) {
            this.i.g1 = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualThickness", {
        /**
         * Gets the effective Thickness for the current series object.
        */
        get: function () {
            return this.i.fw;
        },
        set: function (v) {
            this.i.fw = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualHighlightingMode", {
        /**
         * Gets actual highlighting mode
        */
        get: function () {
            return this.i.bk;
        },
        set: function (v) {
            this.i.bk = ensureEnum(SeriesHighlightingMode_$type, v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualHighlightingFadeOpacity", {
        /**
         * Gets actual highlighting fade opacity
        */
        get: function () {
            return this.i.ft;
        },
        set: function (v) {
            this.i.ft = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "highlightingFadeOpacity", {
        /**
         * Gets or sets the target opacity to fade to for fade style highlighting.
        */
        get: function () {
            return this.i.gr;
        },
        set: function (v) {
            this.i.gr = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isActualLegendFinancial", {
        /**
         * Gets or sets whether the ActualLegend is FinancialLegend or normal Legend.
        */
        get: function () {
            return this.i.c7;
        },
        set: function (v) {
            this.i.c7 = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isComponentHighlightingModeIgnored", {
        /**
         * Gets or sets whether the component level highlight mode is ignored.
        */
        get: function () {
            return this.i.dj;
        },
        set: function (v) {
            this.i.dj = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isHighlightingEnabled", {
        /**
         * Gets or sets whether highlighting should be enabled for this series, if this type of series supports highlighting.
        *
        * ```ts
        * this.series.isHighlightingEnabled = true;
        * ```
        *
        * ```ts
        * <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     isHighlightingEnabled="true" />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.dx;
        },
        set: function (v) {
            this.i.dx = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "shouldHideAutoCallouts", {
        /**
         * Gets or sets whether this series should suppress it's auto callouts
        */
        get: function () {
            return this.i.er;
        },
        set: function (v) {
            this.i.er = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isDropShadowEnabled", {
        /**
         * Gets or sets whether drop shadow should be enabled for this series.
        *
        * `isDropShadowEnabled` is used to decide whether drop shadow should be enabled for this series.
        *
        * ```ts
        * this.series.isDropShadowEnabled = true;
        * ```
        *
        * ```ts
        * <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     isDropShadowEnabled="true" />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.dn;
        },
        set: function (v) {
            this.i.dn = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "shadowBlur", {
        /**
         * Gets or sets the shadow blur.
         * This property is ignored when
         * Series.UseSingleShadow is set to true.
        *
        * `shadowBlur` can be set in conjection with `isDropShadowEnabled` to further define the drop shadow effect.
        *
        * ```ts
        * this.series.shadowBlur = 7;
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     shadowBlur={7}
        *     shadowColor="blue" />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.gy;
        },
        set: function (v) {
            this.i.gy = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "shadowColor", {
        /**
         * Gets or sets the drop shadow color.
        *
        * `shadowColor` can be set in conjection with `isDropShadowEnabled` to further define the drop shadow effect.
        *
        * ```ts
        * this.series.shadowColor = "blue";
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     shadowBlur="7"
        *     shadowColor="blue" />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return colorToString(this.i.pf);
        },
        set: function (v) {
            this.i.pf = stringToColor(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "useSingleShadow", {
        /**
         * Gets or sets whether drop shadow is applied to the whole series visual or to each of the individual shapes forming the series.
         * When this property is set to true, no
         * Series.ShadowBlur is applied.
        *
        * ```ts
        * this.series.useSingleShadow = true;
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     isDropShadowEnabled=true
        *     markerType="circle"
        *     useSingleShadow= {true} />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.e9;
        },
        set: function (v) {
            this.i.e9 = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "shadowOffsetX", {
        /**
         * Gets or sets the drop shadow x-offset.
        *
        * `shadowOffsetX` can be set in conjection with `isDropShadowEnabled` to further define the drop shadow effect.
        *
        * ```ts
        * this.series.shadowOffsetX = 10;
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     shadowOffsetX= {10}
        *     shadowOffsetY={10] />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.gz;
        },
        set: function (v) {
            this.i.gz = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "shadowOffsetY", {
        /**
         * Gets or sets the drop shadow y-offset.
        *
        * `shadowOffsetY` can be set in conjection with `isDropShadowEnabled` to further define the drop shadow effect.
        *
        * ```ts
        * this.series.shadowOffsetY = 10;
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     shadowOffsetX= {10}
        *     shadowOffsetY= {10} />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.g0;
        },
        set: function (v) {
            this.i.g0 = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "areaFillOpacity", {
        /**
         * Gets or sets the opacity applied to the area fill visual.
         * This property only applies to series that have area visual.
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *    actualAreaFillOpacity= {1} />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.f1;
        },
        set: function (v) {
            this.i.f1 = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualAreaFillOpacity", {
        /**
         * Gets the actual opacity applied to the area fill visual.
        *
        * ```ts
        * let actualFillOpacity: number = series.actualAreaFillOpacity;
        * ```
        */
        get: function () {
            return this.i.fs;
        },
        set: function (v) {
            this.i.fs = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "markerFillOpacity", {
        /**
         * Gets or sets the opacity applied to the fill of the markers.
         * This property only applies to series that have area visual.
        */
        get: function () {
            return this.i.gs;
        },
        set: function (v) {
            this.i.gs = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualMarkerFillOpacity", {
        /**
         * Gets the actual opacity applied to the fill of the markers.
        */
        get: function () {
            return this.i.fu;
        },
        set: function (v) {
            this.i.fu = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isDefaultToolTipSelected", {
        /**
         * Gets if the default tooltip has been selected for display.
        *
        * To use the default tooltip set `showDefaultTooltip` to true.
        *
        * ```ts
        * let isDefaultToolTipSelected: boolean = this.series.isDefaultToolTipSelected;
        * ```
        */
        get: function () {
            return this.i.dm;
        },
        set: function (v) {
            this.i.dm = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "showDefaultTooltip", {
        /**
         * Gets or sets whether default tooltip will be shown.
        *
        * The default tooltips display all the information relevant to the particular series item (series title, data values, axis values etc.) and are styled to match the series' style. When using default tooltips, you should also set the series `title`.
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     showDefaultTooltip ="true"
        *     title="InStock Items" />
        *  </IgrDataChart>
        * ```
        *
        * ```ts
        * this.series.showDefaultTooltip ="true";
        * ```
        */
        get: function () {
            return this.i.et;
        },
        set: function (v) {
            this.i.et = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "visibleRangeMode", {
        /**
         * Gets or sets the visible range mode to use.
        */
        get: function () {
            return this.i.b4;
        },
        set: function (v) {
            this.i.b4 = ensureEnum(SeriesVisibleRangeMode_$type, v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "outlineMode", {
        /**
         * Gets or sets the outline mode to use for the series.
        */
        get: function () {
            return this.i.bt;
        },
        set: function (v) {
            this.i.bt = ensureEnum(SeriesOutlineMode_$type, v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "transitionInDuration", {
        /**
         * Gets or sets the duration of the current series's transition in morph.
        *
        * The `transitionInDuration` can be used with `IsTransitionInEnabled` to cofigure the animation when a new datasource is loaded.
        *
        * ```ts
        * this.series.transitionDuration = 500;
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     isTransitionInEnabled= {true}
        *     transitionInSpeedType="indexScaled"
        *     transitionDuration={500}
        *     transitionInDuration= {500} />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.hp;
        },
        set: function (v) {
            this.i.hp = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "transitionInSpeedType", {
        /**
         * Gets or sets the duration of the current series's transition in morph.
        *
        * The `transitionInSpeedType` can be used with `IsTransitionInEnabled` to cofigure the animation when a new datasource is loaded.
        *
        * ```ts
        * this.series.transitionInSpeedType = TransitionInSpeedType.IndexScaled;
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     isTransitionInEnabled=true
        *     transitionInSpeedType="indexScaled"
        *     transitionDuration=500
        *     transitionInDuration=500 />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.ca;
        },
        set: function (v) {
            this.i.ca = ensureEnum(TransitionInSpeedType_$type, v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "mouseOverEnabled", {
        /**
         * Gets or sets the whether the chart reacts to mouse move events.
        */
        get: function () {
            return this.i.em;
        },
        set: function (v) {
            this.i.em = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "coercionMethods", {
        /**
         * Gets or sets the coercion methods to use when loading data from data sources.
         * Should be specified before setting any member paths, if being used. Setting it later
         * will not cause data to be reimported into the chart.
        *
        * &lt;-- position: content member-->
        *
        * ```ts
        * cMethods: any = {
        *     ValueCoercion: function(value:number): number {return value+2;}
        *  }
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource}
        *     width="700px"
        *     height="500px">
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrScatterPolygonSeries
        *      name="series1"
        *      shapeMemberPath="Points"
        *      title="House Floor Plan"
        *      brush="Gray"
        *      outline="Black"
        * 	 coercionMethods = {this.ValueCoercion} />
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this.i.coercionMethods;
        },
        set: function (v) {
            this.i.coercionMethods = v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "expectFunctions", {
        /**
         * Gets or sets whether the series should expect that properties in its items source may be functions that need to be
         * evaluated to yield their value. This defaults to false, as there will be a subtle performance impact to using this feature.
         * This value must be set before assigning an item's source to take effect.
        *
        * `expectFunctions` is used to decide whether the series should expect that its data source members need to be called as functions to get their values.
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="MyFunction"
        *     expectFunctions={true} />
        *  </IgrDataChart>
        * ```
        *
        * ```ts
        * this.series.expectFunctions=true;
        * ```
        */
        get: function () {
            return this.i.expectFunctions;
        },
        set: function (v) {
            this.i.expectFunctions = ensureBool(v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "hitTestMode", {
        /**
         * Method of hit testing to use when pointing to items in this series.
        *
        * The `hitTestMode` can be set to either:
        *
        * -   `Auto`: automatically decide the appropriate hit test mode for the series.
        * -   `ColorEncoded`: use a color encoded off screen buffer for hit testing. Should always be O(1) time for determining a hit series. This increases frame render time and memory usage, however. Consider using this if hit testing time is degrading performance.
        * -   `Computational`: use a computational based approach to determine whether the series has been hit. This uses loose bounding boxes, in some cases, and can range in time complexity between O(1) and O(log n) to find a hit. This decreases frame render time compared to color encoded
        *
        * ```ts
        * this.series.hitTestMode = SeriesHitTestMode.Computational;
        * ```
        */
        get: function () {
            return this.i.bq;
        },
        set: function (v) {
            this.i.bq = ensureEnum(SeriesHitTestMode_$type, v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualHitTestMode", {
        /**
         * Resolved method of hit testing to use when pointing to items in the chart.
        *
        * ```ts
        * let hitTestMode: SeriesHitTestMode = this.series.actualHitTestMode;
        * ```
        */
        get: function () {
            return this.i.bo;
        },
        set: function (v) {
            this.i.bo = ensureEnum(SeriesHitTestMode_$type, v);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isNegativeColorSupported", {
        /**
         * Overridden by derived series classes to indicate when negative colors are supported or not.
        */
        get: function () {
            return this.i.d4;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "isMarkerlessDisplayPreferred", {
        /**
         * Overridden by derived series classes to indicate when markerless display is preferred or not.
        */
        get: function () {
            return this.i.d3;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "finalValue", {
        /**
         * The final value of this series.
        */
        get: function () {
            return this.i.f3;
        },
        set: function (v) {
            this.i.f3 = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "percentChange", {
        /**
         * The percent change from the beginning to the end of this series.
        */
        get: function () {
            return this.i.gu;
        },
        set: function (v) {
            this.i.gu = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualOpenLabel", {
        /**
         * Gets the text that is displayed for the Open label in the tooltip.
        */
        get: function () {
            return this.i.ij;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualCloseLabel", {
        /**
         * Gets the text that is displayed for the Close label in the tooltip.
        */
        get: function () {
            return this.i.h7;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualHighLabel", {
        /**
         * Gets the text that is displayed for the High label in the tooltip.
        */
        get: function () {
            return this.i.h8;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualLowLabel", {
        /**
         * Gets the text that is displayed for the Low label in the tooltip.
        */
        get: function () {
            return this.i.ih;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualVolumeLabel", {
        /**
         * Gets the text that is displayed for the Volume label in the tooltip.
        */
        get: function () {
            return this.i.iq;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualValueLabel", {
        /**
         * Gets the text that is displayed for the Value label in the tooltip.
        */
        get: function () {
            return this.i.ip;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "actualRadiusLabel", {
        /**
         * Gets the text that is displayed for the Value label in the tooltip.
        */
        get: function () {
            return this.i.il;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "opacity", {
        get: function () {
            return this.i.opacity;
        },
        set: function (v) {
            this.i.opacity = +v;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IgrSeries.prototype, "visibility", {
        get: function () {
            return this.i.visibility;
        },
        set: function (v) {
            this.i.visibility = ensureEnum(Visibility_$type, v);
        },
        enumerable: false,
        configurable: true
    });
    IgrSeries.prototype.findByName = function (name) {
        if (this.legend && this.legend.name && this.legend.name == name) {
            return this.legend;
        }
        return null;
    };
    Object.defineProperty(IgrSeries.prototype, "hasUserValues", {
        get: function () {
            return this._hasUserValues;
        },
        enumerable: false,
        configurable: true
    });
    IgrSeries.prototype.__m = function (propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    };
    IgrSeries.prototype._styling = function (container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        var genericPrefix = "";
        var typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("Series");
        var additionalPrefixes = [];
        var prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        var b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            var basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            var parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            var parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    };
    /**
 * Gets the brush for tooltip labels.

*/
    IgrSeries.prototype.resolveTooltipBrush = function () {
        var iv = this.i.jt();
        return (iv);
    };
    IgrSeries.prototype.getItemValue = function (item, memberPathName) {
        var iv = this.i.hy(item, memberPathName);
        return (iv);
    };
    /**
     * Gets the precise item index, if possible, based on the closeness to the previous or next whole integer. If the series cannot provide this information, GetExactItemIndex will return the same integer value as GetItemIndex.
    
    * @param world  * The world position for which to return the index.
    *
    * ```ts
    * let index: number = this.series.getExactItemIndex({x:.5,y:.5});
    * ```
    */
    IgrSeries.prototype.getExactItemIndex = function (world) {
        var iv = this.i.f7(toPoint(world));
        return (iv);
    };
    /**
     * Gets the item index associated with the specified world position
    
    *
    * ```ts
    * let index: number = this.series.getItemIndex({x:.5,y:.5});
    * ```
    */
    IgrSeries.prototype.getItemIndex = function (world) {
        var iv = this.i.hf(toPoint(world));
        return (iv);
    };
    /**
     * Gets the item that is the best match for the specified world coordinates.
    
    * @param world  * The world coordinates to use.
    *
    * ```ts
    * let item: number = this.series.getItem({x:.5,y:.5});
    * ```
    */
    IgrSeries.prototype.getItem = function (world) {
        var iv = this.i.hv(toPoint(world));
        return (iv);
    };
    IgrSeries.prototype.getPreviousOrExactIndex = function (world, skipUnknowns) {
        var iv = this.i.hl(toPoint(world), skipUnknowns);
        return (iv);
    };
    IgrSeries.prototype.getNextOrExactIndex = function (world, skipUnknowns) {
        var iv = this.i.hj(toPoint(world), skipUnknowns);
        return (iv);
    };
    IgrSeries.prototype.getSeriesValue = function (world, useInterpolation, skipUnknowns) {
        var iv = this.i.gl(toPoint(world), useInterpolation, skipUnknowns);
        return (iv);
    };
    IgrSeries.prototype.getSeriesValuePosition = function (world, useInterpolation, skipUnknowns) {
        var iv = this.i.pq(toPoint(world), useInterpolation, skipUnknowns);
        return fromPoint(iv);
    };
    /**
     * If possible, will return the best available value bounding box within the series that has the best value match for the world position provided.
    
    * @param world  * The world coordinate for which to get a value bounding box for
    */
    IgrSeries.prototype.getSeriesValueBoundingBox = function (world) {
        var iv = this.i.pz(toPoint(world));
        return fromRect(iv);
    };
    /**
     * If possible, will return the best available value marker bounding box within the series that has the best value match for the world position provided.
    
    * @param world  * The world coordinates for which to get a value marker bounding box for
    */
    IgrSeries.prototype.getSeriesValueMarkerBoundingBox = function (world) {
        var iv = this.i.p1(toPoint(world));
        return fromRect(iv);
    };
    IgrSeries.prototype.getSeriesHighValue = function (world, useInterpolation, skipUnknowns) {
        var iv = this.i.gh(toPoint(world), useInterpolation, skipUnknowns);
        return (iv);
    };
    IgrSeries.prototype.getSeriesHighValuePosition = function (world, useInterpolation, skipUnknowns) {
        var iv = this.i.pm(toPoint(world), useInterpolation, skipUnknowns);
        return fromPoint(iv);
    };
    IgrSeries.prototype.getSeriesLowValue = function (world, useInterpolation, skipUnknowns) {
        var iv = this.i.gj(toPoint(world), useInterpolation, skipUnknowns);
        return (iv);
    };
    IgrSeries.prototype.getSeriesLowValuePosition = function (world, useInterpolation, skipUnknowns) {
        var iv = this.i.po(toPoint(world), useInterpolation, skipUnknowns);
        return fromPoint(iv);
    };
    IgrSeries.prototype.getSeriesValuePositionFromSeriesPixel = function (mouse, useInterpolation, skipUnknowns) {
        var iv = this.i.pr(toPoint(mouse), useInterpolation, skipUnknowns);
        return fromPoint(iv);
    };
    IgrSeries.prototype.getSeriesValueFromSeriesPixel = function (mouse, useInterpolation, skipUnknowns) {
        var iv = this.i.gm(toPoint(mouse), useInterpolation, skipUnknowns);
        return (iv);
    };
    /**
     * For a category plotted series, returns the current width of the items within the categories. This only returns a value if the items have some form of width (e.g. columns, bars, etc.) otherwise 0 is returned.
    
    *
    * ```ts
    * let span: number = this.series.getItemSpan();
    * ```
    */
    IgrSeries.prototype.getItemSpan = function () {
        var iv = this.i.gc();
        return (iv);
    };
    /**
     * Hides any internal tooltips presented by the series, if any.
    
    */
    IgrSeries.prototype.hideToolTips = function () {
        this.i.lg();
    };
    /**
     * Hides any internal tooltips presented by the series, if any.
    
    */
    IgrSeries.prototype.hideToolTipsImmediate = function () {
        this.i.lh();
    };
    /**
     * Converts a point from coordinates within the series plot area to a world position within axis space.
    
    * @param seriesPoint  * The pixel location within the plot area of the series.
    *
    * ```ts
    * this.series.toWorldPosition({x:500,y:500});
    * ```
    */
    IgrSeries.prototype.toWorldPosition = function (seriesPoint) {
        var iv = this.i.pt(toPoint(seriesPoint));
        return fromPoint(iv);
    };
    /**
     * Converts a point from world coordinates to coordinates within the viewport of the series.
    
    * @param world  * The world position from which to convert.
    */
    IgrSeries.prototype.fromWorldPosition = function (world) {
        var iv = this.i.pl(toPoint(world));
        return fromPoint(iv);
    };
    /**
     * Requests that the provided item should be brought into view if possible.
    
    * @param item  * The item to attempt to bring into view.
    *
    * ```ts
    * this.series.scrollIntoView(dataItem);
    * ```
    */
    IgrSeries.prototype.scrollIntoView = function (item) {
        var iv = this.i.eo(item);
        return (iv);
    };
    /**
     * Renders the series.
    
    * @param animate  * True if the change should be animated.
    *
    * ```ts
    * this.series.renderSeries(true);
    * ```
    */
    IgrSeries.prototype.renderSeries = function (animate) {
        this.i.ml(animate);
    };
    /**
     * Gets the effective viewport, adjusted to account for margins and other factors.
    
    */
    IgrSeries.prototype.getEffectiveViewport = function () {
        var iv = this.i.getEffectiveViewport();
        return fromRect(iv);
    };
    /**
     * Removes all alternate views of this series.
    
    */
    IgrSeries.prototype.removeAllAlternateViews = function () {
        this.i.mf();
    };
    /**
     * Removes an alternate view of this series.
    
    * @param viewIdentifier  * The string identifier for the view to remove.
    */
    IgrSeries.prototype.removeAlternateView = function (viewIdentifier) {
        this.i.mh(viewIdentifier);
    };
    /**
     * Called to notify about changes to indexed-based properties, e.g. Brushes, Outlines, MarkerBrushes, MarkerOutlines and refresh series
    
    */
    IgrSeries.prototype.notifyIndexedPropertiesChanged = function () {
        this.i.ln();
    };
    /**
     * Notifies the series that a visual property has changed, requiring a visual update.
    
    */
    IgrSeries.prototype.notifyVisualPropertiesChanged = function () {
        this.i.lu();
    };
    /**
     * Replays the assigned transition in animation, if any.
    
    *
    * ```ts
    * this.series.replayTransitionIn();
    * ```
    */
    IgrSeries.prototype.replayTransitionIn = function () {
        this.i.mo();
    };
    /**
     * Call to null out the axes of the series;
    
    */
    IgrSeries.prototype.removeAxes = function () {
        this.i.mi();
    };
    /**
     * Simulates a pointer hover over the series surface.
    
    * @param point  * The pointer position relative to the series viewport over which to hover.
    *
    * When tooltips are enabled, `simulateHover` can be used to automatically display the tooltip over a particular series item.
    *
    * ```ts
    * this.series.simulateHover({x:250,y:250});
    * ```
    */
    IgrSeries.prototype.simulateHover = function (point) {
        this.i.mt(toPoint(point));
    };
    /**
     * Called when this series' Style is updated.
    
    */
    IgrSeries.prototype.styleUpdated = function () {
        this.i.mv();
    };
    IgrSeries.prototype.setNegativeColors = function (negativeBrush, negativeOutline) {
        this.i.mq(stringToBrush(negativeBrush), stringToBrush(negativeOutline));
    };
    /**
     * Moves the cursor point to the provided world position. Some series may react to the current cursor position.
    
    * @param point  * The cursor point, in world coordinates.
    *
    * `moveCursorPoint` can be used on annotation layers to programitically show the annotation at the given point.
    *
    * ```ts
    * this.crosshair.moveCursorPoint({x:.5,y:.5});
    * ```
    */
    IgrSeries.prototype.moveCursorPoint = function (point) {
        this.i.lk(toPoint(point));
    };
    Object.defineProperty(IgrSeries.prototype, "renderRequested", {
        /**
         * This event is raised every time a render has been requested from a series.
        *
        * ```ts
        *  const series1 = new IgrAreaSeries({ name: "series1" });
        * series1.valueMemberPath = "USA";
        * series1.title = "USA";
        * series1.xAxisName = "xAxis";
        * series1.yAxisName = "yAxis";
        * series1.renderRequested= this.onRenderRequested;
        *
        * public onRenderRequested =( s:IgrSeries, e: RenderRequestedEventArgs) => {
        *           }
        * ```
        *
        * ```ts
        *  <IgrDataChart
        *     dataSource={this.state.dataSource} >
        *
        *     <IgrNumericXAxis name="xAxis" />
        *     <IgrNumericYAxis name="yAxis" />
        *
        *     <IgrAreaSeries
        *      name="series1"
        *     xAxisName="xAxis"
        * 	yAxisName="yAxis"
        * 	valueMemberPath="Value"
        *     shadowBlur="7"
        *     shadowColor="blue"
        * 	renderRequested= {this.onRenderRequested}/>
        *  </IgrDataChart>
        * ```
        */
        get: function () {
            return this._renderRequested;
        },
        set: function (ev) {
            var _this = this;
            if (this._renderRequested_wrapped !== null) {
                this.i.renderRequested = delegateRemove(this.i.renderRequested, this._renderRequested_wrapped);
                this._renderRequested_wrapped = null;
                this._renderRequested = null;
            }
            this._renderRequested = ev;
            this._renderRequested_wrapped = function (o, e) {
                var outerArgs = new IgrRenderRequestedEventArgs();
                outerArgs._provideImplementation(e);
                if (_this.beforeRenderRequested) {
                    _this.beforeRenderRequested(_this, outerArgs);
                }
                if (_this._renderRequested) {
                    _this._renderRequested(_this, outerArgs);
                }
            };
            this.i.renderRequested = delegateCombine(this.i.renderRequested, this._renderRequested_wrapped);
            ;
        },
        enumerable: false,
        configurable: true
    });
    return IgrSeries;
}(React.Component));
export { IgrSeries };
