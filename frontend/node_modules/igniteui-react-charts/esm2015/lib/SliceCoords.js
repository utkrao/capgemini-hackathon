/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, markType } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
import { ViewportUtils } from "./ViewportUtils";
/**
 * @hidden
 */
export let SliceCoords = /*@__PURE__*/ (() => {
    class SliceCoords extends Base {
        constructor() {
            super(...arguments);
            this.d = null;
            this.f = null;
            this.h = null;
            this.j = null;
            this.e = null;
            this.g = null;
            this.i = null;
            this.k = null;
            this.c = false;
            this.n = new Size();
            this.m = new Size();
            this.l = new Size();
        }
        static b(a, b, c, d, e, f, g) {
            let h = Math.min(c, d);
            let i = Math.max(c, d);
            let j = Math.cos(h);
            let k = Math.sin(h);
            let l = Math.max(0, e);
            let m = f;
            let n = g.x + j * l;
            let o = g.y + k * l;
            let p = g.x + j * m;
            let q = g.y + k * m;
            let r = Math.cos(i);
            let s = Math.sin(i);
            let t = g.x + r * l;
            let u = g.y + s * l;
            let v = g.x + r * m;
            let w = g.y + s * m;
            n = ViewportUtils.c(n, a, b);
            o = ViewportUtils.f(o, a, b);
            p = ViewportUtils.c(p, a, b);
            q = ViewportUtils.f(q, a, b);
            t = ViewportUtils.c(t, a, b);
            u = ViewportUtils.f(u, a, b);
            v = ViewportUtils.c(v, a, b);
            w = ViewportUtils.f(w, a, b);
            let x = { $type: Point_$type, x: n, y: o };
            let y = { $type: Point_$type, x: p, y: q };
            let z = { $type: Point_$type, x: v, y: w };
            let aa = { $type: Point_$type, x: t, y: u };
            let ab = ViewportUtils.d(m, a, b);
            let ac = ViewportUtils.g(m, a, b);
            let ad = ViewportUtils.d(l, a, b);
            let ae = ViewportUtils.g(l, a, b);
            return ((() => {
                let $ret = new SliceCoords();
                $ret.d = x;
                $ret.f = y;
                $ret.h = z;
                $ret.j = aa;
                $ret.c = ((i - h) > Math.PI);
                $ret.n = new Size(1, ab, ac);
                $ret.m = new Size(1, ad, ae);
                return $ret;
            })());
        }
        static a(a, b, c, d, e, f, g, h, i) {
            let j = ViewportUtils.b(i, a, b);
            let k = f - e;
            if (k < 0) {
                return null;
            }
            if (ViewportUtils.d(k, a, b) < 2) {
                return null;
            }
            if (j * 2 > k) {
                j = k / 2;
                i = ViewportUtils.d(j, a, b);
            }
            let l = ViewportUtils.b(h, a, b);
            let m = l / (f - j);
            let n = Math.atan(m);
            if (n * 2 > Math.abs(d - c)) {
                n = Math.abs(d - c) / 2;
                h = ViewportUtils.d(Math.tan(n) * (f - j), a, b);
            }
            let o = SliceCoords.b(a, b, c + n, d - n, e, f, g);
            let p = SliceCoords.b(a, b, c, d, e + (j * (e / f)), f - j, g);
            o.g = o.f;
            o.k = o.j;
            o.e = p.d;
            o.f = p.f;
            o.i = p.h;
            o.j = p.j;
            o.l = new Size(1, h, i);
            return o;
        }
    }
    SliceCoords.$t = /*@__PURE__*/ markType(SliceCoords, 'SliceCoords');
    return SliceCoords;
})();
