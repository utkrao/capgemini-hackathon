import * as React from 'react';
import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { Visibility_$type } from "igniteui-react-core";
import { MarkerType_$type } from "./MarkerType";
import { IgrPropertyUpdatedEventArgs } from "igniteui-react-core";
import { StackedFragmentSeries } from "./StackedFragmentSeries";
import { getModifiedProps, isValidProp, brushToString, stringToBrush, ensureBool, colorToString, stringToColor, ensureEnum, toSpinal, initializePropertiesFromCss, NamePatcher, fromPoint, toPoint, fromRect } from "igniteui-react-core";
import { TypeRegistrar } from "igniteui-react-core";
import { SeriesOutlineMode_$type } from './SeriesOutlineMode';
import { LegendItemBadgeMode_$type } from "igniteui-react-core";
import { LegendItemBadgeShape_$type } from "igniteui-react-core";
import { CategoryTransitionInMode_$type } from './CategoryTransitionInMode';
import { TransitionInSpeedType_$type } from './TransitionInSpeedType';
/**
 * Represents a non-visual child of StackedSeriesBase.
*/
export class IgrStackedFragmentSeries extends React.Component {
    constructor(props) {
        super(props);
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._propertyUpdated = null;
        this._propertyUpdated_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    createImplementation() {
        return new StackedFragmentSeries();
    }
    onImplementationCreated() {
    }
    componentDidMount() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    provideRenderer(renderer) {
        this._renderer = renderer;
        this.i.visualSeriesLink.provideRenderer(renderer);
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    /**
 * Gets or sets the ItemsSource property for the current series object. Normally you will want to provide data to the parent series instead.
 * But if you have data as individual columns, it can be assigned here. The data must be aligned and have the same number of items for each fragment.
*/
    get dataSource() {
        return this.i.itemsSource;
    }
    set dataSource(v) {
        this.i.itemsSource = v;
    }
    /**
     * Gets or sets the brush of the stacked fragment.
    */
    get brush() {
        return brushToString(this.i.jk);
    }
    set brush(v) {
        this.i.jk = stringToBrush(v);
    }
    /**
     * Gets the actual brush used by the series.
    */
    get actualBrush() {
        return brushToString(this.i.jf);
    }
    set actualBrush(v) {
        this.i.jf = stringToBrush(v);
    }
    /**
     * Gets or sets whether drop shadow should be enabled for this series.
    */
    get isDropShadowEnabled() {
        return this.i.ap;
    }
    set isDropShadowEnabled(v) {
        this.i.ap = ensureBool(v);
    }
    /**
     * Gets whether drop shadow is actually enabled for this series.
    */
    get actualIsDropShadowEnabled() {
        return this.i.ai;
    }
    set actualIsDropShadowEnabled(v) {
        this.i.ai = ensureBool(v);
    }
    /**
     * Gets or sets the shadow blur.
     * This property is ignored when
     * StackedFragmentSeries.UseSingleShadow is set to true.
    */
    get shadowBlur() {
        return this.i.bs;
    }
    set shadowBlur(v) {
        this.i.bs = +v;
    }
    /**
     * Gets the actual shadow blur used by the series.
    */
    get actualShadowBlur() {
        return this.i.a9;
    }
    set actualShadowBlur(v) {
        this.i.a9 = +v;
    }
    /**
     * Gets or sets the drop shadow color.
    */
    get shadowColor() {
        return colorToString(this.i.jr);
    }
    set shadowColor(v) {
        this.i.jr = stringToColor(v);
    }
    /**
     * Gets actual the drop shadow color used by the series.
    */
    get actualShadowColor() {
        return colorToString(this.i.jq);
    }
    set actualShadowColor(v) {
        this.i.jq = stringToColor(v);
    }
    /**
     * Gets or sets whether drop shadow is applied to the whole StackedFragmentSeries visual or to each of the individual shapes forming the StackedFragmentSeries.
     * When this property is set to true, no
     * StackedFragmentSeries.ShadowBlur is applied.
    */
    get useSingleShadow() {
        return this.i.ax;
    }
    set useSingleShadow(v) {
        this.i.ax = ensureBool(v);
    }
    /**
     * Gets whether drop shadow is actually applied to the whole StackedFragmentSeries visual or to each of the individual shapes forming the StackedFragmentSeries.
    */
    get actualUseSingleShadow() {
        return this.i.an;
    }
    set actualUseSingleShadow(v) {
        this.i.an = ensureBool(v);
    }
    /**
     * Gets or sets the drop shadow x-offset.
    */
    get shadowOffsetX() {
        return this.i.bt;
    }
    set shadowOffsetX(v) {
        this.i.bt = +v;
    }
    /**
     * Gets the actual drop shadow x-offset applied to the series.
    */
    get actualShadowOffsetX() {
        return this.i.ba;
    }
    set actualShadowOffsetX(v) {
        this.i.ba = +v;
    }
    /**
     * Gets or sets the drop shadow y-offset.
    */
    get shadowOffsetY() {
        return this.i.bu;
    }
    set shadowOffsetY(v) {
        this.i.bu = +v;
    }
    /**
     * Gets the actual drop shadow y-offset applied to the series.
    */
    get actualShadowOffsetY() {
        return this.i.bb;
    }
    set actualShadowOffsetY(v) {
        this.i.bb = +v;
    }
    /**
     * Gets or sets the LegendItemBadgeTemplate property.
     * The legend item badge is created according to the LegendItemBadgeTemplate on-demand by
     * the series object itself.
    */
    get legendItemBadgeTemplate() {
        return this.i.gn;
    }
    set legendItemBadgeTemplate(v) {
        this.i.gn = v;
    }
    /**
     * Gets the actual legend item badge template used by the series.
    */
    get actualLegendItemBadgeTemplate() {
        return this.i.gk;
    }
    set actualLegendItemBadgeTemplate(v) {
        this.i.gk = v;
    }
    /**
     * Gets or sets the LegendItemTemplate property.
     * The legend item control content is created according to the LegendItemTemplate on-demand by
     * the series object itself.
    */
    get legendItemTemplate() {
        return this.i.go;
    }
    set legendItemTemplate(v) {
        this.i.go = v;
    }
    /**
     * Gets the actual legend item template used by the series.
    */
    get actualLegendItemTemplate() {
        return this.i.gl;
    }
    set actualLegendItemTemplate(v) {
        this.i.gl = v;
    }
    /**
     * Gets or sets the legend item visibility for the current series object.
    */
    get legendItemVisibility() {
        return this.i.kh;
    }
    set legendItemVisibility(v) {
        this.i.kh = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets the actual visibility of the legend items in the series.
    */
    get actualLegendItemVisibility() {
        return this.i.kf;
    }
    set actualLegendItemVisibility(v) {
        this.i.kf = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets or sets the type of legend badge representing the current series in a legend.
     * This property will be ignored when the LegendItemTemplate or LegendItemBadgeTemplate property is set on the series
    */
    get legendItemBadgeShape() {
        return this.i.r;
    }
    set legendItemBadgeShape(v) {
        this.i.r = ensureEnum(LegendItemBadgeShape_$type, v);
    }
    /**
     * Gets or sets the mode of legend badge representing the current series in a legend.
     * This property will be ignored when the LegendItemTemplate or LegendItemBadgeTemplate property is set on the series
    */
    get legendItemBadgeMode() {
        return this.i.p;
    }
    set legendItemBadgeMode(v) {
        this.i.p = ensureEnum(LegendItemBadgeMode_$type, v);
    }
    /**
     * Gets the actual LegendItemBadgeShape of the series.
    */
    get actualLegendItemBadgeShape() {
        return this.i.q;
    }
    set actualLegendItemBadgeShape(v) {
        this.i.q = ensureEnum(LegendItemBadgeShape_$type, v);
    }
    /**
     * Gets the actual LegendItemBadgeMode of the series.
    */
    get actualLegendItemBadgeMode() {
        return this.i.o;
    }
    set actualLegendItemBadgeMode(v) {
        this.i.o = ensureEnum(LegendItemBadgeMode_$type, v);
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker interiors are painted.
    */
    get markerBrush() {
        return brushToString(this.i.jl);
    }
    set markerBrush(v) {
        this.i.jl = stringToBrush(v);
    }
    /**
     * Gets the actual marker brush of the series.
    */
    get actualMarkerBrush() {
        return brushToString(this.i.jg);
    }
    set actualMarkerBrush(v) {
        this.i.jg = stringToBrush(v);
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker outlines are painted.
    */
    get markerOutline() {
        return brushToString(this.i.jm);
    }
    set markerOutline(v) {
        this.i.jm = stringToBrush(v);
    }
    /**
     * Gets the actual marker outline of the series.
    */
    get actualMarkerOutline() {
        return brushToString(this.i.jh);
    }
    set actualMarkerOutline(v) {
        this.i.jh = stringToBrush(v);
    }
    /**
     * Gets or sets the MarkerTemplate for the current series object.
    */
    get markerTemplate() {
        return this.i.gp;
    }
    set markerTemplate(v) {
        this.i.gp = v;
    }
    /**
     * Gets the actual marker template used by the series.
    */
    get actualMarkerTemplate() {
        return this.i.gm;
    }
    set actualMarkerTemplate(v) {
        this.i.gm = v;
    }
    /**
     * Gets or sets the marker type for the current series object.
     * If the MarkerTemplate property is set, the setting of the MarkerType property will be ignored.
    */
    get markerType() {
        return this.i.t;
    }
    set markerType(v) {
        this.i.t = ensureEnum(MarkerType_$type, v);
    }
    /**
     * Gets the actual marker type set used in the series.
    */
    get actualMarkerType() {
        return this.i.s;
    }
    set actualMarkerType(v) {
        this.i.s = ensureEnum(MarkerType_$type, v);
    }
    /**
     * Gets or sets the Name of the stacked fragment.
    */
    get name() {
        return this.i.d8;
    }
    set name(v) {
        this.i.d8 = v;
    }
    /**
     * Gets or sets the Opacity of the stacked fragment.
    */
    get opacity() {
        return this.i.bp;
    }
    set opacity(v) {
        this.i.bp = +v;
    }
    /**
     * Gets the series opacity.
    */
    get actualOpacity() {
        return this.i.a6;
    }
    set actualOpacity(v) {
        this.i.a6 = +v;
    }
    /**
     * Gets or sets the brush to use for the outline of the series.
     * Some series types, such as LineSeries, do not display outlines.  Therefore, this property does not affect some charts.
    */
    get outline() {
        return brushToString(this.i.jo);
    }
    set outline(v) {
        this.i.jo = stringToBrush(v);
    }
    /**
     * Gets the series outline.
    */
    get actualOutline() {
        return brushToString(this.i.jj);
    }
    set actualOutline(v) {
        this.i.jj = stringToBrush(v);
    }
    /**
     * Gets or sets the AreaFillOpacity of the stacked fragment. This property only applies for area-like series.
    */
    get areaFillOpacity() {
        return this.i.bd;
    }
    set areaFillOpacity(v) {
        this.i.bd = +v;
    }
    /**
     * Gets the series ActualAreaFillOpacity.  This property only applies for area-like series.
    */
    get actualAreaFillOpacity() {
        return this.i.a2;
    }
    set actualAreaFillOpacity(v) {
        this.i.a2 = +v;
    }
    /**
     * Gets or sets the opacity to use for the marker fills.
    */
    get markerFillOpacity() {
        return this.i.bn;
    }
    set markerFillOpacity(v) {
        this.i.bn = +v;
    }
    /**
     * Gets the actual opacity to use for hte marker fills.
    */
    get actualMarkerFillOpacity() {
        return this.i.a4;
    }
    set actualMarkerFillOpacity(v) {
        this.i.a4 = +v;
    }
    /**
     * Gets or sets the outline mode to use for the fragment.
    */
    get outlineMode() {
        return this.i.w;
    }
    set outlineMode(v) {
        this.i.w = ensureEnum(SeriesOutlineMode_$type, v);
    }
    /**
     * Gets the actual outline mode to use for the fragment.
    */
    get actualOutlineMode() {
        return this.i.v;
    }
    set actualOutlineMode(v) {
        this.i.v = ensureEnum(SeriesOutlineMode_$type, v);
    }
    /**
     * Gets or sets the target opacity to fade to for fade style highlighting.
    */
    get highlightingFadeOpacity() {
        return this.i.bm;
    }
    set highlightingFadeOpacity(v) {
        this.i.bm = +v;
    }
    /**
     * Gets the actual target opacity to fade to for fade style highlighting.
    */
    get actualHighlightingFadeOpacity() {
        return this.i.a3;
    }
    set actualHighlightingFadeOpacity(v) {
        this.i.a3 = +v;
    }
    /**
     * Gets or sets the x-radius of the ellipse that is used to round the corners of the column. This only applies to Bar and Column series.
    */
    get radiusX() {
        return this.i.bq;
    }
    set radiusX(v) {
        this.i.bq = +v;
    }
    /**
     * Gets the actual corner radius of the series
    */
    get actualRadiusX() {
        return this.i.a7;
    }
    set actualRadiusX(v) {
        this.i.a7 = +v;
    }
    /**
     * Gets whether the spline part is considered to be part of the range
    */
    get actualIsSplineShapePartOfRange() {
        return this.i.ak;
    }
    set actualIsSplineShapePartOfRange(v) {
        this.i.ak = ensureBool(v);
    }
    /**
     * Gets or sets whether to include the spline shape in the axis range requested of the axis.
    */
    get isSplineShapePartOfRange() {
        return this.i.ar;
    }
    set isSplineShapePartOfRange(v) {
        this.i.ar = ensureBool(v);
    }
    /**
     * Gets or sets the y-radius of the ellipse that is used to round the corners of the column. This only applies to Bar and Column series.
    */
    get radiusY() {
        return this.i.br;
    }
    set radiusY(v) {
        this.i.br = +v;
    }
    /**
     * Gets the actual corner radius of the series
    */
    get actualRadiusY() {
        return this.i.a8;
    }
    set actualRadiusY(v) {
        this.i.a8 = +v;
    }
    /**
     * Gets or sets the width of the current series object's line thickness.
    */
    get thickness() {
        return this.i.bv;
    }
    set thickness(v) {
        this.i.bv = +v;
    }
    /**
     * Gets or sets the thickness of this stacked fragment.
    */
    get actualThickness() {
        return this.i.bc;
    }
    set actualThickness(v) {
        this.i.bc = +v;
    }
    /**
     * Gets or sets the width of the current series object's marker thickness.
    */
    get markerThickness() {
        return this.i.bo;
    }
    set markerThickness(v) {
        this.i.bo = +v;
    }
    /**
     * Gets actual marker thickness of this stacked fragment.
    */
    get actualMarkerThickness() {
        return this.i.a5;
    }
    set actualMarkerThickness(v) {
        this.i.a5 = +v;
    }
    /**
     * Gets or sets the Title property.
     * The legend item control is created according to the Title on-demand by
     * the series object itself.
    */
    get title() {
        return this.i.ca;
    }
    set title(v) {
        this.i.ca = v;
    }
    /**
     * Gets or sets the EasingFunction used to morph the current series.
    */
    get transitionEasingFunction() {
        return this.i.ad;
    }
    set transitionEasingFunction(v) {
        this.i.ad = v;
    }
    /**
     * Gets or sets the duration of the current series's morph.
    */
    get transitionDuration() {
        return this.i.b4;
    }
    set transitionDuration(v) {
        this.i.b4 = +v;
    }
    /**
     * Gets or sets the duration of the current series's transition in morph.
    */
    get transitionInDuration() {
        return this.i.b5;
    }
    set transitionInDuration(v) {
        this.i.b5 = +v;
    }
    /**
     * Gets or sets the EasingFunction used to morph the current series during the initial transition.
    */
    get transitionInEasingFunction() {
        return this.i.ae;
    }
    set transitionInEasingFunction(v) {
        this.i.ae = v;
    }
    /**
     * Gets or sets the method by which to animate the data into the chart when the chart data source is swapped.
     * Note: Transitions are not currently supported for stacked series.
    */
    get transitionInMode() {
        return this.i.n;
    }
    set transitionInMode(v) {
        this.i.n = ensureEnum(CategoryTransitionInMode_$type, v);
    }
    /**
     * Gets or sets whether the series should transition into the plot area when a new data source is assigned.
     * Note: Transitions are not currently supported for stacked series.
    */
    get isTransitionInEnabled() {
        return this.i.as;
    }
    set isTransitionInEnabled(v) {
        this.i.as = ensureBool(v);
    }
    /**
     * Gets or sets the duration of the current series's transition in morph.
    */
    get transitionInSpeedType() {
        return this.i.z;
    }
    set transitionInSpeedType(v) {
        this.i.z = ensureEnum(TransitionInSpeedType_$type, v);
    }
    /**
     * Gets the the resolved value of whether transition in is enabled.
    */
    get actualIsTransitionInEnabled() {
        return this.i.al;
    }
    set actualIsTransitionInEnabled(v) {
        this.i.al = ensureBool(v);
    }
    /**
     * Gets the resolved transition in duration
    */
    get actualTransitionInDuration() {
        return this.i.by;
    }
    set actualTransitionInDuration(v) {
        this.i.by = +v;
    }
    /**
     * Gets the series transition easing function.
    */
    get actualTransitionInMode() {
        return this.i.m;
    }
    set actualTransitionInMode(v) {
        this.i.m = ensureEnum(CategoryTransitionInMode_$type, v);
    }
    /**
     * Gets the series transition easing function.
    */
    get actualTransitionInSpeedType() {
        return this.i.y;
    }
    set actualTransitionInSpeedType(v) {
        this.i.y = ensureEnum(TransitionInSpeedType_$type, v);
    }
    /**
     * Gets the series transition easing function.
    */
    get actualTransitionInEasingFunction() {
        return this.i.ac;
    }
    set actualTransitionInEasingFunction(v) {
        this.i.ac = v;
    }
    /**
     * Gets the series transition easing function.
    */
    get actualTransitionEasingFunction() {
        return this.i.ab;
    }
    set actualTransitionEasingFunction(v) {
        this.i.ab = v;
    }
    /**
     * Gets the series transition duration.
    */
    get actualTransitionDuration() {
        return this.i.bx;
    }
    set actualTransitionDuration(v) {
        this.i.bx = +v;
    }
    /**
     * Gets or sets the value mapping property for the current series object.
    */
    get valueMemberPath() {
        return this.i.e1;
    }
    set valueMemberPath(v) {
        this.i.e1 = v;
    }
    /**
     * Gets or sets the label displayed before series value in the Data Legend.
    */
    get valueMemberAsLegendLabel() {
        return this.i.ex;
    }
    set valueMemberAsLegendLabel(v) {
        this.i.ex = v;
    }
    /**
     * Gets or sets the unit displayed after series value in the Data Legend.
    */
    get valueMemberAsLegendUnit() {
        return this.i.ez;
    }
    set valueMemberAsLegendUnit(v) {
        this.i.ez = v;
    }
    /**
     * Gets or sets the Visibility of the stacked fragment.
    */
    get visibility() {
        return this.i.ki;
    }
    set visibility(v) {
        this.i.ki = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets the actual visibility of the stacked fragment.
    */
    get actualVisibility() {
        return this.i.kg;
    }
    set actualVisibility(v) {
        this.i.kg = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets the resolved brush used between the local series and the parent series.
    */
    get parentOrLocalBrush() {
        return brushToString(this.i.jp);
    }
    set parentOrLocalBrush(v) {
        this.i.jp = stringToBrush(v);
    }
    findByName(name) {
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("StackedFragmentSeries");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    /**
 * Gets the item index associated with the specified world position

*/
    getItemIndex(world) {
        let iv = this.i.bz(toPoint(world));
        return (iv);
    }
    /**
     * Gets the item that is the best match for the specified world coordinates.
    
    * @param world  * The world coordinates to use.
    */
    getItem(world) {
        let iv = this.i.b8(toPoint(world));
        return (iv);
    }
    getPreviousOrExactIndex(world, skipUnknowns) {
        let iv = this.i.b2(toPoint(world), skipUnknowns);
        return (iv);
    }
    getNextOrExactIndex(world, skipUnknowns) {
        let iv = this.i.b1(toPoint(world), skipUnknowns);
        return (iv);
    }
    getSeriesValue(world, useInterpolation, skipUnknowns) {
        let iv = this.i.bk(toPoint(world), useInterpolation, skipUnknowns);
        return (iv);
    }
    getSeriesValuePosition(world, useInterpolation, skipUnknowns) {
        let iv = this.i.j5(toPoint(world), useInterpolation, skipUnknowns);
        return fromPoint(iv);
    }
    /**
     * If possible, will return the best available value bounding box within the series that has the best value match for the world position provided.
    
    * @param world  * The world coordinate for which to get a value bounding box for
    */
    getSeriesValueBoundingBox(world) {
        let iv = this.i.j9(toPoint(world));
        return fromRect(iv);
    }
    /**
     * If possible, will return the best available value marker bounding box within the series that has the best value match for the world position provided.
    
    * @param world  * The world coordinates for which to get a value marker bounding box for
    */
    getSeriesValueMarkerBoundingBox(world) {
        let iv = this.i.kb(toPoint(world));
        return fromRect(iv);
    }
    getSeriesHighValue(world, useInterpolation, skipUnknowns) {
        let iv = this.i.bg(toPoint(world), useInterpolation, skipUnknowns);
        return (iv);
    }
    getSeriesHighValuePosition(world, useInterpolation, skipUnknowns) {
        let iv = this.i.j1(toPoint(world), useInterpolation, skipUnknowns);
        return fromPoint(iv);
    }
    getSeriesLowValue(world, useInterpolation, skipUnknowns) {
        let iv = this.i.bi(toPoint(world), useInterpolation, skipUnknowns);
        return (iv);
    }
    getSeriesLowValuePosition(world, useInterpolation, skipUnknowns) {
        let iv = this.i.j3(toPoint(world), useInterpolation, skipUnknowns);
        return fromPoint(iv);
    }
    getSeriesValuePositionFromSeriesPixel(mouse, useInterpolation, skipUnknowns) {
        let iv = this.i.j6(toPoint(mouse), useInterpolation, skipUnknowns);
        return fromPoint(iv);
    }
    getSeriesValueFromSeriesPixel(mouse, useInterpolation, skipUnknowns) {
        let iv = this.i.bl(toPoint(mouse), useInterpolation, skipUnknowns);
        return (iv);
    }
    /**
     * For a category plotted series, returns the current width of the items within the categories. This only returns a value if the items have some form of width (e.g. columns, bars, etc.) otherwise 0 is returned.
    
    */
    getItemSpan() {
        let iv = this.i.bf();
        return (iv);
    }
    /**
     * Converts a point from coordinates within the series plot area to a world position within axis space.
    
    * @param seriesPoint  * The pixel location within the plot area of the series.
    */
    toWorldPosition(seriesPoint) {
        let iv = this.i.j7(toPoint(seriesPoint));
        return fromPoint(iv);
    }
    /**
     * Converts a point from world coordinates to coordinates within the viewport of the series.
    
    * @param world  * The world position from which to convert.
    */
    fromWorldPosition(world) {
        let iv = this.i.j0(toPoint(world));
        return fromPoint(iv);
    }
    /**
     * Requests that the provided item should be brought into view if possible.
    
    * @param item  * The item to attempt to bring into view.
    */
    scrollIntoView(item) {
        let iv = this.i.au(item);
        return (iv);
    }
    /**
     * Gets the effective viewport, adjusted to account for margins and other factors.
    
    */
    getEffectiveViewport() {
        let iv = this.i.j8();
        return fromRect(iv);
    }
    /**
     * Notifies the series that a visual property has changed, requiring a visual update.
    
    */
    notifyVisualPropertiesChanged() {
        this.i.e5();
    }
    /**
     * Simulates a pointer hover over the series surface.
    
    * @param point  * The pointer position relative to the series viewport over which to hover.
    */
    simulateHover(point) {
        this.i.fa(toPoint(point));
    }
    /**
     * Moves the cursor point to the provided world position. Some series may react to the current cursor position.
    
    * @param point  * The cursor point, in world coordinates.
    */
    moveCursorPoint(point) {
        this.i.e4(toPoint(point));
    }
    replayTransitionIn() {
        this.i.e9();
    }
    /**
     * Event raised when a property (including "effective" and non-dependency property) value changes.
    */
    get propertyUpdated() {
        return this._propertyUpdated;
    }
    set propertyUpdated(ev) {
        if (this._propertyUpdated_wrapped !== null) {
            this.i.propertyUpdated = delegateRemove(this.i.propertyUpdated, this._propertyUpdated_wrapped);
            this._propertyUpdated_wrapped = null;
            this._propertyUpdated = null;
        }
        this._propertyUpdated = ev;
        this._propertyUpdated_wrapped = (o, e) => {
            let outerArgs = new IgrPropertyUpdatedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforePropertyUpdated) {
                this.beforePropertyUpdated(this, outerArgs);
            }
            if (this._propertyUpdated) {
                this._propertyUpdated(this, outerArgs);
            }
        };
        this.i.propertyUpdated = delegateCombine(this.i.propertyUpdated, this._propertyUpdated_wrapped);
        ;
    }
}
