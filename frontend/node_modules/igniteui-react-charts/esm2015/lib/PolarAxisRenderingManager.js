/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, typeCast, markType } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { ArcSegment } from "igniteui-react-core";
import { ViewportUtils } from "./ViewportUtils";
import { Size } from "igniteui-react-core";
import { PathGeometry } from "igniteui-react-core";
import { LineSegment } from "igniteui-react-core";
import { LineGeometry } from "igniteui-react-core";
import { RangeInfo } from "./RangeInfo";
import { PolarAxisRenderingParameters } from "./PolarAxisRenderingParameters";
import { RadialAxisRenderingParameters } from "./RadialAxisRenderingParameters";
/**
 * @hidden
 */
export let PolarAxisRenderingManager = /*@__PURE__*/ (() => {
    class PolarAxisRenderingManager extends Base {
        p(a, b, c, d, e, f) {
            let g = ViewportUtils.d(a, e, f);
            let h = ViewportUtils.g(a, e, f);
            let i = ViewportUtils.c(b.x, e, f);
            let j = ViewportUtils.f(b.y, e, f);
            if (d - c < Math.PI && d - c > 0) {
                let k = { $type: Point_$type, x: ViewportUtils.c(b.x + a * Math.cos(c), e, f), y: ViewportUtils.f(b.y + a * Math.sin(c), e, f) };
                let l = { $type: Point_$type, x: ViewportUtils.c(b.x + a * Math.cos(d), e, f), y: ViewportUtils.f(b.y + a * Math.sin(d), e, f) };
                let m = new PathFigure();
                m._startPoint = k;
                m._isClosed = false;
                m._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.b = false;
                    $ret.e = l;
                    $ret.f = new Size(1, g, h);
                    $ret.d = 1;
                    return $ret;
                })()));
                return m;
            }
            else {
                let n = new PathFigure();
                n._startPoint = { $type: Point_$type, x: i, y: j - h };
                n._isClosed = true;
                n._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.b = false;
                    $ret.e = { $type: Point_$type, x: i, y: j + h };
                    $ret.f = new Size(1, g, h);
                    $ret.d = 1;
                    return $ret;
                })()));
                n._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.b = false;
                    $ret.e = { $type: Point_$type, x: i, y: j - h };
                    $ret.f = new Size(1, g, h);
                    $ret.d = 1;
                    return $ret;
                })()));
                return n;
            }
        }
        j(a, b, c, d, e, f, g, h) {
            let i = Math.min(b, c);
            let j = Math.max(b, c);
            let k = new PathGeometry();
            let l = null;
            let m = null;
            let n = null;
            let o = null;
            if (i > 0) {
                l = this.p(i, f, g, h, e, d);
                if (h - g < Math.PI && h - g > 0) {
                    let p = typeCast(ArcSegment.$, l._segments._inner[0]);
                    if (p != null) {
                        let q = { $type: Point_$type, x: ViewportUtils.c(f.x + j * Math.cos(h), e, d), y: ViewportUtils.f(f.y + j * Math.sin(h), e, d) };
                        m = ((() => {
                            let $ret = new LineSegment(1);
                            $ret.c = q;
                            return $ret;
                        })());
                    }
                }
            }
            if (j > 0) {
                n = this.p(j, f, g, h, e, d);
            }
            if (i > 0) {
                if (h - g < Math.PI && h - g > 0) {
                    let r = n._startPoint;
                    let s = typeCast(ArcSegment.$, n._segments._inner[0]);
                    if (s != null) {
                        n._startPoint = s.e;
                        s.e = r;
                        s.d = 0;
                        let t = { $type: Point_$type, x: ViewportUtils.c(f.x + i * Math.cos(g), e, d), y: ViewportUtils.f(f.y + i * Math.sin(g), e, d) };
                        o = ((() => {
                            let $ret = new LineSegment(1);
                            $ret.c = t;
                            return $ret;
                        })());
                    }
                }
            }
            if (m != null && o != null) {
                l._segments.add(m);
                let u = n._segments._inner[0];
                n._segments.remove(u);
                l._segments.add(u);
                l._segments.add(o);
                l._isClosed = true;
                k.c.add(l);
            }
            else {
                if (l != null) {
                    k.c.add(l);
                    this.o(n);
                }
                if (n != null) {
                    k.c.add(n);
                }
            }
            a.add(k);
        }
        o(a) {
            if (a._segments.count > 1) {
                let b = typeCast(ArcSegment.$, a._segments._inner[0]);
                let c = typeCast(ArcSegment.$, a._segments._inner[1]);
                a._segments._inner[0] = c;
                a._segments._inner[1] = b;
                let d = c.e;
                let e = a._startPoint;
                let f = b.e;
                a._startPoint = d;
                c.e = f;
                b.e = e;
                b.d = 0;
                c.d = 0;
            }
            else {
                let g = a._startPoint;
                let h = typeCast(ArcSegment.$, a._segments._inner[0]);
                if (h != null) {
                    a._startPoint = h.e;
                    h.e = g;
                    h.d = 0;
                }
            }
        }
        i(a, b, c, d, e, f, g) {
            if (b > 0) {
                let h = new PathGeometry();
                h.c.add(this.p(b, e, f, g, d, c));
                a.add(h);
            }
        }
        n(a, b, c, d, e, f, g, h) {
            let i = Math.min(b, c);
            let j = Math.max(b, c);
            let k = false;
            if (j - i > Math.PI) {
                k = true;
            }
            let l = Math.cos(i);
            let m = Math.sin(i);
            let n = h.x + l * f;
            let o = h.y + m * f;
            let p = h.x + l * g;
            let q = h.y + m * g;
            let r = Math.cos(j);
            let s = Math.sin(j);
            let t = h.x + r * f;
            let u = h.y + s * f;
            let v = h.x + r * g;
            let w = h.y + s * g;
            n = ViewportUtils.c(n, e, d);
            o = ViewportUtils.f(o, e, d);
            p = ViewportUtils.c(p, e, d);
            q = ViewportUtils.f(q, e, d);
            t = ViewportUtils.c(t, e, d);
            u = ViewportUtils.f(u, e, d);
            v = ViewportUtils.c(v, e, d);
            w = ViewportUtils.f(w, e, d);
            let x = new PathFigure();
            x._startPoint = { $type: Point_$type, x: n, y: o };
            x._isClosed = true;
            x._segments.add(((() => {
                let $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: p, y: q };
                return $ret;
            })()));
            x._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: v, y: w };
                $ret.f = new Size(1, ViewportUtils.d(g, e, d), ViewportUtils.g(g, e, d));
                $ret.d = 1;
                $ret.b = k;
                return $ret;
            })()));
            x._segments.add(((() => {
                let $ret = new LineSegment(1);
                $ret.c = { $type: Point_$type, x: t, y: u };
                return $ret;
            })()));
            x._segments.add(((() => {
                let $ret = new ArcSegment();
                $ret.e = { $type: Point_$type, x: n, y: o };
                $ret.f = new Size(1, ViewportUtils.d(f, e, d), ViewportUtils.g(f, e, d));
                $ret.d = 0;
                $ret.b = k;
                return $ret;
            })()));
            let y = new PathGeometry();
            y.c.add(x);
            a.add(y);
        }
        m(a, b, c, d, e, f, g) {
            let h = new LineGeometry();
            let i = Math.cos(b);
            let j = Math.sin(b);
            let k = g.x + i * e;
            let l = g.y + j * e;
            let m = g.x + i * f;
            let n = g.y + j * f;
            k = ViewportUtils.c(k, d, c);
            l = ViewportUtils.f(l, d, c);
            m = ViewportUtils.c(m, d, c);
            n = ViewportUtils.f(n, d, c);
            h.d = { $type: Point_$type, x: k, y: l };
            h.c = { $type: Point_$type, x: m, y: n };
            a.add(h);
        }
        a(a, b) {
            return a.x >= b.left && a.x <= b.right;
        }
        b(a, b) {
            return a.y >= b.top && a.y <= b.bottom;
        }
        c(a, b) {
            let c = Math.sqrt(Math.pow(a.x - b.left, 2) + Math.pow(a.y - b.top, 2));
            let d = Math.sqrt(Math.pow(a.x - b.right, 2) + Math.pow(a.y - b.top, 2));
            let e = Math.sqrt(Math.pow(a.x - b.right, 2) + Math.pow(a.y - b.bottom, 2));
            let f = Math.sqrt(Math.pow(a.x - b.left, 2) + Math.pow(a.y - b.bottom, 2));
            return Math.min(c, Math.min(d, Math.min(e, f)));
        }
        d(a, b) {
            let c = Math.sqrt(Math.pow(a.x - b.left, 2) + Math.pow(a.y - b.top, 2));
            let d = Math.sqrt(Math.pow(a.x - b.right, 2) + Math.pow(a.y - b.top, 2));
            let e = Math.sqrt(Math.pow(a.x - b.right, 2) + Math.pow(a.y - b.bottom, 2));
            let f = Math.sqrt(Math.pow(a.x - b.left, 2) + Math.pow(a.y - b.bottom, 2));
            return Math.max(c, Math.max(d, Math.max(e, f)));
        }
        f(a) {
            let b = { $type: Point_$type, x: 0.5, y: 0.5 };
            if (this.a(b, a) && this.b(b, a)) {
                return 0;
            }
            if (this.a(b, a)) {
                if (b.y < a.top) {
                    return a.top - b.y;
                }
                else {
                    return b.y - a.bottom;
                }
            }
            if (this.b(b, a)) {
                if (b.x < a.left) {
                    return a.left - b.x;
                }
                else {
                    return b.x - a.right;
                }
            }
            return this.c(b, a);
        }
        g(a) {
            let b = { $type: Point_$type, x: 0.5, y: 0.5 };
            return this.d(b, a);
        }
        e(a, b) {
            let c = Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));
            let d = Math.acos((b.x - a.x) / c);
            if ((b.y - a.y) < 0) {
                d = (2 * Math.PI) - d;
            }
            return d;
        }
        h(a, b) {
            return ((a.y - 0.5) * b.x) + ((0.5 - a.x) * b.y) + ((a.x * 0.5) - (0.5 * a.y));
        }
        l(a, b, c) {
            let d = { $type: Point_$type, x: 0.5, y: 0.5 };
            if (this.a(d, a) && this.b(d, a)) {
                b = 0;
                c = Math.PI * 2;
                return {
                    p1: b,
                    p2: c
                };
            }
            let e = this.e(d, { $type: Point_$type, x: a.left, y: a.top });
            let f = this.e(d, { $type: Point_$type, x: a.right, y: a.top });
            let g = this.e(d, { $type: Point_$type, x: a.right, y: a.bottom });
            let h = this.e(d, { $type: Point_$type, x: a.left, y: a.bottom });
            if (this.b(d, a) && a.left > d.x) {
                b = e;
                c = 2 * Math.PI + h;
                return {
                    p1: b,
                    p2: c
                };
            }
            b = Math.min(e, Math.min(f, Math.min(g, h)));
            c = Math.max(e, Math.max(f, Math.max(g, h)));
            return {
                p1: b,
                p2: c
            };
        }
        k(a, b, c, d, e, f, g) {
            let h;
            let i;
            let j = this.l(a, h, i);
            h = j.p1;
            i = j.p2;
            let k = Math.min(h, i);
            let l = Math.max(h, i);
            if (typeCast(PolarAxisRenderingParameters.$, b) !== null) {
                b.minAngle = k;
                b.maxAngle = l;
            }
            else if (typeCast(RadialAxisRenderingParameters.$, b) !== null) {
                b.minAngle = k;
                b.maxAngle = l;
            }
            if (h == 0 && i == Math.PI * 2) {
                let m = c;
                let n = d;
                let o = Math.min(m, n);
                let p = Math.max(m, n);
                b.k.add(((() => {
                    let $ret = new RangeInfo();
                    $ret.d = o;
                    $ret.c = p;
                    $ret.b = g;
                    return $ret;
                })()));
                return;
            }
            else {
                if (i > Math.PI * 2) {
                    i = i - Math.PI * 2;
                }
                let q = f(h);
                let r = f(i);
                if (q < c || q > d) {
                    q = f(h + Math.PI * 2);
                }
                if (r < c || r > d) {
                    r = f(i + Math.PI * 2);
                }
                let s = Math.min(q, r);
                let t = Math.max(q, r);
                if ((!e && q > r) || (e && q < r)) {
                    let u = (d - t);
                    let v = (s - c);
                    b.k.add(((() => {
                        let $ret = new RangeInfo();
                        $ret.d = t;
                        $ret.c = d;
                        $ret.b = (u / (u + v)) * g;
                        return $ret;
                    })()));
                    b.k.add(((() => {
                        let $ret = new RangeInfo();
                        $ret.d = c;
                        $ret.c = s;
                        $ret.b = (v / (u + v)) * g;
                        return $ret;
                    })()));
                }
                else {
                    b.k.add(((() => {
                        let $ret = new RangeInfo();
                        $ret.d = s;
                        $ret.c = t;
                        $ret.b = g;
                        return $ret;
                    })()));
                }
            }
        }
    }
    PolarAxisRenderingManager.$t = /*@__PURE__*/ markType(PolarAxisRenderingManager, 'PolarAxisRenderingManager');
    return PolarAxisRenderingManager;
})();
