/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { ScatterBase } from "./ScatterBase";
import { UnknownValuePlotting_$type } from "igniteui-react-core";
import { DependencyProperty } from "igniteui-react-core";
import { Point_$type, typeCast, runOn, Number_$type, enumGetBox, markType, markDep } from "igniteui-react-core";
import { OwnedPoint } from "./OwnedPoint";
import { ScatterFrame } from "./ScatterFrame";
import { ScatterLineSeriesView } from "./ScatterLineSeriesView";
import { Defaults } from "./Defaults";
import { PathGeometry } from "igniteui-react-core";
import { Rect } from "igniteui-react-core";
import { ScalerParams } from "./ScalerParams";
import { Clipper } from "igniteui-react-core";
import { List$1 } from "igniteui-react-core";
import { RectUtil } from "igniteui-react-core";
import { PolyLineSegment } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { PathFigureCollection } from "igniteui-react-core";
import { Flattener } from "igniteui-react-core";
import { PropertyMetadata } from "igniteui-react-core";
import { boxArray$1, arrayShallowClone } from "igniteui-react-core";
import { isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let ScatterLineSeries = /*@__PURE__*/ (() => {
    class ScatterLineSeries extends ScatterBase {
        constructor() {
            super();
            this.ab = ScatterLineSeries.$;
            this.r7 = new ScatterFrame();
            this.r9 = new ScatterFrame();
            this.r5 = new ScatterFrame();
            let a = (b, c, d) => {
                let e = this.ck.indexOf(b.a);
                if (e == -1 || e == 0) {
                    return b;
                }
                let f = this.ck.item(e - 1);
                let g;
                if (!((() => { let h = c.g.tryGetValue(f, g); g = h.p1; return h.ret; })())) {
                    return b;
                }
                return g;
            };
            this.r7.o = a;
            this.r9.o = a;
            this.r5.o = a;
        }
        get_d2() {
            return true;
        }
        bx() {
            return new ScatterLineSeriesView(this);
        }
        gw() {
            if (!isNaN_(this.gv)) {
                return super.gw();
            }
            return Defaults.x;
        }
        ex(a, b) {
            if (this.qk(a, b)) {
                return true;
            }
            if (this.u7(a, b)) {
                return true;
            }
            return false;
        }
        u7(a, b) {
            let c = this.b0;
            let d = c.dg;
            return this.ey(a, b, d.ak);
        }
        t1(a, b) {
            super.t1(a, b);
            a.m.clear();
            a.u.clear();
            let c = b.bv;
            let d = b.bu;
            let e = this.getEffectiveViewport1(b);
            let f = this.fv * this.fv;
            let g = 0;
            if (this.sh != null) {
                g = this.sh.count;
            }
            if (this.si != null) {
                g = Math.min(this.si.count, g);
            }
            let h = new ScalerParams(0, c, d, this.r1.d, e);
            let i = ((() => {
                let $ret = new ScalerParams(0, c, d, this.r1.e, e);
                $ret.b = this.ge();
                return $ret;
            })());
            let j = arrayShallowClone(this.sh.asArray());
            let k = arrayShallowClone(this.si.asArray());
            this.xAxis.hm(boxArray$1(j), 0, j.length, h);
            this.yAxis.hm(boxArray$1(k), 0, k.length, i);
            let l = d.top - 10;
            let m = d.bottom + 10;
            let n = d.left - 10;
            let o = d.right + 10;
            let p = ((() => {
                let $ret = new Clipper(1, n, m, o, l, false);
                $ret.i = a.m;
                return $ret;
            })());
            for (let q = 0; q < g;) {
                let r = q;
                ++q;
                if (g > this.s2) {
                    while (q < g) {
                        let s = j[q] - j[r];
                        let t = k[q] - k[r];
                        let u = s * s + t * t;
                        if (u >= f) {
                            break;
                        }
                        ++q;
                    }
                    p.j(this.ve(j, k, r, q - 1));
                }
                else {
                    let v = new OwnedPoint();
                    v.c = { $type: Point_$type, x: j[r], y: k[r] };
                    v.a = this.ck.item(r);
                    if (!a.u.containsKey(v.a)) {
                        a.u.addItem(v.a, v);
                    }
                }
            }
            if (g > this.s2) {
                p.i = null;
            }
        }
        ve(a, b, c, d) {
            if (c == d) {
                return { $type: Point_$type, x: a[c], y: b[c] };
            }
            let e = 0;
            let f = 0;
            let g = (d - c + 1);
            for (let h = c; h <= d; ++h) {
                e += a[h];
                f += b[h];
            }
            return { $type: Point_$type, x: e / g, y: f / g };
        }
        get_sp() {
            return true;
        }
        uc(a, b) {
            b.c4(false);
            super.uc(a, b);
            let c = this.getEffectiveViewport1(b);
            let d = new Rect(0, b.bu.left, b.bu.top, b.bu.width, b.bu.height);
            d = RectUtil.t(d, this.fw, this.fw);
            this.t5(a, new Clipper(0, d, false));
            let e = typeCast(ScatterLineSeriesView.$, b);
            this.se.ax(this, this.su(), runOn(this, this.rp));
            let f = false;
            let g = this.se.b;
            if (g != null) {
                f = true;
            }
            if (f) {
                this.tx(-1, this.sh.count, b.q);
            }
            this.se.ad(e.dg, true, false, true, false);
            this.vc(e.dg, a.m.count, (h) => a.m._inner[h].x, (h) => a.m._inner[h].y, this.u6, this.fv);
        }
        vc(a, b, c, d, e, f) {
            let g = new PathGeometry();
            a.ak = g;
            g.c = new PathFigureCollection();
            let h = new List$1(PolyLineSegment.$, 0);
            let i = 0;
            for (let j = 0; j < b; j++) {
                if (isNaN_(c(j)) || isNaN_(d(j))) {
                    let k = j - i;
                    if (k > 0) {
                        if (e == 1 || h.count == 0) {
                            let l = new PolyLineSegment();
                            h.add(l);
                        }
                        this.vb(h._inner[h.count - 1]._points, i, j - 1, c, d, f);
                    }
                    i = j + 1;
                }
            }
            if (e == 1 || h.count == 0) {
                let m = new PolyLineSegment();
                h.add(m);
            }
            this.vb(h._inner[h.count - 1]._points, i, b - 1, c, d, f);
            for (let n = 0; n < h.count; n++) {
                let o = h._inner[n];
                if (o._points.count > 0) {
                    let p = ((() => {
                        let $ret = new PathFigure();
                        $ret.startPoint = o._points._inner[0];
                        return $ret;
                    })());
                    p._segments.add(o);
                    g.c.add(p);
                }
            }
        }
        u8(a, b, c, d, e, f) {
            let g = new List$1(Number_$type, 0);
            let h = d;
            let i = e;
            let j = i - h + 1;
            while (j > 0) {
                if (j <= 512) {
                    Flattener.c(g, b, c, h, i, f);
                    h = i + 1;
                }
                else {
                    let k = h + 512 - 1;
                    Flattener.c(g, b, c, h, k, f);
                    h = k + 1;
                }
                j = i - h + 1;
            }
            return g;
        }
        vb(a, b, c, d, e, f) {
            if (c > -1) {
                let g = !isNaN_(this.gv) ? f : 1;
                let h = this.u8(new List$1(Number_$type, 0), d, e, b, c, g);
                let i;
                for (let j = 0; j < h.count; j++) {
                    i = h.item(j);
                    a.add({ $type: Point_$type, x: d(i), y: e(i) });
                }
            }
        }
        l7(a, b, c, d) {
            super.l7(a, b, c, d);
            switch (b) {
                case ScatterLineSeries.$$p[0]:
                    this.ml(false);
                    this.ls();
                    break;
            }
        }
    }
    ScatterLineSeries.$t = /*@__PURE__*/ markType(ScatterLineSeries, 'ScatterLineSeries', ScatterBase.$);
    ScatterLineSeries.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, ScatterLineSeries, 'raisePropertyChanged', ['UnknownValuePlotting:u6:vd', [UnknownValuePlotting_$type, /*@__PURE__*/ enumGetBox(UnknownValuePlotting_$type, 1)]]);
    return ScatterLineSeries;
})();
