/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { AxisLabelPanelBase } from "./AxisLabelPanelBase";
import { Boolean_$type, typeCast, markType, Point_$type, typeGetValue, fromEnum, runOn, Number_$type, markDep } from "igniteui-react-core";
import { AxisLabelPanelBaseView } from "./AxisLabelPanelBaseView";
import { Rect } from "igniteui-react-core";
import { Extensions } from "igniteui-react-core";
import { Axis } from "./Axis";
import { List$1 } from "igniteui-react-core";
import { LabelPosition } from "./LabelPosition";
import { XamDataChart } from "./XamDataChart";
import { CategoryAxisBase } from "./CategoryAxisBase";
import { IAngleScaler_$type } from "./IAngleScaler";
import { CategoryAxisRenderer } from "./CategoryAxisRenderer";
import { DependencyProperty } from "igniteui-react-core";
import { PolarAxisRenderingManager } from "./PolarAxisRenderingManager";
import { AxisLabelManager } from "./AxisLabelManager";
import { ViewportUtils } from "./ViewportUtils";
import { RadialAxisRenderingParameters } from "./RadialAxisRenderingParameters";
import { CategoryTickmarkValues } from "./CategoryTickmarkValues";
import { SeriesViewer } from "./SeriesViewer";
import { ScalerParams } from "./ScalerParams";
import { AxisRangeChangedEventArgs } from "./AxisRangeChangedEventArgs";
import { LineGeometry } from "igniteui-react-core";
import { PropertyMetadata } from "igniteui-react-core";
import { RangeInfo } from "./RangeInfo";
import { isNaN_, isInfinity } from "igniteui-react-core";
import { NumericAxisBase } from "./NumericAxisBase";
import { LogarithmicTickmarkValues } from "./LogarithmicTickmarkValues";
import { PolarAxisRenderingParameters } from "./PolarAxisRenderingParameters";
import { MathUtil } from "igniteui-react-core";
import { RadialAxisLabelPanel } from "./RadialAxisLabelPanel";
import { LinearTickmarkValues } from "./LinearTickmarkValues";
import { IPolarRadialRenderingParameters_$type } from "./IPolarRadialRenderingParameters";
import { PathGeometry } from "igniteui-react-core";
import { PathFigure } from "igniteui-react-core";
import { ArcSegment } from "igniteui-react-core";
import { Size } from "igniteui-react-core";
import { CategoryAxisBaseView } from "./CategoryAxisBaseView";
import { AxisDefaults } from "./AxisDefaults";
import { NumericAxisBaseView } from "./NumericAxisBaseView";
/**
 * @hidden
 */
export let AngleAxisLabelPanel = /*@__PURE__*/ (() => {
    class AngleAxisLabelPanel extends AxisLabelPanelBase {
        constructor() {
            super();
            this.da = false;
            this.dg = null;
            this.de = 0;
            this.db = 0;
            this.dd = 0;
            this.dc = 0;
        }
        ae() {
            return new AngleAxisLabelPanelView(this);
        }
        ch(a) {
            super.ch(a);
            this.c9 = a;
        }
        at(a, b) {
            if (!Extensions.b(b)) {
                return false;
            }
            if (this.ad == null || this.ad.kc.isEmpty) {
                return super.at(a, b);
            }
            return true;
        }
        a5() {
            let a = new List$1(Rect.$, 0);
            let b = new List$1(Boolean_$type, 0);
            if (this.bb.count != this.ba.count) {
                return a;
            }
            this.c9.a0(a, b);
            let c = false;
            this.ao = this.an(a, b);
            if (!this.ad.b7()) {
                c = true;
                this.bh = this.de / 2;
                this.bh = this.bh + this.df();
            }
            else {
                c = true;
                this.c9.ac();
            }
            if (c) {
                for (let d = 0; d < a.count; d++) {
                    let e = this.bb._inner[d];
                    let f = this.ba._inner[d];
                    let g = a._inner[d];
                    let h = this.dg(f.c);
                    let i = h.x - this.bk(e) / 2;
                    let j = h.y - this.bj(e) / 2;
                    g.x = i;
                    g.y = j;
                    a._inner[d] = g;
                }
            }
            return a;
        }
        df() {
            let a;
            let b;
            b = this.ad;
            a = null;
            if (b != null) {
                a = typeCast(XamDataChart.$, b.bh);
            }
            if (a == null || b == null) {
                return 0;
            }
            let c = new List$1(Axis.$, 0);
            for (let d = 0; d < a.axes.count; d++) {
                let e = a.axes._inner[d];
                if ((typeCast(NumericAngleAxis.$, e) !== null || typeCast(CategoryAngleAxis.$, e) !== null) && typeCast(AngleAxisLabelPanel.$, e.av) !== null && e.av.bb.count > 0 && (!e.b7()) && !e.b4() && (e.ai == null || this.ad.ai == null || e.ai.nm == b.ai.nm)) {
                    c.add(e);
                }
            }
            let f = c.indexOf(b);
            if (f == -1) {
                return 0;
            }
            let g = 0;
            let h = 5;
            if (f == 0) {
                g += h;
            }
            else {
                g += c._inner[f - 1].av.bh;
                g += c._inner[f].av.bh * 2 + h;
            }
            return g;
        }
        ai() {
            return 4;
        }
        ay(a) {
            return a == 4 || a == 5;
        }
    }
    AngleAxisLabelPanel.$t = /*@__PURE__*/ markType(AngleAxisLabelPanel, 'AngleAxisLabelPanel', AxisLabelPanelBase.$);
    return AngleAxisLabelPanel;
})();
/**
 * @hidden
 */
export let CategoryAngleAxis = /*@__PURE__*/ (() => {
    class CategoryAngleAxis extends CategoryAxisBase {
        constructor() {
            super();
            this.ml = null;
            this.mi = null;
            this.mm = false;
            this.mq = NaN;
            this.mj = null;
            this.mr = 0;
            this.mo = 0;
            this.mp = 0;
            this.m2 = 1;
            this.ab = CategoryAngleAxis.$;
            this.mi = this.mh();
            this.ml = new PolarAxisRenderingManager();
        }
        a3() {
            return new CategoryAngleAxisView(this);
        }
        hr(a) {
            super.hr(a);
            this.mg = a;
        }
        get_b8() {
            return true;
        }
        au() {
            let a = new AngleAxisLabelPanel();
            a.dg = (b) => {
                let c = this.bh != null ? this.bh.s9 : Rect.empty;
                let d = !c.isEmpty ? this.kc : Rect.empty;
                return this.nf(b, { $type: Point_$type, x: 0.5, y: 0.5 }, c, d, this.av.bh);
            };
            return a;
        }
        m0(a) {
            return Math.round(a * Math.pow(10, 10)) / Math.pow(10, 10);
        }
        mh() {
            let a = ((() => {
                let $ret = new AxisLabelManager();
                $ret.a = this;
                $ret.f = this.dc;
                $ret.e = this.db;
                $ret.b = this.av;
                return $ret;
            })());
            if (this.ay != null) {
                this.ay.registerAxis(this);
            }
            let b = new CategoryAxisRenderer(a);
            b.u = () => {
                let c = this.a4.a1();
                let d = this.a4.a4();
                let e = this.a4.a2();
                let f = this.a4.a3();
                this.ik();
                this.hh(c);
                this.hh(d);
                this.hh(e);
                this.hh(f);
            };
            b.o = (c, d) => !d.isEmpty && !c.isEmpty && this.mk != null;
            b.d = (c, d, e, f) => this.mf(c, d, e, f);
            b.v = () => {
                if (!this.mm) {
                    this.mm = true;
                    this.mk.c0();
                    this.mm = false;
                }
            };
            b.g = (c, d) => {
                let e = typeGetValue(c);
                if (e > this.kq.count - 1) {
                    e -= this.kq.count;
                }
                let f = this.kq.item(e);
                return this.fy(f);
            };
            b.b.c = (c) => {
                if ((this.ay == null || this.ay.visibility == 0) && this.mk != null && this.mq != c) {
                    let d = typeCast(XamDataChart.$, this.bh);
                    if (d == null) {
                        return;
                    }
                    this.mq = c;
                    this.av.bg = c;
                    d.l6();
                    for (let e of fromEnum(d.axes)) {
                        if (e != this && typeCast(AngleAxisLabelPanel.$, e.av) !== null) {
                            e.a4.ag();
                        }
                    }
                }
            };
            b.k = (c, d, e) => {
                let f = typeCast(RadialAxisRenderingParameters.$, c);
                this.ml.m(d, e, c.z, c.aa, f.minLength, f.maxLength, f.center);
            };
            b.l = (c, d, e, f) => {
                let g = typeCast(RadialAxisRenderingParameters.$, c);
                this.ml.n(d, e, f, g.z, c.aa, g.minLength, g.maxLength, g.center);
            };
            b.m = (c, d) => this.getScaledAngle(d);
            b.q = (c, d) => {
                if (this.m0(d - this.mr) < 0) {
                    return false;
                }
                if (this.m0(d - this.mr - (2 * Math.PI)) > 0) {
                    return false;
                }
                return true;
            };
            b.j = (c) => {
                let d = typeCast(RadialAxisRenderingParameters.$, c);
                if (d.e == d.k._inner[0]) {
                    this.ml.i(c.t, c.n, c.z, c.aa, d.center, d.minAngle, d.maxAngle);
                }
            };
            b.e = (c) => {
                c.n = this.mu();
                c.r = c.n;
            };
            b.p = (c, d, e) => {
                let f = typeCast(RadialAxisRenderingParameters.$, c);
                if (e) {
                    return false;
                }
                let g = this.nf(d, f.center, c.aa, c.z, 0);
                if (g.x < c.z.right && g.x >= c.z.left && g.y < c.z.bottom && g.y >= c.z.top) {
                    return true;
                }
                return false;
            };
            b.a = (c, d, e, f) => {
                let g = c.y;
                let h = new ScalerParams(0, c.aa, c.z, this.cg, g);
                let i = d;
                if (this.categoryMode != 0) {
                    let j = (e * f) + 1;
                    j = Math.min(j, this.le);
                    let k = this.ei(j, h);
                    i = (d + k) / 2;
                }
                return i;
            };
            b.f = runOn(this, this.getGroupCenter);
            b.i = runOn(this, this.mx);
            return b;
        }
        nf(a, b, c, d, e) {
            let f = this.mu();
            let g = ViewportUtils.b(e, c, d);
            if (this.ay != null && (this.ay.c == 5 || this.ay.c == 1)) {
                g *= -1;
            }
            let h = b.x + (f + g) * Math.cos(a);
            let i = b.y + (f + g) * Math.sin(a);
            h = ViewportUtils.c(h, c, d);
            i = ViewportUtils.f(i, c, d);
            return { $type: Point_$type, x: h, y: i };
        }
        mu() {
            if (this.mk == null) {
                return 0;
            }
            if (!this.b4()) {
                return this.mk.nr();
            }
            else {
                return this.mk.ns((this.fu));
            }
        }
        mf(a, b, c, d) {
            if (this.kq == null) {
                return null;
            }
            let e = new RadialAxisRenderingParameters();
            let f = this.kq.count - 1;
            let g = this.a4.a1();
            let h = this.a4.a4();
            let i = this.a4.a2();
            let j = this.a4.a3();
            e.t = g;
            e.w = h;
            e.u = i;
            e.v = j;
            e.l = f;
            e.m = 0;
            e.h = false;
            e.z = a;
            e.y = c;
            e.x = d;
            e.aa = b;
            e.g = this.mn();
            e.p = this.my;
            e.o = this.ex();
            e.q = this.mz;
            e.s = this.fz;
            let k = this.ml.f(b);
            let l = this.ml.g(b);
            let m = 0.5 * this.mk.nm;
            let n = 0.5 * this.mk.nl;
            let o = k;
            let p = l;
            let q = this.mk.nr();
            if (isNaN_(q) || isInfinity(q)) {
                return null;
            }
            if (p >= m) {
                p = q;
            }
            if (o < n) {
                o = n;
            }
            let r = a.width;
            this.ml.k(b, e, 0, this.kq.count, this.cg, runOn(this, this.getUnscaledAngle), r);
            let s = { $type: Point_$type, x: 0.5, y: 0.5 };
            e.center = s;
            e.maxLength = p;
            e.minLength = o;
            e.effectiveMaximum = q;
            e.ae = this.kq.count;
            e.ab = this.categoryMode;
            e.ad = true;
            e.ac = this.cg;
            e.af = this.lg;
            e.f = new CategoryTickmarkValues();
            e.j = this.cx;
            return e;
        }
        getMinMaxAngle(a, b, c) {
            let d = this.ml.l(a, b, c);
            b = d.p1;
            c = d.p2;
            return {
                p1: b,
                p2: c
            };
        }
        ac() {
            super.ac();
            this.h7(false);
        }
        get mk() {
            if (this.mj != null) {
                return this.mj;
            }
            let a = typeCast(XamDataChart.$, this.bh);
            if (a != null) {
                for (let b = 0; b < a.axes.count; b++) {
                    if (typeCast(NumericRadiusAxis.$, a.axes._inner[b]) !== null) {
                        return a.axes._inner[b];
                    }
                }
            }
            return this.mj;
        }
        set mk(a) {
            this.mj = a;
        }
        aj() {
            return this.mk;
        }
        getCategorySize(a, b, c) {
            return 2 * Math.PI / this.le;
        }
        k3(a, b, c) {
            let d = this.la(a, b, c);
            let e = 0;
            if (!isNaN_(this.k9)) {
                e = Math.min(this.k9, 1);
            }
            let f = 1 - 0.5 * d;
            return this.getCategorySize(a, b, c) * f / (this.lg - (this.lg - 1) * e);
        }
        getGroupCenter(a, b, c, d) {
            let e = 0.5;
            if (this.lg > 1) {
                let f = this.la(b, c, d);
                let g = 0;
                if (!isNaN_(this.k9)) {
                    g = Math.min(this.k9, 1);
                }
                let h = 1 - 0.5 * f;
                let i = h / (this.lg - (this.lg - 1) * g);
                let j = (h - i) / (this.lg - 1);
                e = 0.25 * f + 0.5 * i + a * j;
            }
            return this.getCategorySize(b, c, d) * e;
        }
        mx(a) {
            let b = 0.5;
            if (this.lg > 1) {
                let c = this.la(Rect.empty, Rect.empty, Rect.empty);
                let d = 0;
                if (!isNaN_(this.k9)) {
                    d = Math.min(this.k9, 1);
                }
                let e = 1 - 0.5 * c;
                let f = e / (this.lg - (this.lg - 1) * d);
                let g = (e - f) / (this.lg - 1);
                b = 0.25 * c + 0.5 * f + a * g;
            }
            return b;
        }
        h8(a) {
            super.h8(a);
            let b = this.bh != null ? this.bh.s9 : Rect.empty;
            let c = !b.isEmpty ? this.kc : Rect.empty;
            let d = this.j7();
            let e = this.j6();
            let f = this.mi.c(a, c, b, d, e);
            if (f != null) {
                this.ms = f.f.m;
                this.mt = f.f.l;
            }
        }
        mw(a, b) {
            let c;
            let d;
            let e = this.ml.l(b, c, d);
            c = e.p1;
            d = e.p2;
            if (c == 0) {
                if (this.cg) {
                    return this.le;
                }
                else {
                    return 0;
                }
            }
            let f = this.getUnscaledAngle(c);
            if (f < 0 || f > this.le) {
                f = this.getUnscaledAngle(c + Math.PI * 2);
            }
            return f;
        }
        mv(a, b) {
            let c;
            let d;
            let e = this.ml.l(b, c, d);
            c = e.p1;
            d = e.p2;
            if (d > Math.PI * 2) {
                d = d - Math.PI * 2;
            }
            if (d == Math.PI * 2) {
                if (this.cg) {
                    return 0;
                }
                else {
                    return this.le;
                }
            }
            let f = this.getUnscaledAngle(d);
            if (f < 0 || f > this.le) {
                f = this.getUnscaledAngle(d + Math.PI * 2);
            }
            return f;
        }
        getScaledAngle(a) {
            let b = this.le;
            let c = b >= 2 ? (a) / (b) : b == 1 ? 0.5 : NaN;
            if (this.ch) {
                c = 1 - c;
            }
            return (c * 2 * Math.PI) + this.mr;
        }
        getUnscaledAngle(a) {
            if (a < this.mr) {
                a += 2 * Math.PI;
            }
            let b = (a - this.mr) / (2 * Math.PI);
            if (this.cg) {
                b = 1 - b;
            }
            return b * (this.le);
        }
        ei(a, b) {
            return this.getScaledAngle(a);
        }
        el(a, b) {
            return this.getUnscaledAngle(a);
        }
        hv(a, b, c, d) {
            super.hv(a, b, c, d);
            let e = typeCast(XamDataChart.$, this.bh);
            switch (b) {
                case "CrossingAxis":
                    let f = typeCast(NumericRadiusAxis.$, d);
                    this.nb(f);
                    if (f != null) {
                        f.n1(this);
                    }
                    this.cp = true;
                    this.h7(false);
                    break;
                case CategoryAngleAxis.$$p[0]:
                    this.mr = this.m1;
                    while (this.mr < 0) {
                        this.mr += 360;
                    }
                    while (this.mr >= 360) {
                        this.mr -= 360;
                    }
                    this.mr = (this.mr * Math.PI) / 180;
                    this.cp = true;
                    this.h7(false);
                    for (let g of fromEnum(this.dd)) {
                        g.ml(false);
                        g.ls();
                    }
                    break;
                case "Label":
                    if (e != null) {
                        for (let h of fromEnum(e.axes)) {
                            h.cp = true;
                            h.h6();
                        }
                    }
                    break;
                case "CrossingValue":
                    if (e != null) {
                        for (let i of fromEnum(e.axes)) {
                            if (typeCast(NumericAngleAxis.$, i) !== null || typeCast(CategoryAngleAxis.$, i) !== null) {
                                i.cp = true;
                                i.h6();
                            }
                        }
                    }
                    break;
                case "LabelSettings":
                    this.mi = this.mh();
                    this.m9();
                    this.cp = true;
                    this.h7(false);
                    break;
            }
        }
        m9() {
            this.mq = NaN;
        }
        nb(a) {
            this.mk = a;
        }
        get my() {
            return this.c(CategoryAngleAxis.nc);
        }
        set my(a) {
            this.h(CategoryAngleAxis.nc, a);
        }
        get ms() {
            return this.mo;
        }
        set ms(a) {
            if (this.ms != a) {
                let b = this.mo;
                this.mo = a;
                this.h1("ActualInterval", b, this.ms);
            }
        }
        eu() {
            return this.ms;
        }
        get mz() {
            return this.c(CategoryAngleAxis.nd);
        }
        set mz(a) {
            this.h(CategoryAngleAxis.nd, a);
        }
        get mt() {
            return this.mp;
        }
        set mt(a) {
            if (this.mt != a) {
                let b = this.mp;
                this.mp = a;
                this.h1("ActualMinorInterval", b, this.mt);
            }
        }
        mn() {
            return !isNaN_(this.my);
        }
        get_a1() {
            return 2;
        }
        get a1() {
            return this.get_a1();
        }
        c2() {
            if (this.cp && this.c3) {
                this.bb = this.ba();
            }
            if (this.kq == null) {
                return false;
            }
            let a = this.kq.count;
            if (a != this.m3) {
                let b = new AxisRangeChangedEventArgs(0, 1, 1, this.m3, a);
                this.m3 = a;
                this.h2(b);
                return true;
            }
            return false;
        }
        get m3() {
            return this.m2;
        }
        set m3(a) {
            this.m2 = a;
        }
        j4(a, b, c, d = null, e = null) {
            let f = typeCast(RadialAxisRenderingParameters.$, this.mi.d(c, b, d, e));
            if (f == null) {
                return null;
            }
            let g = Math.cos(a);
            let h = Math.sin(a);
            let i = f.center.x + g * f.minLength;
            let j = f.center.y + h * f.minLength;
            let k = f.center.x + g * f.maxLength;
            let l = f.center.y + h * f.maxLength;
            i = ViewportUtils.c(i, b, c);
            j = ViewportUtils.f(j, b, c);
            k = ViewportUtils.c(k, b, c);
            l = ViewportUtils.f(l, b, c);
            let m = new LineGeometry();
            m.d = { $type: Point_$type, x: i, y: j };
            m.c = { $type: Point_$type, x: k, y: l };
            return m;
        }
        get isVertical() {
            return this.co;
        }
        j$c(a, b) {
            return this.el.apply(this, arguments);
        }
        j$b(a, b) {
            return this.ei.apply(this, arguments);
        }
        j$d(a, b, c, d, e) {
            this.hl.apply(this, arguments);
        }
        j$e(a, b, c, d) {
            this.hm.apply(this, arguments);
        }
        j$f(a, b, c, d) {
            this.hn.apply(this, arguments);
        }
        get j$a() {
            return this.cg;
        }
    }
    CategoryAngleAxis.$t = /*@__PURE__*/ markType(CategoryAngleAxis, 'CategoryAngleAxis', CategoryAxisBase.$, [IAngleScaler_$type]);
    CategoryAngleAxis.nc = /*@__PURE__*/ DependencyProperty.i("Interval", Number_$type, CategoryAngleAxis.$, /*@__PURE__*/ new PropertyMetadata(2, NaN, (a, b) => {
        a.h1("Interval", b.oldValue, b.newValue);
        a.h7(false);
    }));
    CategoryAngleAxis.nd = /*@__PURE__*/ DependencyProperty.i("MinorInterval", Number_$type, CategoryAngleAxis.$, /*@__PURE__*/ new PropertyMetadata(2, NaN, (a, b) => {
        (typeCast(CategoryAngleAxis.$, a)).h1("MinorInterval", b.oldValue, b.newValue);
        (typeCast(CategoryAngleAxis.$, a)).h7(false);
    }));
    CategoryAngleAxis.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, CategoryAngleAxis, 'h1', ['StartAngleOffset:m1:ne', [1, 0]]);
    return CategoryAngleAxis;
})();
/**
 * @hidden
 */
export let NumericAngleAxis = /*@__PURE__*/ (() => {
    class NumericAngleAxis extends NumericAxisBase {
        constructor() {
            super();
            this.ni = null;
            this.nj = false;
            this.nk = NaN;
            this.nl = 0;
            this.ng = null;
            this.ab = NumericAngleAxis.$;
            this.ni = new PolarAxisRenderingManager();
            this.ky = this.kw();
        }
        a3() {
            return new NumericAngleAxisView(this);
        }
        hr(a) {
            super.hr(a);
            this.nf = a;
        }
        get_b8() {
            return true;
        }
        au() {
            let a = new AngleAxisLabelPanel();
            a.dg = (b) => {
                let c = this.bh != null ? this.bh.s9 : Rect.empty;
                let d = !c.isEmpty ? this.kc : Rect.empty;
                return this.nv(b, { $type: Point_$type, x: 0.5, y: 0.5 }, c, d, this.av.bh);
            };
            return a;
        }
        nm() {
            if (this.nh == null) {
                return 0;
            }
            if (!this.b4()) {
                return this.nh.nr();
            }
            else {
                return this.nh.ns((this.fu));
            }
        }
        no(a) {
            return Math.round(a * Math.pow(10, 10)) / Math.pow(10, 10);
        }
        kw() {
            let a = super.kw();
            a.b.c = (b) => {
                if ((this.ay == null || this.ay.visibility == 0) && this.nh != null && this.nk != b) {
                    let c = typeCast(XamDataChart.$, this.bh);
                    if (c == null) {
                        return;
                    }
                    this.nk = b;
                    this.av.bg = b;
                    c.l6();
                    for (let d of fromEnum(c.axes)) {
                        if (d != this && typeCast(AngleAxisLabelPanel.$, d.av) !== null) {
                            d.a4.ag();
                        }
                    }
                }
            };
            a.e = (b) => {
                b.n = this.nm();
                b.r = b.n;
            };
            a.j = (b) => {
                let c = typeCast(PolarAxisRenderingParameters.$, b);
                if (c.e == c.k._inner[0]) {
                    this.ni.i(b.t, b.n, b.z, b.aa, c.center, c.minAngle, c.maxAngle);
                }
            };
            a.k = (b, c, d) => {
                let e = typeCast(PolarAxisRenderingParameters.$, b);
                this.ni.m(c, d, b.z, b.aa, e.minLength, e.maxLength, e.center);
            };
            a.l = (b, c, d, e) => {
                let f = typeCast(PolarAxisRenderingParameters.$, b);
                this.ni.n(c, d, e, f.z, b.aa, f.minLength, f.maxLength, f.center);
            };
            a.d = (b, c, d, e) => {
                let f = typeCast(PolarAxisRenderingParameters.$, this.kz(b, c, d, e));
                return f;
            };
            a.v = () => {
                if (!this.nj) {
                    this.nj = true;
                    this.nh.c0();
                    this.nj = false;
                }
            };
            a.m = (b, c) => this.getScaledAngle(c);
            a.o = (b, c) => !c.isEmpty && !b.isEmpty && this.nh != null;
            a.q = (b, c) => {
                if (this.no(c - this.nl) < 0) {
                    return false;
                }
                if (this.no(c - this.nl - (2 * Math.PI)) > 0) {
                    return false;
                }
                return true;
            };
            a.p = (b, c, d) => {
                let e = typeCast(PolarAxisRenderingParameters.$, b);
                let f = this.nv(this.getScaledAngle(e.l), e.center, b.aa, b.z, 0);
                let g = this.nv(c, e.center, b.aa, b.z, 0);
                if (d && MathUtil.g(f.x - g.x, f.y - g.y) < 2) {
                    return false;
                }
                if (g.x < b.z.right && g.x >= b.z.left && g.y < b.z.bottom && g.y >= b.z.top) {
                    return true;
                }
                return false;
            };
            a.r = (b, c, d, e) => {
                if (c < b.m && typeCast(LogarithmicTickmarkValues.$, b.f) !== null) {
                    return b.m;
                }
                else if (c > b.l && (typeCast(LogarithmicTickmarkValues.$, b.f) !== null || b.h)) {
                    return b.l;
                }
                return c;
            };
            return a;
        }
        nv(a, b, c, d, e) {
            let f = this.nm();
            let g = ViewportUtils.b(e, c, d);
            if (this.ay != null && (this.ay.c == 5 || this.ay.c == 1)) {
                g *= -1;
            }
            let h = b.x + (f + g) * Math.cos(a);
            let i = b.y + (f + g) * Math.sin(a);
            h = ViewportUtils.c(h, c, d);
            i = ViewportUtils.f(i, c, d);
            return { $type: Point_$type, x: h, y: i };
        }
        ei(a, b) {
            return this.getScaledAngle(a);
        }
        getScaledAngle1(a, b, c) {
            let d = 0;
            if (b) {
                d = (Math.log(a) - this.l1) / (this.l0 - this.l1);
            }
            else {
                d = (a - this.lv) / (this.lu - this.lv);
            }
            if (c) {
                d = 1 - d;
            }
            return (d * 2 * Math.PI) + this.nl;
        }
        getScaledAngle(a) {
            return this.getScaledAngle1(a, this.lh, this.ch);
        }
        el(a, b) {
            return this.getUnscaledAngle(a);
        }
        getUnscaledAngle(a) {
            let b = (a - this.nl) / (2 * Math.PI);
            if (this.cg) {
                b = 1 - b;
            }
            if (this.lh) {
                return Math.exp(b * (this.l0 - this.l1) + this.l1);
            }
            else {
                return this.lv + b * (this.lu - this.lv);
            }
        }
        hv(a, b, c, d) {
            super.hv(a, b, c, d);
            let e = typeCast(XamDataChart.$, this.bh);
            switch (b) {
                case "CrossingAxis":
                    let f = typeCast(NumericRadiusAxis.$, d);
                    this.nt(f);
                    if (f != null) {
                        f.n1(this);
                    }
                    this.h7(false);
                    break;
                case NumericAngleAxis.$$p[0]:
                    this.nl = this.np;
                    while (this.nl < 0) {
                        this.nl += 360;
                    }
                    while (this.nl >= 360) {
                        this.nl -= 360;
                    }
                    this.nl = (this.np * Math.PI) / 180;
                    this.h7(false);
                    for (let g of fromEnum(this.da())) {
                        g.ml(false);
                        g.ls();
                    }
                    break;
                case "Label":
                    if (e != null) {
                        for (let h of fromEnum(e.axes)) {
                            h.h6();
                        }
                    }
                    break;
                case "CrossingValue":
                    if (e != null) {
                        for (let i of fromEnum(e.axes)) {
                            if (typeCast(NumericAngleAxis.$, i) !== null || typeCast(CategoryAngleAxis.$, i) !== null) {
                                i.h6();
                            }
                        }
                    }
                    break;
                case "LabelSettings":
                    this.ky = this.kw();
                    this.nr();
                    this.cp = true;
                    this.h7(false);
                    break;
            }
        }
        nr() {
            this.nk = NaN;
        }
        k0() {
            return new PolarAxisRenderingParameters();
        }
        kz(a, b, c, d) {
            let e = typeCast(PolarAxisRenderingParameters.$, super.kz(a, b, c, d));
            let f = this.ni.f(b);
            let g = this.ni.g(b);
            let h = 0.5 * this.nh.nm;
            let i = 0.5 * this.nh.nl;
            let j = f;
            let k = g;
            let l = this.nh.nr();
            if (isNaN_(l) || isInfinity(l)) {
                return null;
            }
            if (k >= h) {
                k = l;
            }
            if (j < i) {
                j = i;
            }
            let m = a.width;
            this.ni.k(b, e, this.lv, this.lu, this.cg, runOn(this, this.getUnscaledAngle), m);
            let n = { $type: Point_$type, x: 0.5, y: 0.5 };
            e.center = n;
            e.maxLength = k;
            e.minLength = j;
            e.effectiveMaximum = l;
            return e;
        }
        getMinMaxAngle(a, b, c) {
            let d = this.ni.l(a, b, c);
            b = d.p1;
            c = d.p2;
            return {
                p1: b,
                p2: c
            };
        }
        h8(a) {
            super.h8(a);
            let b = this.bh != null ? this.bh.s9 : Rect.empty;
            let c = !b.isEmpty ? this.kc : Rect.empty;
            let d = this.j7();
            let e = this.j6();
            let f = this.ky.c(a, c, b, d, e);
            if (f != null) {
                this.lt = f.f.m;
                this.lw = f.f.l;
            }
        }
        get nh() {
            if (this.ng != null) {
                return this.ng;
            }
            let a = typeCast(XamDataChart.$, this.bh);
            if (a != null) {
                for (let b = 0; b < a.axes.count; b++) {
                    if (a.axes._inner[b].cl) {
                        return a.axes._inner[b];
                    }
                }
            }
            return this.ng;
        }
        set nh(a) {
            this.ng = a;
        }
        aj() {
            return this.nh;
        }
        nt(a) {
            this.nh = a;
        }
        io(a, b) {
            super.io(a, b);
            if (b.height != a.height || b.width != a.width) {
                this.c0();
            }
        }
        get_a1() {
            return 2;
        }
        get a1() {
            return this.get_a1();
        }
        j4(a, b, c, d = null, e = null) {
            if (this.nh == null) {
                return null;
            }
            let f = typeCast(PolarAxisRenderingParameters.$, this.kz(c, b, d, e));
            if (f == null) {
                return null;
            }
            let g = Math.cos(a);
            let h = Math.sin(a);
            let i = f.center.x + g * f.minLength;
            let j = f.center.y + h * f.minLength;
            let k = f.center.x + g * f.maxLength;
            let l = f.center.y + h * f.maxLength;
            i = ViewportUtils.c(i, b, c);
            j = ViewportUtils.f(j, b, c);
            k = ViewportUtils.c(k, b, c);
            l = ViewportUtils.f(l, b, c);
            let m = new LineGeometry();
            m.d = { $type: Point_$type, x: i, y: j };
            m.c = { $type: Point_$type, x: k, y: l };
            return m;
        }
    }
    NumericAngleAxis.$t = /*@__PURE__*/ markType(NumericAngleAxis, 'NumericAngleAxis', NumericAxisBase.$, [IAngleScaler_$type]);
    NumericAngleAxis.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, NumericAngleAxis, 'h1', ['StartAngleOffset:np:nu', [1, 0]]);
    return NumericAngleAxis;
})();
/**
 * @hidden
 */
export let NumericRadiusAxis = /*@__PURE__*/ (() => {
    class NumericRadiusAxis extends NumericAxisBase {
        constructor() {
            super();
            this.ni = null;
            this.nj = false;
            this.nk = NaN;
            this.nm = 0;
            this.nl = 0;
            this.no = 0;
            this.nf = null;
            this.ab = NumericRadiusAxis.$;
            this.nm = this.nw;
            this.nl = this.nv;
            this.ni = new PolarAxisRenderingManager();
            this.ky = this.kw();
        }
        a3() {
            return new NumericRadiusAxisView(this);
        }
        hr(a) {
            super.hr(a);
            this.nh = a;
        }
        get_cl() {
            return true;
        }
        eh() {
            let a = this.nm;
            let b = this.nl;
            let c = Math.min(this.nq(), this.np()) * (a - b) / 2;
            c = Math.max(c, 14);
            return c;
        }
        nq() {
            return this.kc.width;
        }
        np() {
            return this.kc.height;
        }
        au() {
            return new RadialAxisLabelPanel();
        }
        nn(a) {
            if (a == null) {
                return 0;
            }
            return a;
        }
        kw() {
            let a = super.kw();
            a.b.c = (b) => {
                if ((this.ay == null || this.ay.visibility == 0) && this.ng != null) {
                    if ((this.ay == null || (this.ay.c == 4 || this.ay.c == 5)) && this.nk != b) {
                        this.nk = b;
                        this.av.bg = b;
                        this.bh.l6();
                    }
                }
            };
            a.k = (b, c, d) => {
                let e = typeCast(PolarAxisRenderingParameters.$, b);
                this.ni.i(c, d, e.z, e.aa, e.center, e.minAngle, e.maxAngle);
            };
            a.l = (b, c, d, e) => {
                if (d == e) {
                    return;
                }
                let f = typeCast(PolarAxisRenderingParameters.$, b);
                this.ni.j(c, d, e, f.z, f.aa, f.center, f.minAngle, f.maxAngle);
            };
            a.m = (b, c) => this.ns(c);
            a.q = (b, c) => {
                let d = typeCast(PolarAxisRenderingParameters.$, b);
                return c <= d.effectiveMaximum;
            };
            a.n = (b, c) => {
                let d = typeCast(PolarAxisRenderingParameters.$, b);
                return c <= d.effectiveMaximum;
            };
            a.j = (b) => {
                let c = typeCast(PolarAxisRenderingParameters.$, b);
                this.ni.m(b.t, c.crossingAngleRadians, b.z, b.aa, c.minLength, c.maxLength, c.center);
            };
            a.e = (b) => {
                b.n = this.ay == null || (this.ay.c == 4 || this.ay.c == 0) ? b.z.top : b.z.bottom;
                b.r = b.n;
                let c = typeCast(PolarAxisRenderingParameters.$, b);
                c.crossingAngleRadians = (this.nn(this.fu) * Math.PI) / 180;
                if (this.ay == null || (this.ay.c == 4 || this.ay.c == 5)) {
                    c.n = ViewportUtils.f(0.5, c.aa, c.z) - b.z.top;
                    c.r = c.n;
                    let d = typeCast(RadialAxisLabelPanel.$, this.av);
                    if (d != null) {
                        let e = 0;
                        if (this.ay != null && this.ay.c == 4) {
                            e = 1;
                        }
                        d.dy = { $type: Point_$type, x: ViewportUtils.c(0.5, c.aa, c.z), y: e };
                        d.dv = c.crossingAngleRadians;
                    }
                }
            };
            a.p = (b, c, d) => {
                let e = typeCast(PolarAxisRenderingParameters.$, b);
                if (this.ng == null) {
                    return false;
                }
                if (c > e.effectiveMaximum) {
                    return false;
                }
                let f = false;
                f = this.ay == null || (this.ay.c == 4 || this.ay.c == 5);
                let g = 0;
                if (f) {
                    g = this.no;
                }
                let h = e.center.x + c * Math.cos(g);
                let i = e.center.y + c * Math.sin(g);
                h = ViewportUtils.c(h, e.aa, e.z);
                i = ViewportUtils.f(i, e.aa, e.z);
                if (h <= b.z.right && h >= b.z.left && ((i <= b.z.bottom && i >= b.z.top) || !f)) {
                    return true;
                }
                return false;
            };
            a.h = (b, c) => {
                let d = typeCast(PolarAxisRenderingParameters.$, b);
                return new LabelPosition(ViewportUtils.c(d.center.x + c, d.aa, d.z));
            };
            a.r = (b, c, d, e) => {
                if (c < b.m) {
                    return b.m;
                }
                else if (c > b.l) {
                    return b.l;
                }
                return c;
            };
            return a;
        }
        ei(a, b) {
            return this.ns(a);
        }
        nt(a, b, c, d, e) {
            let f = 0;
            if (b) {
                if (a <= 0) {
                    f = (Math.log(this.lv) - this.l1) / (this.l0 - this.l1);
                }
                else {
                    f = (Math.log(a) - this.l1) / (this.l0 - this.l1);
                }
            }
            else {
                f = (a - this.lv) / (this.lu - this.lv);
            }
            if (c) {
                f = 1 - f;
            }
            f = e + (f * (d - e));
            f /= 2;
            return f;
        }
        ns(a) {
            return this.nt(a, this.lh, this.ch, this.nm, this.nl);
        }
        nu(a) {
            let b = a * 2;
            b = (b - this.nl) / (this.nm - this.nl);
            if (this.cg) {
                b = 1 - b;
            }
            if (this.lh) {
                return Math.exp(b * (this.l0 - this.l1) + this.l1);
            }
            else {
                return this.lv + b * (this.lu - this.lv);
            }
        }
        el(a, b) {
            return this.nu(a);
        }
        hv(a, b, c, d) {
            switch (b) {
                case "CrossingValue":
                    this.no = this.nn(this.fu) * Math.PI / 180;
                    break;
            }
            super.hv(a, b, c, d);
            switch (b) {
                case NumericRadiusAxis.$$p[1]:
                    this.nm = this.nw;
                    if (this.nm < 0) {
                        this.nm = 0.1;
                    }
                    if (this.nm > 1) {
                        this.nm = 1;
                    }
                    if (this.nl >= this.nm) {
                        this.nl = this.nm - 0.01;
                        if (this.nl < 0) {
                            this.nl = 0;
                            this.nm = 0.01;
                        }
                    }
                    this.cp = true;
                    this.h7(false);
                    if (this.ng != null) {
                        this.ng.h6();
                    }
                    for (let e of fromEnum(this.da())) {
                        e.ml(false);
                    }
                    break;
                case NumericRadiusAxis.$$p[0]:
                    this.nl = this.nv;
                    if (this.nl < 0) {
                        this.nl = 0.1;
                    }
                    if (this.nl > 1) {
                        this.nl = 1;
                    }
                    if (this.nl >= this.nm) {
                        this.nl = this.nm - 0.01;
                        if (this.nl < 0) {
                            this.nl = 0;
                            this.nm = 0.01;
                        }
                    }
                    this.cp = true;
                    this.h7(false);
                    if (this.ng != null) {
                        this.ng.h6();
                    }
                    for (let f of fromEnum(this.da())) {
                        f.e1 = true;
                        f.ml(false);
                    }
                    if (this.bh != null) {
                        this.bh.mj();
                    }
                    break;
                case "CrossingAxis":
                    let g = typeCast(NumericAngleAxis.$, d);
                    let h = typeCast(CategoryAngleAxis.$, d);
                    if (g == null && h == null) {
                        this.n1(null);
                    }
                    if (g != null) {
                        this.n1(g);
                        g.nt(this);
                    }
                    if (h != null) {
                        this.n1(h);
                        h.nb(this);
                    }
                    this.cp = true;
                    this.h7(false);
                    break;
                case "IsInverted":
                    if (this.ng != null) {
                        this.ng.cp = true;
                        this.ng.h7(false);
                    }
                    break;
            }
        }
        n1(a) {
            this.ng = a;
        }
        get ng() {
            if (this.nf != null) {
                return this.nf;
            }
            let a = typeCast(XamDataChart.$, this.bh);
            if (a != null) {
                for (let b = 0; b < a.axes.count; b++) {
                    if (typeCast(NumericAngleAxis.$, a.axes._inner[b]) !== null || typeCast(CategoryAngleAxis.$, a.axes._inner[b]) !== null) {
                        return a.axes._inner[b];
                    }
                }
            }
            return this.nf;
        }
        set ng(a) {
            this.nf = a;
        }
        aj() {
            return this.ng;
        }
        k0() {
            return new PolarAxisRenderingParameters();
        }
        kz(a, b, c, d) {
            let e = typeCast(PolarAxisRenderingParameters.$, super.kz(a, b, c, d));
            let f = this.ni.f(b);
            let g = this.ni.g(b);
            let h = 0.5 * this.nm;
            let i = 0.5 * this.nl;
            let j, k;
            if (Rect.l_op_Equality(b, SeriesViewer.tl)) {
                k = this.lu;
                j = this.lv;
            }
            else {
                k = Math.min(g, h);
                j = this.nu(f);
                k = this.nu(k);
                let l = this.n2(a, b, j, k);
                j = l.p2;
                k = l.p3;
            }
            let m = { $type: Point_$type, x: 0.5, y: 0.5 };
            let n = f;
            let o = g;
            let p = Math.min(a.width, a.height) * (this.nm - this.nl) / 2;
            e.center = m;
            let q = Math.max(o, n);
            let r = Math.min(n, o);
            e.maxLength = q;
            e.minLength = r;
            let s = Math.min(j, k);
            let t = Math.max(j, k);
            if (s < this.lv) {
                s = this.lv;
            }
            if (t > this.lu) {
                t = this.lu;
            }
            this.ly = s;
            this.lx = t;
            e.k.add(((() => {
                let $ret = new RangeInfo();
                $ret.d = s;
                $ret.c = t;
                $ret.b = p;
                return $ret;
            })()));
            let u = typeCast(IAngleScaler_$type, this.ng);
            if (u != null) {
                let v;
                let w;
                let x = u.getMinMaxAngle(b, v, w);
                v = x.p1;
                w = x.p2;
                e.minAngle = Math.min(v, w);
                e.maxAngle = Math.max(v, w);
            }
            let y = this.nr();
            if (o >= h) {
                o = y;
            }
            if (n < i) {
                n = i;
            }
            e.minLength = n;
            e.maxLength = o;
            e.effectiveMaximum = y;
            e.f = this.k3;
            let z = typeCast(LinearTickmarkValues.$, e.f);
            if (z != null) {
                z.y = this.nx(m, e.minLength, e.maxLength, b, a);
            }
            return e;
        }
        n2(a, b, c, d) {
            let e = { $type: Point_$type, x: 0.5, y: 0.5 };
            let f = 0;
            if (this.cg) {
                f = this.ns(this.lv);
            }
            else {
                f = this.ns(this.lu);
            }
            let g = 0;
            if (this.fu != null) {
                g = this.no;
            }
            let h = e.x + f * Math.cos(g);
            let i = e.y + f * Math.sin(g);
            e.x = ViewportUtils.c(e.x, b, a);
            e.y = ViewportUtils.f(e.y, b, a);
            h = ViewportUtils.c(h, b, a);
            i = ViewportUtils.f(i, b, a);
            if (h >= a.left && h <= a.right && i >= a.top && i <= a.bottom) {
                if (this.cg) {
                    d = this.lv;
                }
                else {
                    d = this.lu;
                }
            }
            if (e.x >= a.left && e.x <= a.right && e.y >= a.top && e.y <= a.bottom) {
                if (this.cg) {
                    c = this.lu;
                }
                else {
                    c = this.lv;
                }
            }
            return {
                p2: c,
                p3: d
            };
        }
        nx(a, b, c, d, e) {
            let f = ViewportUtils.d(c - b, d, e);
            let g = f / Math.min(e.width, e.height);
            if (g > 0.7) {
                return 10;
            }
            return 5;
        }
        nr() {
            let a = 0;
            if (!this.cg) {
                a = this.ns(this.lu);
            }
            else {
                a = this.ns(this.lv);
            }
            return a;
        }
        m0(a) {
            if (this.ng != null) {
                this.ng.h6();
            }
        }
        h8(a) {
            super.h8(a);
            let b = this.bh != null ? this.bh.s9 : Rect.empty;
            let c = !b.isEmpty ? this.kc : Rect.empty;
            let d = this.j7();
            let e = this.j6();
            let f = this.ky.c(a, c, b, d, e);
            if (f != null) {
                this.lt = f.f.m;
                this.lw = f.f.l;
            }
        }
        io(a, b) {
            super.io(a, b);
            if (b.height != a.height || b.width != a.width) {
                this.c0();
            }
        }
        n0(a, b, c, d, e) {
            let f = typeCast(IPolarRadialRenderingParameters_$type, this.kz(b, c, d, e));
            if (f == null) {
                return;
            }
            this.ni.j(a.d, f.minLength, f.maxLength, b, c, f.center, f.minAngle, f.maxAngle);
        }
        get_a1() {
            return 3;
        }
        get a1() {
            return this.get_a1();
        }
        j4(a, b, c, d = null, e = null) {
            let f = typeCast(PolarAxisRenderingParameters.$, this.kz(c, b, d, e));
            let g = a;
            let h = new PathGeometry();
            let i = ViewportUtils.d(g, b, c);
            let j = ViewportUtils.g(g, b, c);
            if (i <= 0 || j <= 0) {
                return null;
            }
            let k = ViewportUtils.c(f.center.x, b, c);
            let l = ViewportUtils.f(f.center.y, b, c);
            if (f.maxAngle - f.minAngle < Math.PI && f.maxAngle - f.minAngle > 0) {
                let m = { $type: Point_$type, x: ViewportUtils.c(f.center.x + g * Math.cos(f.minAngle), b, c), y: ViewportUtils.f(f.center.y + g * Math.sin(f.minAngle), b, c) };
                let n = { $type: Point_$type, x: ViewportUtils.c(f.center.x + g * Math.cos(f.maxAngle), b, c), y: ViewportUtils.f(f.center.y + g * Math.sin(f.maxAngle), b, c) };
                let o = new PathFigure();
                o._startPoint = m;
                o._isClosed = false;
                o._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.b = false;
                    $ret.e = n;
                    $ret.f = new Size(1, i, j);
                    $ret.d = 1;
                    return $ret;
                })()));
                h.c.add(o);
            }
            else {
                let p = new PathFigure();
                p._startPoint = { $type: Point_$type, x: k, y: l - j };
                p._isClosed = true;
                p._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.b = false;
                    $ret.e = { $type: Point_$type, x: k, y: l + j };
                    $ret.f = new Size(1, i, j);
                    $ret.d = 1;
                    return $ret;
                })()));
                p._segments.add(((() => {
                    let $ret = new ArcSegment();
                    $ret.b = false;
                    $ret.e = { $type: Point_$type, x: k, y: l - j };
                    $ret.f = new Size(1, i, j);
                    $ret.d = 1;
                    return $ret;
                })()));
                h.c.add(p);
            }
            return h;
        }
    }
    NumericRadiusAxis.$t = /*@__PURE__*/ markType(NumericRadiusAxis, 'NumericRadiusAxis', NumericAxisBase.$);
    NumericRadiusAxis.$$p = /*@__PURE__*/ markDep(DependencyProperty, PropertyMetadata, NumericRadiusAxis, 'h1', ['InnerRadiusExtentScale:nv:n3', [1, 0], 'RadiusExtentScale:nw:n4', [1, 0.75]]);
    return NumericRadiusAxis;
})();
/**
 * @hidden
 */
export let AngleAxisLabelPanelView = /*@__PURE__*/ (() => {
    class AngleAxisLabelPanelView extends AxisLabelPanelBaseView {
        constructor(a) {
            super(a);
            this.az = null;
            this.az = a;
        }
        an() {
            super.an();
            this.az.da = true;
        }
        a0(a, b) {
            this.az.de = -1.7976931348623157E+308;
            this.az.db = -1.7976931348623157E+308;
            this.az.dd = -1.7976931348623157E+308;
            this.az.dc = -1.7976931348623157E+308;
            for (let c = 0; c < this.a.bb.count; c++) {
                let d = this.a.bb._inner[c];
                let e = this.a.ba._inner[c];
                let f = e.a;
                let g = this.az.dg(e.c);
                let h = this.m(d);
                let i = this.l(d);
                let j = h + this.p() + this.q();
                let k = i + this.r() + this.o();
                let l = g.x - j / 2;
                let m = g.y - k / 2;
                this.az.dd = Math.max(h, this.az.dd);
                this.az.dc = Math.max(i, this.az.dc);
                this.az.de = Math.max(j, this.az.de);
                this.az.db = Math.max(k, this.az.db);
                let n = new Rect(0, l, m, j, k);
                a.add(n);
                b.add(f);
            }
        }
        o() {
            return 0;
        }
        p() {
            return 0;
        }
        q() {
            return 0;
        }
        r() {
            return 0;
        }
    }
    AngleAxisLabelPanelView.$t = /*@__PURE__*/ markType(AngleAxisLabelPanelView, 'AngleAxisLabelPanelView', AxisLabelPanelBaseView.$);
    return AngleAxisLabelPanelView;
})();
/**
 * @hidden
 */
export let CategoryAngleAxisView = /*@__PURE__*/ (() => {
    class CategoryAngleAxisView extends CategoryAxisBaseView {
        constructor(a) {
            super(a);
            this.bj = null;
            this.bj = a;
        }
        aj() {
            super.aj();
            this.a.jv = AxisDefaults.h;
            this.a.jy = AxisDefaults.g;
        }
    }
    CategoryAngleAxisView.$t = /*@__PURE__*/ markType(CategoryAngleAxisView, 'CategoryAngleAxisView', CategoryAxisBaseView.$);
    return CategoryAngleAxisView;
})();
/**
 * @hidden
 */
export let NumericAngleAxisView = /*@__PURE__*/ (() => {
    class NumericAngleAxisView extends NumericAxisBaseView {
        constructor(a) {
            super(a);
            this.bj = null;
            this.bj = a;
        }
        aj() {
            super.aj();
            this.a.jv = AxisDefaults.h;
            this.a.jy = AxisDefaults.g;
        }
    }
    NumericAngleAxisView.$t = /*@__PURE__*/ markType(NumericAngleAxisView, 'NumericAngleAxisView', NumericAxisBaseView.$);
    return NumericAngleAxisView;
})();
/**
 * @hidden
 */
export let NumericRadiusAxisView = /*@__PURE__*/ (() => {
    class NumericRadiusAxisView extends NumericAxisBaseView {
        constructor(a) {
            super(a);
            this.bj = null;
            this.bj = a;
        }
        aj() {
            super.aj();
            this.a.jv = AxisDefaults.h;
            this.a.jy = AxisDefaults.g;
        }
    }
    NumericRadiusAxisView.$t = /*@__PURE__*/ markType(NumericRadiusAxisView, 'NumericRadiusAxisView', NumericAxisBaseView.$);
    return NumericRadiusAxisView;
})();
