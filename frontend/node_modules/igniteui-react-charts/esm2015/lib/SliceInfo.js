/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, markType } from "igniteui-react-core";
import { SliceAppearance } from "./SliceAppearance";
import { FunnelSliceVisualData } from "./FunnelSliceVisualData";
import { PointData } from "igniteui-react-core";
import { PrimitiveAppearanceData } from "igniteui-react-core";
import { AppearanceHelper } from "igniteui-react-core";
import { RectData } from "igniteui-react-core";
import { LabelAppearanceData } from "igniteui-react-core";
import { stringEmpty } from "igniteui-react-core";
/**
 * @hidden
 */
export let SliceInfo = /*@__PURE__*/ (() => {
    class SliceInfo extends Base {
        constructor() {
            super();
            this.k = null;
            this.m = null;
            this.i = 0;
            this.f = false;
            this.a = null;
            this.e = false;
            this.b = new SliceAppearance();
            this.n = { $type: Point_$type, x: 0, y: 0 };
        }
        get l() {
            return this.k;
        }
        set l(a) {
            this.k = a;
        }
        get n() {
            return this.m;
        }
        set n(a) {
            this.m = a;
        }
        get j() {
            return this.i;
        }
        set j(a) {
            this.i = a;
        }
        get h() {
            return this.f;
        }
        set h(a) {
            this.f = a;
        }
        get b() {
            return this.a;
        }
        set b(a) {
            this.a = a;
        }
        get g() {
            return this.e;
        }
        set g(a) {
            this.e = a;
        }
        static c(a, b, c, d, e) {
            if (a == null) {
                a = new SliceInfo();
            }
            a.g = c.g;
            a.h = c.h;
            a.j = c.j;
            a.l = c.l;
            a.n = { $type: Point_$type, x: (b.n.x * e) + (c.n.x * d), y: (b.n.y * e) + (c.n.y * d) };
            a.b = SliceAppearance.f(a.b, b.b, c.b, d, e);
            return a;
        }
        d() {
            let a = new FunnelSliceVisualData();
            a.appearance = new PrimitiveAppearanceData();
            a.appearance.fill = AppearanceHelper.b(this.b.ad);
            a.appearance.stroke = AppearanceHelper.b(this.b.ag);
            a.appearance.opacity = this.b.p;
            a.appearance.canvasLeft = this.b.aq.x;
            a.appearance.canvasTop = this.b.aq.y;
            a.height = this.b.ao.y - this.b.ar.y;
            a.upperWidth = this.b.as.x - this.b.ar.x;
            a.lowerWidth = this.b.ap.x - this.b.ao.x;
            a.isSelected = this.b.j;
            a.top = this.b.o;
            a.bottom = this.b.n;
            a.index = this.j;
            a.height = this.b.n - this.b.o;
            a.sliceBorderBrush = AppearanceHelper.a(this.b.ag);
            if (this.b.v == null) {
                a.innerLabel = stringEmpty();
            }
            else {
                a.innerLabel = this.b.v.toString();
            }
            if (this.l == null) {
                a.outerLabel = stringEmpty();
            }
            else {
                a.outerLabel = this.l.toString();
            }
            a.upperLeft = PointData.b(this.b.ar);
            a.upperRight = PointData.b(this.b.as);
            a.lowerLeft = PointData.b(this.b.ao);
            a.lowerRight = PointData.b(this.b.ap);
            let b = new Array(this.b.au.count);
            for (let c = 0; c < this.b.au.count; c++) {
                b[c] = new PointData(this.b.au._inner[c].x, this.b.au._inner[c].y);
            }
            a.slicePoints = b;
            a.innerLabelPosition = PointData.b(this.a.an);
            a.outerLabelPosition = PointData.b(this.m);
            a.outerLabelBounds = RectData.b(this.b.ay);
            a.innerLabelBounds = RectData.b(this.b.ax);
            a.isVisibile = this.b.a2 == 0;
            a.innerLabelAppearance = new LabelAppearanceData();
            a.innerLabelAppearance.labelBrush = AppearanceHelper.b(this.b.ae);
            a.innerLabelAppearance.text = a.innerLabel;
            a.innerLabelAppearance.visibility = this.b.i;
            a.outerLabelAppearance = new LabelAppearanceData();
            a.outerLabelAppearance.labelBrush = AppearanceHelper.b(this.b.af);
            a.outerLabelAppearance.text = a.outerLabel;
            a.outerLabelAppearance.visibility = this.g;
            return a;
        }
    }
    SliceInfo.$t = /*@__PURE__*/ markType(SliceInfo, 'SliceInfo');
    return SliceInfo;
})();
