/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, runOn, delegateCombine, delegateRemove, markType, fromEnum, String_$type, INotifyPropertyChanged_$type, PropertyChangedEventArgs, EventArgs, fromEn, EnumUtil, enumGetBox, typeGetValue, Point_$type } from "igniteui-react-core";
import { RenderingContext } from "igniteui-react-core";
import { FontInfo } from "igniteui-react-core";
import { FontDefaults } from "igniteui-react-core";
import { DeviceUtils } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { Rect } from "igniteui-react-core";
import { CanvasViewRenderer } from "igniteui-react-core";
import { CanvasGestureDOMEventProxy } from "igniteui-react-core";
import { TreemapVisualData } from "./TreemapVisualData";
import { List$1 } from "igniteui-react-core";
import { TreemapVisual } from "./TreemapVisual";
import { Pool$1 } from "igniteui-react-core";
import { FontUtil } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
import { truncate, isNaN_, logBase } from "igniteui-react-core";
import { Rectangle } from "igniteui-react-core";
import { TextBlock } from "igniteui-react-core";
import { HorizontalAlignment_$type } from "igniteui-react-core";
import { VerticalAlignment_$type } from "igniteui-react-core";
import { Thickness } from "igniteui-react-core";
import { TreemapNodeVisualData } from "./TreemapNodeVisualData";
import { TreemapLabelVisualData } from "./TreemapLabelVisualData";
import { RectangleVisualData } from "igniteui-react-core";
import { PointData } from "igniteui-react-core";
import { SizeData } from "igniteui-react-core";
import { AppearanceHelper } from "igniteui-react-core";
import { HashSet$1 } from "igniteui-react-core";
import { TreemapOrientation_$type } from "./TreemapOrientation";
import { Size } from "igniteui-react-core";
import { AreaInfo } from "./AreaInfo";
import { Dictionary$2 } from "igniteui-react-core";
import { DoubleAnimator } from "igniteui-react-core";
import { BrushCollection } from "igniteui-react-core";
import { TreemapFillScaleMode_$type } from "./TreemapFillScaleMode";
import { TreemapLabelVerticalFitMode_$type } from "./TreemapLabelVerticalFitMode";
import { TreemapLabelHorizontalFitMode_$type } from "./TreemapLabelHorizontalFitMode";
import { TreemapHeaderDisplayMode_$type } from "./TreemapHeaderDisplayMode";
import { TreemapLayoutType_$type } from "./TreemapLayoutType";
import { FastItemsSource } from "igniteui-react-core";
import { EasingFunctions } from "igniteui-react-core";
import { NotifyCollectionChangedEventArgs } from "igniteui-react-core";
import { ObservableCollection$1 } from "igniteui-react-core";
import { RectData } from "igniteui-react-core";
import { TreemapNodeVisualDataList } from "./TreemapNodeVisualDataList";
import { BrushCollectionUtil } from "igniteui-react-core";
import { TreemapValueMappingMode_$type } from "./TreemapValueMappingMode";
import { TreemapNodePointerEventArgs } from "./TreemapNodePointerEventArgs";
import { TreemapNodeStyleMappingTargetType_$type } from "./TreemapNodeStyleMappingTargetType";
import { stringReplace, stringIsNullOrEmpty } from "igniteui-react-core";
/**
 * @hidden
 */
export let TreemapView = /*@__PURE__*/ (() => {
    class TreemapView extends Base {
        constructor() {
            super();
            this.b = null;
            this.a = null;
            this.o = false;
            this.ae = null;
            this.l = null;
            this.ac = null;
            this.s = 0;
            this.r = 0;
            this.f = null;
            this.ad = null;
            this.v = 1;
            this.ab = null;
            this.c = null;
            this.t = 0;
            this.u = 0;
            this.a3 = null;
            this.h = ((() => {
                let $ret = new FontInfo();
                $ret.n = FontDefaults.treemapFontFamily;
                $ret.d = DeviceUtils.f(FontDefaults.treemapFontSize);
                return $ret;
            })());
            this.g = ((() => {
                let $ret = new FontInfo();
                $ret.n = FontDefaults.treemapFontFamily;
                $ret.d = DeviceUtils.f(FontDefaults.treemapFontSize);
                return $ret;
            })());
            this.q = null;
            this.m = null;
            this.a4 = ((() => {
                let $ret = new Brush();
                $ret.fill = "rgba(0,0,0, 0.0)";
                return $ret;
            })());
            this.e = ((() => {
                let $ret = new FontInfo();
                $ret.n = FontDefaults.treemapFontFamily;
                $ret.d = DeviceUtils.f(FontDefaults.treemapFontSize);
                return $ret;
            })());
            this.d = ((() => {
                let $ret = new FontInfo();
                $ret.n = FontDefaults.treemapHeaderFontFamily;
                $ret.d = DeviceUtils.f(FontDefaults.treemapHeaderFontSize);
                return $ret;
            })());
            this.n = true;
            this.b = new TreemapViewRenderer();
            this.b.j = ((() => {
                let $ret = new Brush();
                $ret.fill = "white";
                return $ret;
            })());
        }
        aw() {
        }
        a0() {
            this.az();
        }
        a1() {
            if (!this.o) {
                this.o = true;
                if (this.ac != null) {
                    this.ac.setTimeout(runOn(this, this.af), 0);
                }
                else {
                    window.setTimeout(runOn(this, this.af), 0);
                }
            }
        }
        af() {
            if (this.o) {
                this.o = false;
                this.a.hf();
            }
        }
        p() {
            return true;
        }
        ax() {
            this.v = this.a.cp;
            this.a1();
        }
        at(a) {
            if (a == null) {
                this.ae = null;
                this.ac = null;
                this.l = null;
                if (this.ab != null) {
                    window.removeEventListener("resize", this.ab, false);
                    this.ab = null;
                }
                this.ag();
                return;
            }
            this.ac = a;
            this.ad = a;
            let b = this.ad.rootWrapper.width();
            let c = this.ad.rootWrapper.height();
            this.aq();
            this.v = (isNaN_(this.a.di) ? this.a.cp : this.a.di);
            let d = this.v;
            let e = Math.round(a.rootWrapper.width());
            let f = Math.round(a.rootWrapper.height());
            let g = e * d;
            let h = f * d;
            this.ac.rootWrapper.setStyleProperty("position", "relative");
            let i = a.createElement("canvas");
            i.setStyleProperty("position", "absolute");
            this.ac.rootWrapper.append(i);
            this.s = b;
            this.r = c;
            i.setAttribute("width", g.toString());
            i.setAttribute("height", h.toString());
            i.setStyleProperty("width", e.toString() + "px");
            i.setStyleProperty("height", f.toString() + "px");
            this.m = i.listen("contextmenu", (j) => j.preventDefault());
            this.a.ip = new Rect(0, 0, 0, e, f);
            this.ae = i;
            let j = this.ac.get2DCanvasContext(this.ae);
            this.l = new RenderingContext(new CanvasViewRenderer(), j);
            this.ap();
            this.a2();
            this.l.ac(this.f);
            this.az();
            this.c = new CanvasGestureDOMEventProxy(this.ae, this.ac, true);
            this.c.ao = (k) => true;
            this.c.bl = this.a.ip;
            let k = this.c;
            k.onMouseOver = delegateCombine(k.onMouseOver, runOn(this, this.al));
            let l = this.c;
            l.onMouseUp = delegateCombine(l.onMouseUp, runOn(this, this.am));
            let m = this.c;
            m.onMouseDown = delegateCombine(m.onMouseDown, runOn(this, this.ai));
            let n = this.c;
            n.onMouseEnter = delegateCombine(n.onMouseEnter, runOn(this, this.aj));
            let o = this.c;
            o.onMouseLeave = delegateCombine(o.onMouseLeave, runOn(this, this.ak));
        }
        ak(a) {
            this.a.g4(a);
        }
        an(a) {
            this.b.e(a, this.q, this);
        }
        aj(a) {
            this.a.g3(a);
        }
        aq() {
            if (this.ab == null) {
                this.ab = (a) => {
                    let b = this.a.di;
                    let c = this.a.cp;
                    if (!isNaN_(b) && b != 0) {
                        return;
                    }
                    if (window.devicePixelRatio != undefined && window.devicePixelRatio != c) {
                        this.a.cp = window.devicePixelRatio;
                    }
                };
                let e_ = this.ab;
                window.addEventListener("resize", e_, false);
            }
            this.ab(null);
        }
        ag() {
            if (this.m != null) {
                this.m();
                this.m = null;
            }
            if (this.c != null) {
                let a = this.c;
                a.onMouseOver = delegateRemove(a.onMouseOver, runOn(this, this.al));
                let b = this.c;
                b.onMouseUp = delegateRemove(b.onMouseUp, runOn(this, this.am));
                let c = this.c;
                c.onMouseDown = delegateRemove(c.onMouseDown, runOn(this, this.ai));
                let d = this.c;
                d.onMouseEnter = delegateRemove(d.onMouseEnter, runOn(this, this.aj));
                let e = this.c;
                e.onMouseLeave = delegateRemove(e.onMouseLeave, runOn(this, this.ak));
                this.c.ao = null;
                this.c.av();
            }
        }
        ai(a) {
            if (this.c.al) {
                this.a.g8(a);
            }
            else {
                this.a.g2(a);
            }
        }
        am(a) {
            if (this.c.al) {
                this.a.g9(a);
            }
            else {
                this.a.g6(a);
            }
        }
        al(a, b, c) {
            this.a.g5(a);
        }
        ap() {
        }
        k() {
            return this.b.b;
        }
        a2() {
            this.f = FontUtil.getFont(this.ac);
            if (this.g != null) {
                this.t = this.w(this.g);
            }
            else {
                this.t = this.w(this.f);
            }
            if (this.h != null) {
                this.u = this.w(this.h);
            }
            else {
                this.u = this.w(this.f);
            }
            this.a3 = new Brush();
            this.a3._fill = this.ac.rootWrapper.getStyleProperty("color");
            if (this.l != null) {
                this.l.ac(this.f);
            }
        }
        ar() {
            let a = this.ad.rootWrapper.width();
            let b = this.ad.rootWrapper.height();
            this.a.ip = new Rect(0, 0, 0, a, b);
            this.aq();
        }
        ao() {
            if (this.o) {
                this.af();
            }
        }
        az() {
            if (this.l == null) {
                return;
            }
            let a = this.a.ip.width;
            let b = this.a.ip.height;
            let c = Math.round(a * this.v);
            let d = Math.round(b * this.v);
            if (this.s != c || this.r != d) {
                this.ae.setAttribute("width", c.toString());
                this.ae.setAttribute("height", d.toString());
                this.ae.setStyleProperty("width", a.toString() + "px");
                this.ae.setStyleProperty("height", b.toString() + "px");
                this.s = truncate(Math.round(c));
                this.r = truncate(Math.round(d));
            }
            if (this.l.d && this.v != 1) {
                this.l.z();
                this.l.aa(this.v, this.v);
            }
            this.b.f(this.l, this.a.ip, this.q, this.t);
            if (this.l.d && this.v != 1) {
                this.l.y();
            }
        }
        av(a) {
            this.h = a;
            if (this.h != null) {
                this.u = this.w(this.h);
            }
            else {
                this.u = this.w(this.f);
            }
        }
        ay(a) {
            this.g = a;
            if (this.g != null) {
                this.t = this.w(this.g);
            }
            else {
                this.t = this.w(this.f);
            }
            if (this.h != null) {
                this.u = this.w(this.h);
            }
            else {
                this.u = this.w(this.f);
            }
        }
        ah(a) {
            this.q = a;
            this.az();
        }
        aa(a) {
            if (a != null) {
                if (this.g != null) {
                    this.l.ac(this.g);
                }
                else {
                    this.l.ac(this.e);
                }
                return this.l.f(a);
            }
            return 0;
        }
        y(a) {
            if (a != null) {
                if (this.h != null) {
                    this.l.ac(this.h);
                }
                else {
                    this.l.ac(this.e);
                }
                return this.l.f(a);
            }
            return 0;
        }
        w(a) {
            return FontUtil.getCurrentFontHeight(this.ac, a);
        }
        z(a) {
            return this.t;
        }
        x(a) {
            return this.u;
        }
        a6() {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "rgb(220,220,220)";
                return $ret;
            })());
        }
        a8() {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "rgb(240, 240, 240)";
                return $ret;
            })());
        }
        a7() {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "rgb(102, 102, 102)";
                return $ret;
            })());
        }
        be() {
            return this.a4;
        }
        ba() {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "black";
                return $ret;
            })());
        }
        a9() {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "rgb(240,240,240)";
                return $ret;
            })());
        }
        bd() {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "rgb(240, 240, 240)";
                return $ret;
            })());
        }
        a5() {
            return ((() => {
                let $ret = new Brush();
                $ret.fill = "rgb(102, 102, 102)";
                return $ret;
            })());
        }
        j() {
            return this.e;
        }
        i() {
            return this.d;
        }
        bb() {
            return BrushUtil.g(153, 25, 25, 25);
        }
        bc() {
            return BrushUtil.g(153, 45, 45, 45);
        }
        as() {
            this.n = true;
            this.aq();
            if (this.c != null) {
                this.c.at(this.ac.rootWrapper, "");
            }
        }
        au() {
            this.n = false;
            if (this.c != null) {
                this.c.bh(this.ac.rootWrapper, "");
            }
        }
    }
    TreemapView.$t = /*@__PURE__*/ markType(TreemapView, 'TreemapView');
    return TreemapView;
})();
/**
 * @hidden
 */
export let TreemapViewRenderer = /*@__PURE__*/ (() => {
    class TreemapViewRenderer extends Base {
        constructor() {
            super();
            this.b = null;
            this.c = null;
            this.j = null;
            this.c = new List$1(TreemapVisual.$, 0);
            this.b = ((() => {
                let $ret = new Pool$1(TreemapVisual.$);
                $ret.create = runOn(this, this.a);
                $ret.activate = runOn(this, this.g);
                $ret.disactivate = runOn(this, this.i);
                $ret.destroy = runOn(this, this.h);
                return $ret;
            })());
        }
        a() {
            let a = new TreemapVisual();
            this.c.add(a);
            return a;
        }
        g(a) {
            a.t = 0;
        }
        i(a) {
            a.t = 1;
        }
        h(a) {
            this.c.remove(a);
        }
        d(a) {
            if (a.c.count != 3) {
                a.c.add1(new Rectangle());
                a.c.add1(new Rectangle());
                a.c.add1(new TextBlock());
            }
        }
        f(a, b, c, d) {
            a.k(b.left, b.top, b.width, b.height);
            if (c != null) {
                for (let e = 0; e < c.count; e++) {
                    let f = c._inner[e];
                    this.d(f);
                    let g = f.c._inner[0];
                    let h = f.c._inner[1];
                    let i = f.c._inner[2];
                    g._fill = f.i;
                    g._stroke = f.l;
                    g.ac = f.f;
                    g.width = f.m.width;
                    g.height = f.m.height;
                    g.n = f.m.left;
                    g.o = f.m.top;
                    a.ac(f.a);
                    let j = a.f(f.g);
                    if (f.b) {
                        i.al = f.g;
                        switch (f.h) {
                            case 0:
                                i.n = f.m.left + f.o.left;
                                break;
                            case 1:
                            case 3:
                                i.n = f.m.left + f.m.width / 2 - f.e / 2;
                                break;
                            case 2:
                                i.n = Math.max(f.m.left + f.o.left, f.m.right - (j + f.o.right));
                                break;
                        }
                        switch (f.p) {
                            case 0:
                                i.o = f.m.top + f.o.top;
                                break;
                            case 1:
                            case 3:
                                i.o = f.m.top + f.m.height / 2 - f.d / 2;
                                break;
                            case 2:
                                i.o = Math.max(f.m.top + f.o.top, f.m.bottom - (d + f.o.bottom));
                                break;
                        }
                        i.ao = f.k;
                    }
                    else {
                        h._fill = f.j;
                        h._stroke = f.l;
                        h.ac = f.f;
                        h.width = f.m.width;
                        h.height = f.d;
                        h.n = f.m.left;
                        h.o = f.m.top;
                        if (f.s == 0) {
                            h.width = j + f.n.left + f.n.right;
                        }
                        i.n = f.m.left + f.n.left;
                        i.o = f.m.top + f.n.top;
                        i.al = f.g;
                        i.ao = f.k;
                    }
                    a.v(g);
                    if (f.s != 0) {
                        if (!f.b) {
                            a.v(h);
                        }
                    }
                    a.z();
                    a.ae(f.m);
                    if (f.s == 0) {
                        if (!f.b) {
                            a.v(h);
                        }
                    }
                    a.w(i);
                    a.y();
                }
            }
        }
        e(a, b, c) {
            if (b != null) {
                for (let d = 0; d < b.count; d++) {
                    let e = b._inner[d];
                    this.d(e);
                    let f = e.c._inner[0];
                    let g = e.c._inner[1];
                    let h = e.c._inner[2];
                    let i = new TreemapNodeVisualData();
                    i.c = new RectangleVisualData(1, "NodePath", f);
                    i.b = new RectangleVisualData(1, "HeaderRect", g);
                    let j = new TreemapLabelVisualData();
                    j.labelPosition = new PointData(h.n, h.o);
                    if (e.b) {
                        j.labelSize = new SizeData(c.aa(h.al), c.z(h.al));
                    }
                    else {
                        j.labelSize = new SizeData(c.y(h.al), c.x(h.al));
                    }
                    j.labelValue = h.al;
                    j.appearance = AppearanceHelper.c(h, e.a);
                    i.a = j;
                    a.nodes.add(i);
                }
            }
        }
    }
    TreemapViewRenderer.$t = /*@__PURE__*/ markType(TreemapViewRenderer, 'TreemapViewRenderer');
    return TreemapViewRenderer;
})();
/**
 * @hidden
 */
export let TreemapLayoutCalculator = /*@__PURE__*/ (() => {
    class TreemapLayoutCalculator extends Base {
        static c(a, b, c, d) {
            let e = a.e();
            let f = d.f;
            let g = f * f / (b.width * b.height);
            if (e / c < g) {
                return true;
            }
            return false;
        }
        static a(a, b, c, d, e) {
            for (let f = 0; f < c.count; f++) {
                let g = c._inner[f];
                if (!a.contains(g)) {
                    return false;
                }
            }
            return true;
        }
        static b(a, b) {
            if (a.width < b.f || a.height < b.f) {
                return true;
            }
            return false;
        }
        h(a, b, c) {
            return a.o(b);
        }
        i(a, b, c) {
            let d = a.o(b);
            if (d.isEmpty) {
                return d;
            }
            if (b.b != null && b.b.count > 0) {
                let e = c.i;
                let f = e.left + e.right;
                let g = e.top + e.bottom;
                let h = a.b(b);
                if (!h) {
                    return d;
                }
                let i = new Rect(0, d.left - e.left, d.top - e.top, d.width + f, d.height + g);
                return i;
            }
            else {
                return d;
            }
        }
        g(a, b, c, d) {
            if (b.b != null && b.b.count > 0) {
                let e = d.i;
                let f = e.left + e.right;
                let g = e.top + e.bottom;
                if (c.width < f || c.height < g) {
                    a.m(b, c);
                    return;
                }
                let h = new Rect(0, c.left + e.left, c.top + e.top, c.width - f, c.height - g);
                a.m(b, h);
                a.n(b, true);
            }
            else {
                a.m(b, c);
            }
        }
        f(a, b, c, d, e, f) {
            if (!TreemapLayoutCalculator.a(a, b, c, e, f)) {
                while (d > 0) {
                    let g = 0;
                    for (let h of fromEnum(c)) {
                        if (a.contains(h)) {
                            continue;
                        }
                        if (d > 0) {
                            let i = (d > 1) ? 1 : d;
                            let j = this.i(b, h, f);
                            if (j.isEmpty) {
                                continue;
                            }
                            this.g(b, h, new Rect(0, j.x + g, j.y, j.width + i, j.height), f);
                            d -= i;
                            g += i;
                        }
                        else {
                            let k = this.i(b, h, f);
                            if (k.isEmpty) {
                                continue;
                            }
                            this.g(b, h, new Rect(0, k.x + g, k.y, k.width, k.height), f);
                        }
                    }
                }
            }
        }
        e(a, b, c, d, e, f) {
            if (!TreemapLayoutCalculator.a(a, b, c, e, f)) {
                while (d > 0) {
                    let g = 0;
                    for (let h of fromEnum(c)) {
                        if (a.contains(h)) {
                            continue;
                        }
                        if (d > 0) {
                            let i = (d > 1) ? 1 : d;
                            let j = this.i(b, h, f);
                            if (j.isEmpty) {
                                continue;
                            }
                            this.g(b, h, new Rect(0, j.x, j.y + g, j.width, j.height + i), f);
                            d -= i;
                            g += i;
                        }
                        else {
                            let k = this.i(b, h, f);
                            if (k.isEmpty) {
                                continue;
                            }
                            this.g(b, h, new Rect(0, k.x, k.y + g, k.width, k.height), f);
                        }
                    }
                }
            }
        }
    }
    TreemapLayoutCalculator.$t = /*@__PURE__*/ markType(TreemapLayoutCalculator, 'TreemapLayoutCalculator');
    return TreemapLayoutCalculator;
})();
/**
 * @hidden
 */
export let StrippedCalculator = /*@__PURE__*/ (() => {
    class StrippedCalculator extends TreemapLayoutCalculator {
        d(a, b) {
            a.g();
            this.o(a, b.b.a, b.h, b, 0);
        }
        q(a, b, c) {
            return c.j;
        }
        o(a, b, c, d, e) {
            if (d.g >= 0 && e > d.g) {
                return;
            }
            if (b == d.c) {
                d.d = true;
                this.g(a, b, c, d);
                let f = new Rect(0, c.left, c.top + d.e, c.width, c.height - d.e);
                c = f;
            }
            if (!d.d) {
                for (let g of fromEnum(b.b)) {
                    this.o(a, g, c, d, e + 1);
                }
                return;
            }
            let h = this.q(b, c, d);
            let i = h.left + h.right;
            let j = h.top + h.bottom;
            let k = new Rect(0, c.left, c.top, c.width, c.height);
            let l = d.a;
            if (i >= k.width || j >= k.height) {
                return;
            }
            k.x = k.x + h.left;
            k.width = k.width - i;
            k.y = k.y + h.top;
            k.height = k.height - j;
            let m = new HashSet$1(TreemapTreeNode.$, 0);
            StrippedCalculator.p(m, d, b.b, k);
            let n = 0;
            for (let o = 0; o < b.b.count; o++) {
                let p = b.b._inner[o];
                if (!m.contains(p)) {
                    n += p.e();
                }
            }
            let q = n;
            let r = (k.width * k.height) / q;
            let s = l == 0 ? k.width : k.height;
            let t = new List$1(TreemapTreeNode.$, 0);
            let u = new List$1(TreemapTreeNode.$, 0);
            for (let v = 0; v < b.b.count; v++) {
                let w = b.b._inner[v];
                if (m.contains(w) || isNaN_(w.e())) {
                    continue;
                }
                let x = StrippedCalculator.j(u, s, r);
                u.add(w);
                let y = StrippedCalculator.j(u, s, r);
                if (x < y) {
                    if (t.count > 0) {
                        let z = this.m(m, a, d, t, r, k, l, false);
                        k = z.p5;
                    }
                    u.removeAt(u.count - 1);
                    t.o(u);
                    u.clear();
                    u.add(w);
                }
            }
            let aa = StrippedCalculator.j(t, s, r);
            let ab = StrippedCalculator.j(u, s, r);
            let ac = new List$1(TreemapTreeNode.$, 0);
            ac.o(t);
            ac.o(u);
            let ad = StrippedCalculator.j(ac, s, r);
            if (ad < (aa + ab) / 2 || k.height < d.f * 2) {
                let ae = this.m(m, a, d, ac, r, k, l, true);
                k = ae.p5;
            }
            else {
                let af = this.m(m, a, d, t, r, k, l, false);
                k = af.p5;
                let ag = this.m(m, a, d, u, r, k, l, true);
                k = ag.p5;
            }
            for (let ah = 0; ah < b.b.count; ah++) {
                let ai = b.b._inner[ah];
                if (m.contains(ai)) {
                    continue;
                }
                let aj = this.h(a, ai, d);
                if (aj.isEmpty) {
                    continue;
                }
                let ak = new Rect(0, aj.left, aj.top + d.e, aj.width, Math.max(aj.height - d.e, 0));
                this.o(a, ai, ak, d, e + 1);
            }
            if (b == d.c) {
                d.d = false;
            }
        }
        m(a, b, c, d, e, f, g, h) {
            if (d.count == 0) {
                return {
                    p5: f
                };
            }
            if (g == 0) {
                let i = this.l(a, b, c, d, e, f, h);
                f = i.p5;
            }
            else {
                let j = this.n(a, b, c, d, e, f, h);
                f = j.p5;
            }
            return {
                p5: f
            };
        }
        l(a, b, c, d, e, f, g) {
            let h = StrippedCalculator.k(d);
            if (h <= 0) {
                return {
                    p5: f
                };
            }
            let i = f.width;
            let j = (h * e) / i;
            let k = f.x;
            let l = 0;
            for (let m = 0; m < d.count; ++m) {
                let n = d._inner[m];
                let o = Math.floor((n.e() / h) * i);
                let p = new Rect(0, k, f.y, o, j);
                if (TreemapLayoutCalculator.b(p, c)) {
                    a.add_1(n);
                }
                else {
                    l = p.right;
                    this.g(b, n, p, c);
                }
                if (a.contains(n)) {
                    h -= n.e();
                }
                else {
                    k += o;
                }
            }
            this.f(a, b, d, f.right - k, f, c);
            f.y = f.y + j;
            if (f.height < j) {
                f.height = 0;
            }
            else {
                f.height = f.height - j;
            }
            d.clear();
            return {
                p5: f
            };
        }
        n(a, b, c, d, e, f, g) {
            let h = StrippedCalculator.k(d);
            if (h <= 0) {
                return {
                    p5: f
                };
            }
            let i = f.height;
            let j = (h * e) / i;
            let k = f.y;
            let l = 0;
            for (let m = 0; m < d.count; ++m) {
                let n = d._inner[m];
                let o = Math.floor((n.e() / h) * i);
                let p = new Rect(0, f.x, k, j, o);
                if (TreemapLayoutCalculator.b(p, c)) {
                    a.add_1(n);
                }
                else {
                    l = p.bottom;
                    this.g(b, n, p, c);
                }
                if (a.contains(n)) {
                    h -= n.e();
                }
                else {
                    k += o;
                }
            }
            this.e(a, b, d, f.bottom - k, f, c);
            f.x = f.x + j;
            if (f.width < j) {
                f.width = 0;
            }
            else {
                f.width = f.width - j;
            }
            d.clear();
            return {
                p5: f
            };
        }
        static j(a, b, c) {
            if (a.count == 0) {
                return 1.7976931348623157E+308;
            }
            let d = StrippedCalculator.k(a);
            let e = (d * c) / b;
            let f = 0;
            for (let g = 0; g < a.count; g++) {
                let h = a._inner[g];
                let i = (h.e() / d) * b;
                f += Math.max(i / e, e / i);
            }
            f /= a.count;
            return f;
        }
        static k(a) {
            let b = 0;
            for (let c = 0; c < a.count; c++) {
                let d = a._inner[c];
                b += d.e();
            }
            return b;
        }
        static p(a, b, c, d) {
            let e = 0;
            for (let f = 0; f < c.count; f++) {
                let g = c._inner[f];
            }
            let h = e;
            let i = b.f * b.f / (d.width * d.height);
            for (let j = 0; j < c.count; j++) {
                let k = c._inner[j];
                if (k.e() / h < i) {
                    a.add_1(k);
                }
            }
        }
    }
    StrippedCalculator.$t = /*@__PURE__*/ markType(StrippedCalculator, 'StrippedCalculator', TreemapLayoutCalculator.$);
    return StrippedCalculator;
})();
/**
 * @hidden
 */
export let SliceAndDiceCalculator = /*@__PURE__*/ (() => {
    class SliceAndDiceCalculator extends TreemapLayoutCalculator {
        d(a, b) {
            a.g();
            this.m(a, b.b.a, b.h, b, 0);
        }
        o(a, b, c) {
            return c.j;
        }
        m(a, b, c, d, e) {
            if (d.g >= 0 && e > d.g) {
                return;
            }
            if (b == d.c) {
                d.d = true;
                this.g(a, b, c, d);
                let f = new Rect(0, c.left, c.top + d.e, c.width, c.height - d.e);
                c = f;
            }
            if (!d.d) {
                for (let g of fromEnum(b.b)) {
                    this.m(a, g, c, d, e + 1);
                }
                return;
            }
            let h = this.o(b, c, d);
            let i = SliceAndDiceCalculator.j(b, d, e);
            let j = h.left + h.right;
            let k = h.top + h.bottom;
            let l = new Rect(0, c.left, c.top, c.width, c.height);
            if (j >= l.width || k >= l.height) {
                return;
            }
            l.x = l.x + h.left;
            l.width = l.width - j;
            l.y = l.y + h.top;
            l.height = l.height - k;
            let m = new Size(1, l.width, l.height);
            let n = l.left;
            let o = l.top;
            let p = new HashSet$1(TreemapTreeNode.$, 0);
            let q = SliceAndDiceCalculator.k(b.b, b, d, m, p);
            if (q) {
                SliceAndDiceCalculator.n(b.b, b, d, m, p);
            }
            let r = 0;
            for (let s = 0; s < b.b.count; s++) {
                let t = b.b._inner[s];
                if (!p.contains(t)) {
                    r += t.e();
                }
            }
            let u = (i == 0) ? m.height : m.width;
            let v = new Rect(4);
            for (let w = 0; w < b.b.count; w++) {
                let x = b.b._inner[w];
                if (p.contains(x) || isNaN_(x.e())) {
                    continue;
                }
                if (r <= 0 || u <= 0) {
                    break;
                }
                let y = x.e() / r;
                v.x = n;
                v.y = o;
                if (i == 0) {
                    v.width = m.width;
                    v.height = Math.round(u * y);
                }
                else {
                    v.width = Math.round(u * y);
                    v.height = m.height;
                }
                this.g(a, x, new Rect(0, v.left, v.top, v.width, v.height), d);
                if (i == 0) {
                    o += v.height;
                    u -= v.height;
                }
                else {
                    n += v.width;
                    u -= v.width;
                }
                r -= x.e();
                let z = this.h(a, x, d);
                if (z.isEmpty) {
                    continue;
                }
                let aa = new Rect(0, z.left, z.top + d.e, z.width, Math.max(z.height - d.e, 0));
                this.m(a, x, aa, d, e + 1);
            }
            if (b == d.c) {
                d.d = false;
            }
        }
        static j(a, b, c) {
            let d = 0;
            if (b.a == 0) {
                d = (c % 2 == 0) ? 0 : 1;
            }
            else {
                d = (c % 2 == 0) ? 1 : 0;
            }
            return d;
        }
        static k(a, b, c, d, e) {
            let f = true;
            let g = b.e();
            let h = Math.min(d.width, d.height);
            for (let i = 0; i < a.count; i++) {
                let j = a._inner[i];
                if (Math.round(j.e() / g * h) < c.f) {
                    if (!e.contains(j)) {
                        e.add_1(j);
                    }
                }
                else {
                    f = false;
                }
            }
            return f;
        }
        static n(a, b, c, d, e) {
            let f = new List$1(TreemapTreeNode.$, 0);
            f.o(a);
            f.aa((g, h) => {
                if (g.e() > h.e()) {
                    return 1;
                }
                else if (g.e() < h.e()) {
                    return -1;
                }
                return 0;
            });
            let g = 0;
            let h = Math.min(d.width, d.height);
            for (let i = 0; i < f.count; i++) {
                let j = f._inner[i];
                if (isNaN_(j.e())) {
                    continue;
                }
                g += j.e();
                if (j.e() / g * h < c.f) {
                    break;
                }
                else {
                    if (e.contains(j)) {
                        e.remove(j);
                    }
                }
            }
        }
    }
    SliceAndDiceCalculator.$t = /*@__PURE__*/ markType(SliceAndDiceCalculator, 'SliceAndDiceCalculator', TreemapLayoutCalculator.$);
    SliceAndDiceCalculator.l = null;
    return SliceAndDiceCalculator;
})();
/**
 * @hidden
 */
export let TreemapLayoutSettings = /*@__PURE__*/ (() => {
    class TreemapLayoutSettings extends Base {
        constructor() {
            super();
            this.a = 0;
            this.h = null;
            this.b = null;
            this.j = null;
            this.i = null;
            this.e = 0;
            this.f = 0;
            this.g = 0;
            this.c = null;
            this.d = false;
            this.g = -1;
            this.d = false;
        }
    }
    TreemapLayoutSettings.$t = /*@__PURE__*/ markType(TreemapLayoutSettings, 'TreemapLayoutSettings');
    return TreemapLayoutSettings;
})();
/**
 * @hidden
 */
export let SquarifiedCalculator = /*@__PURE__*/ (() => {
    class SquarifiedCalculator extends TreemapLayoutCalculator {
        n(a, b, c, d, e) {
            if (d.g >= 0 && e > d.g) {
                return;
            }
            if (b == d.c) {
                d.d = true;
                this.g(a, b, c, d);
                let f = new Rect(0, c.left, c.top + d.e, c.width, c.height - d.e);
                c = f;
            }
            if (!d.d) {
                for (let g of fromEnum(b.b)) {
                    this.n(a, g, c, d, e + 1);
                }
                return;
            }
            let h = this.o(b, c, d);
            let i = new Rect(0, c.left, c.top, c.width, c.height);
            let j = h.left + h.right;
            let k = h.top + h.bottom;
            if (j >= i.width || k >= i.height) {
                return;
            }
            i.x = i.x + h.left;
            i.width = i.width - j;
            i.y = i.y + h.top;
            i.height = i.height - k;
            let l = i.left;
            let m = i.top;
            let n = new List$1(TreemapTreeNode.$, 0);
            let o = b.e();
            let p = new Rect(0, i.left, i.top, i.width, i.height);
            let q = (i.width * i.height) / o;
            let r = new List$1(TreemapTreeNode.$, 1, b.b);
            r.aa((s, t) => {
                if (t.e() < s.e()) {
                    return -1;
                }
                if (t.e() > s.e()) {
                    return 1;
                }
                return 0;
            });
            let s = new AreaInfo();
            s.b = i;
            s.a = o;
            let t = new HashSet$1(TreemapTreeNode.$, 0);
            for (let u of fromEnum(r)) {
                if (TreemapLayoutCalculator.c(u, p, o, d) || isNaN_(u.e())) {
                    t.add_1(u);
                    continue;
                }
                let v = Math.min(i.width, i.height);
                let w = SquarifiedCalculator.j(n, v, q);
                n.add(u);
                let x = SquarifiedCalculator.j(n, v, q);
                if (w <= x) {
                    n.removeAt(n.count - 1);
                    this.l(t, a, n, s, d);
                    i = s.b;
                    n.add(u);
                }
            }
            this.l(t, a, n, s, d);
            i = s.b;
            for (let y of fromEnum(b.b)) {
                if (t.contains(y)) {
                    continue;
                }
                let z = this.h(a, y, d);
                if (z.isEmpty) {
                    continue;
                }
                let aa = new Rect(0, z.left, z.top + d.e, z.width, Math.max(z.height - d.e, 0));
                this.n(a, y, aa, d, e + 1);
            }
            if (b == d.c) {
                d.d = false;
            }
        }
        o(a, b, c) {
            return c.j;
        }
        static j(a, b, c) {
            if (a.count == 0) {
                return 1.7976931348623157E+308;
            }
            let d = 0;
            let e = 1.7976931348623157E+308;
            let f = -1.7976931348623157E+308;
            for (let g of fromEnum(a)) {
                let h = g.e() * c;
                if (e > h) {
                    e = h;
                }
                if (f < h) {
                    f = h;
                }
                d += h;
            }
            let i = (b * b * f) / (d * d);
            let j = (d * d) / (b * b * e);
            return Math.max(i, j);
        }
        l(a, b, c, d, e) {
            if (c.count < 1) {
                return;
            }
            let f = 0;
            for (let g = 0; g < c.count; ++g) {
                f += c._inner[g].e();
            }
            if (f <= 0) {
                return;
            }
            if (d.b.width > d.b.height) {
                this.k(a, b, c, f, d, e);
            }
            else {
                this.m(a, b, c, f, d, e);
            }
        }
        m(a, b, c, d, e, f) {
            let g = e.b;
            let h = e.a;
            let i = Math.round((d / h) * g.height);
            let j = g.x;
            for (let k = 0; k < c.count; ++k) {
                let l = c._inner[k];
                if (g.right < j) {
                    a.add_1(l);
                    continue;
                }
                let m = Math.floor((l.e() / d) * g.width);
                let n = new Rect(0, j, g.y, m, i);
                if (TreemapLayoutCalculator.b(n, f)) {
                    a.add_1(l);
                    continue;
                }
                this.g(b, l, n, f);
                j += n.width;
            }
            this.f(a, b, c, g.right - j, g, f);
            g.y = g.y + i;
            if (g.height < i) {
                g.height = 0;
            }
            else {
                g.height = g.height - i;
            }
            h -= d;
            e.a = h;
            e.b = g;
            c.clear();
        }
        k(a, b, c, d, e, f) {
            let g = e.b;
            let h = e.a;
            let i = Math.round((d / h) * g.width);
            let j = g.y;
            for (let k = 0; k < c.count; ++k) {
                let l = c._inner[k];
                if (g.bottom < j) {
                    a.add_1(l);
                    continue;
                }
                let m = Math.floor((l.e() / d) * g.height);
                let n = new Rect(0, g.x, j, i, m);
                if (TreemapLayoutCalculator.b(n, f)) {
                    a.add_1(l);
                    continue;
                }
                this.g(b, l, n, f);
                j += n.height;
            }
            this.e(a, b, c, g.bottom - j, g, f);
            g.x = g.x + i;
            if (g.width < i) {
                g.width = 0;
            }
            else {
                g.width = g.width - i;
            }
            h -= d;
            e.a = h;
            e.b = g;
            c.clear();
        }
        d(a, b) {
            a.g();
            this.n(a, b.b.a, b.h, b, 0);
        }
    }
    SquarifiedCalculator.$t = /*@__PURE__*/ markType(SquarifiedCalculator, 'SquarifiedCalculator', TreemapLayoutCalculator.$);
    return SquarifiedCalculator;
})();
/**
 * @hidden
 */
export let TreemapTreeData = /*@__PURE__*/ (() => {
    class TreemapTreeData extends Base {
        constructor() {
            super();
            this.a = null;
            this.b = null;
            this.d = null;
            this.c = null;
            this.b = new Dictionary$2(String_$type, TreemapTreeNode.$, 0);
            this.d = new List$1(String_$type, 0);
            this.c = new Dictionary$2(String_$type, List$1.$.specialize(TreemapTreeNode.$), 0);
            this.a = new TreemapTreeNode();
        }
        e(a) {
            this.b.addItem(a.i, a);
            this.d.add(a.i);
            if (a.k == null) {
                this.a.b.add(a);
            }
            else if (this.b.containsKey(a.k)) {
                this.b.item(a.k).b.add(a);
            }
            else {
                let b;
                if (!((() => { let c = this.c.tryGetValue(a.k, b); b = c.p1; return c.ret; })())) {
                    b = new List$1(TreemapTreeNode.$, 0);
                    this.c.item(a.k, b);
                }
                b.add(a);
            }
            if (this.c.containsKey(a.i)) {
                for (let c of fromEnum(this.c.item(a.i))) {
                    a.b.add(c);
                }
                this.c.removeItem(a.i);
            }
        }
        g(a) {
            if (isNaN_(a.f)) {
                if (a.b.count > 0) {
                    a.d = 0;
                }
                for (let b = 0; b < a.b.count; b++) {
                    let c = a.b._inner[b];
                    this.g(c);
                    if (isNaN_(c.f)) {
                        a.d = a.d + c.d;
                    }
                    else {
                        a.d = a.d + c.f;
                    }
                }
            }
        }
        f() {
            this.g(this.a);
        }
    }
    TreemapTreeData.$t = /*@__PURE__*/ markType(TreemapTreeData, 'TreemapTreeData');
    return TreemapTreeData;
})();
/**
 * @hidden
 */
export let TreemapTreeNode = /*@__PURE__*/ (() => {
    class TreemapTreeNode extends Base {
        constructor() {
            super();
            this.i = null;
            this.k = null;
            this.b = null;
            this.c = null;
            this.f = 0;
            this.g = null;
            this.d = 0;
            this.j = null;
            this.h = null;
            this.a = false;
            this.b = new List$1(TreemapTreeNode.$, 0);
            this.f = NaN;
            this.g = null;
            this.c = new List$1(TreemapNodeStyleMapping.$, 0);
            this.d = 0;
        }
        e() {
            if (isNaN_(this.f)) {
                return this.d;
            }
            return this.f;
        }
    }
    TreemapTreeNode.$t = /*@__PURE__*/ markType(TreemapTreeNode, 'TreemapTreeNode');
    return TreemapTreeNode;
})();
/**
 * @hidden
 */
export let Treemap = /*@__PURE__*/ (() => {
    class Treemap extends Base {
        constructor() {
            super();
            this.g = null;
            this.f = null;
            this.e = null;
            this.ba = false;
            this.an = null;
            this.im = null;
            this.ap = null;
            this.ea = null;
            this.d9 = "Root";
            this.d4 = " : ";
            this.d8 = null;
            this.d7 = null;
            this.d5 = null;
            this.d6 = null;
            this.bq = null;
            this.a = new BrushCollection();
            this.ae = new TreemapNodeStyleMappingCollection();
            this.c = 0;
            this.bb = false;
            this.dw = 10;
            this.bx = NaN;
            this.bw = NaN;
            this.n = 0;
            this.k = 0;
            this.hy = null;
            this.hs = null;
            this.hq = null;
            this.hx = null;
            this.hv = null;
            this.hr = null;
            this.hz = null;
            this.hp = null;
            this.hu = null;
            this.ht = null;
            this.at = null;
            this.as = null;
            this.h = 0;
            this.b0 = DeviceUtils.g(5);
            this.b2 = DeviceUtils.g(3);
            this.b1 = DeviceUtils.g(5);
            this.bz = DeviceUtils.g(3);
            this.ca = DeviceUtils.g(10);
            this.cc = DeviceUtils.g(10);
            this.cb = DeviceUtils.g(10);
            this.b9 = DeviceUtils.g(10);
            this.b5 = DeviceUtils.g(5);
            this.b7 = DeviceUtils.g(3);
            this.b6 = DeviceUtils.g(5);
            this.b4 = DeviceUtils.g(3);
            this.cf = DeviceUtils.g(0);
            this.cj = DeviceUtils.g(0);
            this.ch = DeviceUtils.g(0);
            this.cd = DeviceUtils.g(0);
            this.cg = DeviceUtils.g(3);
            this.ck = DeviceUtils.g(3);
            this.ci = DeviceUtils.g(3);
            this.ce = DeviceUtils.g(3);
            this.hm = 1;
            this.iq = 1;
            this.by = NaN;
            this.hw = null;
            this.cm = NaN;
            this.ah = 0;
            this.r = 0;
            this.b8 = DeviceUtils.g(3);
            this.dx = 500;
            this.cn = 0;
            this.dv = null;
            this.aq = null;
            this.a1 = null;
            this.ax = null;
            this.a0 = null;
            this.ay = null;
            this.az = null;
            this.cl = NaN;
            this.bt = 1;
            this.b3 = NaN;
            this.bs = 0.5;
            this.a9 = false;
            this.bf = false;
            this.bi = false;
            this.be = false;
            this.aj = null;
            this.q = null;
            this.bu = NaN;
            this.bv = DeviceUtils.g(1);
            this.propertyChanged = null;
            this.w = null;
            this.t = null;
            this.d2 = null;
            this.am = null;
            this.al = null;
            this.il = null;
            this.nodeStyling = null;
            this.nodePointerOver = null;
            this.nodePointerEnter = null;
            this.nodePointerLeave = null;
            this.nodePointerPressed = null;
            this.nodePointerReleased = null;
            let a = new TreemapView();
            a.a = this;
            this.q = new SquarifiedCalculator();
            this.an = a;
            this.an.aw();
            this.dv = (b, c) => this.go(c.action, c.position, c.count, c.propertyName);
            this.im = Rect.empty;
            this.g = new TreemapFrame();
            this.f = new TreemapFrame();
            this.e = new TreemapFrame();
            this.bf = true;
            this.ap = new DoubleAnimator(0, 1, this.d1);
            this.ap.b = EasingFunctions.cubicEase;
            let b = this.ap;
            b.propertyChanged = delegateCombine(b.propertyChanged, runOn(this, this.gn));
            let c = this.ae;
            c.collectionChanged = delegateCombine(c.collectionChanged, runOn(this, this.gl));
            let d = this.ae;
            d.collectionResetting = delegateCombine(d.collectionResetting, runOn(this, this.gm));
        }
        gm(a, b) {
            for (let c of fromEnum(this.styleMappings)) {
                c.propertyChanged = delegateRemove(c.propertyChanged, runOn(this, this.hi));
            }
            this.bf = true;
            this.bi = true;
            this.an.a1();
        }
        gl(a, b) {
            if (b.oldItems != null) {
                for (let c of fromEn(b.oldItems)) {
                    let d = c;
                    if (d != null) {
                        d.propertyChanged = delegateRemove(d.propertyChanged, runOn(this, this.hi));
                    }
                }
            }
            if (b.newItems != null) {
                for (let e of fromEn(b.newItems)) {
                    let f = e;
                    if (f != null) {
                        f.propertyChanged = delegateCombine(f.propertyChanged, runOn(this, this.hi));
                    }
                }
            }
            this.bf = true;
            this.bi = true;
            this.an.a1();
        }
        hi(a, b) {
            this.bf = true;
            this.bi = true;
            this.an.a1();
        }
        go(a, b, c, d) {
            this.aj = null;
            this.bf = true;
            this.be = true;
            this.bi = true;
            this.an.a1();
        }
        notifySizeChanged() {
            this.an.ar();
        }
        destroy() {
            this.provideContainer(null);
        }
        ao() {
            let a = new TreemapVisualData();
            a.viewport = new RectData(this.ip.left, this.ip.top, this.ip.width, this.ip.height);
            a.nodes = new TreemapNodeVisualDataList();
            this.an.an(a);
            return a;
        }
        ej() {
            let a = this.ao();
            a.scaleByViewport();
            return a.serialize();
        }
        g7(a, b, c) {
            if (this.propertyChanged != null) {
                this.propertyChanged(this, new PropertyChangedEventArgs(a));
            }
            this.hc(a, b, c);
        }
        hc(a, b, c) {
            switch (a) {
                case "FocusItem":
                    this.g1();
                    break;
                case "LayoutType":
                    {
                        switch (EnumUtil.getEnumValue(TreemapLayoutType_$type, c)) {
                            case 0:
                                this.q = new SquarifiedCalculator();
                                break;
                            case 1:
                                this.q = new SliceAndDiceCalculator();
                                break;
                            case 2:
                                this.q = new StrippedCalculator();
                                break;
                        }
                        this.bf = true;
                        this.an.a1();
                    }
                    break;
                case "BreadcrumbSequence":
                    this.bf = true;
                    this.an.a1();
                    break;
                case "RootTitle":
                    this.bf = true;
                    this.an.a1();
                    break;
                case "ValueMemberPath":
                    if (this.ar != null) {
                        this.ar.deregisterColumn(this.a8);
                        this.a8 = this.a6(this.gi);
                        this.aj = null;
                    }
                    this.bf = true;
                    this.be = true;
                    this.an.a1();
                    break;
                case "CustomValueMemberPath":
                    if (this.ar != null) {
                        this.ar.deregisterColumn(this.a2);
                        this.a2 = this.a7(this.eg);
                        this.aj = null;
                    }
                    this.bf = true;
                    this.be = true;
                    this.an.a1();
                    break;
                case "IdMemberPath":
                    if (this.ar != null) {
                        this.ar.deregisterColumn(this.a3);
                        this.a3 = this.a7(this.e5);
                        this.aj = null;
                    }
                    this.bf = true;
                    this.be = true;
                    this.an.a1();
                    break;
                case "LabelMemberPath":
                    if (this.ar != null) {
                        this.ar.deregisterColumn(this.a4);
                        this.a4 = this.a7(this.ff);
                        this.aj = null;
                    }
                    this.bf = true;
                    this.be = true;
                    this.an.a1();
                    break;
                case "ParentIdMemberPath":
                    if (this.ar != null) {
                        this.ar.deregisterColumn(this.a5);
                        this.a5 = this.a7(this.fw);
                        this.aj = null;
                    }
                    this.bf = true;
                    this.be = true;
                    this.an.a1();
                    break;
                case "ItemsSource":
                    this.ar = ((() => {
                        let $ret = new FastItemsSource();
                        $ret.e = this.dataSource;
                        return $ret;
                    })());
                    break;
                case "HeaderLabelLeftMargin":
                case "HeaderLabelTopMargin":
                case "HeaderLabelRightMargin":
                case "HeaderLabelBottomMargin":
                case "LabelLeftMargin":
                case "LabelTopMargin":
                case "LabelRightMargin":
                case "LabelBottomMargin":
                case "ParentNodeLeftMargin":
                case "ParentNodeTopMargin":
                case "ParentNodeRightMargin":
                case "ParentNodeBottomMargin":
                case "ParentNodeLeftPadding":
                case "ParentNodeTopPadding":
                case "ParentNodeRightPadding":
                case "ParentNodeBottomPadding":
                case "HeaderTextColor":
                case "HeaderHoverTextColor":
                case "OverlayHeaderHoverBackground":
                case "HeaderHoverBackground":
                case "StrokeThickness":
                case "Outline":
                case "FillBrushes":
                case "IsFillScaleLogarithmic":
                case "FillScaleMinimumValue":
                case "FillScaleMaximumValue":
                case "HeaderBackground":
                case "OverlayHeaderBackground":
                case "HeaderHeight":
                case "FillScaleLogarithmBase":
                case "FillScaleMode":
                case "MinimumDisplaySize":
                case "LayoutOrientation":
                case "LabelHorizontalAlignment":
                case "LabelVerticalAlignment":
                case "HeaderDisplayMode":
                case "LabelHorizontalFitMode":
                case "LabelVerticalFitMode":
                    this.bf = true;
                    this.an.a1();
                    break;
                case "TextStyle":
                    this.an.ay(this.aw);
                    this.bf = true;
                    this.an.a1();
                    break;
                case "HeaderTextStyle":
                    this.an.av(this.au);
                    this.bf = true;
                    this.an.a1();
                    break;
                case "PixelScalingRatio":
                    if (!isNaN_(c)) {
                        this.cp = c;
                    }
                    break;
                case "ActualPixelScalingRatio":
                    if (isNaN_(this.c0)) {
                        this.co = this.cp / 2;
                    }
                    if (this.an != null) {
                        this.an.ax();
                    }
                    break;
                case "InteractionPixelScalingRatio":
                    if (!isNaN_(c)) {
                        this.co = c;
                    }
                    break;
                case "ActualInteractionPixelScalingRatio":
                    if (this.an != null) {
                        this.an.ax();
                    }
                    break;
                case "TransitionProgress":
                    if (this.du >= 1) {
                        this.ap.w();
                        this.an.ax();
                        let d = this.f;
                        this.f = this.g;
                        this.g = d;
                        this.hb();
                        this.he(this.f);
                        this.an.a0();
                        this.an.a1();
                        return;
                    }
                    this.e.h(this.du, this.g, this.f);
                    this.he(this.e);
                    this.an.a0();
                    break;
                case "Viewport":
                    this.bf = true;
                    this.an.a1();
                    break;
                case "FastItemsSource":
                    let e = b;
                    let f = c;
                    if (b != null) {
                        e.event = delegateRemove(e.event, this.dv);
                        this.a9 = false;
                        e.deregisterColumn(this.a8);
                        e.deregisterColumn(this.a3);
                        e.deregisterColumn(this.a5);
                        e.deregisterColumn(this.a4);
                        e.deregisterColumn(this.a2);
                        this.a8 = null;
                        this.a3 = null;
                        this.a5 = null;
                        this.a4 = null;
                        this.aj = null;
                    }
                    if (c != null) {
                        f.event = delegateCombine(f.event, this.dv);
                        this.a9 = true;
                        this.a8 = this.a6(this.gi);
                        this.a3 = this.a7(this.e5);
                        this.a5 = this.a7(this.fw);
                        this.a4 = this.a7(this.ff);
                        this.a2 = this.a7(this.eg);
                    }
                    this.bf = true;
                    this.be = true;
                    this.an.a1();
                    break;
                case "TransitionDuration":
                    this.ap.r = this.d1;
                    break;
            }
        }
        g1() {
            if (this.ba) {
                return;
            }
            if (this.aj == null) {
                return;
            }
            if (this.d3 == null) {
                this.al = null;
                this.bf = true;
                this.an.a1();
                return;
            }
            for (let a = 0; a < this.aj.d.count; a++) {
                let b = this.aj.b.item(this.aj.d._inner[a]);
                if (b.h == this.d3) {
                    this.al = b;
                    this.bf = true;
                    this.an.a1();
                    break;
                }
            }
        }
        get ip() {
            return this.im;
        }
        set ip(a) {
            let b = this.im;
            this.im = a;
            if (!b.equals1(this.im)) {
                this.g7("Viewport", b, this.im);
            }
        }
        gn(a, b) {
            this.du = this.ap.o;
        }
        get gi() {
            return this.ea;
        }
        set gi(a) {
            let b = this.ea;
            this.ea = a;
            if (b != this.ea) {
                this.hc("ValueMemberPath", b, a);
            }
        }
        get f8() {
            return this.d9;
        }
        set f8(a) {
            let b = this.d9;
            this.d9 = a;
            if (b != this.d9) {
                this.hc("RootTitle", b, a);
            }
        }
        get ed() {
            return this.d4;
        }
        set ed(a) {
            let b = this.d4;
            this.d4 = a;
            if (b != this.d9) {
                this.hc("BreadcrumbSequence", b, a);
            }
        }
        get fw() {
            return this.d8;
        }
        set fw(a) {
            let b = this.d8;
            this.d8 = a;
            if (b != this.d8) {
                this.g7("ParentIdMemberPath", b, a);
            }
        }
        get ff() {
            return this.d7;
        }
        set ff(a) {
            let b = this.d7;
            this.d7 = a;
            if (b != this.d7) {
                this.g7("LabelMemberPath", b, a);
            }
        }
        get eg() {
            return this.d5;
        }
        set eg(a) {
            let b = this.d5;
            this.d5 = a;
            if (b != this.d5) {
                this.g7("CustomValueMemberPath", b, a);
            }
        }
        get e5() {
            return this.d6;
        }
        set e5(a) {
            let b = this.d6;
            this.d6 = a;
            if (b != this.d6) {
                this.g7("IdMemberPath", b, a);
            }
        }
        get dataSource() {
            return this.bq;
        }
        set dataSource(a) {
            let b = this.bq;
            this.bq = a;
            if (b != this.bq) {
                this.g7("ItemsSource", b, a);
            }
        }
        get b() {
            return this.a;
        }
        set b(a) {
            let b = this.a;
            this.a = a;
            if (b != this.a) {
                this.g7("FillBrushes", b, a);
            }
        }
        get styleMappings() {
            return this.ae;
        }
        get d() {
            return this.c;
        }
        set d(a) {
            let b = this.c;
            this.c = a;
            if (b != this.c) {
                this.g7("FillScaleMode", enumGetBox(TreemapFillScaleMode_$type, b), enumGetBox(TreemapFillScaleMode_$type, a));
            }
        }
        get bg() {
            return this.bb;
        }
        set bg(a) {
            let b = this.bb;
            this.bb = a;
            if (b != this.bb) {
                this.g7("IsFillScaleLogarithmic", b, a);
            }
        }
        get dy() {
            return this.dw;
        }
        set dy(a) {
            let b = this.dw;
            this.dw = a;
            if (b != this.dw) {
                this.g7("FillScaleLogarithmBase", b, a);
            }
        }
        get ct() {
            return this.bx;
        }
        set ct(a) {
            let b = this.bx;
            this.bx = a;
            if (b != this.bx) {
                this.g7("FillScaleMinimumValue", b, a);
            }
        }
        get cs() {
            return this.bw;
        }
        set cs(a) {
            let b = this.bw;
            this.bw = a;
            if (b != this.bw) {
                this.g7("FillScaleMaximumValue", b, a);
            }
        }
        get p() {
            return this.n;
        }
        set p(a) {
            let b = this.n;
            this.n = a;
            if (b != this.n) {
                this.g7("LabelVerticalFitMode", enumGetBox(TreemapLabelVerticalFitMode_$type, b), enumGetBox(TreemapLabelVerticalFitMode_$type, a));
            }
        }
        get o() {
            return this.p == 0 ? 1 : this.p;
        }
        get m() {
            return this.k;
        }
        set m(a) {
            let b = this.k;
            this.k = a;
            if (b != this.k) {
                this.g7("LabelHorizontalFitMode", enumGetBox(TreemapLabelHorizontalFitMode_$type, b), enumGetBox(TreemapLabelHorizontalFitMode_$type, a));
            }
        }
        get l() {
            return this.m == 0 ? 1 : this.m;
        }
        get h9() {
            return this.hy;
        }
        set h9(a) {
            let b = this.hy;
            this.hy = a;
            if (b != this.hy) {
                this.g7("OverlayHeaderHoverBackground", b, a);
            }
        }
        get h3() {
            return this.hs;
        }
        set h3(a) {
            let b = this.hs;
            this.hs = a;
            if (b != this.hs) {
                this.g7("HeaderHoverBackground", b, a);
            }
        }
        get h1() {
            return this.hq;
        }
        set h1(a) {
            let b = this.hq;
            this.hq = a;
            if (b != this.hq) {
                this.g7("HeaderBackground", b, a);
            }
        }
        get h8() {
            return this.hx;
        }
        set h8(a) {
            let b = this.hx;
            this.hx = a;
            if (b != this.hx) {
                this.g7("OverlayHeaderBackground", b, a);
            }
        }
        get h6() {
            return this.hv;
        }
        set h6(a) {
            let b = this.hv;
            this.hv = a;
            if (b != this.hv) {
                this.g7("HeaderTextColor", b, a);
            }
        }
        get h2() {
            return this.hr;
        }
        set h2(a) {
            let b = this.hr;
            this.hr = a;
            if (b != this.hr) {
                this.g7("HeaderDarkTextColor", b, a);
            }
        }
        get ik() {
            return this.hz;
        }
        set ik(a) {
            let b = this.hz;
            this.hz = a;
            if (b != this.hz) {
                this.g7("TextColor", b, a);
            }
        }
        get h0() {
            return this.hp;
        }
        set h0(a) {
            let b = this.hp;
            this.hp = a;
            if (b != this.hp) {
                this.g7("DarkTextColor", b, a);
            }
        }
        get h5() {
            return this.hu;
        }
        set h5(a) {
            let b = this.hu;
            this.hu = a;
            if (b != this.hu) {
                this.g7("HeaderHoverTextColor", b, a);
            }
        }
        get h4() {
            return this.ht;
        }
        set h4(a) {
            let b = this.ht;
            this.ht = a;
            if (b != this.ht) {
                this.g7("HeaderHoverDarkTextColor", b, a);
            }
        }
        get aw() {
            return this.at;
        }
        set aw(a) {
            let b = this.at;
            this.at = a;
            if (b != this.at) {
                this.g7("TextStyle", b, this.at);
            }
        }
        get au() {
            return this.as;
        }
        set au(a) {
            let b = this.as;
            this.as = a;
            if (b != this.as) {
                this.g7("HeaderTextStyle", b, this.as);
            }
        }
        get j() {
            return this.h;
        }
        set j(a) {
            let b = this.h;
            this.h = a;
            if (b != this.h) {
                this.g7("HeaderDisplayMode", enumGetBox(TreemapHeaderDisplayMode_$type, b), enumGetBox(TreemapHeaderDisplayMode_$type, this.h));
            }
        }
        get i() {
            return this.j == 0 ? 1 : this.j;
        }
        get cx() {
            return this.b0;
        }
        set cx(a) {
            let b = this.b0;
            this.b0 = a;
            if (b != this.b0) {
                this.g7("HeaderLabelLeftMargin", b, a);
            }
        }
        get cz() {
            return this.b2;
        }
        set cz(a) {
            let b = this.b2;
            this.b2 = a;
            if (b != this.b2) {
                this.g7("HeaderLabelTopMargin", b, a);
            }
        }
        get cy() {
            return this.b1;
        }
        set cy(a) {
            let b = this.b1;
            this.b1 = a;
            if (b != this.b1) {
                this.g7("HeaderLabelRightMargin", b, a);
            }
        }
        get cw() {
            return this.bz;
        }
        set cw(a) {
            let b = this.bz;
            this.bz = a;
            if (b != this.bz) {
                this.g7("HeaderLabelBottomMargin", b, a);
            }
        }
        get c7() {
            return this.ca;
        }
        set c7(a) {
            let b = this.ca;
            this.ca = a;
            if (b != this.ca) {
                this.g7("OverlayHeaderLabelLeftMargin", b, a);
            }
        }
        get c9() {
            return this.cc;
        }
        set c9(a) {
            let b = this.cc;
            this.cc = a;
            if (b != this.cc) {
                this.g7("OverlayHeaderLabelTopMargin", b, a);
            }
        }
        get c8() {
            return this.cb;
        }
        set c8(a) {
            let b = this.cb;
            this.cb = a;
            if (b != this.cb) {
                this.g7("OverlayHeaderLabelRightMargin", b, a);
            }
        }
        get c6() {
            return this.b9;
        }
        set c6(a) {
            let b = this.b9;
            this.b9 = a;
            if (b != this.b9) {
                this.g7("OverlayHeaderLabelBottomMargin", b, a);
            }
        }
        get c2() {
            return this.b5;
        }
        set c2(a) {
            let b = this.b5;
            this.b5 = a;
            if (b != this.b5) {
                this.g7("LabelLeftMargin", b, a);
            }
        }
        get c4() {
            return this.b7;
        }
        set c4(a) {
            let b = this.b7;
            this.b7 = a;
            if (b != this.b7) {
                this.g7("LabelTopMargin", b, a);
            }
        }
        get c3() {
            return this.b6;
        }
        set c3(a) {
            let b = this.b6;
            this.b6 = a;
            if (b != this.b6) {
                this.g7("LabelRightMargin", b, a);
            }
        }
        get c1() {
            return this.b4;
        }
        set c1(a) {
            let b = this.b4;
            this.b4 = a;
            if (b != this.b4) {
                this.g7("LabelBottomMargin", b, a);
            }
        }
        get dc() {
            return this.cf;
        }
        set dc(a) {
            let b = this.cf;
            this.cf = a;
            if (b != this.cf) {
                this.g7("ParentNodeLeftMargin", b, a);
            }
        }
        get dg() {
            return this.cj;
        }
        set dg(a) {
            let b = this.cj;
            this.cj = a;
            if (b != this.cj) {
                this.g7("ParentNodeTopMargin", b, a);
            }
        }
        get de() {
            return this.ch;
        }
        set de(a) {
            let b = this.ch;
            this.ch = a;
            if (b != this.ch) {
                this.g7("ParentNodeRightMargin", b, a);
            }
        }
        get da() {
            return this.cd;
        }
        set da(a) {
            let b = this.cd;
            this.cd = a;
            if (b != this.cd) {
                this.g7("ParentNodeBottomMargin", b, a);
            }
        }
        get dd() {
            return this.cg;
        }
        set dd(a) {
            let b = this.cg;
            this.cg = a;
            if (b != this.cg) {
                this.g7("ParentNodeLeftPadding", b, a);
            }
        }
        get dh() {
            return this.ck;
        }
        set dh(a) {
            let b = this.ck;
            this.ck = a;
            if (b != this.ck) {
                this.g7("ParentNodeTopPadding", b, a);
            }
        }
        get df() {
            return this.ci;
        }
        set df(a) {
            let b = this.ci;
            this.ci = a;
            if (b != this.ci) {
                this.g7("ParentNodeRightPadding", b, a);
            }
        }
        get db() {
            return this.ce;
        }
        set db(a) {
            let b = this.ce;
            this.ce = a;
            if (b != this.ce) {
                this.g7("ParentNodeBottomPadding", b, a);
            }
        }
        get hn() {
            return this.hm;
        }
        set hn(a) {
            let b = this.hm;
            this.hm = a;
            if (b != this.hm) {
                this.g7("LabelHorizontalAlignment", enumGetBox(HorizontalAlignment_$type, b), enumGetBox(HorizontalAlignment_$type, a));
            }
        }
        get ir() {
            return this.iq;
        }
        set ir(a) {
            let b = this.iq;
            this.iq = a;
            if (b != this.iq) {
                this.g7("LabelVerticalAlignment", enumGetBox(VerticalAlignment_$type, b), enumGetBox(VerticalAlignment_$type, a));
            }
        }
        get cv() {
            return this.by;
        }
        set cv(a) {
            let b = this.by;
            this.by = a;
            if (b != this.by) {
                this.g7("HeaderHeight", b, a);
            }
        }
        get h7() {
            return this.hw;
        }
        set h7(a) {
            let b = this.hw;
            this.hw = a;
            if (b != this.hw) {
                this.g7("Outline", b, a);
            }
        }
        get dt() {
            return this.cm;
        }
        set dt(a) {
            let b = this.cm;
            this.cm = a;
            if (b != this.cm) {
                this.g7("StrokeThickness", b, a);
            }
        }
        get ai() {
            return this.ah;
        }
        set ai(a) {
            let b = this.ah;
            this.ah = a;
            if (b != this.ah) {
                this.g7("LayoutOrientation", enumGetBox(TreemapOrientation_$type, b), enumGetBox(TreemapOrientation_$type, a));
            }
        }
        get s() {
            return this.r;
        }
        set s(a) {
            let b = this.r;
            this.r = a;
            if (b != this.r) {
                this.g7("LayoutType", enumGetBox(TreemapLayoutType_$type, b), enumGetBox(TreemapLayoutType_$type, a));
            }
        }
        get c5() {
            return this.b8;
        }
        set c5(a) {
            let b = this.b8;
            this.b8 = a;
            if (b != this.b8) {
                this.g7("MinimumDisplaySize", b, a);
            }
        }
        get d1() {
            return this.dx;
        }
        set d1(a) {
            let b = this.dx;
            this.dx = a;
            if (b != this.dx) {
                this.g7("TransitionDuration", b, a);
            }
        }
        get du() {
            return this.cn;
        }
        set du(a) {
            let b = this.cn;
            this.cn = a;
            if (b != this.cn) {
                this.g7("TransitionProgress", b, a);
            }
        }
        get ar() {
            return this.aq;
        }
        set ar(a) {
            let b = this.aq;
            this.aq = a;
            if (b != this.aq) {
                this.g7("FastItemsSource", b, this.aq);
            }
        }
        get a8() {
            return this.a1;
        }
        set a8(a) {
            this.a1 = a;
        }
        get a2() {
            return this.ax;
        }
        set a2(a) {
            this.ax = a;
        }
        get a5() {
            return this.a0;
        }
        set a5(a) {
            this.a0 = a;
        }
        get a3() {
            return this.ay;
        }
        set a3(a) {
            this.ay = a;
        }
        get a4() {
            return this.az;
        }
        set a4(a) {
            this.az = a;
        }
        get di() {
            return this.cl;
        }
        set di(a) {
            let b = this.cl;
            this.cl = a;
            if (b != this.cl) {
                this.g7("PixelScalingRatio", b, a);
            }
        }
        get cp() {
            return this.bt;
        }
        set cp(a) {
            let b = this.bt;
            this.bt = a;
            if (b != this.bt) {
                this.g7("ActualPixelScalingRatio", b, a);
            }
        }
        get c0() {
            return this.b3;
        }
        set c0(a) {
            let b = this.b3;
            this.b3 = a;
            if (b != this.b3) {
                this.g7("InteractionPixelScalingRatio", b, a);
            }
        }
        get co() {
            return this.bs;
        }
        set co(a) {
            let b = this.bs;
            this.bs = a;
            if (b != this.bs) {
                this.g7("ActualInteractionPixelScalingRatio", b, a);
            }
        }
        a6(a) {
            let b = null;
            return this.ar.registerColumn(a, b, false);
        }
        a7(a) {
            let b = null;
            return this.ar.registerColumnObject(a, b, false);
        }
        gt() {
            this.bf = true;
            this.an.a1();
        }
        get bc() {
            return this.ap.f();
        }
        ak() {
            let a = new TreemapTreeData();
            if (this.a8 == null || (this.a4 == null && this.a3 == null)) {
                return null;
            }
            for (let b = 0; b < this.ar.count; b++) {
                let c = null;
                if (this.a2 != null && this.a2.count > b) {
                    c = this.a2.item(b);
                }
                let d = this.a8.item(b);
                let e = null;
                let f = "";
                if (this.a4 != null) {
                    f = this.a4.item(b) != null ? this.a4.item(b).toString() : "";
                }
                if (this.a3 != null) {
                    if (this.a3.item(b) == null) {
                        continue;
                    }
                    e = stringReplace(this.a3.item(b).toString(), " ", "_");
                }
                if (e == null) {
                    e = stringReplace(f, " ", "_");
                    if (stringIsNullOrEmpty(e)) {
                        continue;
                    }
                }
                let g = null;
                if (this.a5 != null) {
                    g = this.a5.item(b) != null ? stringReplace(this.a5.item(b).toString(), " ", "_") : null;
                }
                let h = new TreemapTreeNode();
                h.i = e;
                h.k = g;
                h.h = this.ar.item(b);
                h.f = d;
                h.g = c;
                h.j = f;
                a.e(h);
            }
            a.f();
            return a;
        }
        hb() {
            if (this.aj == null) {
                this.aj = this.ak();
                if (this.aj == null) {
                    return;
                }
                this.g1();
            }
            if (this.bi) {
                this.bi = false;
                for (let a = 0; a < this.aj.d.count; a++) {
                    let b = this.aj.b.item(this.aj.d._inner[a]);
                    b.c.clear();
                    for (let c = 0; c < this.styleMappings.count; c++) {
                        if (this.bd(this.styleMappings._inner[c], b)) {
                            b.c.add(this.styleMappings._inner[c]);
                        }
                    }
                }
            }
            if (!this.an.p()) {
                return;
            }
            let d = new TreemapLayoutSettings();
            d.b = this.aj;
            if (this.al != null && !this.aj.b.containsKey(this.al.i)) {
                this.al = null;
                this.hj(null);
            }
            else {
                if (this.al != null) {
                    let e = this.aj.b.item(this.al.i);
                    if (e != this.al) {
                        this.al = e;
                        this.hj(this.al);
                    }
                }
            }
            d.h = this.ip;
            d.c = this.al;
            d.f = this.c5;
            d.a = this.ai;
            let f = this.i;
            let g = this.dk();
            let h = this.dm();
            let i = this.dl();
            let j = this.dj();
            let k = this.dp();
            let l = this.dr();
            let m = this.dq();
            let n = this.dn();
            let o = this.ho();
            let p = this.is();
            let q = this.an.x("M");
            let r = this.an.z("M");
            let s = q + h + j;
            let t = r + l + n;
            d.j = new Thickness(1, this.dd, this.dh, this.df, this.db);
            d.i = new Thickness(1, this.dc, this.dg, this.de, this.da);
            if (!isNaN_(this.cv)) {
                s = this.cv;
            }
            d.e = s;
            if (f == 2) {
                d.e = 0;
            }
            d.d = this.al == null;
            this.q.d(this.f, d);
            let u = 1.7976931348623157E+308;
            let v = -1.7976931348623157E+308;
            if (this.d == 1 || this.d == 3) {
                for (let w = 0; w < this.aj.d.count; w++) {
                    let x = 0;
                    if (this.d == 1) {
                        x = this.aj.b.item(this.aj.d._inner[w]).e();
                    }
                    else {
                        x = this.aj.b.item(this.aj.d._inner[w]).f;
                    }
                    if (!isNaN_(x)) {
                        u = Math.min(x, u);
                        v = Math.max(x, v);
                    }
                }
            }
            else {
                for (let y = 0; y < this.f.e.count; y++) {
                    let z = 0;
                    if (this.d == 0) {
                        z = this.aj.b.item(this.f.e._inner[y]).e();
                    }
                    else {
                        z = this.aj.b.item(this.f.e._inner[y]).f;
                    }
                    if (!isNaN_(z)) {
                        u = Math.min(z, u);
                        v = Math.max(z, v);
                    }
                }
            }
            for (let aa = 0; aa < this.f.e.count; aa++) {
                let ab = this.f.e._inner[aa];
                let ac = this.aj.b.item(ab);
                let ad = this.ia(ac, u, v);
                let ae = this.ig(ac);
                let af = this.ib(ac);
                let ag = this.ds(ac);
                let ah = this.f7(this.f, ac, g, i, k, m, s, t);
                let ai = this.ie(ac, ad, af);
                let aj = this.av(ac);
                let ak = 0;
                if (this.bh(ac)) {
                    ak = this.an.y(ah);
                }
                else {
                    ak = this.an.aa(ah);
                }
                let al = 0;
                if (this.bh(ac)) {
                    al = s;
                }
                else {
                    al = this.an.z(ah);
                }
                this.f.l(ac, ah, ad, ae, af, ai, ag, f, ak, al, g, h, i, j, k, l, m, n, o, p);
                if (ac.c.count > 0) {
                    for (let am = 0; am < ac.c.count; am++) {
                        let an = ac.b != null && ac.b.count > 0;
                        if (ac.c._inner[am].bf == 2 && an) {
                            continue;
                        }
                        this.f.f(ac, ac.c._inner[am], runOn(this, this.ie));
                    }
                }
                if (this.nodeStyling != null) {
                    let ao = new TreemapNodeStylingEventArgs();
                    ao.item = ac.h;
                    if (ac.k != null) {
                        if (this.aj.b.containsKey(ac.k)) {
                            let ap = this.aj.b.item(ac.k);
                            ao.parentItem = ap.h;
                            ao.parentLabel = ap.j;
                            ao.parentSum = ap.e();
                            ao.parentValue = ap.f;
                        }
                    }
                    ao.sum = ac.e();
                    ao.value = ac.f;
                    ao.label = ac.j;
                    ao.customValue = ac.g;
                    if (ac.b != null && ac.b.count > 0) {
                        ao.isParent = true;
                    }
                    ao.style = new TreemapNodeStyle();
                    this.nodeStyling(this, ao);
                    this.f.f(ac, ao.style, runOn(this, this.ie));
                }
            }
        }
        bh(a) {
            return a.b != null && a.b.count > 0;
        }
        dn() {
            return this.c1;
        }
        dq() {
            return this.c3;
        }
        dr() {
            return this.c4;
        }
        dp() {
            return this.c2;
        }
        ho() {
            return this.hn;
        }
        is() {
            return this.ir;
        }
        dj() {
            if (this.i == 2) {
                return this.c6;
            }
            return this.cw;
        }
        dl() {
            if (this.i == 2) {
                return this.c8;
            }
            return this.cy;
        }
        dm() {
            if (this.i == 2) {
                return this.c9;
            }
            return this.cz;
        }
        dk() {
            if (this.i == 2) {
                return this.c6;
            }
            return this.cx;
        }
        gg(a, b, c, d, e) {
            let f = b.length;
            let g = b;
            let h = ("\u2026");
            if (isNaN_(this.bu)) {
                if (this.bh(a)) {
                    this.bu = this.an.y(h);
                }
                else {
                    this.bu = this.an.aa(h);
                }
            }
            if (c <= (this.bu + d + e)) {
                if (this.l == 2) {
                    return "";
                }
                return h;
            }
            let i = 0;
            if (this.bh(a)) {
                i = this.an.y(b);
            }
            else {
                i = this.an.aa(b);
            }
            if (i + d + e <= c) {
                return b;
            }
            let j = c / (i + d + e);
            let k = truncate(Math.ceil(f * j));
            let l = b.substr(0, k) + h;
            let m = 0;
            if (this.bh(a)) {
                m = this.an.y(l);
            }
            else {
                m = this.an.aa(l);
            }
            if ((m + d + e) > c) {
                f = k;
            }
            else {
                k = k + 1;
                l = b.substr(0, k) + h;
                if (this.bh(a)) {
                    m = this.an.y(l);
                }
                else {
                    m = this.an.aa(l);
                }
                if ((m + d + e) > c) {
                    f = k;
                }
            }
            while ((i + d + e) > c && f > 0) {
                f--;
                b = b.substr(0, f) + h;
                if (this.l == 2) {
                    return "";
                }
                if (this.bh(a)) {
                    i = this.an.y(b);
                }
                else {
                    i = this.an.aa(b);
                }
            }
            return b;
        }
        f7(a, b, c, d, e, f, g, h) {
            if (b == null) {
                if (this.ed != null && this.f8 != null && !stringIsNullOrEmpty(this.f8)) {
                    return this.f8 + this.ed;
                }
                return "";
            }
            let i = a.o(b);
            let j = i.width;
            let k = i.height;
            let l = b.j;
            if (this.al != null && this.al == b && this.ed != null) {
                let m = null;
                let n = b;
                while (n.k != null) {
                    if (this.aj.b.containsKey(n.k)) {
                        m = this.aj.b.item(n.k);
                        if (m.j != null) {
                            l = m.j + this.ed + l;
                        }
                        n = m;
                    }
                }
                if (this.f8 != null && !stringIsNullOrEmpty(this.f8)) {
                    l = this.f8 + this.ed + l;
                }
            }
            let o = 0;
            let p = 0;
            if (a.c(b.i)) {
                let q = a.a(b.i);
                if (b.b.count > 0) {
                    o = c;
                    p = d;
                    if (this.o == 2) {
                        if (k < g) {
                            return "";
                        }
                    }
                }
                else {
                    o = e;
                    p = f;
                    if (this.o == 2) {
                        if (k < h) {
                            return "";
                        }
                    }
                }
            }
            return this.gg(b, l, j, o, p);
        }
        ds(a) {
            if (!isNaN_(this.dt)) {
                return this.dt;
            }
            return this.bv;
        }
        ib(a) {
            if (this.i == 2) {
                return this.ih(a);
            }
            if (a == this.am) {
                return this.ic(a);
            }
            if (this.h1 != null) {
                return this.h1;
            }
            return this.an.a6();
        }
        ih(a) {
            if (a == this.am) {
                return this.ii(a);
            }
            if (this.h8 != null) {
                return this.h8;
            }
            return this.an.bb();
        }
        ie(a, b, c) {
            if (a.b.count > 0) {
                if (a == this.am) {
                    return this.id(a, c);
                }
                let d = this.an.a7();
                let e = this.an.a8();
                if (this.h6 != null) {
                    e = this.h6;
                }
                if (this.h2 != null) {
                    d = this.h2;
                }
                return BrushUtil.i(c, d, e);
            }
            else {
                let f = this.an.a5();
                let g = this.an.bd();
                if (this.ik != null) {
                    g = this.ik;
                }
                if (this.h0 != null) {
                    f = this.h0;
                }
                return BrushUtil.i(b, f, g);
            }
        }
        av(a) {
            if (a.b.count > 0) {
                if (this.au != null) {
                    return this.au;
                }
                return this.an.i();
            }
            else {
                if (this.aw != null) {
                    return this.aw;
                }
                return this.an.j();
            }
        }
        onDetachedFromUI() {
            this.an.au();
        }
        onAttachedToUI() {
            this.an.as();
        }
        ic(a) {
            if (this.h3 != null) {
                return this.h3;
            }
            return this.an.a9();
        }
        ii(a) {
            if (this.h9 != null) {
                return this.h9;
            }
            return this.an.bc();
        }
        id(a, b) {
            let c = this.an.a7();
            let d = this.an.a8();
            if (this.h6 != null) {
                d = this.h6;
            }
            if (this.h2 != null) {
                c = this.h2;
            }
            if (this.h5 != null) {
                d = this.h5;
            }
            if (this.h4 != null) {
                c = this.h4;
            }
            return BrushUtil.i(b, c, d);
        }
        ig(a) {
            if (this.h7 != null) {
                return this.h7;
            }
            return this.an.ba();
        }
        ia(a, b, c) {
            if (this.b == null || this.b.count == 0) {
                return this.ij(a);
            }
            let d = this.cu(a);
            if (isNaN_(d)) {
                return this.ij(a);
            }
            let e = 0;
            if (this.bg && this.dy > 0) {
                if (d > 0) {
                    e = (logBase(d, this.dy) - logBase(b, this.dy)) / (logBase(c, this.dy) - logBase(b, this.dy));
                }
                else {
                    return this.ij(a);
                }
            }
            else {
                e = (d - b) / (c - b);
            }
            e = e * (this.b.count - 1);
            return BrushCollectionUtil.b(this.b, e);
        }
        cu(a) {
            switch (this.d) {
                case 0:
                case 1: return a.e();
                case 2:
                case 3: return a.f;
            }
            return a.e();
        }
        ij(a) {
            return this.an.a6();
        }
        he(a) {
            let b = new List$1(TreemapVisual.$, 0);
            let c = this.an.k();
            let d = 0;
            if (this.i == 2) {
                d = this.d0(a, false, d, c, (e) => true, b);
                d = this.d0(a, true, d, c, (e) => e.e.b != null && e.e.b.count > 0, b);
            }
            else {
                d = this.d0(a, false, d, c, (e) => true, b);
            }
            c.count = d;
            this.an.ah(b);
        }
        d0(a, b, c, d, e, f) {
            for (let g = 0; g < a.e.count; g++) {
                let h = a.e._inner[g];
                let i = a.a(h);
                if (!e(i)) {
                    continue;
                }
                let j = d.item(c);
                if (i.y.isEmpty || (i.y.width == 0 && i.y.height == 0)) {
                    j.t = 1;
                    continue;
                }
                c++;
                f.add(j);
                let k = i.e.b.count == 0;
                let l = !k && i.a == 2;
                j.a = this.av(i.e);
                j.i = i.u;
                j.l = i.x;
                j.j = i.v;
                j.n = new Thickness(1, i.i, i.k, i.j, i.h);
                j.o = new Thickness(1, i.n, i.p, i.o, i.m);
                j.k = i.w;
                j.g = i.s;
                j.f = i.q;
                j.t = 0;
                j.m = this.io(i.y, i.q);
                j.b = k;
                j.q = !k && !l ? 0 : 1;
                j.s = !k && l ? 0 : 1;
                j.r = k ? 0 : 1;
                j.e = i.l;
                j.d = i.g;
                j.h = i.t;
                j.p = i.z;
                if (!b && !k && l) {
                    j.s = 1;
                }
                if (b && !k && l) {
                    j.i = null;
                    j.l = null;
                }
            }
            return c;
        }
        io(a, b) {
            let c = this.cq(Math.floor(a.left), b);
            let d = this.cq(Math.floor(a.right), b);
            let e = this.cq(Math.floor(a.top), b);
            let f = this.cq(Math.floor(a.bottom), b);
            return new Rect(0, c, e, d - c, f - e);
        }
        cq(a, b) {
            let c = a;
            if (b > 0) {
                let d = b % 2;
                if (d == 0 || d == 1) {
                    let e = 1;
                    c = Math.floor(a);
                    if (c + 0.5 < a) {
                        e = -1;
                        c = Math.ceil(a);
                    }
                    if (d == 1) {
                        c += 0.5 * e;
                    }
                }
            }
            return c;
        }
        bm() {
            return !this.ip.isEmpty && this.an.p();
        }
        hf() {
            if (!this.bm()) {
                return;
            }
            if (this.bf) {
                let a = this.g;
                if (this.bc) {
                    if (this.ap.g) {
                        this.ap.t();
                    }
                    this.g = this.e;
                    this.e = a;
                }
                else {
                    this.g = this.f;
                    this.f = a;
                }
            }
            else if (this.bc) {
                this.e.h(this.du, this.g, this.f);
                this.he(this.e);
            }
            if (this.bf) {
                this.hb();
            }
            if (this.bf && this.bn) {
                this.hh();
                this.e.h(this.du, this.g, this.f);
                this.he(this.e);
            }
            else {
                if (this.bf) {
                    this.he(this.f);
                }
            }
            this.bf = false;
            this.an.a0();
        }
        bd(a, b) {
            let c = null;
            switch (a.bh) {
                case 1:
                    c = b.f;
                    break;
                case 0:
                    c = b.e();
                    break;
                case 2:
                    c = b.g;
                    break;
            }
            if (this.bj(c)) {
                let d = this.cr(c);
                if (a.bn != null) {
                    if (this.bj(a.bn)) {
                        let e = this.cr(a.bn);
                        if (isNaN_(e) && isNaN_(d)) {
                            return true;
                        }
                        if (d == e) {
                            return true;
                        }
                    }
                }
                else if (!isNaN_(a.bl) || !isNaN_(a.bk)) {
                    let f = a.bl;
                    let g = a.bk;
                    if (d >= f && d <= g) {
                        return true;
                    }
                }
            }
            else if (this.bl(c)) {
                if (a.bn != null) {
                    if (this.bl(a.bn)) {
                        let h = (a.bn);
                        if (Base.equalsStatic(h, c)) {
                            return true;
                        }
                    }
                }
            }
            else {
                if (Base.equalsStatic(c, a.bn)) {
                    return true;
                }
            }
            return false;
        }
        bl(a) {
            return typeof a === 'string';
        }
        cr(a) {
            if (typeof a === 'number') {
                return a;
            }
            if (typeof a === 'number') {
                return typeGetValue(a);
            }
            if (typeof a === 'number') {
                return typeGetValue(a);
            }
            if (typeof a === 'number') {
                return typeGetValue(a);
            }
            if (typeof a === 'number') {
                return a;
            }
            if (typeof a === 'number') {
                return typeGetValue(a);
            }
            if (typeof a === 'number') {
                return a;
            }
            return NaN;
        }
        bj(a) {
            if (typeof a === 'number') {
                return true;
            }
            if (typeof a === 'number') {
                return true;
            }
            if (typeof a === 'number') {
                return true;
            }
            if (typeof a === 'number') {
                return true;
            }
            if (typeof a === 'number') {
                return true;
            }
            if (typeof a === 'number') {
                return true;
            }
            if (typeof a === 'number') {
                return true;
            }
            return false;
        }
        u(a) {
            let b = this.f;
            if (this.bc) {
                b = this.e;
            }
            let c = new List$1(TreemapNodeFrame.$, 0);
            for (let d = 0; d < b.e.count; d++) {
                let e = b.e._inner[d];
                let f = b.a(e);
                if (a.x >= f.y.left && a.x <= f.y.right && a.y >= f.y.top && a.y <= f.y.bottom) {
                    c.add(f);
                }
            }
            c.aa((g, h) => {
                let i = this.dz(h);
                let j = this.dz(g);
                if (i > j) {
                    return 1;
                }
                else if (j > i) {
                    return -1;
                }
                return 0;
            });
            for (let g of fromEnum(c)) {
                if (g.e.b.count > 0) {
                    return g;
                }
            }
            return null;
        }
        dz(a) {
            let b = a.e;
            let c = 0;
            while (b.k != null) {
                if (this.aj == null) {
                    break;
                }
                if (this.aj.b.containsKey(b.k)) {
                    c++;
                    b = this.aj.b.item(b.k);
                }
                else {
                    break;
                }
            }
            return c;
        }
        v(a) {
            let b = this.f;
            if (this.bc) {
                b = this.e;
            }
            let c = new List$1(TreemapNodeFrame.$, 0);
            for (let d = 0; d < b.e.count; d++) {
                let e = b.e._inner[d];
                let f = b.a(e);
                if (a.x >= f.y.left && a.x <= f.y.right && a.y >= f.y.top && a.y <= f.y.bottom) {
                    c.add(f);
                }
            }
            c.aa((g, h) => {
                let i = this.dz(h);
                let j = this.dz(g);
                if (i > j) {
                    return 1;
                }
                else if (j > i) {
                    return -1;
                }
                return 0;
            });
            if (this.i == 2) {
                for (let g of fromEnum(c)) {
                    if (g.e.b.count > 0) {
                        if (this.bk(a, g)) {
                            return g;
                        }
                    }
                }
            }
            for (let h of fromEnum(c)) {
                return h;
            }
            return null;
        }
        hh() {
            this.cn = 0;
            this.ap.w();
            this.ap.v();
            this.an.ax();
        }
        get bn() {
            return this.d1 > 0;
        }
        provideContainer(a) {
            this.an.at(a);
            this.ap.u(a);
        }
        gr() {
            this.an.ao();
        }
        get x() {
            return this.t;
        }
        set x(a) {
            let b = this.t;
            this.t = a;
            if (b != a) {
                this.gs(b);
                this.gq(a);
            }
        }
        gq(a) {
            if (a != null) {
                if (this.nodePointerEnter != null) {
                    this.nodePointerEnter(this, this.y(a));
                }
            }
        }
        gs(a) {
            if (a != null) {
                if (this.nodePointerLeave != null) {
                    this.nodePointerLeave(this, this.y(a));
                }
            }
        }
        y(a) {
            let b = new TreemapNodePointerEventArgs();
            if (a != null) {
                b.customValue = a.e.g;
                b.item = a.e.h;
                b.position = this.il;
                b.sum = a.e.e();
                b.value = a.e.f;
                b.label = a.e.j;
                b.isOverHeader = this.bk(this.il, a);
                if (a.e.k != null && this.aj != null && this.aj.b.containsKey(a.e.k)) {
                    let c = this.aj.b.item(a.e.k);
                    b.parentItem = c.h;
                    b.parentSum = c.e();
                    b.parentValue = c.f;
                    b.parentLabel = c.j;
                }
            }
            b.isRightButton = false;
            return b;
        }
        get d3() {
            return this.d2;
        }
        set d3(a) {
            let b = this.d2;
            this.d2 = a;
            if (b != this.d2) {
                this.g7("FocusItem", b, a);
            }
        }
        g2(a) {
            this.hl(a);
            if (this.nodePointerPressed != null && this.x != null) {
                let b = this.y(this.x);
                this.nodePointerPressed(this, b);
            }
        }
        g6(a) {
            this.hl(a);
            let b = false;
            if (this.nodePointerReleased != null && this.x != null) {
                let c = this.y(this.x);
                this.nodePointerReleased(this, c);
                b = c.isHandled;
            }
            if (!b) {
                if (this.w != null) {
                    if (this.w.e == this.al && this.bk(a, this.w)) {
                        this.al = null;
                        this.bf = true;
                        this.an.a1();
                        this.hj(null);
                        return;
                    }
                    this.al = this.w.e;
                    this.hj(this.w.e);
                    this.bf = true;
                    this.an.a1();
                }
                else {
                    this.al = null;
                    this.bf = true;
                    this.hj(null);
                    this.an.a1();
                }
            }
        }
        hj(a) {
            try {
                this.ba = true;
                if (a == null) {
                    this.d3 = null;
                }
                else {
                    this.d3 = a.h;
                }
                this.ba = false;
            }
            finally {
                this.ba = false;
            }
        }
        bk(a, b) {
            let c = this.f;
            if (this.bc) {
                c = this.e;
            }
            if (b == null) {
                return false;
            }
            let d = b;
            if (a.x >= d.y.left && a.x <= d.y.right && a.y >= d.y.top && a.y <= d.y.bottom) {
                if (a.y - d.y.top <= d.g) {
                    return true;
                }
            }
            return false;
        }
        gx(source_, a, b, c) {
            if (source_.dataView && source_.dataSource) {
                source_ = source_.dataView();
            }
            ;
            if (!this.bo(source_)) {
                return;
            }
            let d = this.ar;
            if (d == null) {
                return;
            }
            d.handleCollectionChanged(new NotifyCollectionChangedEventArgs(2, 2, c, b, a));
        }
        gu(source_) {
            if (source_.dataView && source_.dataSource) {
                source_ = source_.dataView();
            }
            ;
            if (!this.bo(source_)) {
                return;
            }
            let a = this.ar;
            a.handleCollectionChanged(new NotifyCollectionChangedEventArgs(0, 4));
        }
        bo(a) {
            return Treemap.bp(a, this.dataSource);
        }
        static bp(a, b) {
            return a == b;
        }
        gv(source_, a, b) {
            if (source_.dataView && source_.dataSource) {
                source_ = source_.dataView();
            }
            ;
            if (!this.bo(source_)) {
                return;
            }
            let c = this.ar;
            if (c == null) {
                return;
            }
            c.handleCollectionChanged(new NotifyCollectionChangedEventArgs(1, 0, b, a));
        }
        gw(source_, a, b) {
            if (source_.dataView && source_.dataSource) {
                source_ = source_.dataView();
            }
            ;
            if (!this.bo(source_)) {
                return;
            }
            let c = this.ar;
            if (c == null) {
                return;
            }
            c.handleCollectionChanged(new NotifyCollectionChangedEventArgs(1, 1, b, a));
        }
        g3(a) {
            this.hl(a);
        }
        g4(a) {
            this.hl(a);
            this.w = null;
            this.x = null;
            if (!this.bc) {
                this.bf = true;
                this.an.a1();
            }
        }
        hl(a) {
            this.il = { $type: Point_$type, x: a.x, y: a.y };
            this.w = this.u(a);
            this.x = this.v(a);
            this.hk(a);
        }
        hg(a) {
            this.g5(a);
        }
        g5(a) {
            this.hl(a);
            if (this.x != null) {
                if (this.nodePointerOver != null) {
                    this.nodePointerOver(this, this.y(this.x));
                }
            }
        }
        hk(a) {
            if (!this.bc) {
                if (this.bk(a, this.w)) {
                    let b = this.am;
                    this.am = this.w.e;
                    if (this.am != b) {
                        this.bf = true;
                        this.an.a1();
                    }
                }
                else {
                    let c = this.am;
                    this.am = null;
                    if (this.am != c) {
                        this.bf = true;
                        this.an.a1();
                    }
                }
            }
        }
        g8(a) {
            this.hl(a);
            if (this.nodePointerPressed != null && this.x != null) {
                let b = this.y(this.x);
                b.isRightButton = true;
                this.nodePointerPressed(this, b);
            }
        }
        g9(a) {
            this.hl(a);
            let b = false;
            if (this.nodePointerReleased != null && this.x != null) {
                let c = this.y(this.x);
                c.isRightButton = true;
                this.nodePointerReleased(this, c);
                b = c.isHandled;
            }
            if (!b) {
                this.w = null;
                this.al = null;
                this.hj(null);
                this.bf = true;
                this.an.a1();
            }
        }
        ha(a) {
            this.bf = true;
            this.an.a1();
        }
    }
    Treemap.$t = /*@__PURE__*/ markType(Treemap, 'Treemap', Base.$, [INotifyPropertyChanged_$type]);
    return Treemap;
})();
/**
 * @hidden
 */
export let TreemapNodeStyle = /*@__PURE__*/ (() => {
    class TreemapNodeStyle extends Base {
        constructor() {
            super(...arguments);
            this.a = null;
            this.c = new HashSet$1(String_$type, 0);
            this.a0 = null;
            this.az = null;
            this.a2 = null;
            this.x = null;
            this.a4 = null;
            this.a1 = null;
            this.f = DeviceUtils.g(5);
            this.h = DeviceUtils.g(3);
            this.g = DeviceUtils.g(5);
            this.e = DeviceUtils.g(3);
            this.j = DeviceUtils.g(5);
            this.l = DeviceUtils.g(3);
            this.k = DeviceUtils.g(5);
            this.i = DeviceUtils.g(3);
            this.d = NaN;
            this.aw = 1;
            this.bc = 1;
            this.ay = null;
            this.a3 = null;
            this.m = NaN;
            this.propertyChanged = null;
        }
        au(a, b, c) {
            if (this.propertyChanged != null) {
                this.propertyChanged(this, new PropertyChangedEventArgs(a));
            }
            this.av(a, b, c);
        }
        at() {
            this.c.clear();
        }
        b(a) {
            return this.c.contains(a);
        }
        av(a, b, c) {
            if (!this.c.contains(a)) {
                this.c.add_1(a);
            }
            if (this.a != null) {
                this.a.ha(this);
            }
        }
        get a7() {
            return this.a0;
        }
        set a7(a) {
            let b = this.a0;
            this.a0 = a;
            if (b != this.a0) {
                this.au("HeaderHoverBackground", b, a);
            }
        }
        get a6() {
            return this.az;
        }
        set a6(a) {
            let b = this.az;
            this.az = a;
            if (b != this.az) {
                this.au("HeaderBackground", b, a);
            }
        }
        get a9() {
            return this.a2;
        }
        set a9(a) {
            let b = this.a2;
            this.a2 = a;
            if (b != this.a2) {
                this.au("HeaderTextColor", b, a);
            }
        }
        get ai() {
            return this.x;
        }
        set ai(a) {
            let b = this.x;
            this.x = a;
            if (b != this.x) {
                this.au("Label", b, a);
            }
        }
        get bb() {
            return this.a4;
        }
        set bb(a) {
            let b = this.a4;
            this.a4 = a;
            if (b != this.a4) {
                this.au("TextColor", b, a);
            }
        }
        get a8() {
            return this.a1;
        }
        set a8(a) {
            let b = this.a1;
            this.a1 = a;
            if (b != this.a1) {
                this.au("HeaderHoverTextColor", b, a);
            }
        }
        get p() {
            return this.f;
        }
        set p(a) {
            let b = this.f;
            this.f = a;
            if (b != this.f) {
                this.au("HeaderLabelLeftMargin", b, a);
            }
        }
        get r() {
            return this.h;
        }
        set r(a) {
            let b = this.h;
            this.h = a;
            if (b != this.h) {
                this.au("HeaderLabelTopMargin", b, a);
            }
        }
        get q() {
            return this.g;
        }
        set q(a) {
            let b = this.g;
            this.g = a;
            if (b != this.g) {
                this.au("HeaderLabelRightMargin", b, a);
            }
        }
        get o() {
            return this.e;
        }
        set o(a) {
            let b = this.e;
            this.e = a;
            if (b != this.e) {
                this.au("HeaderLabelBottomMargin", b, a);
            }
        }
        get t() {
            return this.j;
        }
        set t(a) {
            let b = this.j;
            this.j = a;
            if (b != this.j) {
                this.au("LabelLeftMargin", b, a);
            }
        }
        get v() {
            return this.l;
        }
        set v(a) {
            let b = this.l;
            this.l = a;
            if (b != this.l) {
                this.au("LabelTopMargin", b, a);
            }
        }
        get u() {
            return this.k;
        }
        set u(a) {
            let b = this.k;
            this.k = a;
            if (b != this.k) {
                this.au("LabelRightMargin", b, a);
            }
        }
        get s() {
            return this.i;
        }
        set s(a) {
            let b = this.i;
            this.i = a;
            if (b != this.i) {
                this.au("LabelBottomMargin", b, a);
            }
        }
        get n() {
            return this.d;
        }
        set n(a) {
            let b = this.d;
            this.d = a;
            if (b != this.d) {
                this.au("HeaderHeight", b, a);
            }
        }
        get ax() {
            return this.aw;
        }
        set ax(a) {
            let b = this.aw;
            this.aw = a;
            if (b != this.aw) {
                this.au("LabelHorizontalAlignment", enumGetBox(HorizontalAlignment_$type, b), enumGetBox(HorizontalAlignment_$type, a));
            }
        }
        get bd() {
            return this.bc;
        }
        set bd(a) {
            let b = this.bc;
            this.bc = a;
            if (b != this.bc) {
                this.au("LabelVerticalAlignment", enumGetBox(VerticalAlignment_$type, b), enumGetBox(VerticalAlignment_$type, a));
            }
        }
        get a5() {
            return this.ay;
        }
        set a5(a) {
            let b = this.ay;
            this.ay = a;
            if (b != this.ay) {
                this.au("Fill", b, a);
            }
        }
        get ba() {
            return this.a3;
        }
        set ba(a) {
            let b = this.a3;
            this.a3 = a;
            if (b != this.a3) {
                this.au("Outline", b, a);
            }
        }
        get w() {
            return this.m;
        }
        set w(a) {
            let b = this.m;
            this.m = a;
            if (b != this.m) {
                this.au("StrokeThickness", b, a);
            }
        }
    }
    TreemapNodeStyle.$t = /*@__PURE__*/ markType(TreemapNodeStyle, 'TreemapNodeStyle', Base.$, [INotifyPropertyChanged_$type]);
    return TreemapNodeStyle;
})();
/**
 * @hidden
 */
export let TreemapNodeStyleMapping = /*@__PURE__*/ (() => {
    class TreemapNodeStyleMapping extends TreemapNodeStyle {
        constructor() {
            super(...arguments);
            this.be = 0;
            this.bo = null;
            this.bj = NaN;
            this.bi = NaN;
            this.bm = null;
            this.bg = 1;
        }
        get bf() {
            return this.be;
        }
        set bf(a) {
            let b = this.be;
            this.be = a;
            if (b != this.be) {
                this.au("TargetType", enumGetBox(TreemapNodeStyleMappingTargetType_$type, b), enumGetBox(TreemapNodeStyleMappingTargetType_$type, a));
            }
        }
        get bs() {
            return this.bo;
        }
        set bs(a) {
            let b = this.bo;
            this.bo = a;
            if (b != this.bo) {
                this.au("Name", b, a);
            }
        }
        get bl() {
            return this.bj;
        }
        set bl(a) {
            let b = this.bj;
            this.bj = a;
            if (b != this.bj) {
                this.au("MinimumValue", b, a);
            }
        }
        get bk() {
            return this.bi;
        }
        set bk(a) {
            let b = this.bi;
            this.bi = a;
            if (b != this.bi) {
                this.au("MaximumValue", b, a);
            }
        }
        get bn() {
            return this.bm;
        }
        set bn(a) {
            let b = this.bm;
            this.bm = a;
            if (b != this.bm) {
                this.au("Value", b, a);
            }
        }
        get bh() {
            return this.bg;
        }
        set bh(a) {
            let b = this.bg;
            this.bg = a;
            if (b != this.bg) {
                this.au("MappingMode", enumGetBox(TreemapValueMappingMode_$type, b), enumGetBox(TreemapValueMappingMode_$type, a));
            }
        }
    }
    TreemapNodeStyleMapping.$t = /*@__PURE__*/ markType(TreemapNodeStyleMapping, 'TreemapNodeStyleMapping', TreemapNodeStyle.$);
    return TreemapNodeStyleMapping;
})();
/**
 * @hidden
 */
export let TreemapNodeStyleMappingCollection = /*@__PURE__*/ (() => {
    class TreemapNodeStyleMappingCollection extends ObservableCollection$1 {
        constructor() {
            super(TreemapNodeStyleMapping.$, 0);
            this.collectionResetting = null;
        }
        p() {
            if (this.collectionResetting != null) {
                this.collectionResetting(this, null);
            }
            super.p();
        }
    }
    TreemapNodeStyleMappingCollection.$t = /*@__PURE__*/ markType(TreemapNodeStyleMappingCollection, 'TreemapNodeStyleMappingCollection', /*@__PURE__*/ ObservableCollection$1.$.specialize(TreemapNodeStyleMapping.$));
    return TreemapNodeStyleMappingCollection;
})();
/**
 * @hidden
 */
export let TreemapNodeStylingEventArgs = /*@__PURE__*/ (() => {
    class TreemapNodeStylingEventArgs extends EventArgs {
        constructor() {
            super(...arguments);
            this._value = 0;
            this._sum = 0;
            this._customValue = null;
            this._item = null;
            this._parentItem = null;
            this._label = null;
            this._parentValue = 0;
            this._parentLabel = null;
            this._parentSum = 0;
            this._isParent = false;
            this._style = null;
        }
        get value() {
            return this._value;
        }
        set value(a) {
            this._value = a;
        }
        get sum() {
            return this._sum;
        }
        set sum(a) {
            this._sum = a;
        }
        get customValue() {
            return this._customValue;
        }
        set customValue(a) {
            this._customValue = a;
        }
        get item() {
            return this._item;
        }
        set item(a) {
            this._item = a;
        }
        get parentItem() {
            return this._parentItem;
        }
        set parentItem(a) {
            this._parentItem = a;
        }
        get label() {
            return this._label;
        }
        set label(a) {
            this._label = a;
        }
        get parentValue() {
            return this._parentValue;
        }
        set parentValue(a) {
            this._parentValue = a;
        }
        get parentLabel() {
            return this._parentLabel;
        }
        set parentLabel(a) {
            this._parentLabel = a;
        }
        get parentSum() {
            return this._parentSum;
        }
        set parentSum(a) {
            this._parentSum = a;
        }
        get isParent() {
            return this._isParent;
        }
        set isParent(a) {
            this._isParent = a;
        }
        get style() {
            return this._style;
        }
        set style(a) {
            this._style = a;
        }
    }
    TreemapNodeStylingEventArgs.$t = /*@__PURE__*/ markType(TreemapNodeStylingEventArgs, 'TreemapNodeStylingEventArgs', EventArgs.$);
    return TreemapNodeStylingEventArgs;
})();
/**
 * @hidden
 */
export let TreemapFrame = /*@__PURE__*/ (() => {
    class TreemapFrame extends Base {
        constructor() {
            super();
            this.d = null;
            this.e = null;
            this.e = new List$1(String_$type, 0);
            this.d = new Dictionary$2(String_$type, TreemapNodeFrame.$, 0);
        }
        h(a, b, c) {
            this.g();
            this.k(a, b, c);
            this.j(a, b, c);
            this.i(a, b, c);
        }
        i(a, b, c) {
            for (let d = 0; d < b.e.count; d++) {
                let e = b.e._inner[d];
                if (c.d.containsKey(e)) {
                    let f = TreemapNodeFrame.b(a, b.d.item(e), c.d.item(e));
                    this.d.addItem(f.r, f);
                    this.e.add(f.r);
                }
            }
        }
        j(a, b, c) {
            for (let d = 0; d < c.e.count; d++) {
                let e = c.e._inner[d];
                if (!b.d.containsKey(e)) {
                    let f = TreemapNodeFrame.c(a, c.d.item(e));
                    this.d.addItem(f.r, f);
                    this.e.add(f.r);
                }
            }
        }
        k(a, b, c) {
            for (let d = 0; d < b.e.count; d++) {
                let e = b.e._inner[d];
                if (!c.d.containsKey(e)) {
                    let f = TreemapNodeFrame.d(a, b.d.item(e));
                    this.d.addItem(f.r, f);
                    this.e.add(f.r);
                }
            }
        }
        m(a, b) {
            let c;
            if (!((() => { let d = this.d.tryGetValue(a.i, c); c = d.p1; return d.ret; })())) {
                c = new TreemapNodeFrame();
                c.r = a.i;
                c.e = a;
                this.d.item(c.r, c);
                this.e.add(c.r);
            }
            c.y = b;
        }
        n(a, b) {
            this.d.item(a.i).f = b;
        }
        b(a) {
            if (!this.d.containsKey(a.i)) {
                return false;
            }
            return this.d.item(a.i).f;
        }
        o(a) {
            let b;
            if (!((() => { let c = this.d.tryGetValue(a.i, b); b = c.p1; return c.ret; })())) {
                return Rect.empty;
            }
            return b.y;
        }
        l(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t) {
            let u;
            if (!((() => { let v = this.d.tryGetValue(a.i, u); u = v.p1; return v.ret; })())) {
                return;
            }
            u.s = b;
            u.u = c;
            u.x = d;
            u.q = g;
            u.v = e;
            u.a = h;
            u.l = i;
            u.g = j;
            u.w = f;
            u.i = k;
            u.k = l;
            u.j = m;
            u.h = n;
            u.n = o;
            u.p = p;
            u.o = q;
            u.m = r;
            u.t = s;
            u.z = t;
        }
        g() {
            this.e.clear();
            this.d.clear();
        }
        c(a) {
            return this.d.containsKey(a);
        }
        a(a) {
            return this.d.item(a);
        }
        f(a, b, c) {
            let d;
            if (!((() => { let e = this.d.tryGetValue(a.i, d); d = e.p1; return e.ret; })())) {
                return;
            }
            let e = a.b != null && a.b.count > 0;
            if (b.b("Label")) {
                d.s = b.ai;
            }
            if (b.b("Fill")) {
                d.u = b.a5;
            }
            if (b.b("LabelHorizontalAlignment")) {
                d.t = b.ax;
            }
            if (b.b("Outline")) {
                d.x = b.ba;
            }
            if (b.b("StrokeThickness")) {
                d.q = b.w;
            }
            if (b.b("HeaderBackground")) {
                d.v = b.a6;
            }
            if (e) {
                if (b.b("HeaderTextColor")) {
                    d.w = b.a9;
                }
                else if (b.b("Fill") || b.b("HeaderBackground")) {
                    d.w = c(a, d.u, d.v);
                }
            }
            else {
                if (b.b("TextColor")) {
                    d.w = b.bb;
                }
                else if (b.b("Fill") || b.b("HeaderBackground")) {
                    d.w = c(a, d.u, d.v);
                }
            }
            if (b.b("HeaderLabelLeftMargin")) {
                d.i = b.p;
            }
            if (b.b("HeaderLabelTopMargin")) {
                d.k = b.r;
            }
            if (b.b("HeaderLabelRightMargin")) {
                d.j = b.q;
            }
            if (b.b("HeaderLabelBottomMargin")) {
                d.h = b.o;
            }
            if (b.b("LabelLeftMargin")) {
                d.n = b.t;
            }
            if (b.b("LabelTopMargin")) {
                d.p = b.v;
            }
            if (b.b("LabelRightMargin")) {
                d.o = b.u;
            }
            if (b.b("LabelBottomMargin")) {
                d.m = b.s;
            }
        }
    }
    TreemapFrame.$t = /*@__PURE__*/ markType(TreemapFrame, 'TreemapFrame');
    return TreemapFrame;
})();
/**
 * @hidden
 */
export let TreemapNodeFrame = /*@__PURE__*/ (() => {
    class TreemapNodeFrame extends Base {
        constructor() {
            super();
            this.y = null;
            this.e = null;
            this.r = null;
            this.s = null;
            this.u = null;
            this.x = null;
            this.q = 0;
            this.i = 0;
            this.k = 0;
            this.j = 0;
            this.h = 0;
            this.n = 0;
            this.p = 0;
            this.o = 0;
            this.m = 0;
            this.w = null;
            this.v = null;
            this.a = 0;
            this.l = 0;
            this.g = 0;
            this.t = 0;
            this.z = 0;
            this.f = false;
            this.y = Rect.empty;
        }
        static b(a, b, c) {
            let d = new TreemapNodeFrame();
            d.e = c.e;
            d.r = c.r;
            d.s = c.s;
            let e = c.y;
            if (e.isEmpty) {
                e = new Rect(0, 0, 0, 0, 0);
            }
            let f = b.y;
            if (f.isEmpty) {
                f = new Rect(0, 0, 0, 0, 0);
            }
            d.y = new Rect(0, f.left + (e.left - f.left) * a, f.top + (e.top - f.top) * a, f.width + (e.width - f.width) * a, f.height + (e.height - f.height) * a);
            d.u = BrushUtil.k(b.u, a, c.u, 0);
            d.x = BrushUtil.k(b.x, a, c.x, 0);
            d.v = BrushUtil.k(b.v, a, c.v, 0);
            d.w = BrushUtil.k(b.w, a, c.w, 0);
            d.q = b.q + (c.q - b.q) * a;
            d.i = b.i + (c.i - b.i) * a;
            d.k = b.k + (c.k - b.k) * a;
            d.j = b.j + (c.j - b.j) * a;
            d.h = b.h + (c.h - b.h) * a;
            d.n = b.n + (c.n - b.n) * a;
            d.p = b.p + (c.p - b.p) * a;
            d.o = b.o + (c.o - b.o) * a;
            d.m = b.m + (c.m - b.m) * a;
            d.l = b.l + (c.l - b.l) * a;
            d.g = b.g + (c.g - b.g) * a;
            d.t = a < 0.5 ? b.t : c.t;
            d.z = a < 0.5 ? b.z : c.z;
            d.a = a < 0.5 ? b.a : c.a;
            return d;
        }
        static d(a, b) {
            let c = new Rect(0, 0, 0, 0, 0);
            let d = new TreemapNodeFrame();
            d.e = b.e;
            d.s = b.s;
            d.r = b.r;
            let e = b.y;
            if (e.isEmpty) {
                e = new Rect(0, 0, 0, 0, 0);
            }
            d.y = new Rect(0, e.left + (c.left - e.left) * a, e.top + (c.top - e.top) * a, e.width + (c.width - e.width) * a, e.height + (c.height - e.height) * a);
            d.u = BrushUtil.k(b.u, a, null, 0);
            d.x = BrushUtil.k(b.x, a, null, 0);
            d.v = BrushUtil.k(b.v, a, null, 0);
            d.w = BrushUtil.k(b.w, a, null, 0);
            d.q = b.q + (0 - b.q) * a;
            d.i = b.i + (0 - b.i) * a;
            d.k = b.k + (0 - b.k) * a;
            d.j = b.j + (0 - b.j) * a;
            d.h = b.h + (0 - b.h) * a;
            d.n = b.n + (0 - b.n) * a;
            d.p = b.p + (0 - b.p) * a;
            d.o = b.o + (0 - b.o) * a;
            d.m = b.m + (0 - b.m) * a;
            d.l = b.l + (0 - b.l) * a;
            d.g = b.g + (0 - b.g) * a;
            d.t = b.t;
            d.z = b.z;
            d.a = b.a;
            return d;
        }
        static c(a, b) {
            let c = new Rect(0, 0, 0, 0, 0);
            let d = new TreemapNodeFrame();
            d.e = b.e;
            d.s = b.s;
            d.r = b.r;
            let e = b.y;
            if (e.isEmpty) {
                e = new Rect(0, 0, 0, 0, 0);
            }
            d.y = new Rect(0, c.left + (e.left - c.left) * a, c.top + (e.top - c.top) * a, c.width + (e.width - c.width) * a, c.height + (e.height - c.height) * a);
            d.u = BrushUtil.k(null, a, b.u, 0);
            d.x = BrushUtil.k(null, a, b.x, 0);
            d.v = BrushUtil.k(null, a, b.v, 0);
            d.w = BrushUtil.k(null, a, b.w, 0);
            d.q = 0 + (b.q - 0) * a;
            d.i = 0 + (b.i - 0) * a;
            d.k = 0 + (b.k - 0) * a;
            d.j = 0 + (b.j - 0) * a;
            d.h = 0 + (b.h - 0) * a;
            d.n = 0 + (b.n - 0) * a;
            d.p = 0 + (b.p - 0) * a;
            d.o = 0 + (b.o - 0) * a;
            d.m = 0 + (b.m - 0) * a;
            d.l = 0 + (b.l - 0) * a;
            d.g = 0 + (b.g - 0) * a;
            d.t = b.t;
            d.z = b.z;
            d.a = b.a;
            return d;
        }
    }
    TreemapNodeFrame.$t = /*@__PURE__*/ markType(TreemapNodeFrame, 'TreemapNodeFrame');
    return TreemapNodeFrame;
})();
