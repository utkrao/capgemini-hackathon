/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Snapper } from "./Snapper";
import { markType } from "igniteui-react-core";
import { truncate, isNaN_ } from "igniteui-react-core";
/**
 * @hidden
 */
export let LinearCategorySnapper = /*@__PURE__*/ (() => {
    class LinearCategorySnapper extends Snapper {
        constructor(a, ..._rest) {
            super();
            this.g = 0;
            this.h = 0;
            a = (a == void 0) ? 0 : a;
            switch (a) {
                case 0:
                    {
                        let c = _rest[0];
                        let d = _rest[1];
                        let e = _rest[2];
                        let f = _rest[3];
                        let g = [c, d, e, NaN, 0, f];
                        {
                            let i = g[0];
                            let j = g[1];
                            let k = g[2];
                            let l = g[3];
                            let m = g[4];
                            let n = g[5];
                            if (n > 0) {
                                this.f = n;
                                this.b = true;
                            }
                            this.g = l;
                            this.h = 0;
                            let o = Math.min(10, truncate((k / this.f)));
                            if (o > 0) {
                                let p = this.i(i, j, o);
                                if (this.b && p > o) {
                                    this.g = l;
                                    p = this.i(i, j, o - 1);
                                }
                                o = p;
                                if (k / o > this.f * 10) {
                                    this.h = 10;
                                }
                                else {
                                    if (k / o > this.f * 5) {
                                        this.h = 5;
                                    }
                                    else {
                                        if (k / o > this.f * 2) {
                                            this.h = 2;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    break;
                case 1:
                    {
                        let c = _rest[0];
                        let d = _rest[1];
                        let e = _rest[2];
                        let f = _rest[3];
                        let g = _rest[4];
                        let h = _rest[5];
                        if (h > 0) {
                            this.f = h;
                            this.b = true;
                        }
                        this.g = f;
                        this.h = 0;
                        let i = Math.min(10, truncate((e / this.f)));
                        if (i > 0) {
                            let j = this.i(c, d, i);
                            if (this.b && j > i) {
                                this.g = f;
                                j = this.i(c, d, i - 1);
                            }
                            i = j;
                            if (e / i > this.f * 10) {
                                this.h = 10;
                            }
                            else {
                                if (e / i > this.f * 5) {
                                    this.h = 5;
                                }
                                else {
                                    if (e / i > this.f * 2) {
                                        this.h = 2;
                                    }
                                }
                            }
                        }
                    }
                    break;
            }
        }
        i(a, b, c) {
            let d = Snapper.e(b - a, false);
            if (isNaN_(this.g)) {
                let e = Math.max(c - 1, 1);
                this.g = Snapper.e(d / e, true);
            }
            if (this.g < 1) {
                this.g = 1;
            }
            let f = Math.floor(a / this.g) * this.g;
            let g = Math.ceil(b / this.g) * this.g;
            let h = truncate(Math.round((g - f) / this.g));
            return h;
        }
    }
    LinearCategorySnapper.$t = /*@__PURE__*/ markType(LinearCategorySnapper, 'LinearCategorySnapper', Snapper.$);
    return LinearCategorySnapper;
})();
