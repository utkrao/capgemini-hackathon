/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, Point_$type, fromEnum, markType } from "igniteui-react-core";
import { PointList } from "./PointList";
import { PointCollection } from "igniteui-react-core";
import { Rect } from "igniteui-react-core";
import { intDivide } from "igniteui-react-core";
/**
 * @hidden
 */
export let SliceAppearance = /*@__PURE__*/ (() => {
    class SliceAppearance extends Base {
        constructor() {
            super();
            this.l = 0;
            this.k = 0;
            this.ak = null;
            this.al = null;
            this.a = null;
            this.b = null;
            this.at = null;
            this.am = null;
            this.aj = null;
            this.ai = null;
            this.az = null;
            this.z = null;
            this.ac = null;
            this.t = null;
            this.ah = null;
            this.g = false;
            this.u = null;
            this.r = 0;
            this.av = Rect.empty;
            this.aw = Rect.empty;
            this.aa = null;
            this.ab = null;
            this.a1 = 0;
            this.h = false;
            this.q = 0;
            this.m = 1;
            this.ai = { $type: Point_$type, x: 0, y: 0 };
            this.aj = { $type: Point_$type, x: 0, y: 0 };
            this.al = { $type: Point_$type, x: 0, y: 0 };
            this.am = { $type: Point_$type, x: 0, y: 0 };
            this.ak = { $type: Point_$type, x: 0, y: 0 };
        }
        get o() {
            return this.l;
        }
        set o(a) {
            this.l = a;
            this.y();
        }
        get n() {
            return this.k;
        }
        set n(a) {
            this.k = a;
            this.y();
        }
        get aq() {
            return this.ak;
        }
        set aq(a) {
            this.ak = a;
        }
        get ar() {
            return this.al;
        }
        set ar(a) {
            this.al = a;
            this.y();
        }
        get c() {
            return this.a;
        }
        set c(a) {
            this.a = a;
            this.y();
        }
        get e() {
            return this.b;
        }
        set e(a) {
            this.b = a;
            this.y();
        }
        get au() {
            return this.at;
        }
        set au(a) {
            this.at = a;
        }
        y() {
        }
        x() {
            let a = new PointCollection(0);
            if (this.e != null) {
                for (let b of fromEnum(this.e)) {
                    a.add(b);
                }
            }
            else {
                a.add(this.ar);
                a.add(this.as);
            }
            if (this.c != null) {
                for (let c of fromEnum(this.c)) {
                    a.add(c);
                }
                if (this.e != null && this.e.count > 0) {
                    a.add(this.e._inner[0]);
                }
            }
            else {
                a.add(this.ap);
                a.add(this.ao);
                a.add(this.ar);
            }
            let d = 0, e = Math.min(intDivide(a.count, 2), 5);
            if (e > 1) {
                let f = a._inner[0];
                let g = 0, h = f.x, i = f.y;
                while (++d < e && g < 2) {
                    f = a._inner[d];
                    g = Math.abs(f.x - h) + Math.abs(f.y - i);
                    if (g > 1) {
                        a.add({ $type: Point_$type, x: f.x, y: f.y });
                    }
                }
            }
            this.au = a;
        }
        get as() {
            return this.am;
        }
        set as(a) {
            this.am = a;
            this.y();
        }
        get ap() {
            return this.aj;
        }
        set ap(a) {
            this.aj = a;
            this.y();
        }
        get ao() {
            return this.ai;
        }
        set ao(a) {
            this.ai = a;
            this.y();
        }
        get a0() {
            return this.az;
        }
        set a0(a) {
            this.az = a;
        }
        get ad() {
            return this.z;
        }
        set ad(a) {
            this.z = a;
        }
        get ag() {
            return this.ac;
        }
        set ag(a) {
            this.ac = a;
        }
        get v() {
            return this.t;
        }
        set v(a) {
            this.t = a;
        }
        get an() {
            return this.ah;
        }
        set an(a) {
            this.ah = a;
        }
        get i() {
            return this.g && this.t != null;
        }
        set i(a) {
            this.g = a;
        }
        get item() {
            return this.u;
        }
        set item(a) {
            this.u = a;
        }
        get s() {
            return this.r;
        }
        set s(a) {
            this.r = a;
        }
        get ax() {
            return this.av;
        }
        set ax(a) {
            this.av = a;
        }
        get ay() {
            return this.aw;
        }
        set ay(a) {
            this.aw = a;
        }
        get ae() {
            return this.aa;
        }
        set ae(a) {
            this.aa = a;
        }
        get af() {
            return this.ab;
        }
        set af(a) {
            this.ab = a;
        }
        get a2() {
            return this.a1;
        }
        set a2(a) {
            this.a1 = a;
        }
        get j() {
            return this.h;
        }
        set j(a) {
            this.h = a;
        }
        get p() {
            return this.m;
        }
        set p(a) {
            this.m = a;
        }
        static f(a, b, c, d, e) {
            if (a == null) {
                a = new SliceAppearance();
            }
            a.ad = c.ad;
            a.i = c.i;
            a.v = c.v;
            if (b.i && c.i) {
                a.an = { $type: Point_$type, x: (b.an.x * e) + (c.an.x * d), y: (b.an.y * e) + (c.an.y * d) };
            }
            else if (c.i) {
                a.an = { $type: Point_$type, x: c.an.x * d, y: c.an.y * d };
            }
            a.ao = { $type: Point_$type, x: (b.ao.x * e) + (c.ao.x * d), y: (b.ao.y * e) + (c.ao.y * d) };
            a.ap = { $type: Point_$type, x: (b.ap.x * e) + (c.ap.x * d), y: (b.ap.y * e) + (c.ap.y * d) };
            a.ar = { $type: Point_$type, x: (b.ar.x * e) + (c.ar.x * d), y: (b.ar.y * e) + (c.ar.y * d) };
            a.as = { $type: Point_$type, x: (b.as.x * e) + (c.as.x * d), y: (b.as.y * e) + (c.as.y * d) };
            a.aq = { $type: Point_$type, x: (b.aq.x * e) + (c.aq.x * d), y: (b.aq.y * e) + (c.aq.y * d) };
            if (c.c != null) {
                let f = b.c;
                if (f == null) {
                    f = new PointList();
                    f.add(b.ar);
                    f.add(b.ao);
                }
                a.c = SliceAppearance.d(a.c, f, c.c, d, e);
            }
            else {
                a.c = null;
            }
            if (c.e != null) {
                let g = b.e;
                if (g == null) {
                    g = new PointList();
                    g.add(b.ap);
                    g.add(b.as);
                }
                a.e = SliceAppearance.d(a.e, g, c.e, d, e);
            }
            else {
                a.e = null;
            }
            a.ag = c.ag;
            a.a0 = c.a0;
            a.item = c.item;
            a.s = c.s;
            a.x();
            return a;
        }
        static d(a, b, c, d, e) {
            if (a == null) {
                a = new PointList();
            }
            if (b == null) {
                b = new PointList();
            }
            let f = b.count;
            let g = c.count;
            let h = Math.max(f, g);
            if (a.count < h) {
                a.s(a.count, new Array(h - a.count));
            }
            if (a.count > h) {
                a.v(h, a.count - h);
            }
            for (let i = 0; i < Math.min(f, g); ++i) {
                a._inner[i] = { $type: Point_$type, x: (b._inner[i].x * e) + (c._inner[i].x * d), y: (b._inner[i].y * e) + (c._inner[i].y * d) };
            }
            if (f < g) {
                let j = f > 0 ? b._inner[f - 1] : { $type: Point_$type, x: 0, y: 0 };
                for (let k = f; k < g; ++k) {
                    a._inner[k] = { $type: Point_$type, x: (j.x * e) + (c._inner[k].x * d), y: (j.y * e) + (c._inner[k].y * d) };
                }
            }
            if (f > g) {
                let l = g > 0 ? c._inner[g - 1] : { $type: Point_$type, x: 0, y: 0 };
                for (let m = g; m < f; ++m) {
                    a._inner[m] = { $type: Point_$type, x: (b._inner[m].x * e) + (l.x * d), y: (b._inner[m].y * e) + (l.y * d) };
                }
            }
            return a;
        }
    }
    SliceAppearance.$t = /*@__PURE__*/ markType(SliceAppearance, 'SliceAppearance');
    return SliceAppearance;
})();
